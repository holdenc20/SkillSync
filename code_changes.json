{
    "repo_name": "swift",
    "author_name": "owenv",
    "commits": [
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2020-04-17T16:19:57Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/342e53f8d0f6e39e570142e57861137f36bc5612",
                "changes": [
                    {
                        "filename": "include/swift/AST/DefineDiagnosticMacros.h",
                        "code": "@@ -0,0 +1,70 @@\n+//===--- DefineDiagnosticMacros.h - Shared Diagnostic Macros ----*- C++ -*-===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2020 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+//  This file defines macros shared across diagnostic definition files.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Define macros\n+#ifdef DEFINE_DIAGNOSTIC_MACROS\n+\n+#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && \\\n+                        defined(REMARK)))\n+#error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n+#endif\n+\n+#ifndef ERROR\n+#define ERROR(ID, Options, Text, Signature)                                    \\\n+  DIAG(ERROR, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef WARNING\n+#define WARNING(ID, Options, Text, Signature)                                  \\\n+  DIAG(WARNING, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef NOTE\n+#define NOTE(ID, Options, Text, Signature)                                     \\\n+  DIAG(NOTE, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef REMARK\n+#define REMARK(ID, Options, Text, Signature)                                   \\\n+  DIAG(REMARK, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef FIXIT\n+#define FIXIT(ID, Text, Signature)\n+#endif\n+\n+#undef DEFINE_DIAGNOSTIC_MACROS\n+#endif\n+\n+// Undefine macros\n+#ifdef UNDEFINE_DIAGNOSTIC_MACROS\n+\n+#ifndef DIAG_NO_UNDEF\n+\n+#if defined(DIAG)\n+#undef DIAG\n+#endif\n+\n+#undef REMARK\n+#undef NOTE\n+#undef WARNING\n+#undef ERROR\n+#undef FIXIT\n+\n+#endif\n+\n+#undef UNDEFINE_DIAGNOSTIC_MACROS\n+#endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsAll.def",
                        "code": "@@ -14,33 +14,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n #define DIAG_NO_UNDEF\n \n@@ -57,11 +32,5 @@\n \n #undef DIAG_NO_UNDEF\n \n-#if defined(DIAG)\n-#  undef DIAG\n-#endif\n-#undef NOTE\n-#undef WARNING\n-#undef ERROR\n-#undef REMARK\n-#undef FIXIT\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsClangImporter.def",
                        "code": "@@ -17,29 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_from_clang,none,\n   \"%0\", (StringRef))\n@@ -101,12 +80,5 @@ WARNING(implicit_bridging_header_imported_from_module,none,\n         \"is deprecated and will be removed in a later version of Swift\",\n         (StringRef, Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef REMARK\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsCommon.def",
                        "code": "@@ -17,33 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(invalid_diagnostic,none,\n       \"INTERNAL ERROR: this diagnostic should not be produced\", ())\n@@ -188,12 +163,5 @@ WARNING(cross_imported_by_both_modules, none,\n         \"please report this bug to the maintainers of these modules\",\n         (Identifier, Identifier, Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsDriver.def",
                        "code": "@@ -18,29 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_parallel_execution_not_supported,none,\n         \"parallel execution not supported; falling back to serial execution\",\n@@ -211,11 +190,5 @@ WARNING(warn_drv_darwin_sdk_invalid_settings, none,\n     \"SDK settings were ignored because 'SDKSettings.json' could not be parsed\",\n     ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsFrontend.def",
                        "code": "@@ -18,30 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && \\\n-                        defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature)   \\\n-DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_no_such_sdk,none,\n         \"no such SDK: '%0'\", (StringRef))\n@@ -407,12 +385,5 @@ ERROR(expectation_missing_opening_braces,none,\n ERROR(expectation_missing_closing_braces,none,\n       \"didn't find '}}' to match '{{' in expectation\", ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef REMARK\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsIRGen.def",
                        "code": "@@ -17,25 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(no_llvm_target,none,\n       \"error loading LLVM target for triple '%0': %1\", (StringRef, StringRef))\n@@ -67,11 +50,5 @@ ERROR(alignment_more_than_maximum,none,\n       \"@_alignment cannot increase alignment above maximum alignment of %0\",\n       (unsigned))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsModuleDiffer.def",
                        "code": "@@ -17,24 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(generic_sig_change,none,\"%0 has generic signature change from %1 to %2\", (StringRef, StringRef, StringRef))\n \n@@ -104,11 +88,5 @@ ERROR(not_inheriting_convenience_inits,none,\"%0 no longer inherits convenience i\n \n ERROR(enum_case_added,none,\"%0 has been added as a new enum case\", (StringRef))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.def",
                        "code": "@@ -17,28 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n //==============================================================================\n // MARK: Lexing and Parsing diagnostics\n@@ -1770,12 +1750,5 @@ ERROR(availability_query_repeated_platform, none,\n ERROR(unknown_syntax_entity, PointsToFirstBadToken,\n       \"unknown %0 syntax exists in the source\", (StringRef))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsRefactoring.def",
                        "code": "@@ -17,24 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n //==============================================================================\n // Refactoring diagnostics\n@@ -69,3 +53,6 @@ ERROR(no_remaining_cases, none, \"no remaining cases to expand\", ())\n WARNING(mismatched_rename, none, \"the name at the given location cannot be renamed to '%0'\", (StringRef))\n \n ERROR(no_insert_position, none, \"cannot find inserting position\", ())\n+\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSIL.def",
                        "code": "@@ -17,30 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n // SILGen issues.\n ERROR(bridging_module_missing,none,\n@@ -644,12 +622,5 @@ ERROR(box_to_stack_cannot_promote_box_to_stack_due_to_escape_alloc, none,\n NOTE(box_to_stack_cannot_promote_box_to_stack_due_to_escape_location, none,\n      \"value escapes here\", ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef REMARK\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -18,28 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n #ifndef REMARK\n #  define REMARK(ID,Options,Text,Signature)   \\\n@@ -5067,12 +5047,5 @@ ERROR(atomics_ordering_must_be_constant, none,\n       \"ordering argument must be a static method or property of %0\",\n       (Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    }
                ]
            },
            {
                "date": "2019-10-19T21:09:29Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/fdb6eabb0aee156b0c5371d70b0029c9fa4fcb22",
                "changes": [
                    {
                        "filename": "include/swift/AST/DefineDiagnosticMacros.h",
                        "code": "@@ -0,0 +1,70 @@\n+//===--- DefineDiagnosticMacros.h - Shared Diagnostic Macros ----*- C++ -*-===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2020 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+//  This file defines macros shared across diagnostic definition files.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Define macros\n+#ifdef DEFINE_DIAGNOSTIC_MACROS\n+\n+#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && \\\n+                        defined(REMARK)))\n+#error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n+#endif\n+\n+#ifndef ERROR\n+#define ERROR(ID, Options, Text, Signature)                                    \\\n+  DIAG(ERROR, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef WARNING\n+#define WARNING(ID, Options, Text, Signature)                                  \\\n+  DIAG(WARNING, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef NOTE\n+#define NOTE(ID, Options, Text, Signature)                                     \\\n+  DIAG(NOTE, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef REMARK\n+#define REMARK(ID, Options, Text, Signature)                                   \\\n+  DIAG(REMARK, ID, Options, Text, Signature)\n+#endif\n+\n+#ifndef FIXIT\n+#define FIXIT(ID, Text, Signature)\n+#endif\n+\n+#undef DEFINE_DIAGNOSTIC_MACROS\n+#endif\n+\n+// Undefine macros\n+#ifdef UNDEFINE_DIAGNOSTIC_MACROS\n+\n+#ifndef DIAG_NO_UNDEF\n+\n+#if defined(DIAG)\n+#undef DIAG\n+#endif\n+\n+#undef REMARK\n+#undef NOTE\n+#undef WARNING\n+#undef ERROR\n+#undef FIXIT\n+\n+#endif\n+\n+#undef UNDEFINE_DIAGNOSTIC_MACROS\n+#endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsAll.def",
                        "code": "@@ -14,33 +14,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n #define DIAG_NO_UNDEF\n \n@@ -57,11 +32,5 @@\n \n #undef DIAG_NO_UNDEF\n \n-#if defined(DIAG)\n-#  undef DIAG\n-#endif\n-#undef NOTE\n-#undef WARNING\n-#undef ERROR\n-#undef REMARK\n-#undef FIXIT\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsClangImporter.def",
                        "code": "@@ -17,29 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_from_clang,none,\n   \"%0\", (StringRef))\n@@ -101,12 +80,5 @@ WARNING(implicit_bridging_header_imported_from_module,none,\n         \"is deprecated and will be removed in a later version of Swift\",\n         (StringRef, Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef REMARK\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsCommon.def",
                        "code": "@@ -17,33 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(invalid_diagnostic,none,\n       \"INTERNAL ERROR: this diagnostic should not be produced\", ())\n@@ -188,12 +163,5 @@ WARNING(cross_imported_by_both_modules, none,\n         \"please report this bug to the maintainers of these modules\",\n         (Identifier, Identifier, Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsDriver.def",
                        "code": "@@ -18,29 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_parallel_execution_not_supported,none,\n         \"parallel execution not supported; falling back to serial execution\",\n@@ -211,11 +190,5 @@ WARNING(warn_drv_darwin_sdk_invalid_settings, none,\n     \"SDK settings were ignored because 'SDKSettings.json' could not be parsed\",\n     ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsFrontend.def",
                        "code": "@@ -18,30 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && \\\n-                        defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature)   \\\n-DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n WARNING(warning_no_such_sdk,none,\n         \"no such SDK: '%0'\", (StringRef))\n@@ -407,12 +385,5 @@ ERROR(expectation_missing_opening_braces,none,\n ERROR(expectation_missing_closing_braces,none,\n       \"didn't find '}}' to match '{{' in expectation\", ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef REMARK\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsIRGen.def",
                        "code": "@@ -17,25 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(no_llvm_target,none,\n       \"error loading LLVM target for triple '%0': %1\", (StringRef, StringRef))\n@@ -67,11 +50,5 @@ ERROR(alignment_more_than_maximum,none,\n       \"@_alignment cannot increase alignment above maximum alignment of %0\",\n       (unsigned))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsModuleDiffer.def",
                        "code": "@@ -17,24 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n ERROR(generic_sig_change,none,\"%0 has generic signature change from %1 to %2\", (StringRef, StringRef, StringRef))\n \n@@ -104,11 +88,5 @@ ERROR(not_inheriting_convenience_inits,none,\"%0 no longer inherits convenience i\n \n ERROR(enum_case_added,none,\"%0 has been added as a new enum case\", (StringRef))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.def",
                        "code": "@@ -17,28 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n //==============================================================================\n // MARK: Lexing and Parsing diagnostics\n@@ -1770,12 +1750,5 @@ ERROR(availability_query_repeated_platform, none,\n ERROR(unknown_syntax_entity, PointsToFirstBadToken,\n       \"unknown %0 syntax exists in the source\", (StringRef))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsRefactoring.def",
                        "code": "@@ -17,24 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n //==============================================================================\n // Refactoring diagnostics\n@@ -69,3 +53,6 @@ ERROR(no_remaining_cases, none, \"no remaining cases to expand\", ())\n WARNING(mismatched_rename, none, \"the name at the given location cannot be renamed to '%0'\", (StringRef))\n \n ERROR(no_insert_position, none, \"cannot find inserting position\", ())\n+\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSIL.def",
                        "code": "@@ -17,30 +17,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE) && defined(REMARK)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE,REMARK}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef REMARK\n-#  define REMARK(ID,Options,Text,Signature) \\\n-  DIAG(REMARK,ID,Options,Text,Signature)\n-#endif\n-\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n // SILGen issues.\n ERROR(bridging_module_missing,none,\n@@ -644,12 +622,5 @@ ERROR(box_to_stack_cannot_promote_box_to_stack_due_to_escape_alloc, none,\n NOTE(box_to_stack_cannot_promote_box_to_stack_due_to_escape_location, none,\n      \"value escapes here\", ())\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef REMARK\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -18,28 +18,8 @@\n //\n //===----------------------------------------------------------------------===//\n \n-#if !(defined(DIAG) || (defined(ERROR) && defined(WARNING) && defined(NOTE)))\n-#  error Must define either DIAG or the set {ERROR,WARNING,NOTE}\n-#endif\n-\n-#ifndef ERROR\n-#  define ERROR(ID,Options,Text,Signature)   \\\n-  DIAG(ERROR,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef WARNING\n-#  define WARNING(ID,Options,Text,Signature) \\\n-  DIAG(WARNING,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef NOTE\n-#  define NOTE(ID,Options,Text,Signature) \\\n-  DIAG(NOTE,ID,Options,Text,Signature)\n-#endif\n-\n-#ifndef FIXIT\n-#  define FIXIT(ID, Text, Signature)\n-#endif\n+#define DEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\"\n \n #ifndef REMARK\n #  define REMARK(ID,Options,Text,Signature)   \\\n@@ -5064,12 +5044,5 @@ ERROR(atomics_ordering_must_be_constant, none,\n       \"ordering argument must be a static method or property of %0\",\n       (Identifier))\n \n-#ifndef DIAG_NO_UNDEF\n-# if defined(DIAG)\n-#  undef DIAG\n-# endif\n-# undef NOTE\n-# undef WARNING\n-# undef ERROR\n-# undef FIXIT\n-#endif\n+#define UNDEFINE_DIAGNOSTIC_MACROS\n+#include \"DefineDiagnosticMacros.h\""
                    }
                ]
            },
            {
                "date": "2020-04-11T22:56:33Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/cdd06d36de66362f5855ab6820cc201fb670152c",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -740,7 +740,7 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n       // Verify educational notes\n       for (auto &foundName : FoundDiagnostic.EducationalNotes) {\n         llvm::erase_if(expectedNotes->Names,\n-                       [&](std::string item) { return item == foundName; });\n+                       [&](StringRef item) { return item.equals(foundName); });\n       }\n \n       if (!expectedNotes->Names.empty()) {\n@@ -950,7 +950,7 @@ void DiagnosticVerifier::handleDiagnostic(SourceManager &SM,\n \n   llvm::SmallVector<std::string, 1> eduNotes;\n   for (auto &notePath : Info.EducationalNotePaths) {\n-    eduNotes.push_back(llvm::sys::path::stem(notePath));\n+    eduNotes.push_back(llvm::sys::path::stem(notePath).str());\n   }\n \n   llvm::SmallString<128> message;"
                    }
                ]
            },
            {
                "date": "2020-04-10T16:25:51Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/456081715ebaf2b5f2bb2bbdd3f7185c97d6843a",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -644,10 +644,10 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n         -> ActualFixitsPhrase {\n       std::string actualFixitsStr = renderFixits(actualFixits, InputFile);\n \n-      auto phrase = Twine(\"actual fix-it\") +\n-                    (actualFixits.size() >= 2 ? \"s\" : \"\") +\n-                    \" seen: \" + actualFixitsStr;\n-      return ActualFixitsPhrase{phrase.str(), actualFixitsStr};\n+      return ActualFixitsPhrase{(Twine(\"actual fix-it\") +\n+                                 (actualFixits.size() >= 2 ? \"s\" : \"\") +\n+                                 \" seen: \" + actualFixitsStr).str(),\n+                                actualFixitsStr};\n     };\n \n     auto emitFixItsError = [&](const char *location, const Twine &message,"
                    }
                ]
            },
            {
                "date": "2020-04-10T11:51:51Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/20d3afc4393712a59b0ef345c6898e08db79262b",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -589,10 +589,10 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n         -> ActualFixitsPhrase {\n       std::string actualFixitsStr = renderFixits(actualFixits, InputFile);\n \n-      auto phrase = Twine(\"actual fix-it\") +\n-                    (actualFixits.size() >= 2 ? \"s\" : \"\") +\n-                    \" seen: \" + actualFixitsStr;\n-      return ActualFixitsPhrase{phrase.str(), actualFixitsStr};\n+      return ActualFixitsPhrase{(Twine(\"actual fix-it\") +\n+                                 (actualFixits.size() >= 2 ? \"s\" : \"\") +\n+                                 \" seen: \" + actualFixitsStr).str(),\n+                                actualFixitsStr};\n     };\n \n     auto emitFixItsError = [&](const char *location, const Twine &message,"
                    }
                ]
            },
            {
                "date": "2020-03-31T16:15:49Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/77aa5642c363fdea7989025532fde57d270ff85e",
                "changes": [
                    {
                        "filename": "test/Constraints/diagnostics.swift",
                        "code": "@@ -161,7 +161,7 @@ public func myMap<T, U>(_ x: T?, _ f: (T) -> U) -> U? {\n \n // <rdar://problem/20142523>\n func rdar20142523() {\n-  myMap(0..<10, { x in // expected-error{{unable to infer complex closure return type; add explicit type to disambiguate}} {{21-21=-> <#Result#> }}\n+  myMap(0..<10, { x in // expected-error{{unable to infer complex closure return type; add explicit type to disambiguate}} {{21-21=-> <#Result#> }} {{educational-notes=complex-closure-inference}}\n     ()\n     return x\n   })"
                    },
                    {
                        "filename": "test/attr/attr_dynamic_callable.swift",
                        "code": "@@ -98,7 +98,7 @@ func testFunction(a: CallableReturningFunction) {\n //===----------------------------------------------------------------------===//\n \n // Arguments' type may not be variadic.\n-// expected-error @+1 {{@dynamicCallable attribute requires 'Invalid1' to have either a valid 'dynamicallyCall(withArguments:)' method or 'dynamicallyCall(withKeywordArguments:)' method}}\n+// expected-error @+1 {{@dynamicCallable attribute requires 'Invalid1' to have either a valid 'dynamicallyCall(withArguments:)' method or 'dynamicallyCall(withKeywordArguments:)' method}} {{educational-notes=dynamic-callable-requirements}}\n @dynamicCallable\n struct Invalid1 {\n   func dynamicallyCall(withArguments arguments: [Int]...) -> Int {\n@@ -107,7 +107,7 @@ struct Invalid1 {\n }\n \n // Keyword arguments' key type must be ExpressibleByStringLiteral.\n-// expected-error @+1 {{@dynamicCallable attribute requires 'Invalid2' to have either a valid 'dynamicallyCall(withArguments:)' method or 'dynamicallyCall(withKeywordArguments:)' method}}\n+// expected-error @+1 {{@dynamicCallable attribute requires 'Invalid2' to have either a valid 'dynamicallyCall(withArguments:)' method or 'dynamicallyCall(withKeywordArguments:)' method}} {{educational-notes=dynamic-callable-requirements}}\n @dynamicCallable\n struct Invalid2 {\n   func dynamicallyCall(\n@@ -128,8 +128,8 @@ protocol NoKeywordProtocol {\n }\n \n func testInvalidKeywordCall(x: NoKeyword, y: NoKeywordProtocol & AnyObject) {\n-  x(a: 1, b: 2) // expected-error {{@dynamicCallable type 'NoKeyword' cannot be applied with keyword arguments; missing 'dynamicCall(withKeywordArguments:)' method}}\n-  y(a: 1, b: 2) // expected-error {{@dynamicCallable type 'NoKeywordProtocol & AnyObject' cannot be applied with keyword arguments; missing 'dynamicCall(withKeywordArguments:)' method}}\n+  x(a: 1, b: 2) // expected-error {{@dynamicCallable type 'NoKeyword' cannot be applied with keyword arguments; missing 'dynamicCall(withKeywordArguments:)' method}} {{educational-notes=dynamic-callable-requirements}}\n+  y(a: 1, b: 2) // expected-error {{@dynamicCallable type 'NoKeywordProtocol & AnyObject' cannot be applied with keyword arguments; missing 'dynamicCall(withKeywordArguments:)' method}} {{educational-notes=dynamic-callable-requirements}}\n }\n \n // expected-error @+1 {{'@dynamicCallable' attribute cannot be applied to this declaration}}"
                    },
                    {
                        "filename": "test/decl/ext/extensions.swift",
                        "code": "@@ -81,10 +81,10 @@ protocol P1 {}\n \n protocol P2 {}\n \n-extension () {} // expected-error {{non-nominal type '()' cannot be extended}}\n+extension () {} // expected-error {{non-nominal type '()' cannot be extended}} {{educational-notes=nominal-types}}\n \n typealias TupleAlias = (x: Int, y: Int)\n-extension TupleAlias {} // expected-error{{non-nominal type 'TupleAlias' (aka '(x: Int, y: Int)') cannot be extended}}\n+extension TupleAlias {} // expected-error{{non-nominal type 'TupleAlias' (aka '(x: Int, y: Int)') cannot be extended}} {{educational-notes=nominal-types}}\n \n // Test property accessors in extended types\n class C {}"
                    },
                    {
                        "filename": "test/decl/var/property_wrappers.swift",
                        "code": "@@ -58,7 +58,7 @@ struct WrapperAcceptingAutoclosure<T> {\n \n @propertyWrapper\n struct MissingValue<T> { }\n-// expected-error@-1{{property wrapper type 'MissingValue' does not contain a non-static property named 'wrappedValue'}}\n+// expected-error@-1{{property wrapper type 'MissingValue' does not contain a non-static property named 'wrappedValue'}} {{educational-notes=property-wrapper-requirements}}\n \n @propertyWrapper\n struct StaticValue {\n@@ -76,7 +76,7 @@ protocol CannotBeAWrapper {\n \n @propertyWrapper\n struct NonVisibleValueWrapper<Value> {\n-  private var wrappedValue: Value // expected-error{{private property 'wrappedValue' cannot have more restrictive access than its enclosing property wrapper type 'NonVisibleValueWrapper' (which is internal)}}\n+  private var wrappedValue: Value // expected-error{{private property 'wrappedValue' cannot have more restrictive access than its enclosing property wrapper type 'NonVisibleValueWrapper' (which is internal)}} {{educational-notes=property-wrapper-requirements}}\n }\n \n @propertyWrapper\n@@ -92,7 +92,7 @@ struct NonVisibleInitWrapper<Value> {\n struct InitialValueTypeMismatch<Value> {\n   var wrappedValue: Value // expected-note{{'wrappedValue' declared here}}\n \n-  init(wrappedValue initialValue: Value?) { // expected-error{{'init(wrappedValue:)' parameter type ('Value?') must be the same as its 'wrappedValue' property type ('Value') or an @autoclosure thereof}}\n+  init(wrappedValue initialValue: Value?) { // expected-error{{'init(wrappedValue:)' parameter type ('Value?') must be the same as its 'wrappedValue' property type ('Value') or an @autoclosure thereof}} {{educational-notes=property-wrapper-requirements}}\n     self.wrappedValue = initialValue!\n   }\n }\n@@ -112,7 +112,7 @@ struct MultipleInitialValues<Value> {\n struct InitialValueFailable<Value> {\n   var wrappedValue: Value\n \n-  init?(wrappedValue initialValue: Value) { // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}}\n+  init?(wrappedValue initialValue: Value) { // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}} {{educational-notes=property-wrapper-requirements}}\n     return nil\n   }\n }"
                    },
                    {
                        "filename": "test/type/protocol_types.swift",
                        "code": "@@ -3,7 +3,7 @@\n protocol HasSelfRequirements {\n   func foo(_ x: Self)\n \n-  func returnsOwnProtocol() -> HasSelfRequirements // expected-error{{protocol 'HasSelfRequirements' can only be used as a generic constraint because it has Self or associated type requirements}}\n+  func returnsOwnProtocol() -> HasSelfRequirements // expected-error{{protocol 'HasSelfRequirements' can only be used as a generic constraint because it has Self or associated type requirements}} {{educational-notes=associated-type-requirements}}\n }\n protocol Bar {\n   // init() methods should not prevent use as an existential.\n@@ -68,7 +68,7 @@ protocol HasAssoc {\n }\n \n func testHasAssoc(_ x: Any) {\n-  if let p = x as? HasAssoc { // expected-error {{protocol 'HasAssoc' can only be used as a generic constraint}}\n+  if let p = x as? HasAssoc { // expected-error {{protocol 'HasAssoc' can only be used as a generic constraint}} {{educational-notes=associated-type-requirements}}\n     p.foo() // don't crash here.\n   }\n }"
                    }
                ]
            },
            {
                "date": "2019-12-28T20:02:31Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/1ac3709dfa56ce86eb5cbd858ae04ac3f6dac5fd",
                "changes": [
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -150,3 +150,5 @@ An expected diagnostic is denoted by a comment which begins with `expected-error\n - (Required) The expected error message. The message should be enclosed in double curly braces and should not include the `error:`/`warning:`/`note:`/`remark:` prefix. For example, `// expected-error {{invalid redeclaration of 'y'}}` would match an error with that message on the same line. The expected message does not need to match the emitted message verbatim. As long as the expected message is a substring of the original message, they will match.\n \n - (Optional) Expected fix-its. These are each enclosed in double curly braces and appear after the expected message. An expected fix-it consists of a column range followed by the text it's expected to be replaced with. For example, `let r : Int i = j // expected-error{{consecutive statements}} {{12-12=;}}` will match a fix-it attached to the consecutive statements error which inserts a semicolon at column 12, just after the 't' in 'Int'. The special {{none}} specifier is also supported, which will cause the diagnostic match to fail if unexpected fix-its are produced.\n+\n+- (Optional) Expected educational notes. These appear as a comma separated list after the expected message, enclosed in double curly braces and prefixed by 'educational-notes='. For example, `{{educational-notes=some-note,some-other-note}}` will verify the educational notes with filenames `some-note` and `some-other-note` appear. Do not include the file extension when specifying note names."
                    }
                ]
            },
            {
                "date": "2020-03-31T15:53:49Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/cfbedd81c42bf9a7708313d9ce4b717688438c0c",
                "changes": [
                    {
                        "filename": "include/swift/Frontend/DiagnosticVerifier.h",
                        "code": "@@ -46,14 +46,19 @@ struct CapturedDiagnosticInfo {\n   unsigned Line;\n   unsigned Column;\n   SmallVector<DiagnosticInfo::FixIt, 2> FixIts;\n+  SmallVector<std::string, 1> EducationalNotes;\n \n   CapturedDiagnosticInfo(llvm::SmallString<128> Message,\n                          llvm::SmallString<32> FileName,\n                          DiagnosticKind Classification, SourceLoc Loc,\n                          unsigned Line, unsigned Column,\n-                         SmallVector<DiagnosticInfo::FixIt, 2> FixIts)\n+                         SmallVector<DiagnosticInfo::FixIt, 2> FixIts,\n+                         SmallVector<std::string, 1> EducationalNotes)\n       : Message(Message), FileName(FileName), Classification(Classification),\n-        Loc(Loc), Line(Line), Column(Column), FixIts(FixIts) {}\n+        Loc(Loc), Line(Line), Column(Column), FixIts(FixIts),\n+        EducationalNotes(EducationalNotes) {\n+    std::sort(EducationalNotes.begin(), EducationalNotes.end());\n+  }\n };\n /// This class implements support for -verify mode in the compiler.  It\n /// buffers up diagnostics produced during compilation, then checks them"
                    },
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -17,9 +17,11 @@\n #include \"swift/Frontend/DiagnosticVerifier.h\"\n #include \"swift/Basic/SourceManager.h\"\n #include \"swift/Parse/Lexer.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/FormatVariadic.h\"\n #include \"llvm/Support/MemoryBuffer.h\"\n+#include \"llvm/Support/Path.h\"\n #include \"llvm/Support/raw_ostream.h\"\n \n using namespace swift;\n@@ -36,6 +38,7 @@ struct ExpectedFixIt {\n namespace {\n \n static constexpr StringLiteral fixitExpectationNoneString(\"none\");\n+static constexpr StringLiteral educationalNotesSpecifier(\"educational-notes=\");\n \n struct ExpectedDiagnosticInfo {\n   // This specifies the full range of the \"expected-foo {{}}\" specifier.\n@@ -65,6 +68,17 @@ struct ExpectedDiagnosticInfo {\n   // Loc of {{none}}\n   const char *noneMarkerStartLoc = nullptr;\n \n+  /// Represents a specifier of the form '{{educational-notes=note1,note2}}'.\n+  struct ExpectedEducationalNotes {\n+    const char *StartLoc, *EndLoc; // The loc of the {{ and }}'s.\n+    llvm::SmallVector<StringRef, 1> Names; // Names of expected notes.\n+\n+    ExpectedEducationalNotes(const char *StartLoc, const char *EndLoc,\n+                             llvm::SmallVector<StringRef, 1> Names)\n+        : StartLoc(StartLoc), EndLoc(EndLoc), Names(Names) {}\n+  };\n+  Optional<ExpectedEducationalNotes> EducationalNotes;\n+\n   ExpectedDiagnosticInfo(const char *ExpectedStart,\n                          DiagnosticKind Classification)\n       : ExpectedStart(ExpectedStart), Classification(Classification) {}\n@@ -85,6 +99,18 @@ static std::string getDiagKindString(DiagnosticKind Kind) {\n   llvm_unreachable(\"Unhandled DiagKind in switch.\");\n }\n \n+/// Render the verifier syntax for a given set of educational notes.\n+static std::string\n+renderEducationalNotes(llvm::SmallVectorImpl<std::string> &EducationalNotes) {\n+  std::string Result;\n+  llvm::raw_string_ostream OS(Result);\n+  OS << \"{{\" << educationalNotesSpecifier;\n+  interleave(EducationalNotes, [&](const auto &Note) { OS << Note; },\n+             [&] { OS << ','; });\n+  OS << \"}}\";\n+  return OS.str();\n+}\n+\n /// If we find the specified diagnostic in the list, return it.\n /// Otherwise return CapturedDiagnostics.end().\n static std::vector<CapturedDiagnosticInfo>::iterator\n@@ -439,38 +465,67 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n     StringRef ExtraChecks = MatchStart.substr(End+2).ltrim(\" \\t\");\n     while (ExtraChecks.startswith(\"{{\")) {\n       // First make sure we have a closing \"}}\".\n-      size_t EndLoc = ExtraChecks.find(\"}}\");\n-      if (EndLoc == StringRef::npos) {\n+      size_t EndIndex = ExtraChecks.find(\"}}\");\n+      if (EndIndex == StringRef::npos) {\n         addError(ExtraChecks.data(),\n-                 \"didn't find '}}' to match '{{' in fix-it verification\");\n+                 \"didn't find '}}' to match '{{' in diagnostic verification\");\n         break;\n       }\n-      \n+\n       // Allow for close braces to appear in the replacement text.\n-      while (EndLoc+2 < ExtraChecks.size() && ExtraChecks[EndLoc+2] == '}')\n-        ++EndLoc;\n-      \n-      StringRef FixItStr = ExtraChecks.slice(2, EndLoc);\n+      while (EndIndex + 2 < ExtraChecks.size() &&\n+             ExtraChecks[EndIndex + 2] == '}')\n+        ++EndIndex;\n+\n+      const char *OpenLoc = ExtraChecks.data(); // Beginning of opening '{{'.\n+      const char *CloseLoc =\n+          ExtraChecks.data() + EndIndex + 2; // End of closing '}}'.\n+\n+      StringRef CheckStr = ExtraChecks.slice(2, EndIndex);\n       // Check for matching a later \"}}\" on a different line.\n-      if (FixItStr.find_first_of(\"\\r\\n\") != StringRef::npos) {\n+      if (CheckStr.find_first_of(\"\\r\\n\") != StringRef::npos) {\n         addError(ExtraChecks.data(), \"didn't find '}}' to match '{{' in \"\n-                 \"fix-it verification\");\n+                                     \"diagnostic verification\");\n         break;\n       }\n-      \n+\n       // Prepare for the next round of checks.\n-      ExtraChecks = ExtraChecks.substr(EndLoc+2).ltrim();\n-      \n+      ExtraChecks = ExtraChecks.substr(EndIndex + 2).ltrim();\n+\n+      // If this check starts with 'educational-notes=', check for one or more\n+      // educational notes instead of a fix-it.\n+      if (CheckStr.startswith(educationalNotesSpecifier)) {\n+        if (Expected.EducationalNotes.hasValue()) {\n+          addError(CheckStr.data(),\n+                   \"each verified diagnostic may only have one \"\n+                   \"{{educational-notes=<#notes#>}} declaration\");\n+          continue;\n+        }\n+        StringRef NotesStr = CheckStr.substr(\n+            educationalNotesSpecifier.size()); // Trim 'educational-notes='.\n+        llvm::SmallVector<StringRef, 1> names;\n+        // Note names are comma-separated.\n+        std::pair<StringRef, StringRef> split;\n+        do {\n+          split = NotesStr.split(',');\n+          names.push_back(split.first);\n+          NotesStr = split.second;\n+        } while (!NotesStr.empty());\n+        Expected.EducationalNotes.emplace(OpenLoc, CloseLoc, names);\n+        continue;\n+      }\n+\n+      // This wasn't an educational notes specifier, so it must be a fix-it.\n       // Special case for specifying no fixits should appear.\n-      if (FixItStr == fixitExpectationNoneString) {\n+      if (CheckStr == fixitExpectationNoneString) {\n         if (Expected.noneMarkerStartLoc) {\n-          addError(FixItStr.data() - 2,\n+          addError(CheckStr.data() - 2,\n                    Twine(\"A second {{\") + fixitExpectationNoneString +\n                        \"}} was found. It may only appear once in an expectation.\");\n           break;\n         }\n \n-        Expected.noneMarkerStartLoc = FixItStr.data() - 2;\n+        Expected.noneMarkerStartLoc = CheckStr.data() - 2;\n         continue;\n       }\n \n@@ -482,14 +537,14 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n       }\n \n       // Parse the pieces of the fix-it.\n-      size_t MinusLoc = FixItStr.find('-');\n+      size_t MinusLoc = CheckStr.find('-');\n       if (MinusLoc == StringRef::npos) {\n-        addError(FixItStr.data(), \"expected '-' in fix-it verification\");\n+        addError(CheckStr.data(), \"expected '-' in fix-it verification\");\n         continue;\n       }\n-      StringRef StartColStr = FixItStr.slice(0, MinusLoc);\n-      StringRef AfterMinus = FixItStr.substr(MinusLoc+1);\n-      \n+      StringRef StartColStr = CheckStr.slice(0, MinusLoc);\n+      StringRef AfterMinus = CheckStr.substr(MinusLoc + 1);\n+\n       size_t EqualLoc = AfterMinus.find('=');\n       if (EqualLoc == StringRef::npos) {\n         addError(AfterMinus.data(),\n@@ -500,8 +555,8 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n       StringRef AfterEqual = AfterMinus.substr(EqualLoc+1);\n       \n       ExpectedFixIt FixIt;\n-      FixIt.StartLoc = StartColStr.data()-2;\n-      FixIt.EndLoc = FixItStr.data()+EndLoc;\n+      FixIt.StartLoc = OpenLoc;\n+      FixIt.EndLoc = CloseLoc;\n       if (StartColStr.getAsInteger(10, FixIt.StartCol)) {\n         addError(StartColStr.data(),\n                  \"invalid column number in fix-it verification\");\n@@ -514,7 +569,7 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n       }\n       \n       // Translate literal \"\\\\n\" into '\\n', inefficiently.\n-      StringRef fixItText = AfterEqual.slice(0, EndLoc);\n+      StringRef fixItText = AfterEqual.slice(0, EndIndex);\n       for (const char *current = fixItText.begin(), *end = fixItText.end();\n            current != end; /* in loop */) {\n         if (*current == '\\\\' && current + 1 < end) {\n@@ -681,6 +736,33 @@ DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n                       replEndLoc, actualFixits);\n     }\n \n+    if (auto expectedNotes = expected.EducationalNotes) {\n+      // Verify educational notes\n+      for (auto &foundName : FoundDiagnostic.EducationalNotes) {\n+        llvm::erase_if(expectedNotes->Names,\n+                       [&](std::string item) { return item == foundName; });\n+      }\n+\n+      if (!expectedNotes->Names.empty()) {\n+        if (FoundDiagnostic.EducationalNotes.empty()) {\n+          addError(expectedNotes->StartLoc,\n+                   \"expected educational note(s) not seen\");\n+        } else {\n+          // If we had an incorrect expected note, render it and produce a fixit\n+          // of our own.\n+          auto actual =\n+              renderEducationalNotes(FoundDiagnostic.EducationalNotes);\n+          auto replStartLoc = SMLoc::getFromPointer(expectedNotes->StartLoc);\n+          auto replEndLoc = SMLoc::getFromPointer(expectedNotes->EndLoc);\n+\n+          llvm::SMFixIt fix(llvm::SMRange(replStartLoc, replEndLoc), actual);\n+          addError(expectedNotes->StartLoc,\n+                   \"expected educational note(s) not seen; actual educational \"\n+                   \"note(s): \" + actual, fix);\n+        }\n+      }\n+    }\n+\n     // Actually remove the diagnostic from the list, so we don't match it\n     // again. We do have to do this after checking fix-its, though, because\n     // the diagnostic owns its fix-its.\n@@ -866,6 +948,11 @@ void DiagnosticVerifier::handleDiagnostic(SourceManager &SM,\n   SmallVector<DiagnosticInfo::FixIt, 2> fixIts;\n   std::copy(Info.FixIts.begin(), Info.FixIts.end(), std::back_inserter(fixIts));\n \n+  llvm::SmallVector<std::string, 1> eduNotes;\n+  for (auto &notePath : Info.EducationalNotePaths) {\n+    eduNotes.push_back(llvm::sys::path::stem(notePath));\n+  }\n+\n   llvm::SmallString<128> message;\n   {\n     llvm::raw_svector_ostream Out(message);\n@@ -878,10 +965,10 @@ void DiagnosticVerifier::handleDiagnostic(SourceManager &SM,\n     const auto fileName = SM.getDisplayNameForLoc(Info.Loc);\n     CapturedDiagnostics.emplace_back(message, fileName, Info.Kind, Info.Loc,\n                                      lineAndColumn.first, lineAndColumn.second,\n-                                     fixIts);\n+                                     fixIts, eduNotes);\n   } else {\n     CapturedDiagnostics.emplace_back(message, StringRef(), Info.Kind, Info.Loc,\n-                                     0, 0, fixIts);\n+                                     0, 0, fixIts, eduNotes);\n   }\n }\n "
                    },
                    {
                        "filename": "test/diagnostics/verifier.swift",
                        "code": "@@ -33,6 +33,15 @@ func b() {\n // CHECK: unexpected warning produced: initialization of immutable value 'c' was never used\n // CHECK-WARNINGS-AS-ERRORS: unexpected error produced: initialization of immutable value 'c' was never used\n \n+extension (Int, Int) {} // expected-error {{non-nominal type '(Int, Int)' cannot be extended}} {{educational-notes=foo-bar-baz}}\n+// CHECK: error: expected educational note(s) not seen; actual educational note(s): {{[{][{]}}educational-notes=nominal-types{{[}][}]}}\n+\n+extension (Bool, Int) {} // expected-error {{non-nominal type '(Bool, Int)' cannot be extended}} {{educational-notes=nominal-types}} {{educational-notes=nominal-types}}\n+// CHECK: error: each verified diagnostic may only have one {{[{][{]}}educational-notes=<#notes#>{{[}][}]}} declaration\n+\n+extension (Bool, Bool) {} // expected-error {{non-nominal type '(Bool, Bool)' cannot be extended}} {{educational-notes=nominal-types,foo-bar-baz}}\n+// CHECK: error: expected educational note(s) not seen; actual educational note(s): {{[{][{]}}educational-notes=nominal-types{{[}][}]}}\n+\n // Verify the serialized diags have the right magic at the top.\n // CHECK-SERIALIZED: DIA\n "
                    }
                ]
            },
            {
                "date": "2020-04-09T14:23:26Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/39465996b8d1c47bcdf225e553c373f05ac1f047",
                "changes": [
                    {
                        "filename": "lib/Sema/TypeCheckStmt.cpp",
                        "code": "@@ -1072,40 +1072,28 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     }\n   }\n \n-  Stmt *visitSwitchStmt(SwitchStmt *switchStmt) {\n-    // Type-check the subject expression.\n-    Expr *subjectExpr = switchStmt->getSubjectExpr();\n-    auto resultTy = TypeChecker::typeCheckExpression(subjectExpr, DC);\n-    auto limitExhaustivityChecks = !resultTy;\n-    if (Expr *newSubjectExpr =\n-            TypeChecker::coerceToRValue(getASTContext(), subjectExpr))\n-      subjectExpr = newSubjectExpr;\n-    switchStmt->setSubjectExpr(subjectExpr);\n-    Type subjectType = switchStmt->getSubjectExpr()->getType();\n-\n-    // Type-check the case blocks.\n-    AddSwitchNest switchNest(*this);\n-    AddLabeledStmt labelNest(*this, switchStmt);\n-\n-    // Pre-emptively visit all Decls (#if/#warning/#error) that still exist in\n-    // the list of raw cases.\n-    for (auto &node : switchStmt->getRawCases()) {\n-      if (!node.is<Decl *>())\n-        continue;\n-      TypeChecker::typeCheckDecl(node.get<Decl *>());\n-    }\n+  template <typename Iterator>\n+  void checkSiblingCaseStmts(Iterator casesBegin, Iterator casesEnd,\n+                             CaseParentKind parentKind,\n+                             bool &limitExhaustivityChecks, Type subjectType) {\n+    static_assert(\n+        std::is_same<typename std::iterator_traits<Iterator>::value_type,\n+                     CaseStmt *>::value,\n+        \"Expected an iterator over CaseStmt *\");\n \n     SmallVector<VarDecl *, 8> scratchMemory1;\n     SmallVector<VarDecl *, 8> scratchMemory2;\n-\n-    auto cases = switchStmt->getCases();\n     CaseStmt *previousBlock = nullptr;\n-    for (auto i = cases.begin(), e = cases.end(); i != e; ++i) {\n+\n+    for (auto i = casesBegin; i != casesEnd; ++i) {\n       auto *caseBlock = *i;\n-      // Fallthrough transfers control to the next case block. In the\n-      // final case block, it is invalid.\n-      FallthroughSource = caseBlock;\n-      FallthroughDest = std::next(i) == e ? nullptr : *std::next(i);\n+\n+      if (parentKind == CaseParentKind::Switch) {\n+        // Fallthrough transfers control to the next case block. In the\n+        // final case block, it is invalid. Only switch supports fallthrough.\n+        FallthroughSource = caseBlock;\n+        FallthroughDest = std::next(i) == casesEnd ? nullptr : *std::next(i);\n+      }\n \n       scratchMemory1.clear();\n       scratchMemory2.clear();\n@@ -1193,24 +1181,57 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n \n       // Check restrictions on '@unknown'.\n       if (caseBlock->hasUnknownAttr()) {\n+        assert(parentKind == CaseParentKind::Switch &&\n+               \"'@unknown' can only appear on switch cases\");\n         checkUnknownAttrRestrictions(\n             getASTContext(), caseBlock, FallthroughDest,\n             limitExhaustivityChecks);\n       }\n \n-      // If the previous case fellthrough, similarly check that that case's\n-      // bindings includes our first label item's pattern bindings and types.\n-      if (PreviousFallthrough && previousBlock) {\n-        checkFallthroughPatternBindingsAndTypes(caseBlock, previousBlock);\n+      if (parentKind == CaseParentKind::Switch) {\n+        // If the previous case fellthrough, similarly check that that case's\n+        // bindings includes our first label item's pattern bindings and types.\n+        // Only switch statements support fallthrough.\n+        if (PreviousFallthrough && previousBlock) {\n+          checkFallthroughPatternBindingsAndTypes(caseBlock, previousBlock);\n+        }\n+        PreviousFallthrough = nullptr;\n       }\n \n       // Type-check the body statements.\n-      PreviousFallthrough = nullptr;\n       Stmt *body = caseBlock->getBody();\n       limitExhaustivityChecks |= typeCheckStmt(body);\n       caseBlock->setBody(body);\n       previousBlock = caseBlock;\n     }\n+  }\n+\n+  Stmt *visitSwitchStmt(SwitchStmt *switchStmt) {\n+    // Type-check the subject expression.\n+    Expr *subjectExpr = switchStmt->getSubjectExpr();\n+    auto resultTy = TypeChecker::typeCheckExpression(subjectExpr, DC);\n+    auto limitExhaustivityChecks = !resultTy;\n+    if (Expr *newSubjectExpr =\n+            TypeChecker::coerceToRValue(getASTContext(), subjectExpr))\n+      subjectExpr = newSubjectExpr;\n+    switchStmt->setSubjectExpr(subjectExpr);\n+    Type subjectType = switchStmt->getSubjectExpr()->getType();\n+\n+    // Type-check the case blocks.\n+    AddSwitchNest switchNest(*this);\n+    AddLabeledStmt labelNest(*this, switchStmt);\n+\n+    // Pre-emptively visit all Decls (#if/#warning/#error) that still exist in\n+    // the list of raw cases.\n+    for (auto &node : switchStmt->getRawCases()) {\n+      if (!node.is<Decl *>())\n+        continue;\n+      TypeChecker::typeCheckDecl(node.get<Decl *>());\n+    }\n+\n+    auto cases = switchStmt->getCases();\n+    checkSiblingCaseStmts(cases.begin(), cases.end(), CaseParentKind::Switch,\n+                          limitExhaustivityChecks, subjectType);\n \n     if (!switchStmt->isImplicit()) {\n       TypeChecker::checkSwitchExhaustiveness(switchStmt, DC,\n@@ -1237,108 +1258,13 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     typeCheckStmt(newBody);\n     S->setBody(newBody);\n \n-    SmallVector<VarDecl *, 8> scratchMemory1;\n-    SmallVector<VarDecl *, 8> scratchMemory2;\n-\n-    auto clauses = S->getCatches();\n-    CaseStmt *previousBlock = nullptr;\n-    for (auto i = clauses.begin(), e = clauses.end(); i != e; ++i) {\n-      auto *caseBlock = *i;\n-\n-      scratchMemory1.clear();\n-      scratchMemory2.clear();\n-\n-      SmallVectorImpl<VarDecl *> *prevCaseDecls = nullptr;\n-      SmallVectorImpl<VarDecl *> *nextCaseDecls = &scratchMemory1;\n-\n-      auto caseLabelItemArray = caseBlock->getMutableCaseLabelItems();\n-      {\n-        // Peel off the first iteration so we handle the first case label\n-        // especially since we use it to begin the validation chain.\n-        auto &labelItem = caseLabelItemArray.front();\n-\n-        // Resolve the pattern in our case label if it has not been resolved and\n-        // check that our var decls follow invariants.\n-        bool limit = true;\n-        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n-                                  getASTContext().getExceptionType(),\n-                                  &prevCaseDecls, &nextCaseDecls);\n-\n-        // After this is complete, prevCaseDecls will be pointing at\n-        // scratchMemory1 which contains the initial case block's var decls and\n-        // nextCaseDecls will be a nullptr. Set nextCaseDecls to point at\n-        // scratchMemory2 for the next iterations.\n-        assert(prevCaseDecls == &scratchMemory1);\n-        assert(nextCaseDecls == nullptr);\n-        nextCaseDecls = &scratchMemory2;\n-\n-        // Check the guard expression, if present.\n-        if (auto *guard = labelItem.getGuardExpr()) {\n-          TypeChecker::typeCheckCondition(guard, DC);\n-          labelItem.setGuardExpr(guard);\n-        }\n-      }\n-\n-      // Setup the types of our case body var decls.\n-      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n-        assert(expected->hasName());\n-        for (auto *prev : *prevCaseDecls) {\n-          if (!prev->hasName() || expected->getName() != prev->getName()) {\n-            continue;\n-          }\n-          if (prev->hasInterfaceType())\n-            expected->setInterfaceType(prev->getInterfaceType());\n-          break;\n-        }\n-      }\n+    // Do-catch statements always limit exhaustivity checks.\n+    bool limitExhaustivityChecks = true;\n \n-      // Then check the rest.\n-      for (auto &labelItem : caseLabelItemArray.drop_front()) {\n-        // Resolve the pattern in our case label if it has not been resolved\n-        // and check that our var decls follow invariants.\n-        bool limit = true;\n-        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n-                                  getASTContext().getExceptionType(),\n-                                  &prevCaseDecls, &nextCaseDecls);\n-        // Check the guard expression, if present.\n-        if (auto *guard = labelItem.getGuardExpr()) {\n-          TypeChecker::typeCheckCondition(guard, DC);\n-          labelItem.setGuardExpr(guard);\n-        }\n-      }\n-\n-      // Our last CaseLabelItem's VarDecls are now in\n-      // prevCaseDecls. Wire them up as parents of our case body var\n-      // decls.\n-      //\n-      // NOTE: We know that the two lists of var decls must be in sync. Remember\n-      // that we constructed our case body VarDecls from the first\n-      // CaseLabelItems var decls. Just now we proved that all other\n-      // CaseLabelItems have matching var decls of the first meaning\n-      // transitively that our last case label item must have matching var decls\n-      // for our case stmts CaseBodyVarDecls.\n-      //\n-      // NOTE: We do not check that we matched everything here. That is because\n-      // the check has already been done by comparing the 1st CaseLabelItem var\n-      // decls. If we insert a check here, we will emit the same error multiple\n-      // times.\n-      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n-        assert(expected->hasName());\n-        for (auto *prev : *prevCaseDecls) {\n-          if (!prev->hasName() || expected->getName() != prev->getName()) {\n-            continue;\n-          }\n-          expected->setParentVarDecl(prev);\n-          break;\n-        }\n-      }\n-\n-      // Type-check the body statements.\n-      Stmt *body = caseBlock->getBody();\n-      typeCheckStmt(body);\n-      caseBlock->setBody(body);\n-      previousBlock = caseBlock;\n-    }\n+    auto catches = S->getCatches();\n+    checkSiblingCaseStmts(catches.begin(), catches.end(),\n+                          CaseParentKind::DoCatch, limitExhaustivityChecks,\n+                          getASTContext().getExceptionType());\n \n     return S;\n   }"
                    }
                ]
            },
            {
                "date": "2020-04-08T00:56:39Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/5213bec4d2e96d6cdccf4e91a615433f330d0336",
                "changes": [
                    {
                        "filename": "lib/Sema/TypeCheckStmt.cpp",
                        "code": "@@ -1072,40 +1072,28 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     }\n   }\n \n-  Stmt *visitSwitchStmt(SwitchStmt *switchStmt) {\n-    // Type-check the subject expression.\n-    Expr *subjectExpr = switchStmt->getSubjectExpr();\n-    auto resultTy = TypeChecker::typeCheckExpression(subjectExpr, DC);\n-    auto limitExhaustivityChecks = !resultTy;\n-    if (Expr *newSubjectExpr =\n-            TypeChecker::coerceToRValue(getASTContext(), subjectExpr))\n-      subjectExpr = newSubjectExpr;\n-    switchStmt->setSubjectExpr(subjectExpr);\n-    Type subjectType = switchStmt->getSubjectExpr()->getType();\n-\n-    // Type-check the case blocks.\n-    AddSwitchNest switchNest(*this);\n-    AddLabeledStmt labelNest(*this, switchStmt);\n-\n-    // Pre-emptively visit all Decls (#if/#warning/#error) that still exist in\n-    // the list of raw cases.\n-    for (auto &node : switchStmt->getRawCases()) {\n-      if (!node.is<Decl *>())\n-        continue;\n-      TypeChecker::typeCheckDecl(node.get<Decl *>());\n-    }\n+  template <typename Iterator>\n+  void checkSiblingCaseStmts(Iterator casesBegin, Iterator casesEnd,\n+                             CaseParentKind parentKind,\n+                             bool &limitExhaustivityChecks, Type subjectType) {\n+    static_assert(\n+        std::is_same<typename std::iterator_traits<Iterator>::value_type,\n+                     CaseStmt *>::value,\n+        \"Expected an iterator over CaseStmt *\");\n \n     SmallVector<VarDecl *, 8> scratchMemory1;\n     SmallVector<VarDecl *, 8> scratchMemory2;\n-\n-    auto cases = switchStmt->getCases();\n     CaseStmt *previousBlock = nullptr;\n-    for (auto i = cases.begin(), e = cases.end(); i != e; ++i) {\n+\n+    for (auto i = casesBegin; i != casesEnd; ++i) {\n       auto *caseBlock = *i;\n-      // Fallthrough transfers control to the next case block. In the\n-      // final case block, it is invalid.\n-      FallthroughSource = caseBlock;\n-      FallthroughDest = std::next(i) == e ? nullptr : *std::next(i);\n+\n+      if (parentKind == CaseParentKind::Switch) {\n+        // Fallthrough transfers control to the next case block. In the\n+        // final case block, it is invalid. Only switch supports fallthrough.\n+        FallthroughSource = caseBlock;\n+        FallthroughDest = std::next(i) == casesEnd ? nullptr : *std::next(i);\n+      }\n \n       scratchMemory1.clear();\n       scratchMemory2.clear();\n@@ -1193,24 +1181,57 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n \n       // Check restrictions on '@unknown'.\n       if (caseBlock->hasUnknownAttr()) {\n+        assert(parentKind == CaseParentKind::Switch &&\n+               \"'@unknown' can only appear on switch cases\");\n         checkUnknownAttrRestrictions(\n             getASTContext(), caseBlock, FallthroughDest,\n             limitExhaustivityChecks);\n       }\n \n-      // If the previous case fellthrough, similarly check that that case's\n-      // bindings includes our first label item's pattern bindings and types.\n-      if (PreviousFallthrough && previousBlock) {\n-        checkFallthroughPatternBindingsAndTypes(caseBlock, previousBlock);\n+      if (parentKind == CaseParentKind::Switch) {\n+        // If the previous case fellthrough, similarly check that that case's\n+        // bindings includes our first label item's pattern bindings and types.\n+        // Only switch statements support fallthrough.\n+        if (PreviousFallthrough && previousBlock) {\n+          checkFallthroughPatternBindingsAndTypes(caseBlock, previousBlock);\n+        }\n+        PreviousFallthrough = nullptr;\n       }\n \n       // Type-check the body statements.\n-      PreviousFallthrough = nullptr;\n       Stmt *body = caseBlock->getBody();\n       limitExhaustivityChecks |= typeCheckStmt(body);\n       caseBlock->setBody(body);\n       previousBlock = caseBlock;\n     }\n+  }\n+\n+  Stmt *visitSwitchStmt(SwitchStmt *switchStmt) {\n+    // Type-check the subject expression.\n+    Expr *subjectExpr = switchStmt->getSubjectExpr();\n+    auto resultTy = TypeChecker::typeCheckExpression(subjectExpr, DC);\n+    auto limitExhaustivityChecks = !resultTy;\n+    if (Expr *newSubjectExpr =\n+            TypeChecker::coerceToRValue(getASTContext(), subjectExpr))\n+      subjectExpr = newSubjectExpr;\n+    switchStmt->setSubjectExpr(subjectExpr);\n+    Type subjectType = switchStmt->getSubjectExpr()->getType();\n+\n+    // Type-check the case blocks.\n+    AddSwitchNest switchNest(*this);\n+    AddLabeledStmt labelNest(*this, switchStmt);\n+\n+    // Pre-emptively visit all Decls (#if/#warning/#error) that still exist in\n+    // the list of raw cases.\n+    for (auto &node : switchStmt->getRawCases()) {\n+      if (!node.is<Decl *>())\n+        continue;\n+      TypeChecker::typeCheckDecl(node.get<Decl *>());\n+    }\n+\n+    auto cases = switchStmt->getCases();\n+    checkSiblingCaseStmts(cases.begin(), cases.end(), CaseParentKind::Switch,\n+                          limitExhaustivityChecks, subjectType);\n \n     if (!switchStmt->isImplicit()) {\n       TypeChecker::checkSwitchExhaustiveness(switchStmt, DC,\n@@ -1237,108 +1258,13 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     typeCheckStmt(newBody);\n     S->setBody(newBody);\n \n-    SmallVector<VarDecl *, 8> scratchMemory1;\n-    SmallVector<VarDecl *, 8> scratchMemory2;\n-\n-    auto clauses = S->getCatches();\n-    CaseStmt *previousBlock = nullptr;\n-    for (auto i = clauses.begin(), e = clauses.end(); i != e; ++i) {\n-      auto *caseBlock = *i;\n-\n-      scratchMemory1.clear();\n-      scratchMemory2.clear();\n-\n-      SmallVectorImpl<VarDecl *> *prevCaseDecls = nullptr;\n-      SmallVectorImpl<VarDecl *> *nextCaseDecls = &scratchMemory1;\n-\n-      auto caseLabelItemArray = caseBlock->getMutableCaseLabelItems();\n-      {\n-        // Peel off the first iteration so we handle the first case label\n-        // especially since we use it to begin the validation chain.\n-        auto &labelItem = caseLabelItemArray.front();\n-\n-        // Resolve the pattern in our case label if it has not been resolved and\n-        // check that our var decls follow invariants.\n-        bool limit = true;\n-        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n-                                  getASTContext().getExceptionType(),\n-                                  &prevCaseDecls, &nextCaseDecls);\n-\n-        // After this is complete, prevCaseDecls will be pointing at\n-        // scratchMemory1 which contains the initial case block's var decls and\n-        // nextCaseDecls will be a nullptr. Set nextCaseDecls to point at\n-        // scratchMemory2 for the next iterations.\n-        assert(prevCaseDecls == &scratchMemory1);\n-        assert(nextCaseDecls == nullptr);\n-        nextCaseDecls = &scratchMemory2;\n-\n-        // Check the guard expression, if present.\n-        if (auto *guard = labelItem.getGuardExpr()) {\n-          TypeChecker::typeCheckCondition(guard, DC);\n-          labelItem.setGuardExpr(guard);\n-        }\n-      }\n-\n-      // Setup the types of our case body var decls.\n-      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n-        assert(expected->hasName());\n-        for (auto *prev : *prevCaseDecls) {\n-          if (!prev->hasName() || expected->getName() != prev->getName()) {\n-            continue;\n-          }\n-          if (prev->hasInterfaceType())\n-            expected->setInterfaceType(prev->getInterfaceType());\n-          break;\n-        }\n-      }\n+    // Do-catch statements always limit exhaustivity checks.\n+    bool limitExhaustivityChecks = true;\n \n-      // Then check the rest.\n-      for (auto &labelItem : caseLabelItemArray.drop_front()) {\n-        // Resolve the pattern in our case label if it has not been resolved\n-        // and check that our var decls follow invariants.\n-        bool limit = true;\n-        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n-                                  getASTContext().getExceptionType(),\n-                                  &prevCaseDecls, &nextCaseDecls);\n-        // Check the guard expression, if present.\n-        if (auto *guard = labelItem.getGuardExpr()) {\n-          TypeChecker::typeCheckCondition(guard, DC);\n-          labelItem.setGuardExpr(guard);\n-        }\n-      }\n-\n-      // Our last CaseLabelItem's VarDecls are now in\n-      // prevCaseDecls. Wire them up as parents of our case body var\n-      // decls.\n-      //\n-      // NOTE: We know that the two lists of var decls must be in sync. Remember\n-      // that we constructed our case body VarDecls from the first\n-      // CaseLabelItems var decls. Just now we proved that all other\n-      // CaseLabelItems have matching var decls of the first meaning\n-      // transitively that our last case label item must have matching var decls\n-      // for our case stmts CaseBodyVarDecls.\n-      //\n-      // NOTE: We do not check that we matched everything here. That is because\n-      // the check has already been done by comparing the 1st CaseLabelItem var\n-      // decls. If we insert a check here, we will emit the same error multiple\n-      // times.\n-      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n-        assert(expected->hasName());\n-        for (auto *prev : *prevCaseDecls) {\n-          if (!prev->hasName() || expected->getName() != prev->getName()) {\n-            continue;\n-          }\n-          expected->setParentVarDecl(prev);\n-          break;\n-        }\n-      }\n-\n-      // Type-check the body statements.\n-      Stmt *body = caseBlock->getBody();\n-      typeCheckStmt(body);\n-      caseBlock->setBody(body);\n-      previousBlock = caseBlock;\n-    }\n+    auto catches = S->getCatches();\n+    checkSiblingCaseStmts(catches.begin(), catches.end(),\n+                          CaseParentKind::DoCatch, limitExhaustivityChecks,\n+                          getASTContext().getExceptionType());\n \n     return S;\n   }"
                    }
                ]
            },
            {
                "date": "2020-04-07T21:44:47Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/0bfd10e8d26d9ae1fd28dc3462be74c1722bc063",
                "changes": [
                    {
                        "filename": "CHANGELOG.md",
                        "code": "@@ -27,6 +27,19 @@ CHANGELOG\n Swift 5.3\n ----------\n \n+* [SE-0276][]:\n+\n+  Catch clauses in a `do`-`catch` statement can now include multiple patterns in a comma-separated list. The body of a `catch` clause will be executed if a thrown error matches any of its patterns.\n+\n+  ```swift\n+  do {\n+    try performTask()\n+  } catch TaskError.someFailure(let msg),\n+          TaskError.anotherFailure(let msg) {\n+    showMessage(msg)\n+  }\n+  ```\n+\n * [SE-0280][]:\n   \n   Enum cases can now satisfy static protocol requirements. A static get-only property of type `Self` can be witnessed by an enum case with no associated values and a static function with arguments and returning `Self` can be witnessed by an enum case with associated values.\n@@ -7970,6 +7983,7 @@ Swift 1.0\n [SE-0266]: <https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md>\n [SE-0267]: <https://github.com/apple/swift-evolution/blob/master/proposals/0267-where-on-contextually-generic.md>\n [SE-0269]: <https://github.com/apple/swift-evolution/blob/master/proposals/0269-implicit-self-explicit-capture.md>\n+[SE-0276]: <https://github.com/apple/swift-evolution/blob/master/proposals/0276-multi-pattern-catch-clauses.md>\n [SE-0280]: <https://github.com/apple/swift-evolution/blob/master/proposals/0280-enum-cases-as-protocol-witnesses.md>\n \n [SR-75]: <https://bugs.swift.org/browse/SR-75>"
                    }
                ]
            },
            {
                "date": "2019-10-12T22:22:42Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/43e2d107e1e5bf9e1ea325d884c0ff79f3e514aa",
                "changes": [
                    {
                        "filename": "include/swift/AST/ASTScope.h",
                        "code": "@@ -1893,29 +1893,6 @@ class ForEachPatternScope final : public ASTScopeImpl {\n                              DeclConsumer) const override;\n };\n \n-class CatchStmtScope final : public AbstractStmtScope {\n-public:\n-  CatchStmt *const stmt;\n-  CatchStmtScope(CatchStmt *e) : stmt(e) {}\n-  virtual ~CatchStmtScope() {}\n-\n-protected:\n-  ASTScopeImpl *expandSpecifically(ScopeCreator &scopeCreator) override;\n-\n-private:\n-  void expandAScopeThatDoesNotCreateANewInsertionPoint(ScopeCreator &);\n-\n-public:\n-  std::string getClassName() const override;\n-  SourceRange\n-  getSourceRangeOfThisASTNode(bool omitAssertions = false) const override;\n-  Stmt *getStmt() const override { return stmt; }\n-\n-protected:\n-  bool lookupLocalsOrMembers(ArrayRef<const ASTScopeImpl *>,\n-                             ASTScopeImpl::DeclConsumer) const override;\n-};\n-\n class CaseStmtScope final : public AbstractStmtScope {\n public:\n   CaseStmt *const stmt;"
                    },
                    {
                        "filename": "include/swift/AST/NameLookup.h",
                        "code": "@@ -593,8 +593,6 @@ class FindLocalVal : public StmtVisitor<FindLocalVal> {\n   void visitCaseStmt(CaseStmt *S);\n \n   void visitDoCatchStmt(DoCatchStmt *S);\n-  void visitCatchClauses(ArrayRef<CatchStmt*> clauses);\n-  void visitCatchStmt(CatchStmt *S);\n   \n };\n   "
                    },
                    {
                        "filename": "include/swift/AST/Stmt.h",
                        "code": "@@ -559,105 +559,6 @@ class DoStmt : public LabeledStmt {\n   static bool classof(const Stmt *S) { return S->getKind() == StmtKind::Do; }\n };\n \n-/// An individual 'catch' clause.\n-/// \n-/// This isn't really an independent statement any more than CaseStmt\n-/// is; it's just a structural part of a DoCatchStmt.\n-class CatchStmt : public Stmt {\n-  SourceLoc CatchLoc;\n-  SourceLoc WhereLoc;\n-  Pattern *ErrorPattern;\n-  Expr *GuardExpr;\n-  Stmt *CatchBody;\n-\n-public:\n-  CatchStmt(SourceLoc catchLoc, Pattern *errorPattern,\n-            SourceLoc whereLoc, Expr *guardExpr, Stmt *body,\n-            Optional<bool> implicit = None)\n-    : Stmt(StmtKind::Catch, getDefaultImplicitFlag(implicit, catchLoc)),\n-      CatchLoc(catchLoc), WhereLoc(whereLoc),\n-      ErrorPattern(nullptr), GuardExpr(guardExpr), CatchBody(body) {\n-    setErrorPattern(errorPattern);\n-  }\n-\n-  SourceLoc getCatchLoc() const { return CatchLoc; }\n-\n-  /// The location of the 'where' keyword if there's a guard expression.\n-  SourceLoc getWhereLoc() const { return WhereLoc; }\n-\n-  SourceLoc getStartLoc() const { return CatchLoc; }\n-  SourceLoc getEndLoc() const { return CatchBody->getEndLoc(); }\n-\n-  Stmt *getBody() const { return CatchBody; }\n-  void setBody(Stmt *body) { CatchBody = body; }\n-\n-  Pattern *getErrorPattern() { return ErrorPattern; }\n-  const Pattern *getErrorPattern() const { return ErrorPattern; }\n-  void setErrorPattern(Pattern *pattern);\n-\n-  /// Is this catch clause \"syntactically exhaustive\"?\n-  bool isSyntacticallyExhaustive() const;\n-\n-  /// Return the guard expression if present, or null if the catch has\n-  /// no guard.\n-  Expr *getGuardExpr() const { return GuardExpr; }\n-  void setGuardExpr(Expr *guard) { GuardExpr = guard; }\n-\n-  static bool classof(const Stmt *S) { return S->getKind() == StmtKind::Catch; }\n-};\n-\n-/// DoCatchStmt - do statement with trailing 'catch' clauses.\n-class DoCatchStmt final : public LabeledStmt,\n-    private llvm::TrailingObjects<DoCatchStmt, CatchStmt *> {\n-  friend TrailingObjects;\n-\n-  SourceLoc DoLoc;\n-  Stmt *Body;\n-\n-  DoCatchStmt(LabeledStmtInfo labelInfo, SourceLoc doLoc,\n-              Stmt *body, ArrayRef<CatchStmt*> catches,\n-              Optional<bool> implicit)\n-    : LabeledStmt(StmtKind::DoCatch, getDefaultImplicitFlag(implicit, doLoc),\n-                  labelInfo), DoLoc(doLoc), Body(body) {\n-    Bits.DoCatchStmt.NumCatches = catches.size();\n-    std::uninitialized_copy(catches.begin(), catches.end(),\n-                            getTrailingObjects<CatchStmt *>());\n-  }\n-\n-public:\n-  static DoCatchStmt *create(ASTContext &ctx, LabeledStmtInfo labelInfo,\n-                             SourceLoc doLoc, Stmt *body,\n-                             ArrayRef<CatchStmt*> catches,\n-                             Optional<bool> implicit = None);\n-\n-  SourceLoc getDoLoc() const { return DoLoc; }\n-\n-  SourceLoc getStartLoc() const { return getLabelLocOrKeywordLoc(DoLoc); }\n-  SourceLoc getEndLoc() const { return getCatches().back()->getEndLoc(); }\n-\n-  Stmt *getBody() const { return Body; }\n-  void setBody(Stmt *s) { Body = s; }\n-\n-  ArrayRef<CatchStmt*> getCatches() const {\n-    return {getTrailingObjects<CatchStmt*>(), Bits.DoCatchStmt.NumCatches};\n-  }\n-  MutableArrayRef<CatchStmt*> getMutableCatches() {\n-    return {getTrailingObjects<CatchStmt*>(), Bits.DoCatchStmt.NumCatches};\n-  }\n-\n-  /// Does this statement contain a syntactically exhaustive catch\n-  /// clause?\n-  ///\n-  /// Note that an exhaustive do/catch statement can still throw\n-  /// errors out of its catch block(s).\n-  bool isSyntacticallyExhaustive() const;\n-\n-  static bool classof(const Stmt *S) {\n-    return S->getKind() == StmtKind::DoCatch;\n-  }\n-};\n-\n-\n /// Either an \"if let\" case or a simple boolean expression can appear as the\n /// condition of an 'if' or 'while' statement.\n using StmtCondition = MutableArrayRef<StmtConditionElement>;\n@@ -962,6 +863,8 @@ class CaseLabelItem {\n   bool isDefault() const {\n     return GuardExprAndKind.getInt() == Kind::Default;\n   }\n+\n+  bool isSyntacticallyExhaustive() const;\n };\n \n /// FallthroughStmt - The keyword \"fallthrough\".\n@@ -1003,9 +906,12 @@ class FallthroughStmt : public Stmt {\n   }\n };\n \n-/// A 'case' or 'default' block of a switch statement.  Only valid as the\n-/// substatement of a SwitchStmt.  A case block begins either with one or more\n-/// CaseLabelItems or a single 'default' label.\n+enum CaseParentKind { Switch, DoCatch };\n+\n+/// A 'case' or 'default' block of a switch statement, or a 'catch' clause of a\n+/// do-catch statement.  Only valid as the substatement of a SwitchStmt or\n+/// DoCatchStmt.  A case block begins either with one or more CaseLabelItems or\n+/// a single 'default' label.\n ///\n /// Some examples:\n /// \\code\n@@ -1023,28 +929,32 @@ class CaseStmt final\n   friend TrailingObjects;\n \n   SourceLoc UnknownAttrLoc;\n-  SourceLoc CaseLoc;\n-  SourceLoc ColonLoc;\n+  SourceLoc ItemIntroducerLoc;\n+  SourceLoc ItemTerminatorLoc;\n+  CaseParentKind ParentKind;\n \n   llvm::PointerIntPair<Stmt *, 1, bool> BodyAndHasFallthrough;\n \n   Optional<MutableArrayRef<VarDecl *>> CaseBodyVariables;\n \n-  CaseStmt(SourceLoc CaseLoc, ArrayRef<CaseLabelItem> CaseLabelItems,\n-           SourceLoc UnknownAttrLoc, SourceLoc ColonLoc, Stmt *Body,\n+  CaseStmt(CaseParentKind ParentKind, SourceLoc ItemIntroducerLoc,\n+           ArrayRef<CaseLabelItem> CaseLabelItems, SourceLoc UnknownAttrLoc,\n+           SourceLoc ItemTerminatorLoc, Stmt *Body,\n            Optional<MutableArrayRef<VarDecl *>> CaseBodyVariables,\n            Optional<bool> Implicit,\n            NullablePtr<FallthroughStmt> fallthroughStmt);\n \n public:\n   static CaseStmt *\n-  create(ASTContext &C, SourceLoc CaseLoc,\n+  create(ASTContext &C, CaseParentKind ParentKind, SourceLoc ItemIntroducerLoc,\n          ArrayRef<CaseLabelItem> CaseLabelItems, SourceLoc UnknownAttrLoc,\n-         SourceLoc ColonLoc, Stmt *Body,\n+         SourceLoc ItemTerminatorLoc, Stmt *Body,\n          Optional<MutableArrayRef<VarDecl *>> CaseBodyVariables,\n          Optional<bool> Implicit = None,\n          NullablePtr<FallthroughStmt> fallthroughStmt = nullptr);\n \n+  CaseParentKind getParentKind() const { return ParentKind; }\n+\n   ArrayRef<CaseLabelItem> getCaseLabelItems() const {\n     return {getTrailingObjects<CaseLabelItem>(), Bits.CaseStmt.NumPatterns};\n   }\n@@ -1073,17 +983,38 @@ class CaseStmt final\n   /// True if the case block declares any patterns with local variable bindings.\n   bool hasBoundDecls() const { return CaseBodyVariables.hasValue(); }\n \n-  /// Get the source location of the 'case' or 'default' of the first label.\n-  SourceLoc getLoc() const { return CaseLoc; }\n+  /// Get the source location of the 'case', 'default', or 'catch' of the first\n+  /// label.\n+  SourceLoc getLoc() const { return ItemIntroducerLoc; }\n \n   SourceLoc getStartLoc() const {\n     if (UnknownAttrLoc.isValid())\n       return UnknownAttrLoc;\n     return getLoc();\n   }\n   SourceLoc getEndLoc() const { return getBody()->getEndLoc(); }\n+\n   SourceRange getLabelItemsRange() const {\n-    return ColonLoc.isValid() ? SourceRange(getLoc(), ColonLoc) : getSourceRange();\n+    switch (ParentKind) {\n+    case CaseParentKind::Switch:\n+      // The range extends from 'case' to the colon at the end.\n+      return ItemTerminatorLoc.isValid()\n+                 ? SourceRange(getLoc(), ItemTerminatorLoc)\n+                 : getSourceRange();\n+    case CaseParentKind::DoCatch: {\n+      // The range extends from 'catch' to the end of the last non-implicit\n+      // item.\n+      auto items = getCaseLabelItems();\n+      for (auto item = items.rbegin(), end = items.rend(); item != end;\n+           ++item) {\n+        auto itemEndLoc = item->getEndLoc();\n+        if (itemEndLoc.isValid())\n+          return SourceRange(getLoc(), itemEndLoc);\n+      }\n+      // Handle the 'catch {' case.\n+      return SourceRange(getLoc(), getLoc());\n+    }\n+    }\n   }\n \n   bool isDefault() { return getCaseLabelItems()[0].isDefault(); }\n@@ -1213,6 +1144,58 @@ class SwitchStmt final : public LabeledStmt,\n   }\n };\n \n+/// DoCatchStmt - do statement with trailing 'catch' clauses.\n+class DoCatchStmt final\n+    : public LabeledStmt,\n+      private llvm::TrailingObjects<DoCatchStmt, CaseStmt *> {\n+  friend TrailingObjects;\n+\n+  SourceLoc DoLoc;\n+  Stmt *Body;\n+\n+  DoCatchStmt(LabeledStmtInfo labelInfo, SourceLoc doLoc, Stmt *body,\n+              ArrayRef<CaseStmt *> catches, Optional<bool> implicit)\n+      : LabeledStmt(StmtKind::DoCatch, getDefaultImplicitFlag(implicit, doLoc),\n+                    labelInfo),\n+        DoLoc(doLoc), Body(body) {\n+    Bits.DoCatchStmt.NumCatches = catches.size();\n+    std::uninitialized_copy(catches.begin(), catches.end(),\n+                            getTrailingObjects<CaseStmt *>());\n+  }\n+\n+public:\n+  static DoCatchStmt *create(ASTContext &ctx, LabeledStmtInfo labelInfo,\n+                             SourceLoc doLoc, Stmt *body,\n+                             ArrayRef<CaseStmt *> catches,\n+                             Optional<bool> implicit = None);\n+\n+  SourceLoc getDoLoc() const { return DoLoc; }\n+\n+  SourceLoc getStartLoc() const { return getLabelLocOrKeywordLoc(DoLoc); }\n+  SourceLoc getEndLoc() const { return getCatches().back()->getEndLoc(); }\n+\n+  Stmt *getBody() const { return Body; }\n+  void setBody(Stmt *s) { Body = s; }\n+\n+  ArrayRef<CaseStmt *> getCatches() const {\n+    return {getTrailingObjects<CaseStmt *>(), Bits.DoCatchStmt.NumCatches};\n+  }\n+  MutableArrayRef<CaseStmt *> getMutableCatches() {\n+    return {getTrailingObjects<CaseStmt *>(), Bits.DoCatchStmt.NumCatches};\n+  }\n+\n+  /// Does this statement contain a syntactically exhaustive catch\n+  /// clause?\n+  ///\n+  /// Note that an exhaustive do/catch statement can still throw\n+  /// errors out of its catch block(s).\n+  bool isSyntacticallyExhaustive() const;\n+\n+  static bool classof(const Stmt *S) {\n+    return S->getKind() == StmtKind::DoCatch;\n+  }\n+};\n+\n /// BreakStmt - The \"break\" and \"break label\" statement.\n class BreakStmt : public Stmt {\n   SourceLoc Loc;"
                    },
                    {
                        "filename": "include/swift/AST/StmtNodes.def",
                        "code": "@@ -61,7 +61,6 @@ ABSTRACT_STMT(Labeled, Stmt)\n   LABELED_STMT(Switch, LabeledStmt)\n   STMT_RANGE(Labeled, If, Switch)\n STMT(Case, Stmt)\n-STMT(Catch, Stmt)\n STMT(Break, Stmt)\n STMT(Continue, Stmt)\n STMT(Fallthrough, Stmt)"
                    },
                    {
                        "filename": "include/swift/Parse/Parser.h",
                        "code": "@@ -1617,7 +1617,7 @@ class Parser {\n   ParserResult<Stmt> parseStmtRepeat(LabeledStmtInfo LabelInfo);\n   ParserResult<Stmt> parseStmtDo(LabeledStmtInfo LabelInfo,\n                                  bool shouldSkipDoTokenConsume = false);\n-  ParserResult<CatchStmt> parseStmtCatch();\n+  ParserResult<CaseStmt> parseStmtCatch();\n   ParserResult<Stmt> parseStmtForEach(LabeledStmtInfo LabelInfo);\n   ParserResult<Stmt> parseStmtSwitch(LabeledStmtInfo LabelInfo);\n   ParserStatus parseStmtCases(SmallVectorImpl<ASTNode> &cases, bool IsActive);"
                    },
                    {
                        "filename": "lib/AST/ASTDumper.cpp",
                        "code": "@@ -1710,22 +1710,11 @@ class PrintStmt : public StmtVisitor<PrintStmt> {\n     Indent -= 2;\n     PrintWithColorRAII(OS, ParenthesisColor) << ')';\n   }\n-  void visitCatches(ArrayRef<CatchStmt*> clauses) {\n+  void visitCatches(ArrayRef<CaseStmt *> clauses) {\n     for (auto clause : clauses) {\n-      visitCatchStmt(clause);\n+      visitCaseStmt(clause);\n     }\n   }\n-  void visitCatchStmt(CatchStmt *clause) {\n-    printCommon(clause, \"catch\") << '\\n';\n-    printRec(clause->getErrorPattern());\n-    if (auto guard = clause->getGuardExpr()) {\n-      OS << '\\n';\n-      printRec(guard);\n-    }\n-    OS << '\\n';\n-    printRec(clause->getBody());\n-    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n-  }\n };\n \n } // end anonymous namespace"
                    },
                    {
                        "filename": "lib/AST/ASTPrinter.cpp",
                        "code": "@@ -3364,22 +3364,10 @@ void PrintAST::visitDoCatchStmt(DoCatchStmt *stmt) {\n   Printer << tok::kw_do << \" \";\n   visit(stmt->getBody());\n   for (auto clause : stmt->getCatches()) {\n-    visitCatchStmt(clause);\n+    visitCaseStmt(clause);\n   }\n }\n \n-void PrintAST::visitCatchStmt(CatchStmt *stmt) {\n-  Printer << tok::kw_catch << \" \";\n-  printPattern(stmt->getErrorPattern());\n-  if (auto guard = stmt->getGuardExpr()) {\n-    Printer << \" \" << tok::kw_where << \" \";\n-    // FIXME: print guard expression\n-    (void) guard;\n-  }\n-  Printer << ' ';\n-  visit(stmt->getBody());\n-}\n-\n void PrintAST::visitForEachStmt(ForEachStmt *stmt) {\n   Printer << tok::kw_for << \" \";\n   printPattern(stmt->getPattern());"
                    },
                    {
                        "filename": "lib/AST/ASTScope.cpp",
                        "code": "@@ -241,7 +241,6 @@ DEFINE_GET_CLASS_NAME(DoCatchStmtScope)\n DEFINE_GET_CLASS_NAME(SwitchStmtScope)\n DEFINE_GET_CLASS_NAME(ForEachStmtScope)\n DEFINE_GET_CLASS_NAME(ForEachPatternScope)\n-DEFINE_GET_CLASS_NAME(CatchStmtScope)\n DEFINE_GET_CLASS_NAME(CaseStmtScope)\n DEFINE_GET_CLASS_NAME(BraceStmtScope)\n "
                    },
                    {
                        "filename": "lib/AST/ASTScopeCreation.cpp",
                        "code": "@@ -869,7 +869,6 @@ class NodeAdder\n   VISIT_AND_CREATE(DoCatchStmt, DoCatchStmtScope)\n   VISIT_AND_CREATE(SwitchStmt, SwitchStmtScope)\n   VISIT_AND_CREATE(ForEachStmt, ForEachStmtScope)\n-  VISIT_AND_CREATE(CatchStmt, CatchStmtScope)\n   VISIT_AND_CREATE(CaseStmt, CaseStmtScope)\n   VISIT_AND_CREATE(AbstractFunctionDecl, AbstractFunctionDeclScope)\n \n@@ -1203,7 +1202,6 @@ NO_NEW_INSERTION_POINT(EnumElementScope)\n \n NO_NEW_INSERTION_POINT(CaptureListScope)\n NO_NEW_INSERTION_POINT(CaseStmtScope)\n-NO_NEW_INSERTION_POINT(CatchStmtScope)\n NO_NEW_INSERTION_POINT(ClosureBodyScope)\n NO_NEW_INSERTION_POINT(DefaultArgumentInitializerScope)\n NO_NEW_INSERTION_POINT(DoCatchStmtScope)\n@@ -1513,12 +1511,6 @@ void ForEachPatternScope::expandAScopeThatDoesNotCreateANewInsertionPoint(\n   scopeCreator.addToScopeTree(stmt->getBody(), this);\n }\n \n-void CatchStmtScope::expandAScopeThatDoesNotCreateANewInsertionPoint(\n-    ScopeCreator &scopeCreator) {\n-  scopeCreator.addToScopeTree(stmt->getGuardExpr(), this);\n-  scopeCreator.addToScopeTree(stmt->getBody(), this);\n-}\n-\n void CaseStmtScope::expandAScopeThatDoesNotCreateANewInsertionPoint(\n     ScopeCreator &scopeCreator) {\n   for (auto &caseItem : stmt->getMutableCaseLabelItems())"
                    },
                    {
                        "filename": "lib/AST/ASTScopeLookup.cpp",
                        "code": "@@ -388,12 +388,6 @@ bool ForEachPatternScope::lookupLocalsOrMembers(ArrayRef<const ASTScopeImpl *>,\n       stmt->getPattern(), DeclVisibilityKind::LocalVariable, consumer);\n }\n \n-bool CatchStmtScope::lookupLocalsOrMembers(ArrayRef<const ASTScopeImpl *>,\n-                                           DeclConsumer consumer) const {\n-  return lookupLocalBindingsInPattern(\n-      stmt->getErrorPattern(), DeclVisibilityKind::LocalVariable, consumer);\n-}\n-\n bool CaseStmtScope::lookupLocalsOrMembers(ArrayRef<const ASTScopeImpl *>,\n                                           DeclConsumer consumer) const {\n   for (auto &item : stmt->getMutableCaseLabelItems())"
                    },
                    {
                        "filename": "lib/AST/ASTScopeSourceRange.cpp",
                        "code": "@@ -391,16 +391,6 @@ SourceRange ForEachPatternScope::getSourceRangeOfThisASTNode(\n   return stmt->getBody()->getSourceRange();\n }\n \n-SourceRange\n-CatchStmtScope::getSourceRangeOfThisASTNode(const bool omitAssertions) const {\n-  // The scope of the pattern extends from the 'where' (if present)\n-  // to the end of the body.\n-  if (stmt->getGuardExpr())\n-    return SourceRange(stmt->getWhereLoc(), stmt->getBody()->getEndLoc());\n-\n-  // Otherwise, the scope of the pattern encompasses the body.\n-  return stmt->getBody()->getSourceRange();\n-}\n SourceRange\n CaseStmtScope::getSourceRangeOfThisASTNode(const bool omitAssertions) const {\n   // The scope of the case statement begins at the first guard expression,"
                    },
                    {
                        "filename": "lib/AST/ASTVerifier.cpp",
                        "code": "@@ -971,17 +971,6 @@ class Verifier : public ASTWalker {\n       verifyCheckedBase(S);\n     }\n \n-    bool shouldVerifyChecked(CatchStmt *S) {\n-      return shouldVerifyChecked(S->getErrorPattern());\n-    }\n-\n-    void verifyChecked(CatchStmt *S) {\n-      checkSameType(S->getErrorPattern()->getType(),\n-                    checkExceptionTypeExists(\"catch statement\"),\n-                    \"catch pattern\");\n-      verifyCheckedBase(S);\n-    }\n-\n     bool shouldVerifyChecked(ReturnStmt *S) {\n       return !S->hasResult() || shouldVerifyChecked(S->getResult());\n     }"
                    },
                    {
                        "filename": "lib/AST/ASTWalker.cpp",
                        "code": "@@ -1491,9 +1491,9 @@ Stmt *Traversal::visitDoCatchStmt(DoCatchStmt *stmt) {\n   }\n \n   // Transform each of the catch clauses:\n-  for (CatchStmt *&clause : stmt->getMutableCatches()) {\n+  for (CaseStmt *&clause : stmt->getMutableCatches()) {\n     if (auto newClause = doIt(clause)) {\n-      clause = cast<CatchStmt>(newClause);\n+      clause = cast<CaseStmt>(newClause);\n     } else {\n       return nullptr;\n     }\n@@ -1502,33 +1502,6 @@ Stmt *Traversal::visitDoCatchStmt(DoCatchStmt *stmt) {\n   return stmt;\n }\n \n-Stmt *Traversal::visitCatchStmt(CatchStmt *stmt) {\n-  // Transform the error pattern.\n-  if (Pattern *newPattern = doIt(stmt->getErrorPattern())) {\n-    stmt->setErrorPattern(newPattern);\n-  } else {\n-    return nullptr;\n-  }\n-\n-  // Transform the guard expression if present.\n-  if (Expr *oldGuardExpr = stmt->getGuardExpr()) {\n-    if (Expr *newGuardExpr = doIt(oldGuardExpr)) {\n-      stmt->setGuardExpr(newGuardExpr);\n-    } else {\n-      return nullptr;\n-    }\n-  }\n-\n-  // Transform the body of the catch clause.\n-  if (Stmt *newCatchBody = doIt(stmt->getBody())) {\n-    stmt->setBody(newCatchBody);\n-  } else {\n-    return nullptr;\n-  }\n-\n-  return stmt;\n-}\n-\n Stmt *Traversal::visitWhileStmt(WhileStmt *WS) {\n   if (doIt(WS->getCond()))\n     return nullptr;"
                    },
                    {
                        "filename": "lib/AST/Decl.cpp",
                        "code": "@@ -5622,9 +5622,6 @@ Pattern *VarDecl::getParentPattern() const {\n   if (auto *stmt = getParentPatternStmt()) {\n     if (auto *FES = dyn_cast<ForEachStmt>(stmt))\n       return FES->getPattern();\n-    \n-    if (auto *CS = dyn_cast<CatchStmt>(stmt))\n-      return CS->getErrorPattern();\n \n     if (auto *cs = dyn_cast<CaseStmt>(stmt)) {\n       // In a case statement, search for the pattern that contains it.  This is"
                    },
                    {
                        "filename": "lib/AST/NameLookup.cpp",
                        "code": "@@ -2626,22 +2626,10 @@ void FindLocalVal::visitDoCatchStmt(DoCatchStmt *S) {\n   if (!isReferencePointInRange(S->getSourceRange()))\n     return;\n   visit(S->getBody());\n-  visitCatchClauses(S->getCatches());\n-}\n-void FindLocalVal::visitCatchClauses(ArrayRef<CatchStmt*> clauses) {\n-  // TODO: some sort of binary search?\n-  for (auto clause : clauses) {\n-    visitCatchStmt(clause);\n+  for (CaseStmt *C : S->getCatches()) {\n+    visit(C);\n   }\n }\n-void FindLocalVal::visitCatchStmt(CatchStmt *S) {\n-  if (!isReferencePointInRange(S->getSourceRange()))\n-    return;\n-  // Names in the pattern aren't visible until after the pattern.\n-  if (!isReferencePointInRange(S->getErrorPattern()->getSourceRange()))\n-    checkPattern(S->getErrorPattern(), DeclVisibilityKind::LocalVariable);\n-  visit(S->getBody());\n-}\n \n void swift::simple_display(llvm::raw_ostream &out, NLKind kind) {\n   switch (kind) {"
                    },
                    {
                        "filename": "lib/AST/Stmt.cpp",
                        "code": "@@ -262,25 +262,25 @@ void ForEachStmt::setPattern(Pattern *p) {\n   Pat->markOwnedByStatement(this);\n }\n \n-void CatchStmt::setErrorPattern(Pattern *pattern) {\n-  ErrorPattern = pattern;\n-  ErrorPattern->markOwnedByStatement(this);\n-}\n-\n-\n DoCatchStmt *DoCatchStmt::create(ASTContext &ctx, LabeledStmtInfo labelInfo,\n                                  SourceLoc doLoc, Stmt *body,\n-                                 ArrayRef<CatchStmt*> catches,\n+                                 ArrayRef<CaseStmt *> catches,\n                                  Optional<bool> implicit) {\n-  void *mem = ctx.Allocate(totalSizeToAlloc<CatchStmt*>(catches.size()),\n+  void *mem = ctx.Allocate(totalSizeToAlloc<CaseStmt *>(catches.size()),\n                            alignof(DoCatchStmt));\n   return ::new (mem) DoCatchStmt(labelInfo, doLoc, body, catches, implicit);\n }\n \n+bool CaseLabelItem::isSyntacticallyExhaustive() const {\n+  return getGuardExpr() == nullptr && !getPattern()->isRefutablePattern();\n+}\n+\n bool DoCatchStmt::isSyntacticallyExhaustive() const {\n   for (auto clause : getCatches()) {\n-    if (clause->isSyntacticallyExhaustive())\n-      return true;\n+    for (auto &LabelItem : clause->getCaseLabelItems()) {\n+      if (LabelItem.isSyntacticallyExhaustive())\n+        return true;\n+    }\n   }\n   return false;\n }\n@@ -296,13 +296,6 @@ void LabeledConditionalStmt::setCond(StmtCondition e) {\n   Cond = e;\n }\n \n-bool CatchStmt::isSyntacticallyExhaustive() const {\n-  // It cannot have a guard expression and the pattern cannot be refutable.\n-  return getGuardExpr() == nullptr &&\n-         !getErrorPattern()->isRefutablePattern();\n-}\n-\n-\n PoundAvailableInfo *PoundAvailableInfo::create(ASTContext &ctx,\n                                                SourceLoc PoundLoc,\n                                                SourceLoc LParenLoc,\n@@ -411,19 +404,24 @@ SourceLoc CaseLabelItem::getEndLoc() const {\n   return CasePattern->getEndLoc();\n }\n \n-CaseStmt::CaseStmt(SourceLoc caseLoc, ArrayRef<CaseLabelItem> caseLabelItems,\n-                   SourceLoc unknownAttrLoc, SourceLoc colonLoc, Stmt *body,\n+CaseStmt::CaseStmt(CaseParentKind parentKind, SourceLoc itemIntroducerLoc,\n+                   ArrayRef<CaseLabelItem> caseLabelItems,\n+                   SourceLoc unknownAttrLoc, SourceLoc itemTerminatorLoc,\n+                   Stmt *body,\n                    Optional<MutableArrayRef<VarDecl *>> caseBodyVariables,\n                    Optional<bool> implicit,\n                    NullablePtr<FallthroughStmt> fallthroughStmt)\n-    : Stmt(StmtKind::Case, getDefaultImplicitFlag(implicit, caseLoc)),\n-      UnknownAttrLoc(unknownAttrLoc), CaseLoc(caseLoc), ColonLoc(colonLoc),\n+    : Stmt(StmtKind::Case, getDefaultImplicitFlag(implicit, itemIntroducerLoc)),\n+      UnknownAttrLoc(unknownAttrLoc), ItemIntroducerLoc(itemIntroducerLoc),\n+      ItemTerminatorLoc(itemTerminatorLoc), ParentKind(parentKind),\n       BodyAndHasFallthrough(body, fallthroughStmt.isNonNull()),\n       CaseBodyVariables(caseBodyVariables) {\n   Bits.CaseStmt.NumPatterns = caseLabelItems.size();\n   assert(Bits.CaseStmt.NumPatterns > 0 &&\n          \"case block must have at least one pattern\");\n-\n+  assert(\n+      !(parentKind == CaseParentKind::DoCatch && fallthroughStmt.isNonNull()) &&\n+      \"Only switch cases can have a fallthrough.\");\n   if (hasFallthroughDest()) {\n     *getTrailingObjects<FallthroughStmt *>() = fallthroughStmt.get();\n   }\n@@ -443,7 +441,8 @@ CaseStmt::CaseStmt(SourceLoc caseLoc, ArrayRef<CaseLabelItem> caseLabelItems,\n   }\n }\n \n-CaseStmt *CaseStmt::create(ASTContext &ctx, SourceLoc caseLoc,\n+CaseStmt *CaseStmt::create(ASTContext &ctx, CaseParentKind ParentKind,\n+                           SourceLoc caseLoc,\n                            ArrayRef<CaseLabelItem> caseLabelItems,\n                            SourceLoc unknownAttrLoc, SourceLoc colonLoc,\n                            Stmt *body,\n@@ -454,8 +453,9 @@ CaseStmt *CaseStmt::create(ASTContext &ctx, SourceLoc caseLoc,\n       ctx.Allocate(totalSizeToAlloc<FallthroughStmt *, CaseLabelItem>(\n                        fallthroughStmt.isNonNull(), caseLabelItems.size()),\n                    alignof(CaseStmt));\n-  return ::new (mem) CaseStmt(caseLoc, caseLabelItems, unknownAttrLoc, colonLoc,\n-                              body, caseVarDecls, implicit, fallthroughStmt);\n+  return ::new (mem)\n+      CaseStmt(ParentKind, caseLoc, caseLabelItems, unknownAttrLoc, colonLoc,\n+               body, caseVarDecls, implicit, fallthroughStmt);\n }\n \n SwitchStmt *SwitchStmt::create(LabeledStmtInfo LabelInfo, SourceLoc SwitchLoc,"
                    },
                    {
                        "filename": "lib/IDE/Formatting.cpp",
                        "code": "@@ -551,8 +551,10 @@ class RangeWalker: protected ASTWalker {\n     } else if (auto *DCS = dyn_cast<DoCatchStmt>(S)) {\n       if (!handleBraceStmt(DCS->getBody(), DCS->getDoLoc()))\n         return Stop;\n-    } else if (auto *CS = dyn_cast<CatchStmt>(S)) {\n-      if (!handleBraceStmt(CS->getBody(), CS->getCatchLoc()))\n+    } else if (isa<CaseStmt>(S) &&\n+               cast<CaseStmt>(S)->getParentKind() == CaseParentKind::DoCatch) {\n+      auto CS = cast<CaseStmt>(S);\n+      if (!handleBraceStmt(CS->getBody(), CS->getLoc()))\n         return Stop;\n     } else if (auto *RWS = dyn_cast<RepeatWhileStmt>(S)) {\n       if (!handleBraceStmt(RWS->getBody(), RWS->getRepeatLoc()))\n@@ -1805,7 +1807,8 @@ class FormatWalker : public ASTWalker {\n       return IndentContext {ContextLoc, false};\n     }\n \n-    if (auto *CS = dyn_cast<CaseStmt>(S)) {\n+    auto *CS = dyn_cast<CaseStmt>(S);\n+    if (CS && CS->getParentKind() == CaseParentKind::Switch) {\n       if (TrailingTarget && !TrailingTarget->isEmpty())\n         return None;\n \n@@ -1854,7 +1857,7 @@ class FormatWalker : public ASTWalker {\n       return IndentContext {DS->getStartLoc(), false};\n     }\n \n-    if (auto *CS = dyn_cast<CatchStmt>(S)) {\n+    if (CS && CS->getParentKind() == CaseParentKind::DoCatch) {\n       if (auto *BS = dyn_cast<BraceStmt>(CS->getBody())) {\n         if (auto Ctx = getIndentContextFrom(BS, CS->getStartLoc()))\n           return Ctx;"
                    },
                    {
                        "filename": "lib/IDE/Refactoring.cpp",
                        "code": "@@ -914,7 +914,7 @@ ExtractCheckResult checkExtractConditions(ResolvedRangeInfo &RangeInfo,\n     Stmt *S = RangeInfo.ContainedNodes[0].get<Stmt *>();\n \n     // These aren't independent statement.\n-    if (isa<BraceStmt>(S) || isa<CatchStmt>(S) || isa<CaseStmt>(S))\n+    if (isa<BraceStmt>(S) || isa<CaseStmt>(S))\n       return ExtractCheckResult();\n   }\n "
                    },
                    {
                        "filename": "lib/Parse/ParseExpr.cpp",
                        "code": "@@ -427,7 +427,7 @@ ParserResult<Expr> Parser::parseExprSequenceElement(Diag<> message,\n         // Eat all of the catch clauses, so we don't trip over them in error\n         // recovery.\n         while (Tok.is(tok::kw_catch)) {\n-          ParserResult<CatchStmt> clause = parseStmtCatch();\n+          ParserResult<CaseStmt> clause = parseStmtCatch();\n           if (clause.hasCodeCompletion() && clause.isNull())\n             break;\n         }"
                    },
                    {
                        "filename": "lib/Parse/ParseStmt.cpp",
                        "code": "@@ -1906,10 +1906,10 @@ ParserResult<Stmt> Parser::parseStmtDo(LabeledStmtInfo labelInfo,\n   if (Tok.is(tok::kw_catch)) {\n     SyntaxParsingContext CatchListCtxt(SyntaxContext,\n                                        SyntaxKind::CatchClauseList);\n-    // Parse 'catch' clauses \n-    SmallVector<CatchStmt*, 4> allClauses;\n+    // Parse 'catch' clauses\n+    SmallVector<CaseStmt *, 4> allClauses;\n     do {\n-      ParserResult<CatchStmt> clause = parseStmtCatch();\n+      ParserResult<CaseStmt> clause = parseStmtCatch();\n       status |= clause;\n       if (status.hasCodeCompletion() && clause.isNull())\n         return makeParserResult<Stmt>(status, nullptr);\n@@ -1973,21 +1973,65 @@ ParserResult<Stmt> Parser::parseStmtDo(LabeledStmtInfo labelInfo,\n ///\n /// This routine promises to return a non-null result unless there was\n /// a code-completion token in the pattern.\n-ParserResult<CatchStmt> Parser::parseStmtCatch() {\n+ParserResult<CaseStmt> Parser::parseStmtCatch() {\n   SyntaxParsingContext CatchClauseCtxt(SyntaxContext, SyntaxKind::CatchClause);\n   // A catch block has its own scope for variables bound out of the pattern.\n   Scope S(this, ScopeKind::CatchVars);\n \n   SourceLoc catchLoc = consumeToken(tok::kw_catch);\n \n   SmallVector<VarDecl*, 4> boundDecls;\n-\n   ParserStatus status;\n-  GuardedPattern pattern;\n-  parseGuardedPattern(*this, pattern, status, boundDecls,\n-                      GuardedPatternContext::Catch, /* isFirst */ true);\n-  if (status.hasCodeCompletion()) {\n-    return makeParserCodeCompletionResult<CatchStmt>();\n+  Optional<MutableArrayRef<VarDecl *>> caseBodyDecls;\n+  SmallVector<CaseLabelItem, 1> caseLabelItems;\n+\n+  {\n+    SyntaxParsingContext ListContext(SyntaxContext, SyntaxKind::CatchItemList);\n+    bool isFirst = true;\n+    while (true) {\n+      SyntaxParsingContext ItemContext(SyntaxContext, SyntaxKind::CatchItem);\n+      GuardedPattern PatternResult;\n+      parseGuardedPattern(*this, PatternResult, status, boundDecls,\n+                          GuardedPatternContext::Catch, isFirst);\n+      if (status.hasCodeCompletion()) {\n+        return makeParserCodeCompletionResult<CaseStmt>();\n+      }\n+      caseLabelItems.emplace_back(PatternResult.ThePattern,\n+                                  PatternResult.WhereLoc, PatternResult.Guard);\n+      isFirst = false;\n+      if (!consumeIf(tok::comma))\n+        break;\n+    }\n+\n+    // Grab the first case label item pattern and use it to initialize the case\n+    // body var decls.\n+    SmallVector<VarDecl *, 4> tmp;\n+    caseLabelItems.front().getPattern()->collectVariables(tmp);\n+    auto Result = Context.AllocateUninitialized<VarDecl *>(tmp.size());\n+    for (unsigned i : indices(tmp)) {\n+      auto *vOld = tmp[i];\n+      auto *vNew = new (Context) VarDecl(\n+          /*IsStatic*/ false, vOld->getIntroducer(), false /*IsCaptureList*/,\n+          vOld->getNameLoc(), vOld->getName(), vOld->getDeclContext());\n+      vNew->setHasNonPatternBindingInit();\n+      vNew->setImplicit();\n+      Result[i] = vNew;\n+    }\n+    caseBodyDecls.emplace(Result);\n+  }\n+\n+  // Add a scope so that the parser can find our body bound decls if it emits\n+  // optimized accesses.\n+  Optional<Scope> BodyScope;\n+  if (caseBodyDecls) {\n+    BodyScope.emplace(this, ScopeKind::CatchVars);\n+    for (auto *v : *caseBodyDecls) {\n+      setLocalDiscriminator(v);\n+      // If we had any bad redefinitions, we already diagnosed them against the\n+      // first case label item.\n+      if (v->hasName())\n+        addToScope(v, false /*diagnoseRedefinitions*/);\n+    }\n   }\n \n   auto bodyResult = parseBraceItemList(diag::expected_lbrace_after_catch);\n@@ -1998,10 +2042,12 @@ ParserResult<CatchStmt> Parser::parseStmtCatch() {\n                                                          /*implicit=*/ true));\n   }\n \n-  auto result =\n-    new (Context) CatchStmt(catchLoc, pattern.ThePattern, pattern.WhereLoc,\n-                            pattern.Guard, bodyResult.get());\n-  return makeParserResult(status, result);\n+  return makeParserResult(\n+      status, CaseStmt::create(Context, CaseParentKind::DoCatch, catchLoc,\n+                               caseLabelItems,\n+                               /*UnknownAttrLoc*/ SourceLoc(),\n+                               bodyResult.get()->getStartLoc(),\n+                               bodyResult.get(), caseBodyDecls, None, nullptr));\n }\n \n static bool isStmtForCStyle(Parser &P) {\n@@ -2493,9 +2539,10 @@ ParserResult<CaseStmt> Parser::parseStmtCase(bool IsActive) {\n   }\n \n   return makeParserResult(\n-      Status, CaseStmt::create(Context, CaseLoc, CaseLabelItems, UnknownAttrLoc,\n-                               ColonLoc, Body, CaseBodyDecls, None,\n-                               FallthroughFinder::findFallthrough(Body)));\n+      Status,\n+      CaseStmt::create(Context, CaseParentKind::Switch, CaseLoc, CaseLabelItems,\n+                       UnknownAttrLoc, ColonLoc, Body, CaseBodyDecls, None,\n+                       FallthroughFinder::findFallthrough(Body)));\n }\n \n /// stmt-pound-assert:"
                    },
                    {
                        "filename": "lib/SIL/IR/SILProfiler.cpp",
                        "code": "@@ -120,6 +120,15 @@ DeclContext *getProfilerContextForDecl(ASTNode N, SILDeclRef forDecl) {\n   return forDecl.getDecl()->getDeclContext();\n }\n \n+static Stmt *getProfilerStmtForCase(CaseStmt *caseStmt) {\n+  switch (caseStmt->getParentKind()) {\n+  case CaseParentKind::Switch:\n+    return caseStmt;\n+  case CaseParentKind::DoCatch:\n+    return caseStmt->getBody();\n+  }\n+}\n+\n /// Check that the input AST has at least been type-checked.\n LLVM_ATTRIBUTE_UNUSED\n static bool hasASTBeenTypeChecked(ASTNode N, SILDeclRef forDecl) {\n@@ -245,9 +254,7 @@ struct MapRegionCounters : public ASTWalker {\n     } else if (auto *SS = dyn_cast<SwitchStmt>(S)) {\n       mapRegion(SS);\n     } else if (auto *CS = dyn_cast<CaseStmt>(S)) {\n-      mapRegion(CS);\n-    } else if (auto *CS = dyn_cast<CatchStmt>(S)) {\n-      mapRegion(CS->getBody());\n+      mapRegion(getProfilerStmtForCase(CS));\n     }\n     return {true, S};\n   }\n@@ -603,14 +610,10 @@ struct PGOMapping : public ASTWalker {\n       auto ssCount = loadExecutionCount(SS);\n       LoadedCounterMap[SS] = ssCount;\n     } else if (auto *CS = dyn_cast<CaseStmt>(S)) {\n-      CounterMap[CS] = NextCounter++;\n-      auto csCount = loadExecutionCount(CS);\n-      LoadedCounterMap[CS] = csCount;\n-    } else if (auto *CS = dyn_cast<CatchStmt>(S)) {\n-      auto csBody = CS->getBody();\n-      CounterMap[csBody] = NextCounter++;\n-      auto csBodyCount = loadExecutionCount(csBody);\n-      LoadedCounterMap[csBody] = csBodyCount;\n+      auto stmt = getProfilerStmtForCase(CS);\n+      CounterMap[stmt] = NextCounter++;\n+      auto csCount = loadExecutionCount(stmt);\n+      LoadedCounterMap[stmt] = csCount;\n     }\n     return {true, S};\n   }\n@@ -762,8 +765,10 @@ struct CoverageMapping : public ASTWalker {\n     CounterExpr *JumpsToLabel = nullptr;\n     Stmt *ParentStmt = Parent.getAsStmt();\n     if (ParentStmt) {\n-      if (isa<DoStmt>(ParentStmt) || isa<DoCatchStmt>(ParentStmt) ||\n-          isa<CatchStmt>(ParentStmt))\n+      if (isa<DoStmt>(ParentStmt) || isa<DoCatchStmt>(ParentStmt))\n+        return;\n+      auto caseStmt = dyn_cast_or_null<CaseStmt>(ParentStmt);\n+      if (caseStmt && caseStmt->getParentKind() == CaseParentKind::DoCatch)\n         return;\n       if (auto *LS = dyn_cast<LabeledStmt>(ParentStmt))\n         JumpsToLabel = &getCounter(LS);\n@@ -959,9 +964,9 @@ struct CoverageMapping : public ASTWalker {\n       for (CaseStmt *Case : SS->getCases())\n         assignCounter(Case);\n \n-    } else if (isa<CaseStmt>(S)) {\n-      pushRegion(S);\n-\n+    } else if (auto caseStmt = dyn_cast<CaseStmt>(S)) {\n+      if (caseStmt->getParentKind() == CaseParentKind::Switch)\n+        pushRegion(S);\n     } else if (auto *DS = dyn_cast<DoStmt>(S)) {\n       assignCounter(DS->getBody(), CounterExpr::Ref(getCurrentCounter()));\n       assignCounter(DS);\n@@ -970,14 +975,13 @@ struct CoverageMapping : public ASTWalker {\n       // The do-catch body is visited the same number of times as its parent.\n       assignCounter(DCS->getBody(), CounterExpr::Ref(getCurrentCounter()));\n \n+      for (CaseStmt *Catch : DCS->getCatches())\n+        assignCounter(Catch->getBody());\n+\n       // Initialize the exit count of the do-catch to the entry count, then\n       // subtract off non-local exits as they are visited.\n       assignCounter(DCS, CounterExpr::Ref(getCurrentCounter()));\n       DoCatchStack.push_back(DCS);\n-\n-    } else if (auto *CS = dyn_cast<CatchStmt>(S)) {\n-      assert(DoCatchStack.size() && \"catch stmt with no parent\");\n-      assignCounter(CS->getBody());\n     }\n     return {true, S};\n   }\n@@ -1035,17 +1039,15 @@ struct CoverageMapping : public ASTWalker {\n     } else if (isa<SwitchStmt>(S)) {\n       replaceCount(CounterExpr::Ref(getCounter(S)), getEndLoc(S));\n \n-    } else if (isa<CaseStmt>(S)) {\n-      popRegions(S);\n+    } else if (auto caseStmt = dyn_cast<CaseStmt>(S)) {\n+      if (caseStmt->getParentKind() == CaseParentKind::Switch)\n+        popRegions(S);\n \n     } else if (auto *DCS = dyn_cast<DoCatchStmt>(S)) {\n       assert(DoCatchStack.back() == DCS && \"Malformed do-catch stack\");\n       DoCatchStack.pop_back();\n       replaceCount(CounterExpr::Ref(getCounter(S)), getEndLoc(S));\n \n-    } else if (isa<CatchStmt>(S)) {\n-      assert(DoCatchStack.size() && \"catch stmt with no parent\");\n-\n     } else if (isa<ReturnStmt>(S) || isa<FailStmt>(S) || isa<ThrowStmt>(S)) {\n       // When we return, adjust loop condition counts and do-catch exit counts\n       // to reflect the early exit."
                    },
                    {
                        "filename": "lib/SILGen/SILGenFunction.h",
                        "code": "@@ -1088,7 +1088,7 @@ class LLVM_LIBRARY_VISIBILITY SILGenFunction\n   void emitBreakOutOf(SILLocation loc, Stmt *S);\n \n   void emitCatchDispatch(DoCatchStmt *S, ManagedValue exn,\n-                         ArrayRef<CatchStmt*> clauses,\n+                         ArrayRef<CaseStmt *> clauses,\n                          JumpDest catchFallthroughDest);\n \n   /// Emit code for the throw expr. If \\p emitWillThrow is set then emit a"
                    },
                    {
                        "filename": "lib/SILGen/SILGenPattern.cpp",
                        "code": "@@ -441,7 +441,7 @@ class PatternMatchEmission {\n \n   JumpDest getSharedCaseBlockDest(CaseStmt *caseStmt);\n \n-  void emitSharedCaseBlocks();\n+  void emitSharedCaseBlocks(llvm::function_ref<void(CaseStmt *)> bodyEmitter);\n \n   void emitCaseBody(CaseStmt *caseBlock);\n \n@@ -1084,7 +1084,7 @@ void PatternMatchEmission::emitWildcardDispatch(ClauseMatrix &clauses,\n   assert(!hasGuard || !clauses[row].isIrrefutable());\n \n   auto stmt = clauses[row].getClientData<Stmt>();\n-  assert(isa<CaseStmt>(stmt) || isa<CatchStmt>(stmt));\n+  assert(isa<CaseStmt>(stmt));\n \n   auto *caseStmt = dyn_cast<CaseStmt>(stmt);\n   bool hasMultipleItems =\n@@ -2392,7 +2392,8 @@ emitAddressOnlyInitialization(VarDecl *dest, SILValue value) {\n }\n \n /// Emit all the shared case statements.\n-void PatternMatchEmission::emitSharedCaseBlocks() {\n+void PatternMatchEmission::emitSharedCaseBlocks(\n+    llvm::function_ref<void(CaseStmt *)> bodyEmitter) {\n   for (auto &entry : SharedCases) {\n     CaseStmt *caseBlock = entry.first;\n     SILBasicBlock *caseBB = entry.second.first;\n@@ -2488,7 +2489,7 @@ void PatternMatchEmission::emitSharedCaseBlocks() {\n \n     // Now that we have setup all of the VarLocs correctly, emit the shared case\n     // body.\n-    emitCaseBody(caseBlock);\n+    bodyEmitter(caseBlock);\n   }\n }\n \n@@ -2847,7 +2848,8 @@ void SILGenFunction::emitSwitchStmt(SwitchStmt *S) {\n   switchScope.pop();\n \n   // Then emit the case blocks shared by multiple pattern cases.\n-  emission.emitSharedCaseBlocks();\n+  emission.emitSharedCaseBlocks(\n+      [&](CaseStmt *caseStmt) { emission.emitCaseBody(caseStmt); });\n \n   // Bookkeeping.\n   SwitchStack.pop_back();\n@@ -2919,38 +2921,145 @@ void SILGenFunction::emitSwitchFallthrough(FallthroughStmt *S) {\n   Cleanups.emitBranchAndCleanups(sharedDest, S, args);\n }\n \n-\n-/// Emit a sequence of catch clauses.\n void SILGenFunction::emitCatchDispatch(DoCatchStmt *S, ManagedValue exn,\n-                                       ArrayRef<CatchStmt*> clauses,\n+                                       ArrayRef<CaseStmt *> clauses,\n                                        JumpDest catchFallthroughDest) {\n+\n   auto completionHandler = [&](PatternMatchEmission &emission,\n-                               ArgArray argArray,\n-                               ClauseRow &row) {\n-    auto clause = row.getClientData<CatchStmt>();\n+                               ArgArray argArray, ClauseRow &row) {\n+    auto clause = row.getClientData<CaseStmt>();\n     emitProfilerIncrement(clause->getBody());\n-    emitStmt(clause->getBody());\n \n-    // If we fell out of the catch clause, branch to the fallthrough dest.\n-    if (B.hasValidInsertionPoint()) {\n-      Cleanups.emitBranchAndCleanups(catchFallthroughDest, clause->getBody());\n+    // Certain catch clauses can be entered along multiple paths because they\n+    // have multiple labels. When we need multiple entrance path, we factor the\n+    // paths with a shared block.\n+    //\n+    // If we don't have a multi-pattern 'catch', we can emit the\n+    // body inline. Emit the statement here and bail early.\n+    if (clause->getCaseLabelItems().size() == 1) {\n+      // If we have case body vars, set them up to point at the matching var\n+      // decls.\n+      if (clause->hasCaseBodyVariables()) {\n+        // Since we know that we only have one case label item, grab its pattern\n+        // vars and use that to update expected with the right SILValue.\n+        //\n+        // TODO: Do we need a copy here?\n+        SmallVector<VarDecl *, 4> patternVars;\n+        row.getCasePattern()->collectVariables(patternVars);\n+        for (auto *expected : clause->getCaseBodyVariables()) {\n+          if (!expected->hasName())\n+            continue;\n+          for (auto *vd : patternVars) {\n+            if (!vd->hasName() || vd->getName() != expected->getName()) {\n+              continue;\n+            }\n+\n+            // Ok, we found a match. Update the VarLocs for the case block.\n+            auto v = VarLocs[vd];\n+            VarLocs[expected] = v;\n+          }\n+        }\n+      }\n+\n+      emitStmt(clause->getBody());\n+\n+      // If we fell out of the catch clause, branch to the fallthrough dest.\n+      if (B.hasValidInsertionPoint()) {\n+        Cleanups.emitBranchAndCleanups(catchFallthroughDest, clause->getBody());\n+      }\n+      return;\n+    }\n+\n+    // Ok, at this point we know that we have a multiple entrance block. Grab\n+    // our shared destination in preperation for branching to it.\n+    //\n+    // NOTE: We do not emit anything yet, since we will emit the shared block\n+    // later.\n+    JumpDest sharedDest = emission.getSharedCaseBlockDest(clause);\n+\n+    // If we do not have any bound decls, we do not need to setup any\n+    // variables. Just jump to the shared destination.\n+    if (!clause->hasCaseBodyVariables()) {\n+      // Don't emit anything yet, we emit it at the cleanup level of the switch\n+      // statement.\n+      JumpDest sharedDest = emission.getSharedCaseBlockDest(clause);\n+      Cleanups.emitBranchAndCleanups(sharedDest, clause);\n+      return;\n     }\n+\n+    // Generate the arguments from this row's pattern in the case block's\n+    // expected order, and keep those arguments from being cleaned up, as we're\n+    // passing the +1 along to the shared case block dest. (The cleanups still\n+    // happen, as they are threaded through here messily, but the explicit\n+    // retains here counteract them, and then the retain/release pair gets\n+    // optimized out.)\n+    SmallVector<SILValue, 4> args;\n+    SmallVector<VarDecl *, 4> patternVars;\n+    row.getCasePattern()->collectVariables(patternVars);\n+    for (auto *expected : clause->getCaseBodyVariables()) {\n+      if (!expected->hasName())\n+        continue;\n+      for (auto *var : patternVars) {\n+        if (!var->hasName() || var->getName() != expected->getName())\n+          continue;\n+\n+        SILValue value = VarLocs[var].value;\n+        SILType type = value->getType();\n+\n+        // If we have an address-only type, initialize the temporary\n+        // allocation. We're not going to pass the address as a block\n+        // argument.\n+        if (type.isAddressOnly(F)) {\n+          emission.emitAddressOnlyInitialization(expected, value);\n+          break;\n+        }\n+\n+        // If we have a loadable address, perform a load [copy].\n+        if (type.isAddress()) {\n+          value = B.emitLoadValueOperation(CurrentSILLoc, value,\n+                                           LoadOwnershipQualifier::Copy);\n+          args.push_back(value);\n+          break;\n+        }\n+\n+        value = B.emitCopyValueOperation(CurrentSILLoc, value);\n+        args.push_back(value);\n+        break;\n+      }\n+    }\n+\n+    // Now that we have initialized our arguments, branch to the shared dest.\n+    Cleanups.emitBranchAndCleanups(sharedDest, clause, args);\n   };\n \n+  LLVM_DEBUG(llvm::dbgs() << \"emitting catch dispatch\\n\"; S->dump(llvm::dbgs());\n+             llvm::dbgs() << '\\n');\n+\n   PatternMatchEmission emission(*this, S, completionHandler);\n \n-  // Add a row for each clause.\n-  std::vector<ClauseRow> clauseRows;\n-  clauseRows.reserve(clauses.size());\n-  for (CatchStmt *clause : clauses) {\n-    clauseRows.emplace_back(clause,\n-                            clause->getErrorPattern(),\n-                            clause->getGuardExpr(),\n-                            /*hasFallthroughTo*/false);\n+  // Add a row for each label of each case.\n+  SmallVector<ClauseRow, 8> clauseRows;\n+  clauseRows.reserve(S->getCatches().size());\n+  for (auto caseBlock : S->getCatches()) {\n+    // If we have multiple case label itmes, create a shared case block to\n+    // generate the shared block.\n+    if (caseBlock->getCaseLabelItems().size() > 1) {\n+      emission.initSharedCaseBlockDest(caseBlock, /*hasFallthrough*/ false);\n+    }\n+\n+    for (auto &labelItem : caseBlock->getCaseLabelItems()) {\n+      clauseRows.emplace_back(caseBlock,\n+                              const_cast<Pattern *>(labelItem.getPattern()),\n+                              const_cast<Expr *>(labelItem.getGuardExpr()),\n+                              /*hasFallthrough*/ false);\n+    }\n   }\n \n-  // Set up an initial clause matrix.\n-  ClauseMatrix clauseMatrix(clauseRows);\n+  // Emit alloc_stacks for address-only variables appearing in\n+  // multiple-entry case blocks.\n+  emission.emitAddressOnlyAllocations();\n+\n+  Scope stmtScope(Cleanups, CleanupLocation(S));\n \n   assert(exn.getType().isObject() &&\n          \"Error is special and should always be an object\");\n@@ -2982,10 +3091,22 @@ void SILGenFunction::emitCatchDispatch(DoCatchStmt *S, ManagedValue exn,\n     }\n     emitThrow(S, exn);\n   };\n+  // Set up an initial clause matrix.\n+  ClauseMatrix clauseMatrix(clauseRows);\n \n   // Recursively specialize and emit the clause matrix.\n   emission.emitDispatch(clauseMatrix, subject, failure);\n   assert(!B.hasValidInsertionPoint());\n-}\n \n+  stmtScope.pop();\n \n+  // Then emit the case blocks shared by multiple pattern cases.\n+  emission.emitSharedCaseBlocks([&](CaseStmt *caseStmt) {\n+    emitStmt(caseStmt->getBody());\n+\n+    // If we fell out of the catch clause, branch to the fallthrough dest.\n+    if (B.hasValidInsertionPoint()) {\n+      Cleanups.emitBranchAndCleanups(catchFallthroughDest, caseStmt->getBody());\n+    }\n+  });\n+}"
                    },
                    {
                        "filename": "lib/SILGen/SILGenStmt.cpp",
                        "code": "@@ -782,8 +782,12 @@ void StmtEmitter::visitDoStmt(DoStmt *S) {\n }\n \n void StmtEmitter::visitDoCatchStmt(DoCatchStmt *S) {\n-  Type formalExnType =\n-    S->getCatches().front()->getErrorPattern()->getType();\n+  Type formalExnType = S->getCatches()\n+                           .front()\n+                           ->getCaseLabelItems()\n+                           .front()\n+                           .getPattern()\n+                           ->getType();\n   auto &exnTL = SGF.getTypeLowering(formalExnType);\n \n   // Create the throw destination at the end of the function.\n@@ -857,10 +861,6 @@ void StmtEmitter::visitDoCatchStmt(DoCatchStmt *S) {\n   emitOrDeleteBlock(SGF, endDest, CleanupLocation(S->getBody()));\n }\n \n-void StmtEmitter::visitCatchStmt(CatchStmt *S) {\n-  llvm_unreachable(\"catch statement outside of context?\");\n-}\n-\n void StmtEmitter::visitRepeatWhileStmt(RepeatWhileStmt *S) {\n   // Create a new basic block and jump into it.\n   SILBasicBlock *loopBB = createBasicBlock();"
                    },
                    {
                        "filename": "lib/Sema/BuilderTransform.cpp",
                        "code": "@@ -746,7 +746,6 @@ class BuilderClosureVisitor\n   CONTROL_FLOW_STMT(RepeatWhile)\n   CONTROL_FLOW_STMT(ForEach)\n   CONTROL_FLOW_STMT(Case)\n-  CONTROL_FLOW_STMT(Catch)\n   CONTROL_FLOW_STMT(Break)\n   CONTROL_FLOW_STMT(Continue)\n   CONTROL_FLOW_STMT(Fallthrough)\n@@ -1195,7 +1194,6 @@ class BuilderClosureRewriter\n   UNHANDLED_FUNCTION_BUILDER_STMT(DoCatch)\n   UNHANDLED_FUNCTION_BUILDER_STMT(RepeatWhile)\n   UNHANDLED_FUNCTION_BUILDER_STMT(ForEach)\n-  UNHANDLED_FUNCTION_BUILDER_STMT(Catch)\n   UNHANDLED_FUNCTION_BUILDER_STMT(Break)\n   UNHANDLED_FUNCTION_BUILDER_STMT(Continue)\n   UNHANDLED_FUNCTION_BUILDER_STMT(Fallthrough)"
                    },
                    {
                        "filename": "lib/Sema/CSGen.cpp",
                        "code": "@@ -2623,31 +2623,35 @@ namespace {\n \n         bool isSyntacticallyExhaustive(DoCatchStmt *stmt) {\n           for (auto catchClause : stmt->getCatches()) {\n-            if (isSyntacticallyExhaustive(catchClause))\n-              return true;\n+            for (auto &LabelItem : catchClause->getMutableCaseLabelItems()) {\n+              if (isSyntacticallyExhaustive(catchClause->getStartLoc(),\n+                                            LabelItem))\n+                return true;\n+            }\n           }\n \n           return false;\n         }\n \n-        bool isSyntacticallyExhaustive(CatchStmt *clause) {\n+        bool isSyntacticallyExhaustive(SourceLoc CatchLoc,\n+                                       CaseLabelItem &LabelItem) {\n           // If it's obviously non-exhaustive, great.\n-          if (clause->getGuardExpr())\n+          if (LabelItem.getGuardExpr())\n             return false;\n \n           // If we can show that it's exhaustive without full\n           // type-checking, great.\n-          if (clause->isSyntacticallyExhaustive())\n+          if (LabelItem.isSyntacticallyExhaustive())\n             return true;\n \n           // Okay, resolve the pattern.\n-          Pattern *pattern = clause->getErrorPattern();\n+          Pattern *pattern = LabelItem.getPattern();\n           pattern = TypeChecker::resolvePattern(pattern, CS.DC,\n-                                                /*isStmtCondition*/false);\n+                                         /*isStmtCondition*/false);\n           if (!pattern) return false;\n \n           // Save that aside while we explore the type.\n-          clause->setErrorPattern(pattern);\n+          LabelItem.setPattern(pattern);\n \n           // Require the pattern to have a particular shape: a number\n           // of is-patterns applied to an irrefutable pattern.\n@@ -2673,8 +2677,9 @@ namespace {\n \n           // Okay, now it should be safe to coerce the pattern.\n           // Pull the top-level pattern back out.\n-          pattern = clause->getErrorPattern();\n+          pattern = LabelItem.getPattern();\n           Type exnType = CS.getASTContext().getErrorDecl()->getDeclaredType();\n+\n           if (!exnType)\n             return false;\n           auto contextualPattern =\n@@ -2684,10 +2689,10 @@ namespace {\n           if (!pattern)\n             return false;\n \n-          clause->setErrorPattern(pattern);\n-          return clause->isSyntacticallyExhaustive();\n+          LabelItem.setPattern(pattern);\n+          return LabelItem.isSyntacticallyExhaustive();\n         }\n-        \n+\n         std::pair<bool, Stmt *> walkToStmtPre(Stmt *stmt) override {\n           // If we've found a 'throw', record it and terminate the traversal.\n           if (isa<ThrowStmt>(stmt)) {"
                    },
                    {
                        "filename": "lib/Sema/DerivedConformanceCodingKey.cpp",
                        "code": "@@ -225,8 +225,9 @@ deriveBodyCodingKey_enum_stringValue(AbstractFunctionDecl *strValDecl, void *) {\n       auto *returnStmt = new (C) ReturnStmt(SourceLoc(), caseValue);\n       auto *caseBody = BraceStmt::create(C, SourceLoc(), ASTNode(returnStmt),\n                                          SourceLoc());\n-      cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                       SourceLoc(), caseBody,\n+      cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                       labelItem, SourceLoc(), SourceLoc(),\n+                                       caseBody,\n                                        /*case body var decls*/ None));\n     }\n \n@@ -292,8 +293,8 @@ deriveBodyCodingKey_init_stringValue(AbstractFunctionDecl *initDecl, void *) {\n \n     auto *body = BraceStmt::create(C, SourceLoc(), ASTNode(assignment),\n                                    SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n                                      /*case body var decls*/ None));\n   }\n \n@@ -304,8 +305,9 @@ deriveBodyCodingKey_init_stringValue(AbstractFunctionDecl *initDecl, void *) {\n   auto *dfltReturnStmt = new (C) FailStmt(SourceLoc(), SourceLoc());\n   auto *dfltBody = BraceStmt::create(C, SourceLoc(), ASTNode(dfltReturnStmt),\n                                      SourceLoc());\n-  cases.push_back(CaseStmt::create(C, SourceLoc(), dfltLabelItem, SourceLoc(),\n-                                   SourceLoc(), dfltBody,\n+  cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                   dfltLabelItem, SourceLoc(), SourceLoc(),\n+                                   dfltBody,\n                                    /*case body var decls*/ None));\n \n   auto *stringValueDecl = initDecl->getParameters()->get(0);"
                    },
                    {
                        "filename": "lib/Sema/DerivedConformanceComparable.cpp",
                        "code": "@@ -205,8 +205,9 @@ deriveBodyComparable_enum_hasAssociatedValues_lt(AbstractFunctionDecl *ltDecl, v\n \n     auto body = BraceStmt::create(C, SourceLoc(), statementsInCase,\n                                   SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body, caseBodyVarDecls));\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n+                                     caseBodyVarDecls));\n   }\n \n   // default: result = <enum index>(lhs) < <enum index>(rhs)\n@@ -218,8 +219,9 @@ deriveBodyComparable_enum_hasAssociatedValues_lt(AbstractFunctionDecl *ltDecl, v\n     defaultPattern->setImplicit();\n     auto defaultItem = CaseLabelItem::getDefault(defaultPattern);\n     auto body = deriveBodyComparable_enum_noAssociatedValues_lt(ltDecl, nullptr).first;\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), defaultItem, SourceLoc(),\n-                                     SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     defaultItem, SourceLoc(), SourceLoc(),\n+                                     body,\n                                      /*case body var decls*/ None));\n   }\n "
                    },
                    {
                        "filename": "lib/Sema/DerivedConformanceEquatableHashable.cpp",
                        "code": "@@ -328,8 +328,9 @@ deriveBodyEquatable_enum_hasAssociatedValues_eq(AbstractFunctionDecl *eqDecl,\n \n     auto body = BraceStmt::create(C, SourceLoc(), statementsInCase,\n                                   SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body, caseBodyVarDecls));\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n+                                     caseBodyVarDecls));\n   }\n \n   // default: result = false\n@@ -345,8 +346,9 @@ deriveBodyEquatable_enum_hasAssociatedValues_eq(AbstractFunctionDecl *eqDecl,\n     auto returnStmt = new (C) ReturnStmt(SourceLoc(), falseExpr);\n     auto body = BraceStmt::create(C, SourceLoc(), ASTNode(returnStmt),\n                                   SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), defaultItem, SourceLoc(),\n-                                     SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     defaultItem, SourceLoc(), SourceLoc(),\n+                                     body,\n                                      /*case body var decls*/ None));\n   }\n \n@@ -829,8 +831,9 @@ deriveBodyHashable_enum_hasAssociatedValues_hashInto(\n     }\n \n     auto body = BraceStmt::create(C, SourceLoc(), statements, SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body, caseBodyVarDecls,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n+                                     caseBodyVarDecls,\n                                      /*implicit*/ true));\n   }\n "
                    },
                    {
                        "filename": "lib/Sema/DerivedConformanceRawRepresentable.cpp",
                        "code": "@@ -121,8 +121,8 @@ deriveBodyRawRepresentable_raw(AbstractFunctionDecl *toRawDecl, void *) {\n     auto body = BraceStmt::create(C, SourceLoc(),\n                                   ASTNode(returnStmt), SourceLoc());\n \n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n                                      /*case body var decls*/ None));\n   }\n \n@@ -350,8 +350,9 @@ deriveBodyRawRepresentable_init(AbstractFunctionDecl *initDecl, void *) {\n                                   stmts, SourceLoc());\n \n     // cases.append(\"case \\(litPat): \\(body)\")\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), CaseLabelItem(litPat),\n-                                     SourceLoc(), SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     CaseLabelItem(litPat), SourceLoc(),\n+                                     SourceLoc(), body,\n                                      /*case body var decls*/ None));\n     Idx++;\n   }\n@@ -363,8 +364,9 @@ deriveBodyRawRepresentable_init(AbstractFunctionDecl *initDecl, void *) {\n   auto dfltReturnStmt = new (C) FailStmt(SourceLoc(), SourceLoc());\n   auto dfltBody = BraceStmt::create(C, SourceLoc(),\n                                     ASTNode(dfltReturnStmt), SourceLoc());\n-  cases.push_back(CaseStmt::create(C, SourceLoc(), dfltLabelItem, SourceLoc(),\n-                                   SourceLoc(), dfltBody,\n+  cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                   dfltLabelItem, SourceLoc(), SourceLoc(),\n+                                   dfltBody,\n                                    /*case body var decls*/ None));\n \n   auto rawDecl = initDecl->getParameters()->get(0);"
                    },
                    {
                        "filename": "lib/Sema/DerivedConformances.cpp",
                        "code": "@@ -562,8 +562,8 @@ DeclRefExpr *DerivedConformance::convertEnumToIndex(SmallVectorImpl<ASTNode> &st\n     assignExpr->setType(TupleType::getEmpty(C));\n     auto body = BraceStmt::create(C, SourceLoc(), ASTNode(assignExpr),\n                                   SourceLoc());\n-    cases.push_back(CaseStmt::create(C, SourceLoc(), labelItem, SourceLoc(),\n-                                     SourceLoc(), body,\n+    cases.push_back(CaseStmt::create(C, CaseParentKind::Switch, SourceLoc(),\n+                                     labelItem, SourceLoc(), SourceLoc(), body,\n                                      /*case body vardecls*/ None));\n   }\n "
                    },
                    {
                        "filename": "lib/Sema/MiscDiagnostics.cpp",
                        "code": "@@ -3321,7 +3321,8 @@ static void checkStmtConditionTrailingClosure(ASTContext &ctx, const Stmt *S) {\n     checkStmtConditionTrailingClosure(ctx, FES->getWhere());\n   } else if (auto DCS = dyn_cast<DoCatchStmt>(S)) {\n     for (auto CS : DCS->getCatches())\n-      checkStmtConditionTrailingClosure(ctx, CS->getGuardExpr());\n+      for (auto &LabelItem : CS->getCaseLabelItems())\n+        checkStmtConditionTrailingClosure(ctx, LabelItem.getGuardExpr());\n   }\n }\n "
                    },
                    {
                        "filename": "lib/Sema/PCMacro.cpp",
                        "code": "@@ -306,7 +306,7 @@ class Instrumenter : InstrumenterBase {\n         DCS->setBody(NB);\n       }\n     }\n-    for (CatchStmt *C : DCS->getCatches()) {\n+    for (CaseStmt *C : DCS->getCatches()) {\n       if (auto *CB = dyn_cast_or_null<BraceStmt>(C->getBody())) {\n         BraceStmt *NCB = transformBraceStmt(CB);\n         if (NCB != CB) {"
                    },
                    {
                        "filename": "lib/Sema/PlaygroundTransform.cpp",
                        "code": "@@ -274,7 +274,7 @@ class Instrumenter : InstrumenterBase {\n         DCS->setBody(NB);\n       }\n     }\n-    for (CatchStmt *C : DCS->getCatches()) {\n+    for (CaseStmt *C : DCS->getCatches()) {\n       if (auto *CB = dyn_cast_or_null<BraceStmt>(C->getBody())) {\n         BraceStmt *NCB = transformBraceStmt(CB);\n         if (NCB != CB) {"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckError.cpp",
                        "code": "@@ -235,8 +235,6 @@ class ErrorHandlingWalker : public ASTWalker {\n       recurse = asImpl().checkDoCatch(doCatch);\n     } else if (auto thr = dyn_cast<ThrowStmt>(S)) {\n       recurse = asImpl().checkThrow(thr);\n-    } else {\n-      assert(!isa<CatchStmt>(S));\n     }\n     return {bool(recurse), S};\n   }\n@@ -629,7 +627,7 @@ class ApplyClassifier {\n       return ThrowingKind::None;\n     }\n \n-    void checkCatch(CatchStmt *S, ThrowingKind doThrowingKind) {\n+    void checkCatch(CaseStmt *S, ThrowingKind doThrowingKind) {\n       if (doThrowingKind != ThrowingKind::None) {\n         // This was an exhaustive do body, so bound our throwing kind by its\n         // throwing kind.\n@@ -927,11 +925,11 @@ class Context {\n     return Context(Kind::NonExhaustiveCatch);\n   }\n \n-  static Context forCatchPattern(CatchStmt *S) {\n+  static Context forCatchPattern(CaseStmt *S) {\n     return Context(Kind::CatchPattern);\n   }\n \n-  static Context forCatchGuard(CatchStmt *S) {\n+  static Context forCatchGuard(CaseStmt *S) {\n     return Context(Kind::CatchGuard);\n   }\n \n@@ -1408,20 +1406,22 @@ class CheckErrorCoverage : public ErrorHandlingWalker<CheckErrorCoverage> {\n     // implicit do/catch in a debugger function.\n     if (!Flags.has(ContextFlags::HasAnyThrowSite) &&\n         !scope.wasTopLevelDebuggerFunction()) {\n-      Ctx.Diags.diagnose(S->getCatches().front()->getCatchLoc(),\n+      Ctx.Diags.diagnose(S->getCatches().front()->getStartLoc(),\n                          diag::no_throw_in_do_with_catch);\n     }\n   }\n \n-  void checkCatch(CatchStmt *S, ThrowingKind doThrowingKind) {\n-    // The pattern and guard aren't allowed to throw.\n-    {\n-      ContextScope scope(*this, Context::forCatchPattern(S));\n-      S->getErrorPattern()->walk(*this);\n-    }\n-    if (auto guard = S->getGuardExpr()) {\n-      ContextScope scope(*this, Context::forCatchGuard(S));\n-      guard->walk(*this);\n+  void checkCatch(CaseStmt *S, ThrowingKind doThrowingKind) {\n+    for (auto &LabelItem : S->getMutableCaseLabelItems()) {\n+      // The pattern and guard aren't allowed to throw.\n+      {\n+        ContextScope scope(*this, Context::forCatchPattern(S));\n+        LabelItem.getPattern()->walk(*this);\n+      }\n+      if (auto guard = LabelItem.getGuardExpr()) {\n+        ContextScope scope(*this, Context::forCatchGuard(S));\n+        guard->walk(*this);\n+      }\n     }\n \n     auto savedContext = CurContext;"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckStmt.cpp",
                        "code": "@@ -1225,27 +1225,6 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     llvm_unreachable(\"case stmt outside of switch?!\");\n   }\n \n-  Stmt *visitCatchStmt(CatchStmt *S) {\n-    // Catches are handled in visitDoCatchStmt.\n-    llvm_unreachable(\"catch stmt outside of do-catch?!\");\n-  }\n-\n-  void checkCatchStmt(CatchStmt *S) {\n-    // Check the catch pattern.\n-    TypeChecker::typeCheckCatchPattern(S, DC);\n-\n-    // Check the guard expression, if present.\n-    if (Expr *guard = S->getGuardExpr()) {\n-      TypeChecker::typeCheckCondition(guard, DC);\n-      S->setGuardExpr(guard);\n-    }\n-      \n-    // Type-check the clause body.\n-    Stmt *body = S->getBody();\n-    typeCheckStmt(body);\n-    S->setBody(body);\n-  }\n-\n   Stmt *visitDoCatchStmt(DoCatchStmt *S) {\n     // The labels are in scope for both the 'do' and all of the catch\n     // clauses.  This allows the user to break out of (or restart) the\n@@ -1258,11 +1237,109 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n     typeCheckStmt(newBody);\n     S->setBody(newBody);\n \n-    // Check all the catch clauses independently.\n-    for (auto clause : S->getCatches()) {\n-      checkCatchStmt(clause);\n+    SmallVector<VarDecl *, 8> scratchMemory1;\n+    SmallVector<VarDecl *, 8> scratchMemory2;\n+\n+    auto clauses = S->getCatches();\n+    CaseStmt *previousBlock = nullptr;\n+    for (auto i = clauses.begin(), e = clauses.end(); i != e; ++i) {\n+      auto *caseBlock = *i;\n+\n+      scratchMemory1.clear();\n+      scratchMemory2.clear();\n+\n+      SmallVectorImpl<VarDecl *> *prevCaseDecls = nullptr;\n+      SmallVectorImpl<VarDecl *> *nextCaseDecls = &scratchMemory1;\n+\n+      auto caseLabelItemArray = caseBlock->getMutableCaseLabelItems();\n+      {\n+        // Peel off the first iteration so we handle the first case label\n+        // especially since we use it to begin the validation chain.\n+        auto &labelItem = caseLabelItemArray.front();\n+\n+        // Resolve the pattern in our case label if it has not been resolved and\n+        // check that our var decls follow invariants.\n+        bool limit = true;\n+        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n+                                  getASTContext().getExceptionType(),\n+                                  &prevCaseDecls, &nextCaseDecls);\n+\n+        // After this is complete, prevCaseDecls will be pointing at\n+        // scratchMemory1 which contains the initial case block's var decls and\n+        // nextCaseDecls will be a nullptr. Set nextCaseDecls to point at\n+        // scratchMemory2 for the next iterations.\n+        assert(prevCaseDecls == &scratchMemory1);\n+        assert(nextCaseDecls == nullptr);\n+        nextCaseDecls = &scratchMemory2;\n+\n+        // Check the guard expression, if present.\n+        if (auto *guard = labelItem.getGuardExpr()) {\n+          TypeChecker::typeCheckCondition(guard, DC);\n+          labelItem.setGuardExpr(guard);\n+        }\n+      }\n+\n+      // Setup the types of our case body var decls.\n+      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n+        assert(expected->hasName());\n+        for (auto *prev : *prevCaseDecls) {\n+          if (!prev->hasName() || expected->getName() != prev->getName()) {\n+            continue;\n+          }\n+          if (prev->hasInterfaceType())\n+            expected->setInterfaceType(prev->getInterfaceType());\n+          break;\n+        }\n+      }\n+\n+      // Then check the rest.\n+      for (auto &labelItem : caseLabelItemArray.drop_front()) {\n+        // Resolve the pattern in our case label if it has not been resolved\n+        // and check that our var decls follow invariants.\n+        bool limit = true;\n+        checkCaseLabelItemPattern(caseBlock, labelItem, limit,\n+                                  getASTContext().getExceptionType(),\n+                                  &prevCaseDecls, &nextCaseDecls);\n+        // Check the guard expression, if present.\n+        if (auto *guard = labelItem.getGuardExpr()) {\n+          TypeChecker::typeCheckCondition(guard, DC);\n+          labelItem.setGuardExpr(guard);\n+        }\n+      }\n+\n+      // Our last CaseLabelItem's VarDecls are now in\n+      // prevCaseDecls. Wire them up as parents of our case body var\n+      // decls.\n+      //\n+      // NOTE: We know that the two lists of var decls must be in sync. Remember\n+      // that we constructed our case body VarDecls from the first\n+      // CaseLabelItems var decls. Just now we proved that all other\n+      // CaseLabelItems have matching var decls of the first meaning\n+      // transitively that our last case label item must have matching var decls\n+      // for our case stmts CaseBodyVarDecls.\n+      //\n+      // NOTE: We do not check that we matched everything here. That is because\n+      // the check has already been done by comparing the 1st CaseLabelItem var\n+      // decls. If we insert a check here, we will emit the same error multiple\n+      // times.\n+      for (auto *expected : caseBlock->getCaseBodyVariablesOrEmptyArray()) {\n+        assert(expected->hasName());\n+        for (auto *prev : *prevCaseDecls) {\n+          if (!prev->hasName() || expected->getName() != prev->getName()) {\n+            continue;\n+          }\n+          expected->setParentVarDecl(prev);\n+          break;\n+        }\n+      }\n+\n+      // Type-check the body statements.\n+      Stmt *body = caseBlock->getBody();\n+      typeCheckStmt(body);\n+      caseBlock->setBody(body);\n+      previousBlock = caseBlock;\n     }\n-    \n+\n     return S;\n   }\n \n@@ -1275,42 +1352,6 @@ class StmtChecker : public StmtVisitor<StmtChecker, Stmt*> {\n };\n } // end anonymous namespace\n \n-bool TypeChecker::typeCheckCatchPattern(CatchStmt *S, DeclContext *DC) {\n-  // Grab the standard exception type.\n-  Type exnType = DC->getASTContext().getErrorDecl()->getDeclaredType();\n-\n-  Pattern *pattern = S->getErrorPattern();\n-  if (Pattern *newPattern = TypeChecker::resolvePattern(pattern, DC,\n-                                           /*isStmtCondition*/false)) {\n-    pattern = newPattern;\n-\n-    // Coerce the pattern to the exception type.\n-    bool coercionError = false;\n-    if (exnType) {\n-      auto contextualPattern = ContextualPattern::forRawPattern(pattern, DC);\n-      TypeResolutionOptions patternOptions(TypeResolverContext::InExpression);\n-      auto coercedPattern = coercePatternToType(\n-          contextualPattern, exnType, patternOptions);\n-      if (coercedPattern)\n-        pattern = coercedPattern;\n-      else\n-        coercionError = true;\n-    }\n-\n-    if (!exnType || coercionError) {\n-      // If that failed, be sure to give the variables error types\n-      // before we type-check the guard.  (This will probably kill\n-      // most of the type-checking, but maybe not.)\n-      pattern->forEachVariable([&](VarDecl *var) {\n-        var->setInvalid();\n-      });\n-    }\n-\n-    S->setErrorPattern(pattern);\n-  }\n-  return false;\n-}\n-\n static bool isDiscardableType(Type type) {\n   return (type->hasError() ||\n           type->isUninhabited() ||"
                    },
                    {
                        "filename": "lib/Sema/TypeChecker.h",
                        "code": "@@ -896,7 +896,7 @@ Pattern *resolvePattern(Pattern *P, DeclContext *dc, bool isStmtCondition);\n /// unbound generic types.\n Type typeCheckPattern(ContextualPattern pattern);\n \n-bool typeCheckCatchPattern(CatchStmt *S, DeclContext *dc);\n+bool typeCheckCatchPattern(CaseStmt *S, DeclContext *dc);\n \n /// Coerce a pattern to the given type.\n ///"
                    },
                    {
                        "filename": "test/Interpreter/errors.swift",
                        "code": "@@ -44,4 +44,279 @@ ErrorHandlingTests.test(\"tryOptional\") {\n   expectEqual(Optional<LifetimeTracked>.none, try? furball(true))\n }\n \n+ErrorHandlingTests.test(\"fallthroughInCatch\") {\n+  switch 1 {\n+  case 1:\n+    do {\n+      try furball(true)\n+      expectUnreachable()\n+    } catch Excuse.CatAteHomework(_) {\n+      fallthrough\n+    } catch {\n+      expectUnreachable()\n+    }\n+  case 0:\n+    return\n+  default:\n+    expectUnreachable()\n+  }\n+  expectUnreachable()\n+}\n+\n+ErrorHandlingTests.test(\"breakInCatch\") {\n+  switch 1 {\n+  case 1:\n+    do {\n+      try furball(true)\n+    } catch {\n+      break\n+    }\n+    expectUnreachable() // break out of the case, not the catch\n+  default:\n+    break\n+  }\n+}\n+\n+enum Foo: Error {\n+  case a(LifetimeTracked)\n+  case b(LifetimeTracked)\n+}\n+\n+func baz(_ x: Foo, _ condition: (LifetimeTracked) -> Bool) -> Bool {\n+  do {\n+    throw x\n+  } catch Foo.a(let obj) where condition(obj),\n+          Foo.b(let obj) where condition(obj) {\n+    return true\n+  } catch {}\n+  return false\n+}\n+\n+ErrorHandlingTests.test(\"multiPatternWherePaths\") {\n+  _ = baz(.a(LifetimeTracked(1)), { _ in true })\n+  _ = baz(.b(LifetimeTracked(2)), { _ in true })\n+  _ = baz(.a(LifetimeTracked(3)), { _ in false })\n+  _ = baz(.b(LifetimeTracked(4)), { _ in false })\n+}\n+\n+public enum Phase<Value>: Error {\n+  case possible\n+  case active(Value)\n+  case paused(Value)\n+  case ended(Value)\n+  case failed\n+}\n+\n+extension Phase {\n+  public var valueLet: Value? {\n+    do {\n+      throw self\n+    }\n+    catch Phase.possible, Phase.failed {\n+      return nil\n+    }\n+    catch let Phase.active(value), let Phase.paused(value), let Phase.ended(value) {\n+      return value\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return nil\n+  }\n+\n+  public var valueVar: Value? {\n+    do {\n+      throw self\n+    }\n+    catch Phase.possible, Phase.failed {\n+      return nil\n+    }\n+    catch var Phase.active(value), var Phase.paused(value), var Phase.ended(value) {\n+      return value\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return nil\n+  }\n+}\n+\n+enum K {\n+  case A, B\n+}\n+\n+enum A<K>: Error {\n+  case left(a: K, b: K)\n+  case right(a: K, b: K)\n+  \n+  var valueLet: [K] {\n+    do {\n+      throw self\n+    }\n+    catch let A.left(a, b), let A.right(a, b) {\n+      return [a, b]\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return []\n+  }\n+  \n+  var valueVar: [K] {\n+    do {\n+      throw self\n+    }\n+    catch var A.left(a, b), var A.right(a, b) {\n+      return [a, b]\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return []\n+  }\n+}\n+\n+ErrorHandlingTests.test(\"GenericLet\") {\n+  do {\n+    expectEqual(1.0, Phase.active(1.0).valueLet)\n+    expectEqual(2.0, Phase.paused(2.0).valueLet)\n+    expectEqual(3.0, Phase.ended(3.0).valueLet)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    expectTrue(l === Phase.active(l).valueLet)\n+    expectTrue(l === Phase.paused(l).valueLet)\n+    expectTrue(l === Phase.ended(l).valueLet)\n+  }\n+\n+  do {\n+    expectEqual([K.A, K.B], A.left(a: K.A, b: K.B).valueLet)\n+    expectEqual([K.A, K.B], A.right(a: K.A, b: K.B).valueLet)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    let r = LifetimeTracked(0)\n+    let arr = A.left(a: l, b: r).valueLet\n+    expectTrue(arr[0] === l)\n+    expectTrue(arr[1] === r)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    let r = LifetimeTracked(0)\n+    let arr = A.right(a: l, b: r).valueLet\n+    expectTrue(arr[0] === l)\n+    expectTrue(arr[1] === r)\n+  }\n+}\n+\n+ErrorHandlingTests.test(\"GenericVar\") {\n+  do {\n+    expectEqual(1.0, Phase.active(1.0).valueVar)\n+    expectEqual(2.0, Phase.paused(2.0).valueVar)\n+    expectEqual(3.0, Phase.ended(3.0).valueVar)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    expectTrue(l === Phase.active(l).valueVar)\n+    expectTrue(l === Phase.paused(l).valueVar)\n+    expectTrue(l === Phase.ended(l).valueVar)\n+  }\n+\n+  do {\n+    expectEqual([K.A, K.B], A.left(a: K.A, b: K.B).valueVar)\n+    expectEqual([K.A, K.B], A.right(a: K.A, b: K.B).valueVar)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    let r = LifetimeTracked(0)\n+    let arr = A.left(a: l, b: r).valueVar\n+    expectTrue(arr[0] === l)\n+    expectTrue(arr[1] === r)\n+  }\n+\n+  do {\n+    let l = LifetimeTracked(0)\n+    let r = LifetimeTracked(0)\n+    let arr = A.right(a: l, b: r).valueVar\n+    expectTrue(arr[0] === l)\n+    expectTrue(arr[1] === r)\n+  }\n+}\n+\n+enum Gesture: Error {\n+  case pan(Any)\n+  case pinch(Any)\n+}\n+\n+extension Gesture {\n+  var valueLet: Any {\n+    do {\n+      throw self\n+    }\n+    catch Gesture.pan(let data),\n+          Gesture.pinch(let data) {\n+      return data\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return 42\n+  }\n+  var valueVar: Any {\n+    do { throw self }\n+    catch Gesture.pan(var data),\n+          Gesture.pinch(var data) {\n+      return data\n+    } catch { expectUnreachable() }\n+    expectUnreachable()\n+    return 42\n+  }\n+}\n+\n+ErrorHandlingTests.test(\"GenericLet\") {\n+  expectEqual(1, Gesture.pan(1).valueLet as! Int)\n+  expectEqual(2, Gesture.pinch(2).valueLet as! Int)\n+\n+  let l = LifetimeTracked(0)\n+  expectTrue(l === Gesture.pan(l).valueLet as! LifetimeTracked)\n+  expectTrue(l === Gesture.pinch(l).valueLet as! LifetimeTracked)\n+}\n+\n+ErrorHandlingTests.test(\"GenericVar\") {\n+  expectEqual(1, Gesture.pan(1).valueVar as! Int)\n+  expectEqual(2, Gesture.pinch(2).valueVar as! Int)\n+\n+  let l = LifetimeTracked(0)\n+  expectTrue(l === Gesture.pan(l).valueVar as! LifetimeTracked)\n+  expectTrue(l === Gesture.pinch(l).valueVar as! LifetimeTracked)\n+}\n+\n+ErrorHandlingTests.test(\"Enum Initialization Leaks\") {\n+  enum Enum1 {\n+  case case1(LifetimeTracked)\n+  case case2(LifetimeTracked, Int)\n+  }\n+\n+  enum Enum2: Error {\n+  case case1(LifetimeTracked)\n+  case case2(Enum1, LifetimeTracked)\n+  }\n+\n+  struct Struct {\n+    var value: Enum2 = .case2(.case1(LifetimeTracked(0)), LifetimeTracked(1))\n+\n+    func doSomethingCatch() {\n+      do {\n+        throw value\n+      }\n+      catch let Enum2.case2(.case2(k, _), _) {\n+        return\n+      } catch {\n+        return\n+      }\n+      return\n+    }\n+  }\n+\n+  do {\n+    let s = Struct()\n+    s.doSomethingCatch()\n+  }\n+}\n+\n runAllTests()"
                    },
                    {
                        "filename": "test/Parse/errors.swift",
                        "code": "@@ -55,6 +55,12 @@ func one() {\n #endif\n   } catch {    // don't warn, #if code should be scanned.\n   }\n+  \n+  do {\n+    throw opaque_error()\n+  } catch MSV.Foo, MSV.CarriesInt(let num) { // expected-error {{'num' must be bound in every pattern}}\n+  } catch {\n+  }\n }\n \n func takesAutoclosure(_ fn : @autoclosure () -> Int) {}"
                    },
                    {
                        "filename": "test/SILGen/errors.swift",
                        "code": "@@ -8,6 +8,7 @@ enum HomeworkError : Error {\n   case TooHard\n   case TooMuch\n   case CatAteIt(Cat)\n+  case CatHidIt(Cat)\n }\n \n func someValidPointer<T>() -> UnsafePointer<T> { fatalError() }\n@@ -241,6 +242,134 @@ func all_together_now_three(_ flag: Bool) throws -> Cat? {\n   }\n }\n \n+// Same as the previous test, but with a multi-pattern catch instead of two separate ones.\n+//\n+// CHECK-LABEL: sil hidden [ossa] @$s6errors21all_together_now_fouryAA3CatCSgSbKF : $@convention(thin) (Bool) -> (@owned Optional<Cat>, @error Error) {\n+// CHECK: bb0(\n+// CHECK-NOT: bb1\n+// CHECK:   try_apply {{.*}}, normal [[NORMAL_BB:bb[0-9]+]], error [[ERROR_BB:bb[0-9]+]]\n+//\n+// CHECK: [[ERROR_BB]]([[ERROR:%.*]] : @owned $Error):\n+// CHECK:   [[BORROWED_ERROR:%.*]] = begin_borrow [[ERROR]]\n+// CHECK:   [[COPIED_ERROR:%.*]] = copy_value [[BORROWED_ERROR]]\n+// CHECK:   store [[COPIED_ERROR]] to [init] [[CAST_INPUT_MEM:%.*]] : $*Error\n+// CHECK:   checked_cast_addr_br copy_on_success Error in [[CAST_INPUT_MEM]] : $*Error to HomeworkError in [[CAST_OUTPUT_MEM:%.*]] : $*HomeworkError, [[CAST_YES_BB:bb[0-9]+]], [[CAST_NO_BB:bb[0-9]+]],\n+//\n+// CHECK: [[CAST_YES_BB]]:\n+// CHECK:   [[SUBERROR:%.*]] = load [take] [[CAST_OUTPUT_MEM]]\n+// CHECK:   switch_enum [[SUBERROR]] : $HomeworkError, case #HomeworkError.TooHard!enumelt: [[TOO_HARD_BB:bb[0-9]+]], case #HomeworkError.TooMuch!enumelt: [[TOO_MUCH_BB:bb[0-9]+]], default [[SWITCH_MATCH_FAIL_BB:bb[0-9]+]],\n+//\n+// CHECK: [[TOO_HARD_BB]]:\n+// CHECK:   br [[CASE_BODY_BB:bb[0-9]+]]\n+//\n+// CHECK: [[TOO_MUCH_BB]]:\n+// CHECK:   br [[CASE_BODY_BB]]\n+//\n+// CHECK: [[CASE_BODY_BB]]\n+// CHECK:   [[RETVAL:%.*]] = enum $Optional<Cat>\n+// CHECK:   destroy_value [[ERROR]]\n+// CHECK:   br bb2([[RETVAL]] : $Optional<Cat>)\n+//\n+// CHECK: [[SWITCH_MATCH_FAIL_BB]]([[SUBERROR:%.*]] : @owned $HomeworkError):\n+// CHECK:   destroy_value [[SUBERROR]]\n+// CHECK:   end_borrow [[BORROWED_ERROR]]\n+// CHECK:   br [[RETHROW_BB:bb[0-9]+]]([[ERROR]] : $Error)\n+//\n+// CHECK: [[CAST_NO_BB]]:\n+// CHECK:   end_borrow [[BORROWED_ERROR]]\n+// CHECK:   br [[RETHROW_BB]]([[ERROR]] : $Error)\n+//\n+// CHECK: [[RETHROW_BB]]([[ERROR_FOR_RETHROW:%.*]] : @owned $Error):\n+// CHECK:   throw [[ERROR_FOR_RETHROW]]\n+// CHECK: } // end sil function '$s6errors21all_together_now_fouryAA3CatCSgSbKF'\n+func all_together_now_four(_ flag: Bool) throws -> Cat? {\n+  do {\n+    return try dont_return(Cat())\n+  } catch HomeworkError.TooHard, HomeworkError.TooMuch {\n+    return nil\n+  }\n+}\n+\n+// A multi-pattern catch with associated value bindings.\n+//\n+// CHECK-LABEL: sil hidden [ossa] @$s6errors21all_together_now_fiveyAA3CatCSbKF : $@convention(thin) (Bool) -> (@owned Cat, @error Error) {\n+\n+// Return block.\n+// CHECK:    [[RETURN:bb[0-9]+]]([[RETVAL:%.*]] : @owned $Cat):\n+// CHECK-NEXT: return [[RETVAL]] : $Cat\n+\n+//   Catch dispatch block.\n+// CHECK:    [[CATCH:bb[0-9]+]]([[ERROR:%.*]] : @owned $Error):\n+// CHECK:    [[BORROWED_ERROR:%.*]] = begin_borrow [[ERROR]]\n+// CHECK-NEXT: [[SRC_TEMP:%.*]] = alloc_stack $Error\n+// CHECK-NEXT: [[COPIED_BORROWED_ERROR:%.*]] = copy_value [[BORROWED_ERROR]]\n+// CHECK-NEXT: store [[COPIED_BORROWED_ERROR]] to [init] [[SRC_TEMP]]\n+// CHECK-NEXT: [[DEST_TEMP:%.*]] = alloc_stack $HomeworkError\n+// CHECK-NEXT: checked_cast_addr_br copy_on_success Error in [[SRC_TEMP]] : $*Error to HomeworkError in [[DEST_TEMP]] : $*HomeworkError, [[IS_HWE:bb[0-9]+]], [[NOT_HWE:bb[0-9]+]]\n+\n+//   Catch HomeworkError.\n+// CHECK:    [[IS_HWE]]:\n+// CHECK-NEXT: [[T0_ORIG:%.*]] = load [take] [[DEST_TEMP]] : $*HomeworkError\n+// CHECK-NEXT: switch_enum [[T0_ORIG]] : $HomeworkError, case #HomeworkError.CatAteIt!enumelt: [[MATCH_ATE:bb[0-9]+]], case #HomeworkError.CatHidIt!enumelt: [[MATCH_HID:bb[0-9]+]], default [[NO_MATCH:bb[0-9]+]]\n+\n+//   Catch HomeworkError.CatAteIt.\n+// CHECK:    [[MATCH_ATE]]([[T0:%.*]] : @owned $Cat):\n+// CHECK-NEXT: debug_value\n+// CHECK-NEXT: [[T0_COPY:%.*]] = copy_value [[T0]]\n+// CHECK-NEXT: destroy_value [[T0]]\n+// CHECK-NEXT: dealloc_stack [[DEST_TEMP]]\n+// CHECK-NEXT: destroy_addr [[SRC_TEMP]]\n+// CHECK-NEXT: dealloc_stack [[SRC_TEMP]]\n+// CHECK-NEXT: end_borrow [[BORROWED_ERROR]]\n+// CHECK-NEXT: br [[EXTRACT:bb[0-9]+]]([[T0_COPY]] : $Cat)\n+\n+//   Catch HomeworkError.CatHidIt.\n+// CHECK:    [[MATCH_HID]]([[T0:%.*]] : @owned $Cat):\n+// CHECK-NEXT: debug_value\n+// CHECK-NEXT: [[T0_COPY:%.*]] = copy_value [[T0]]\n+// CHECK-NEXT: destroy_value [[T0]]\n+// CHECK-NEXT: dealloc_stack [[DEST_TEMP]]\n+// CHECK-NEXT: destroy_addr [[SRC_TEMP]]\n+// CHECK-NEXT: dealloc_stack [[SRC_TEMP]]\n+// CHECK-NEXT: end_borrow [[BORROWED_ERROR]]\n+// CHECK-NEXT: br [[EXTRACT]]([[T0_COPY]] : $Cat)\n+\n+// CHECK:    [[EXTRACT]]([[CAT:%.*]] : @owned $Cat):\n+// CHECK-NEXT: [[BORROWED_CAT:%.*]] = begin_borrow [[CAT]] : $Cat\n+// CHECK-NEXT: [[COPIED_CAT:%.*]] = copy_value [[BORROWED_CAT]] : $Cat\n+// CHECK-NEXT: end_borrow [[BORROWED_CAT]] : $Cat\n+// CHECK-NEXT: destroy_value [[CAT]] : $Cat\n+// CHECK-NEXT: destroy_value [[ERROR]] : $Error\n+// CHECK-NEXT: br [[RETURN]]([[COPIED_CAT]] : $Cat)\n+\n+//   Catch other HomeworkErrors.\n+// CHECK:    [[NO_MATCH]]([[CATCHALL_ERROR:%.*]] : @owned $HomeworkError):\n+// CHECK-NEXT: destroy_value [[CATCHALL_ERROR]]\n+// CHECK-NEXT: dealloc_stack [[DEST_TEMP]]\n+// CHECK-NEXT: destroy_addr [[SRC_TEMP]]\n+// CHECK-NEXT: dealloc_stack [[SRC_TEMP]]\n+// CHECK-NEXT: end_borrow [[BORROWED_ERROR]]\n+// CHECK-NEXT: br [[RETHROW:bb[0-9]+]]\n+\n+//   Catch other types.\n+// CHECK:    [[NOT_HWE]]:\n+// CHECK-NEXT: dealloc_stack [[DEST_TEMP]]\n+// CHECK-NEXT: destroy_addr [[SRC_TEMP]]\n+// CHECK-NEXT: dealloc_stack [[SRC_TEMP]]\n+// CHECK-NEXT: end_borrow [[BORROWED_ERROR]]\n+// CHECK-NEXT: br [[RETHROW]]\n+\n+// Rethrow\n+// CHECK: [[RETHROW]]([[ERROR:%.*]] : @owned $Error):\n+// CHECK-NEXT: throw [[ERROR]] : $Error\n+func all_together_now_five(_ flag: Bool) throws -> Cat {\n+  do {\n+    return try dont_return(Cat())\n+  } catch HomeworkError.CatAteIt(let theCat), HomeworkError.CatHidIt(let theCat) {\n+    return theCat\n+  }\n+}\n+\n //   Catch in non-throwing context.\n // CHECK-LABEL: sil hidden [ossa] @$s6errors11catch_a_catAA3CatCyF : $@convention(thin) () -> @owned Cat\n // CHECK-NEXT: bb0:"
                    },
                    {
                        "filename": "test/Syntax/Outputs/round_trip_parse_gen.swift.withkinds",
                        "code": "@@ -328,10 +328,11 @@ do <CodeBlock>{<SwitchStmt>\n \n func statementTests<FunctionSignature><ParameterClause>() </ParameterClause></FunctionSignature><CodeBlock>{<DoStmt>\n   do <CodeBlock>{\n-  } </CodeBlock><CatchClause>catch <ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>var <IdentifierPattern>x</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>y</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>) </TupleExpr></ExpressionPattern><CodeBlock>{\n-  } </CodeBlock></CatchClause><CatchClause>catch <WhereClause>where <BooleanLiteralExpr>false </BooleanLiteralExpr></WhereClause><CodeBlock>{\n-  } </CodeBlock></CatchClause><CatchClause>catch <ValueBindingPattern>let <IdentifierPattern>e </IdentifierPattern></ValueBindingPattern><WhereClause>where <SequenceExpr><MemberAccessExpr><IdentifierExpr>e</IdentifierExpr>.foo </MemberAccessExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><IdentifierExpr>bar </IdentifierExpr></SequenceExpr></WhereClause><CodeBlock>{\n-  } </CodeBlock></CatchClause><CatchClause>catch <CodeBlock>{\n+  } </CodeBlock><CatchClause>catch <CatchItem><ExpressionPattern><TupleExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>var <IdentifierPattern>x</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr>, </TupleExprElement><TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>y</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>) </TupleExpr></ExpressionPattern></CatchItem><CodeBlock>{\n+  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><WhereClause>where <BooleanLiteralExpr>false </BooleanLiteralExpr></WhereClause></CatchItem><CodeBlock>{\n+  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><ValueBindingPattern>let <IdentifierPattern>e </IdentifierPattern></ValueBindingPattern><WhereClause>where <SequenceExpr><MemberAccessExpr><IdentifierExpr>e</IdentifierExpr>.foo </MemberAccessExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><IdentifierExpr>bar </IdentifierExpr></SequenceExpr></WhereClause></CatchItem><CodeBlock>{\n+  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem><ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.a</MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>a</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>)</FunctionCallExpr></ExpressionPattern>, </CatchItem><CatchItem><ExpressionPattern><FunctionCallExpr><MemberAccessExpr>.b</MemberAccessExpr>(<TupleExprElement><UnresolvedPatternExpr><ValueBindingPattern>let <IdentifierPattern>b</IdentifierPattern></ValueBindingPattern></UnresolvedPatternExpr></TupleExprElement>) </FunctionCallExpr></ExpressionPattern><WhereClause>where <SequenceExpr><IdentifierExpr>b </IdentifierExpr><BinaryOperatorExpr>== </BinaryOperatorExpr><StringLiteralExpr>\"<StringSegment></StringSegment>\" </StringLiteralExpr></SequenceExpr></WhereClause></CatchItem><CodeBlock>{\n+  } </CodeBlock></CatchClause><CatchClause>catch <CatchItem></CatchItem><CodeBlock>{\n   }</CodeBlock></CatchClause></DoStmt><RepeatWhileStmt>\n   repeat <CodeBlock>{ } </CodeBlock>while <BooleanLiteralExpr>true</BooleanLiteralExpr></RepeatWhileStmt><RepeatWhileStmt>\n   LABEL: repeat <CodeBlock>{ } </CodeBlock>while <BooleanLiteralExpr>false</BooleanLiteralExpr></RepeatWhileStmt><WhileStmt>"
                    },
                    {
                        "filename": "test/Syntax/round_trip_parse_gen.swift",
                        "code": "@@ -331,6 +331,7 @@ func statementTests() {\n   } catch (var x, let y) {\n   } catch where false {\n   } catch let e where e.foo == bar {\n+  } catch .a(let a), .b(let b) where b == \"\" {\n   } catch {\n   }\n   repeat { } while true"
                    },
                    {
                        "filename": "test/stmt/errors.swift",
                        "code": "@@ -97,6 +97,14 @@ class eight {\n   }()\n }\n \n+func multiPattern() {\n+  do {\n+    throw opaque_error()\n+  } catch MSV.Foo, _ {\n+    _ = e\n+  }\n+}\n+\n protocol ThrowingProto {\n   func foo() throws\n   static func bar() throws"
                    },
                    {
                        "filename": "utils/gyb_syntax_support/NodeSerializationCodes.py",
                        "code": "@@ -244,6 +244,8 @@\n     'PoundFilePathExpr': 240,\n     'DerivativeRegistrationAttributeArguments': 241,\n     'QualifiedDeclName': 242,\n+    'CatchItem': 243,\n+    'CatchItemList': 244,\n }\n \n "
                    },
                    {
                        "filename": "utils/gyb_syntax_support/StmtNodes.py",
                        "code": "@@ -177,6 +177,10 @@\n     Node('CaseItemList', kind='SyntaxCollection',\n          element='CaseItem'),\n \n+    # catch-item-list -> catch-item catch-item-list?\n+    Node('CatchItemList', kind='SyntaxCollection',\n+         element='CatchItem'),\n+\n     # condition -> expression\n     #            | availability-condition\n     #            | case-condition\n@@ -315,6 +319,17 @@\n                    is_optional=True),\n          ]),\n \n+    # catch-item -> pattern? where-clause? ','?\n+    Node('CatchItem', kind='Syntax',\n+         traits=['WithTrailingComma'],\n+         children=[\n+             Child('Pattern', kind='Pattern', is_optional=True),\n+             Child('WhereClause', kind='WhereClause',\n+                   is_optional=True),\n+             Child('TrailingComma', kind='CommaToken',\n+                   is_optional=True),\n+         ]),\n+\n     # switch-case-label -> 'case' case-item-list ':'\n     Node('SwitchCaseLabel', kind='Syntax',\n          children=[\n@@ -324,14 +339,13 @@\n              Child('Colon', kind='ColonToken'),\n          ]),\n \n-    # catch-clause 'catch' pattern? where-clause? code-block\n+    # catch-clause 'catch' case-item-list? code-block\n     Node('CatchClause', kind='Syntax',\n+         traits=['WithCodeBlock'],\n          children=[\n              Child('CatchKeyword', kind='CatchToken'),\n-             Child('Pattern', kind='Pattern',\n-                   is_optional=True),\n-             Child('WhereClause', kind='WhereClause',\n-                   is_optional=True),\n+             Child('CatchItems', kind='CatchItemList',\n+                   collection_element_name='CatchItem', is_optional=True),\n              Child('Body', kind='CodeBlock'),\n          ]),\n "
                    }
                ]
            },
            {
                "date": "2020-04-01T22:12:30Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/d6a2910f4199d696f6900ac787c7e7071cb1caa7",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -755,7 +755,7 @@ void DiagnosticVerifier::printRemainingDiagnostics() const {\n \n     SM.getLLVMSourceMgr().PrintMessage(\n         llvm::errs(), getRawLoc(diag.Loc), SMKind,\n-        \"diagnostic produced by elsewhere: \" + diag.Message.str(),\n+        \"diagnostic produced elsewhere: \" + diag.Message.str(),\n         /*Ranges=*/{}, {});\n   }\n }"
                    }
                ]
            },
            {
                "date": "2020-04-01T22:05:24Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/2c2850d7ebd43ea3d21c90ed160dfef04b77494b",
                "changes": [
                    {
                        "filename": ".gitignore",
                        "code": "@@ -22,6 +22,7 @@\n #==============================================================================#\n # Explicit files to ignore (only matches one).\n #==============================================================================#\n+Brewfile.lock.json\n cscope.files\n cscope.out\n .vimrc"
                    },
                    {
                        "filename": "Brewfile",
                        "code": "@@ -0,0 +1,2 @@\n+brew \"cmake\"\n+brew \"ninja\""
                    },
                    {
                        "filename": "CHANGELOG.md",
                        "code": "@@ -6,7 +6,8 @@ CHANGELOG\n \n | Version                | Released   | Toolchain   |\n | :--------------------- | :--------- | :---------- |\n-| [Swift 5.2](#swift-52) |            |             |\n+| [Swift 5.3](#swift-53) |            |             |\n+| [Swift 5.2](#swift-52) | 2020-03-24 | Xcode 11.4  |\n | [Swift 5.1](#swift-51) | 2019-09-20 | Xcode 11.0  |\n | [Swift 5.0](#swift-50) | 2019-03-25 | Xcode 10.2  |\n | [Swift 4.2](#swift-42) | 2018-09-17 | Xcode 10.0  |\n@@ -23,9 +24,25 @@ CHANGELOG\n \n </details>\n \n-Swift Next\n+Swift 5.3\n ----------\n \n+* [SE-0280][]:\n+  \n+  Enum cases can now satisfy static protocol requirements. A static get-only property of type `Self` can be witnessed by an enum case with no associated values and a static function with arguments and returning `Self` can be witnessed by an enum case with associated values.\n+  \n+  ```swift\n+  protocol P {\n+    static var foo: Self { get }\n+    static func bar(value: Int) -> Self\n+  }\n+  \n+  enum E: P {\n+    case foo // matches 'static var foo'\n+    case bar(value: Int) // matches 'static func bar(value:)'\n+  }\n+  ```\n+\n * [SE-0267][]:\n   \n   Non-generic members that support a generic parameter list, including nested type declarations, are now allowed to carry a contextual `where` clause against outer generic parameters. Previously, such declarations could only be expressed by placing the member inside a dedicated constrained extension.\n@@ -49,15 +66,15 @@ Swift Next\n \n * [SR-75][]:\n \n-  Unapplied references to protocol methods methods are now supported. Previously this\n+  Unapplied references to protocol methods are now supported. Previously this\n   only worked for methods defined in structs, enums and classes.\n \n   ```swift\n   protocol Cat {\n     func play(catToy: Toy)\n   }\n \n-  let fn = Cat.play\n+  let fn = Cat.play(catToy:)\n   fn(myCat)(myToy)\n   ```\n \n@@ -97,9 +114,13 @@ Swift Next\n   closure's capture list in addition to the existing 'use `self.` explicitly'\n   fix-it.\n \n+**Add new entries to the top of this section, not here!**\n+\n Swift 5.2\n ---------\n \n+### 2020-03-24 (Xcode 11.4)\n+\n * [SR-11841][]:\n \n   When chaining calls to `filter(_:)` on a lazy sequence or collection, the\n@@ -292,8 +313,6 @@ Swift 5.2\n   print(s[0])\n   ```\n \n-**Add new entries to the top of this section, not here!**\n-\n Swift 5.1\n ---------\n \n@@ -7951,6 +7970,7 @@ Swift 1.0\n [SE-0266]: <https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md>\n [SE-0267]: <https://github.com/apple/swift-evolution/blob/master/proposals/0267-where-on-contextually-generic.md>\n [SE-0269]: <https://github.com/apple/swift-evolution/blob/master/proposals/0269-implicit-self-explicit-capture.md>\n+[SE-0280]: <https://github.com/apple/swift-evolution/blob/master/proposals/0280-enum-cases-as-protocol-witnesses.md>\n \n [SR-75]: <https://bugs.swift.org/browse/SR-75>\n [SR-106]: <https://bugs.swift.org/browse/SR-106>"
                    },
                    {
                        "filename": "CMakeLists.txt",
                        "code": "@@ -1027,13 +1027,11 @@ if(SWIFT_BUILD_SYNTAXPARSERLIB OR SWIFT_BUILD_SOURCEKIT)\n       set(SOURCEKIT_RUNTIME_DIR lib)\n     endif()\n     add_dependencies(sourcekit-inproc BlocksRuntime dispatch)\n-    if(\"${SWIFT_HOST_VARIANT_SDK}\" MATCHES \"OSX|WINDOWS\")\n-      swift_install_in_component(FILES\n-                                   $<TARGET_FILE:dispatch>\n-                                   $<TARGET_FILE:BlocksRuntime>\n-                                 DESTINATION ${SOURCEKIT_RUNTIME_DIR}\n-                                 COMPONENT sourcekit-inproc)\n-    endif()\n+    swift_install_in_component(FILES\n+                                 $<TARGET_FILE:dispatch>\n+                                 $<TARGET_FILE:BlocksRuntime>\n+                               DESTINATION ${SOURCEKIT_RUNTIME_DIR}\n+                               COMPONENT sourcekit-inproc)\n     if(SWIFT_HOST_VARIANT_SDK STREQUAL WINDOWS)\n       swift_install_in_component(FILES\n                                    $<TARGET_LINKER_FILE:dispatch>"
                    },
                    {
                        "filename": "README.md",
                        "code": "@@ -91,7 +91,7 @@ Please make sure you use Python 2.x. Python 3.x is not supported currently.\n \n #### macOS\n \n-To build for macOS, you need [Xcode 11.3](https://developer.apple.com/xcode/downloads/).\n+To build for macOS, you need [Xcode 11.4](https://developer.apple.com/xcode/downloads/).\n The required version of Xcode changes frequently, and is often a beta release.\n Check this document or the host information on <https://ci.swift.org> for the\n current required version.\n@@ -102,6 +102,12 @@ which can be installed via a package manager:\n **[Homebrew](https://brew.sh/)**\n \n     brew install cmake ninja\n+    \n+You can also use [homebrew-bundle](https://github.com/Homebrew/homebrew-bundle)\n+from the root of this repository's working directory to install all of these\n+dependencies:\n+\n+    brew bundle\n \n **[MacPorts](https://macports.org)**\n \n@@ -359,7 +365,7 @@ expressed today.\n \n ### CMake\n [CMake](https://cmake.org) is the core infrastructure used to configure builds of\n-Swift and its companion projects; at least version 3.4.3 is required.\n+Swift and its companion projects; at least version 3.16.5 is required.\n \n On macOS, you can download the [CMake Binary Distribution](https://cmake.org/download),\n bundled as an application, copy it to `/Applications`, and add the embedded"
                    },
                    {
                        "filename": "docs/ABI/Mangling.rst",
                        "code": "@@ -517,6 +517,10 @@ Types\n   FUNCTION-KIND ::= 'C'                      // C function pointer type\n   FUNCTION-KIND ::= 'A'                      // @auto_closure function type (escaping)\n   FUNCTION-KIND ::= 'E'                      // function type (noescape)\n+  FUNCTION-KIND ::= 'F'                      // @differentiable function type\n+  FUNCTION-KIND ::= 'G'                      // @differentiable function type (escaping)\n+  FUNCTION-KIND ::= 'H'                      // @differentiable(linear) function type\n+  FUNCTION-KIND ::= 'I'                      // @differentiable(linear) function type (escaping)\n \n   function-signature ::= params-type params-type throws? // results and parameters\n \n@@ -585,14 +589,18 @@ mangled in to disambiguate.\n   impl-function-type ::= type* 'I' FUNC-ATTRIBUTES '_'\n   impl-function-type ::= type* generic-signature 'I' FUNC-ATTRIBUTES '_'\n \n-  FUNC-ATTRIBUTES ::= PATTERN-SUBS? INVOCATION-SUBS? PSEUDO-GENERIC? CALLEE-ESCAPE? CALLEE-CONVENTION FUNC-REPRESENTATION? COROUTINE-KIND? PARAM-CONVENTION* RESULT-CONVENTION* ('Y' PARAM-CONVENTION)* ('z' RESULT-CONVENTION)?\n+  FUNC-ATTRIBUTES ::= PATTERN-SUBS? INVOCATION-SUBS? PSEUDO-GENERIC? CALLEE-ESCAPE? DIFFERENTIABILITY-KIND? CALLEE-CONVENTION FUNC-REPRESENTATION? COROUTINE-KIND? PARAM-CONVENTION* RESULT-CONVENTION* ('Y' PARAM-CONVENTION)* ('z' RESULT-CONVENTION)?\n \n   PATTERN-SUBS ::= 's'                       // has pattern substitutions\n   INVOCATION-SUB ::= 'I'                     // has invocation substitutions\n   PSEUDO-GENERIC ::= 'P'\n \n   CALLEE-ESCAPE ::= 'e'                      // @escaping (inverse of SIL @noescape)\n \n+  DIFFERENTIABILITY-KIND ::= DIFFERENTIABLE | LINEAR\n+  DIFFERENTIABLE ::= 'd'                     // @differentiable\n+  LINEAR ::= 'l'                             // @differentiable(linear)\n+\n   CALLEE-CONVENTION ::= 'y'                  // @callee_unowned\n   CALLEE-CONVENTION ::= 'g'                  // @callee_guaranteed\n   CALLEE-CONVENTION ::= 'x'                  // @callee_owned"
                    },
                    {
                        "filename": "docs/CompilerPerformance.md",
                        "code": "@@ -570,7 +570,7 @@ compilers on hand while you're working.\n     Total Execution Time: 0.0876 seconds (0.0877 wall clock)\n \n      ---User Time---   --System Time--   --User+System--   ---Wall Time---  --- Name ---\n-     0.0241 ( 53.9%)   0.0394 ( 92.0%)   0.0635 ( 72.5%)   0.0635 ( 72.5%)  Name binding\n+     0.0241 ( 53.9%)   0.0394 ( 92.0%)   0.0635 ( 72.5%)   0.0635 ( 72.5%)  Import resolution\n      0.0170 ( 38.0%)   0.0025 (  5.8%)   0.0195 ( 22.3%)   0.0195 ( 22.2%)  Type checking / Semantic analysis\n      0.0013 (  3.0%)   0.0004 (  0.8%)   0.0017 (  1.9%)   0.0017 (  1.9%)  LLVM output\n      0.0010 (  2.3%)   0.0003 (  0.7%)   0.0013 (  1.5%)   0.0013 (  1.5%)  SILGen"
                    },
                    {
                        "filename": "docs/CppInteroperabilityManifesto.md",
                        "code": "@@ -1103,7 +1103,7 @@ public:\n // C++ header imported in Swift.\n \n struct Employee {\n-  func mutable_name() -> UnsafeMutablePointer<std.string>\n+  func mutable_company() -> UnsafeMutablePointer<std.string>\n }\n ```\n \n@@ -1536,7 +1536,7 @@ public moveonly struct File {\n \n func useArrayOfFiles() {\n   var files: [File] = ...\n-  consumeFile(files[0].move())\n+  consumeFile(files[0].cxxMove())\n }\n ```\n "
                    },
                    {
                        "filename": "docs/DebuggingTheCompiler.rst",
                        "code": "@@ -164,22 +164,66 @@ Debugging on SIL Level\n Options for Dumping the SIL\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-Often it is not sufficient to dump the SIL at the beginning or end of the\n-optimization pipeline.\n-The SILPassManager supports useful options to dump the SIL also between\n-pass runs.\n+Often it is not sufficient to dump the SIL at the beginning or end of\n+the optimization pipeline. The SILPassManager supports useful options\n+to dump the SIL also between pass runs.\n \n-The option ``-Xllvm -sil-print-all`` dumps the whole SIL module after all\n-passes. Although it prints only functions which were changed by a pass, the\n-output can get *very* large.\n+The SILPassManager's SIL dumping options vary along two orthogonal\n+functional axes:\n \n-It is useful if you identified a problem in the final SIL and you want to\n-check which pass did introduce the wrong SIL.\n+1. Options that control if functions/modules are printed.\n+2. Options that filter what is printed at those points.\n \n-There are several other options available, e.g. to filter the output by\n-function names (``-Xllvm -sil-print-only-function``/``s``) or by pass names\n-(``-Xllvm -sil-print-before``/``after``/``around``).\n-For details see ``PassManager.cpp``.\n+One generally always specifies an option of type 1 and optionally adds\n+an option of type 2 to filter the output.\n+\n+A short (non-exhaustive) list of type 1 options:\n+\n+* ``-Xllvm -sil-print-all``: Print functions/modules when ever a\n+  function pass modifies a function and Print the entire module\n+  (modulo filtering) if a module pass modifies a SILModule.\n+\n+A short (non-exhaustive) list of type 2 options:\n+\n+* ``-Xllvm -sil-print-around=$PASS_NAME``: Print a function/module\n+  before and after a function pass with name ``$PASS_NAME`` runs on a\n+  function/module or dump a module before a module pass with name\n+  ``$PASS_NAME`` runs on a module.\n+\n+* ``-Xllvm -sil-print-before=$PASS_NAME``: Print a function/module\n+  before a function pass with name ``$PASS_NAME`` runs on a\n+  function/module or dump a module before a module pass with name\n+  ``$PASS_NAME`` runs on a module. NOTE: This happens even without\n+  sil-print-all set!\n+\n+* ``-Xllvm -sil-print-after=$PASS_NAME``: Print a function/module\n+  after a function pass with name ``$PASS_NAME`` runs on a\n+  function/module or dump a module before a module pass with name\n+  ``$PASS_NAME`` runs on a module.\n+\n+* ``-Xllvm '-sil-print-only-function=SWIFT_MANGLED_NAME'``: When ever\n+  one would print a function/module, only print the given function.\n+\n+These options together allow one to visualize how a\n+SILFunction/SILModule is optimized by the optimizer as each\n+optimization pass runs easily via formulations like::\n+\n+    swiftc -Xllvm '-sil-print-only-function=$myMainFunction' -Xllvm -sil-print-all\n+\n+NOTE: This may emit a lot of text to stderr, so be sure to pipe the\n+output to a file.\n+\n+Getting CommandLine for swift stdlib from Ninja\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If one builds swift using ninja and wants to dump the SIL of the\n+stdlib using some of the SIL dumping options from the previous\n+section, one can use the following one-liner::\n+\n+  ninja -t commands | grep swiftc | grep Swift.o | grep \" -c \"\n+\n+This should give one a single command line that one can use for\n+Swift.o, perfect for applying the previous sections options to.\n \n Dumping the SIL and other Data in LLDB\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -359,6 +403,17 @@ we know to ignore swift_getGenericMetadata 84 times, i.e.::\n \n     (lldb) br set -i 84 -n GlobalARCOpts::run\n \n+A final trick is that one can use the -R option to stop at a relative assembly\n+address in lldb. Specifically, lldb resolves the breakpoint normally and then\n+just adds the argument -R to the address. So for instance, if I want to stop at\n+the address at +38 in the function with the name 'foo', I would write::\n+\n+    (lldb) br set -R 38 -n foo\n+\n+Then lldb would add 38 to the offset of foo and break there. This is really\n+useful in contexts where one wants to set a breakpoint at an assembly address\n+that is stable across multiple different invocations of lldb.\n+\n LLDB Scripts\n ~~~~~~~~~~~~\n "
                    },
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -92,23 +92,34 @@ Most diagnostics have no reason to change behavior under editor mode. An example\n \n ### Educational Notes ###\n \n-**Note**: This feature is currently experimental. It can be enabled by passing the `-Xfrontend -enable-descriptive-diagnostics` flag.\n+Educational notes are short-form documentation attached to a diagnostic which explain relevant language concepts. They are intended to further Swift's goal of progressive disclosure by providing a learning resource at the point of use when encountering an error message for the first time. In very limited circumstances, they also allow the main diagnostic message to use precise terminology (e.g. nominal types) which would otherwise be too unfriendly for beginners.\n \n-Educational notes are small snippets of documentation attached to a diagnostic which explain relevant language concepts. They are intended to further Swift's goal of progressive disclosure by providing a learning resource at the point of use for users encountering a new error message for the first time. In very limited circumstances, they also allow the main diagnostic message to use more precise and correct terminology (e.g. nominal types) which would otherwise be too unfriendly for beginners.\n+When outputting diagnostics on the command line, educational notes will be printed after the main diagnostic body if enabled using the `-print-educational-notes` driver option. When presented in an IDE, it's expected they will be collapsed under a disclosure arrow, info button, or similar to avoid cluttering output.\n \n-When outputting diagnostics on the command line, educational notes will be printed after the main diagnostic body if descriptive diagnostics are enabled. When presented in an IDE, it's expected they will be collapsed under a disclosure arrow, info button, or similar to avoid cluttering output.\n-\n-Generally speaking, a diagnostic should try to provide educational notes for any concepts/terminology which is difficult to understand from context or is especially subtle. Educational notes should:\n-- Explain a single language concept. This makes them easy to reuse across diagnostics and helps keep them clear, concise, and easy to understand.\n-- Be written in unabbreviated English. These are longer form messages compared to the main diagnostic, so there is no need to omit needless words and punctuation.\n-- Not generally exceed 3-4 paragraphs. Educational notes should be clear and easily digestible. Messages which are too long also have the potential to create diagnostics UX issues in some contexts.\n+Educational notes should:\n+- Explain a single language concept. This makes them easy to reuse across related diagnostics and helps keep them clear, concise, and easy to understand.\n+- Be written in unabbreviated English. These are longer-form messages compared to the main diagnostic, so there's no need to omit needless words and punctuation.\n+- Not generally exceed 3-4 paragraphs. Educational notes should be clear and easily digestible. Messages which are too long also have the potential to create UX issues on the command line.\n - Be accessible. Educational notes should be beginner friendly and avoid assuming unnecesary prior knowledge. The goal is not only to help users understand what a diagnostic is telling them, but also to turn errors and warnings into \"teachable moments\".\n-- Include references to relevant chapters of _The Swift Programming Language_ if applicable.\n-- Be written in Markdown, but avoid excessive markup to avoid impacting the terminal UX. \n+- Include references to relevant chapters of _The Swift Programming Language_.\n+- Be written in Markdown, but avoid excessive markup which negatively impacts the terminal UX.\n+\n+### Quick-Start Guide for Contributing New Educational Notes ###\n+\n+Adding new educational notes is a great way to get familiar with the process of contributing to Swift, while also making a big impact!\n \n To add a new educational note:\n-1. Add a new Markdown file in the `userdocs/diagnostics/` directory containing the contents of the note. \n-2. Associate the note with one or more diagnostics in EducationalNotes.def.\n+1. Follow the [directions in the README](https://github.com/apple/swift#getting-sources-for-swift-and-related-projects) to checkout the Swift sources locally. Being able to build the Swift compiler is recommended, but not required, when contributing a new note.\n+2. Identify a diagnostic to write an educational note for. To associate an educational note with a diagnostic name, you'll need to know its internal identifier. The easiest way to do this is to write a small program which triggers the diagnostic, and run it using the `-debug-diagnostic-names` compiler flag. This flag will cause the internal diagnostic identifier to be printed after the diagnostic message in square brackets.\n+3. Find any closely related diagnostics. Sometimes, what appears to be one diagnostic from a user's perspective may have multiple variations internally. After determining a diagnostic's internal identifier, run a search for it in the compiler source. You should find:\n+    - An entry in a `Diagnostics*.def` file describing the diagnostic. If there are any closely related diagnostics the note should also be attached to, they can usually be found nearby.\n+    - Each point in the compiler source where the diagnostic is emitted. This can be helpful in determining the exact circumstances which cause it to be emitted.\n+4. Add a new Markdown file in the `userdocs/diagnostics/` directory in the swift repository containing the contents of the note. When writing a note, keep the writing guidelines from the section above in mind. The existing notes in the directory are another useful guide.\n+5. Associate the note with the appropriate diagnostics in `EducationalNotes.def`. An entry like `EDUCATIONAL_NOTES(property_wrapper_failable_init, \"property-wrapper-requirements.md\")` will associate the note with filename `property-wrapper-requirements.md` with the diagnostic having an internal identifier of `property_wrapper_failable_init`.\n+6. If possible, rebuild the compiler and try recompiling your test program with `-print-educational-notes`. Your new note should appear after the diagnostic in the terminal.\n+7. That's it! The new note is now ready to be submitted as a pull request on GitHub.\n+\n+If you run into any issues or have questions while following the steps above, feel free to post a question on the Swift forums or open a work-in-progress pull request on GitHub.\n \n ### Format Specifiers ###\n "
                    },
                    {
                        "filename": "docs/HowSwiftImportsCAPIs.md",
                        "code": "@@ -315,8 +315,8 @@ void drawStringRenamed(const char *, int xPos, int yPos)\n ```swift\n // C header imported in Swift.\n \n-func drawString(_: UnsafePointer<CChar>!, _ xPos: Int, _ yPos: Int)\n-func drawStringRenamed(_: UnsafePointer<CChar>!, x: Int, y: Int)\n+func drawString(_: UnsafePointer<CChar>!, _ xPos: CInt, _ yPos: CInt)\n+func drawStringRenamed(_: UnsafePointer<CChar>!, x: CInt, y: CInt)\n \n drawString(\"hello\", 10, 20)\n drawStringRenamed(\"hello\", x: 10, y: 20)\n@@ -602,9 +602,9 @@ memory layout.\n \n As discussed above, there are cases where bridging that adjusts memory layout is\n not possible, for example, when importing pointers to function pointers. For\n-example, while C's int `(*)(char)` can be imported as `(Int8) -> Int` (requires\n+example, while C's `int (*)(char)` can be imported as `(CChar) -> CInt` (requires\n an adjustment of memory layout), C's `int (**)(char)` can't be imported as\n-`UnsafePointer<(Int8) -> Int>`, because the pointee must have identical memory\n+`UnsafePointer<(CChar) -> CInt>`, because the pointee must have identical memory\n layout in C and in Swift.\n \n Therefore, we need a Swift type that has a memory layout identical to C function\n@@ -800,9 +800,9 @@ union IntOrFloat {\n \n struct IntOrFloat {\n   var i: CInt { get set } // Computed property.\n-  var f: Float { get set } // Computed property.\n+  var f: CFloat { get set } // Computed property.\n   init(i: CInt)\n-  init(f: Float)\n+  init(f: CFloat)\n   init()\n }\n ```"
                    },
                    {
                        "filename": "docs/Lexicon.rst",
                        "code": "@@ -77,6 +77,17 @@ source code, tests, and commit messages. See also the `LLVM lexicon`_.\n     same; the exception is when generics get involved. In this case you'll need\n     a `generic environment`. Contrast with `sugared type`.\n \n+  cascading dependency\n+    A kind of dependency edge relevant to the incremental name tracking\n+    subsystem. A cascading dependency (as opposed to a\n+    `private dependency <private dependency>`) requires the Swift driver to\n+    transitively consider dependency edges in the file that defines the used\n+    name when incremental compilation is enabled. A cascading dependency is much\n+    safer to produce than its private counterpart, but it comes at the cost of\n+    increased usage of compilation resources - even if those resources are being\n+    wasted on rebuilding a file that didn't actually require rebuilding.\n+    See :doc:`DependencyAnalysis.rst <DependencyAnalysis>`.\n+\n   Clang importer\n     The part of the compiler that reads C and Objective-C declarations and\n     exposes them as Swift. Essentially contains a small instance of Clang\n@@ -100,6 +111,24 @@ source code, tests, and commit messages. See also the `LLVM lexicon`_.\n     i.e. one that conforming types don't *have* to implement but have the option\n     to \"customize\".\n \n+  dependency sink\n+    Any request that uses a matching dependency source to write dependency\n+    edges into the referenced name trackers. For example, a request that\n+    performs direct lookup will write the name being looked up into the\n+    name tracker associated with the file that issued the lookup request.\n+    The request evaluator automatically determines the appropriate tracker\n+    for a dependency sink to write into based on the current active\n+    `dependency source <dependency source>` request.\n+\n+  dependency source\n+    Any request that defines a scope under which reference dependencies may be\n+    registered. For example, a request to type check an entire file is a\n+    dependency source. Dependency sources are automatically managed by the\n+    request evaluator as request evaluation proceeds. Dependency sources provide\n+    one half of the necessary information to complete a full dependency edge.\n+    The other half is provided by corresponding\n+    `dependency sink <dependency sink>` requests.\n+\n   DI (definite initialization / definitive initialization)\n     The feature that no uninitialized variables, constants, or properties will\n     be read by a program, or the analysis pass that operates on SIL to\n@@ -327,6 +356,17 @@ source code, tests, and commit messages. See also the `LLVM lexicon`_.\n     only needed for context. See also\n     `Whole-Module Optimization <WMO (whole-module optimization)>`.\n \n+  private dependency\n+    A kind of dependency edge relevant to the incremental name tracking\n+    subsystem. A private dependency (as opposed to a\n+    `cascading dependency <cascading dependency>`) declares a dependency edge\n+    from one file to a name referenced in that file that does not\n+    require further transitive evaluation of dependency edges by the Swift\n+    driver. Private dependencies are therefore cheaper than cascading\n+    dependencies, but must be used with the utmost care or dependent files will\n+    fail to rebuild and the result will most certainly be a miscompile.\n+    See :doc:`DependencyAnalysis.rst <DependencyAnalysis>`.\n+\n   QoI\n     \"Quality of implementation.\" The term is meant to describe not how\n     well-engineered a particular implementation is, but how much value it"
                    },
                    {
                        "filename": "docs/RequestEvaluator.md",
                        "code": "@@ -52,12 +52,16 @@ The request-evaluator contains a cache of any requests that have already been ev\n \n Until then, the request-evaluator lives in a compiler that has mutable ASTs, and will for the foreseeable future. To cope with this, requests can opt for \"separate\" caching of their results, implementing a simple protocol to query their own cache (`getCachedResult`) and set the value for the cache (`cacheResult`). For now, these functions can directly modify state in the AST, allowing the requests to be mixed with direct mutation of the state. For each request, the intent is to make all state access go through the evaluator, but getting there can be an incremental process.\n \n+## Incremental Dependency Tracking\n+Request evaluation naturally captures the dependency structure of any given invocation of the compiler frontend. In fact, it captures it so well that the request graph trace generated by a select kind of lookup request can be used to completely recover the information relevant to the Swift compiler's incremental compilation subsystem. For these select *dependency-relevant* requests, we can further subdivide them into so-called *dependency sources* and *dependency sinks*. A dependency source is any (usually high-level) request that introduces a new context under which dependencies can be registered. Currently, these are the requests that operate that the level of individual source files. A dependency sink is any (usually lower-level) request that executes as a sub-computation of a dependency source. Any names that are dependency-relevant, such as the result of a lookup in a particular context, are then registered against trackers in the active dependency source (file). Using this, the evaluator pushes and pops sources and sinks automatically as request evaluation proceeds, and sink requests pair automatically to source requests to write out dependency information.\n+\n+To define a request as a dependency source, it must implement an accessor for the new active scope (`readDependencySource`). To define a request as a dependency sink, it must implement a function that writes the result of evaluating the request into the current active source (`writeDependencySink`).\n+\n ## Open Projects\n \n The request-evaluator is relatively new to the Swift compiler, having been introduced in mid-2018. There are a number of improvements that can be made to the evaluator itself and how it is used in the compiler:\n \n * The evaluator uses a `DenseMap<AnyRequest, AnyValue>` as its cache: we can almost certainly do better with per-request-kind caches that don't depend on so much type erasure.\n-* The stack of active requests uses a `SetVector<AnyRequest>`: we can almost certainly do better with some kind of heterogeneous on-stack representation that only realizes `AnyRequest` instances in the failure cases (e.g., to diagnose a cycle).\n * Explore how best to cache data structures in the evaluator. For example, caching `std::vector<T>` or `std::string` implies that we'll make copies of the underlying data structure each time we access the data. Could we automatically intern the data into an allocation arena owned by the evaluator, and vend `ArrayRef<T>` and `StringRef` to clients instead?\n * Cycle diagnostics are far too complicated and produce very poor results. Consider replacing the current `diagnoseCycle`/`noteCycleStep` scheme with a single method that produces summary information (e.g., a short summary string + source location information) and provides richer diagnostics from that string.\n * The `isCached()` check to determine whether a specific instance of a request is worth caching may be at the wrong level, because one generally has to duplicate effort (or worse, code!) to make the decision in `isCached()`. Consider whether the `evaluator()` function could return something special to say \"produce this value without caching\" vs. the normal \"produce this value with caching\"."
                    },
                    {
                        "filename": "docs/SIL.rst",
                        "code": "@@ -177,9 +177,9 @@ Here is an example of a ``.sil`` file::\n   // Define a SIL vtable. This matches dynamically-dispatched method\n   // identifiers to their implementations for a known static class type.\n   sil_vtable Button {\n-    #Button.onClick!1: @_TC5norms6Button7onClickfS0_FT_T_\n-    #Button.onMouseDown!1: @_TC5norms6Button11onMouseDownfS0_FT_T_\n-    #Button.onMouseUp!1: @_TC5norms6Button9onMouseUpfS0_FT_T_\n+    #Button.onClick: @_TC5norms6Button7onClickfS0_FT_T_\n+    #Button.onMouseDown: @_TC5norms6Button11onMouseDownfS0_FT_T_\n+    #Button.onMouseUp: @_TC5norms6Button9onMouseUpfS0_FT_T_\n   }\n \n SIL Stage\n@@ -239,8 +239,6 @@ For example, the lowered type of a declaration reference:\n \n - will usually be thin,\n \n-- will frequently be uncurried,\n-\n - may have a non-Swift calling convention,\n \n - may use bridged types in its interface, and\n@@ -1090,9 +1088,9 @@ Declaration References\n ::\n \n   sil-decl-ref ::= '#' sil-identifier ('.' sil-identifier)* sil-decl-subref?\n-  sil-decl-subref ::= '!' sil-decl-subref-part ('.' sil-decl-uncurry-level)? ('.' sil-decl-lang)?\n-  sil-decl-subref ::= '!' sil-decl-uncurry-level ('.' sil-decl-lang)?\n+  sil-decl-subref ::= '!' sil-decl-subref-part ('.' sil-decl-lang)? ('.' sil-decl-autodiff)?\n   sil-decl-subref ::= '!' sil-decl-lang\n+  sil-decl-subref ::= '!' sil-decl-autodiff\n   sil-decl-subref-part ::= 'getter'\n   sil-decl-subref-part ::= 'setter'\n   sil-decl-subref-part ::= 'allocator'\n@@ -1104,8 +1102,11 @@ Declaration References\n   sil-decl-subref-part ::= 'ivardestroyer'\n   sil-decl-subref-part ::= 'ivarinitializer'\n   sil-decl-subref-part ::= 'defaultarg' '.' [0-9]+\n-  sil-decl-uncurry-level ::= [0-9]+\n   sil-decl-lang ::= 'foreign'\n+  sil-decl-autodiff ::= sil-decl-autodiff-kind '.' sil-decl-autodiff-indices\n+  sil-decl-autodiff-kind ::= 'jvp'\n+  sil-decl-autodiff-kind ::= 'vjp'\n+  sil-decl-autodiff-indices ::= [SU]+\n \n Some SIL instructions need to reference Swift declarations directly. These\n references are introduced with the ``#`` sigil followed by the fully qualified\n@@ -1128,35 +1129,6 @@ entity discriminators:\n   the *n*\\ -th argument of a Swift ``func``\n - ``foreign``: a specific entry point for C/Objective-C interoperability\n \n-Methods and curried function definitions in Swift also have multiple\n-\"uncurry levels\" in SIL, representing the function at each possible\n-partial application level. For a curried function declaration::\n-\n-  // Module example\n-  func foo(_ x:A)(y:B)(z:C) -> D\n-\n-The declaration references and types for the different uncurry levels are as\n-follows::\n-\n-  #example.foo!0 : $@convention(thin) (x:A) -> (y:B) -> (z:C) -> D\n-  #example.foo!1 : $@convention(thin) ((y:B), (x:A)) -> (z:C) -> D\n-  #example.foo!2 : $@convention(thin) ((z:C), (y:B), (x:A)) -> D\n-\n-The deepest uncurry level is referred to as the **natural uncurry level**. In\n-this specific example, the reference at the natural uncurry level is\n-``#example.foo!2``.  Note that the uncurried argument clauses are composed\n-right-to-left, as specified in the `calling convention`_. For uncurry levels\n-less than the uncurry level, the entry point itself is ``@convention(thin)`` but\n-returns a thick function value carrying the partially applied arguments for its\n-context.\n-\n-`Dynamic dispatch`_ instructions such as ``class method`` require their method\n-declaration reference to be uncurried to at least uncurry level 1 (which applies\n-both the \"self\" argument and the method arguments), because uncurry level zero\n-represents the application of the method to its \"self\" argument, as in\n-``foo.method``, which is where the dynamic dispatch semantically occurs\n-in Swift.\n-\n Linkage\n ~~~~~~~\n ::\n@@ -1309,9 +1281,9 @@ class::\n   sil @A_bas : $@convention(thin) (@owned A) -> ()\n \n   sil_vtable A {\n-    #A.foo!1: @A_foo\n-    #A.bar!1: @A_bar\n-    #A.bas!1: @A_bas\n+    #A.foo: @A_foo\n+    #A.bar: @A_bar\n+    #A.bas: @A_bas\n   }\n \n   class B : A {\n@@ -1321,9 +1293,9 @@ class::\n   sil @B_bar : $@convention(thin) (@owned B) -> ()\n \n   sil_vtable B {\n-    #A.foo!1: @A_foo\n-    #A.bar!1: @B_bar\n-    #A.bas!1: @A_bas\n+    #A.foo: @A_foo\n+    #A.bar: @B_bar\n+    #A.bas: @A_bas\n   }\n \n   class C : B {\n@@ -1333,9 +1305,9 @@ class::\n   sil @C_bas : $@convention(thin) (@owned C) -> ()\n \n   sil_vtable C {\n-    #A.foo!1: @A_foo\n-    #A.bar!1: @B_bar\n-    #A.bas!1: @C_bas\n+    #A.foo: @A_foo\n+    #A.bar: @B_bar\n+    #A.bas: @C_bas\n   }\n \n Note that the declaration reference in the vtable is to the least-derived method\n@@ -1781,23 +1753,6 @@ gets called in SIL as::\n   %ws = <<make array from %w0, %w1, %w2>>\n   apply %zang(%x, %y, %zs, %v, %ws)  : $(x:Int, (y:Int, z:Int...), v:Int, w:Int...) -> ()\n \n-Function Currying\n-`````````````````\n-\n-Curried function definitions in Swift emit multiple SIL entry points, one for\n-each \"uncurry level\" of the function. When a function is uncurried, its\n-outermost argument clauses are combined into a tuple in right-to-left order.\n-For the following declaration::\n-\n-  func curried(_ x:A)(y:B)(z:C)(w:D) -> Int {}\n-\n-The types of the SIL entry points are as follows::\n-\n-  sil @curried_0 : $(x:A) -> (y:B) -> (z:C) -> (w:D) -> Int { ... }\n-  sil @curried_1 : $((y:B), (x:A)) -> (z:C) -> (w:D) -> Int { ... }\n-  sil @curried_2 : $((z:C), (y:B), (x:A)) -> (w:D) -> Int { ... }\n-  sil @curried_3 : $((w:D), (z:C), (y:B), (x:A)) -> Int { ... }\n-\n @inout Arguments\n ````````````````\n \n@@ -1831,8 +1786,7 @@ Swift Method Calling Convention @convention(method)\n The method calling convention is currently identical to the freestanding\n function convention. Methods are considered to be curried functions, taking\n the \"self\" argument as their outer argument clause, and the method arguments\n-as the inner argument clause(s). When uncurried, the \"self\" argument is thus\n-passed last::\n+as the inner argument clause(s). The \"self\" argument is thus passed last::\n \n   struct Foo {\n     func method(_ x:Int) -> Int {}\n@@ -2035,7 +1989,7 @@ independently assured of validity.  For example, a class method may\n return a class reference::\n \n   bb0(%0 : $MyClass):\n-    %1 = class_method %0 : $MyClass, #MyClass.foo!1\n+    %1 = class_method %0 : $MyClass, #MyClass.foo\n     %2 = apply %1(%0) : $@convention(method) (@guaranteed MyClass) -> @owned MyOtherClass\n     // use of %2 goes here; no use of %1\n     strong_release %2 : $MyOtherClass\n@@ -3469,7 +3423,7 @@ Swift native methods and always use vtable dispatch.\n \n The ``objc_method`` and ``objc_super_method`` instructions must reference\n Objective-C methods (indicated by the ``foreign`` marker on a method\n-reference, as in ``#NSObject.description!1.foreign``).\n+reference, as in ``#NSObject.description!foreign``).\n \n Note that ``objc_msgSend`` invocations can only be used as the callee\n of an ``apply`` instruction or ``partial_apply`` instruction. They cannot\n@@ -3482,10 +3436,10 @@ class_method\n   sil-instruction ::= 'class_method' sil-method-attributes?\n                         sil-operand ',' sil-decl-ref ':' sil-type\n \n-  %1 = class_method %0 : $T, #T.method!1 : $@convention(class_method) U -> V\n+  %1 = class_method %0 : $T, #T.method : $@convention(class_method) U -> V\n   // %0 must be of a class type or class metatype $T\n-  // #T.method!1 must be a reference to a Swift native method of T or\n-  // of one of its superclasses, at uncurry level == 1\n+  // #T.method must be a reference to a Swift native method of T or\n+  // of one of its superclasses\n   // %1 will be of type $U -> V\n \n Looks up a method based on the dynamic type of a class or class metatype\n@@ -3504,10 +3458,10 @@ objc_method\n   sil-instruction ::= 'objc_method' sil-method-attributes?\n                         sil-operand ',' sil-decl-ref ':' sil-type\n \n-  %1 = objc_method %0 : $T, #T.method!1.foreign : $@convention(objc_method) U -> V\n+  %1 = objc_method %0 : $T, #T.method!foreign : $@convention(objc_method) U -> V\n   // %0 must be of a class type or class metatype $T\n-  // #T.method!1 must be a reference to an Objective-C method of T or\n-  // of one of its superclasses, at uncurry level == 1\n+  // #T.method must be a reference to an Objective-C method of T or\n+  // of one of its superclasses\n   // %1 will be of type $U -> V\n \n Performs Objective-C method dispatch using ``objc_msgSend()``.\n@@ -3521,10 +3475,10 @@ super_method\n   sil-instruction ::= 'super_method' sil-method-attributes?\n                         sil-operand ',' sil-decl-ref ':' sil-type\n \n-  %1 = super_method %0 : $T, #Super.method!1 : $@convention(thin) U -> V\n+  %1 = super_method %0 : $T, #Super.method : $@convention(thin) U -> V\n   // %0 must be of a non-root class type or class metatype $T\n-  // #Super.method!1 must be a reference to a native Swift method of T's\n-  // superclass or of one of its ancestor classes, at uncurry level >= 1\n+  // #Super.method must be a reference to a native Swift method of T's\n+  // superclass or of one of its ancestor classes\n   // %1 will be of type $@convention(thin) U -> V\n \n Looks up a method in the superclass of a class or class metatype instance.\n@@ -3536,10 +3490,10 @@ objc_super_method\n   sil-instruction ::= 'super_method' sil-method-attributes?\n                         sil-operand ',' sil-decl-ref ':' sil-type\n \n-  %1 = super_method %0 : $T, #Super.method!1.foreign : $@convention(thin) U -> V\n+  %1 = super_method %0 : $T, #Super.method!foreign : $@convention(thin) U -> V\n   // %0 must be of a non-root class type or class metatype $T\n-  // #Super.method!1.foreign must be a reference to an ObjC method of T's\n-  // superclass or of one of its ancestor classes, at uncurry level >= 1\n+  // #Super.method!foreign must be a reference to an ObjC method of T's\n+  // superclass or of one of its ancestor classes\n   // %1 will be of type $@convention(thin) U -> V\n \n This instruction performs an Objective-C message send using\n@@ -3552,10 +3506,10 @@ witness_method\n   sil-instruction ::= 'witness_method' sil-method-attributes?\n                         sil-type ',' sil-decl-ref ':' sil-type\n \n-  %1 = witness_method $T, #Proto.method!1 \\\n+  %1 = witness_method $T, #Proto.method \\\n     : $@convention(witness_method) <Self: Proto> U -> V\n   // $T must be an archetype\n-  // #Proto.method!1 must be a reference to a method of one of the protocol\n+  // #Proto.method must be a reference to a method of one of the protocol\n   //   constraints on T\n   // <Self: Proto> U -> V must be the type of the referenced method,\n   //   generic on Self\n@@ -3741,41 +3695,7 @@ partial_apply\n   // %r will be of the substituted thick function type $(Z'...) -> R'\n \n Creates a closure by partially applying the function ``%0`` to a partial\n-sequence of its arguments. This instruction is used to implement both curry\n-thunks and closures. A curried function in Swift::\n-\n-  func foo(_ a:A)(b:B)(c:C)(d:D) -> E { /* body of foo */ }\n-\n-emits curry thunks in SIL as follows (retains and releases omitted for\n-clarity)::\n-\n-  func @foo : $@convention(thin) A -> B -> C -> D -> E {\n-  entry(%a : $A):\n-    %foo_1 = function_ref @foo_1 : $@convention(thin) (B, A) -> C -> D -> E\n-    %thunk = partial_apply %foo_1(%a) : $@convention(thin) (B, A) -> C -> D -> E\n-    return %thunk : $B -> C -> D -> E\n-  }\n-\n-  func @foo_1 : $@convention(thin) (B, A) -> C -> D -> E {\n-  entry(%b : $B, %a : $A):\n-    %foo_2 = function_ref @foo_2 : $@convention(thin) (C, B, A) -> D -> E\n-    %thunk = partial_apply %foo_2(%b, %a) \\\n-      : $@convention(thin) (C, B, A) -> D -> E\n-    return %thunk : $(B, A) -> C -> D -> E\n-  }\n-\n-  func @foo_2 : $@convention(thin) (C, B, A) -> D -> E {\n-  entry(%c : $C, %b : $B, %a : $A):\n-    %foo_3 = function_ref @foo_3 : $@convention(thin) (D, C, B, A) -> E\n-    %thunk = partial_apply %foo_3(%c, %b, %a) \\\n-      : $@convention(thin) (D, C, B, A) -> E\n-    return %thunk : $(C, B, A) -> D -> E\n-  }\n-\n-  func @foo_3 : $@convention(thin) (D, C, B, A) -> E {\n-  entry(%d : $D, %c : $C, %b : $B, %a : $A):\n-    // ... body of foo ...\n-  }\n+sequence of its arguments. This instruction is used to implement closures.\n \n A local function in Swift that captures context, such as ``bar`` in the\n following example::\n@@ -4298,10 +4218,10 @@ an `inject_enum_addr`_ instruction::\n   sil @init_with_data : $(AddressOnlyType) -> AddressOnlyEnum {\n   entry(%0 : $*AddressOnlyEnum, %1 : $*AddressOnlyType):\n     // Store the data argument for the case.\n-    %2 = init_enum_data_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData!enumelt.1\n+    %2 = init_enum_data_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData!enumelt\n     copy_addr [take] %2 to [initialization] %1 : $*AddressOnlyType\n     // Inject the tag.\n-    inject_enum_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData!enumelt.1\n+    inject_enum_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData!enumelt\n     return\n   }\n \n@@ -4318,7 +4238,7 @@ discriminator and is done with the `switch_enum`_ terminator::\n \n   sil @switch_foo : $(Foo) -> () {\n   entry(%foo : $Foo):\n-    switch_enum %foo : $Foo, case #Foo.A!enumelt.1: a_dest, case #Foo.B!enumelt.1: b_dest\n+    switch_enum %foo : $Foo, case #Foo.A!enumelt: a_dest, case #Foo.B!enumelt: b_dest\n \n   a_dest(%a : $Int):\n     /* use %a */\n@@ -4335,15 +4255,15 @@ projecting the enum value with `unchecked_take_enum_data_addr`_::\n \n   sil @switch_foo : $<T> (Foo<T>) -> () {\n   entry(%foo : $*Foo<T>):\n-    switch_enum_addr %foo : $*Foo<T>, case #Foo.A!enumelt.1: a_dest, \\\n-      case #Foo.B!enumelt.1: b_dest\n+    switch_enum_addr %foo : $*Foo<T>, case #Foo.A!enumelt: a_dest, \\\n+      case #Foo.B!enumelt: b_dest\n \n   a_dest:\n-    %a = unchecked_take_enum_data_addr %foo : $*Foo<T>, #Foo.A!enumelt.1\n+    %a = unchecked_take_enum_data_addr %foo : $*Foo<T>, #Foo.A!enumelt\n     /* use %a */\n \n   b_dest:\n-    %b = unchecked_take_enum_data_addr %foo : $*Foo<T>, #Foo.B!enumelt.1\n+    %b = unchecked_take_enum_data_addr %foo : $*Foo<T>, #Foo.B!enumelt\n     /* use %b */\n   }\n \n@@ -4369,7 +4289,7 @@ enum\n   sil-instruction ::= 'enum' sil-type ',' sil-decl-ref (',' sil-operand)?\n \n   %1 = enum $U, #U.EmptyCase!enumelt\n-  %1 = enum $U, #U.DataCase!enumelt.1, %0 : $T\n+  %1 = enum $U, #U.DataCase!enumelt, %0 : $T\n   // $U must be an enum type\n   // #U.DataCase or #U.EmptyCase must be a case of enum $U\n   // If #U.Case has a data type $T, %0 must be a value of type $T\n@@ -4385,7 +4305,7 @@ unchecked_enum_data\n \n   sil-instruction ::= 'unchecked_enum_data' sil-operand ',' sil-decl-ref\n \n-  %1 = unchecked_enum_data %0 : $U, #U.DataCase!enumelt.1\n+  %1 = unchecked_enum_data %0 : $U, #U.DataCase!enumelt\n   // $U must be an enum type\n   // #U.DataCase must be a case of enum $U with data\n   // %1 will be of object type $T for the data type of case U.DataCase\n@@ -4400,7 +4320,7 @@ init_enum_data_addr\n \n   sil-instruction ::= 'init_enum_data_addr' sil-operand ',' sil-decl-ref\n \n-  %1 = init_enum_data_addr %0 : $*U, #U.DataCase!enumelt.1\n+  %1 = init_enum_data_addr %0 : $*U, #U.DataCase!enumelt\n   // $U must be an enum type\n   // #U.DataCase must be a case of enum $U with data\n   // %1 will be of address type $*T for the data type of case U.DataCase\n@@ -4442,7 +4362,7 @@ unchecked_take_enum_data_addr\n \n   sil-instruction ::= 'unchecked_take_enum_data_addr' sil-operand ',' sil-decl-ref\n \n-  %1 = unchecked_take_enum_data_addr %0 : $*U, #U.DataCase!enumelt.1\n+  %1 = unchecked_take_enum_data_addr %0 : $*U, #U.DataCase!enumelt\n   // $U must be an enum type\n   // #U.DataCase must be a case of enum $U with data\n   // %1 will be of address type $*T for the data type of case U.DataCase\n@@ -4810,7 +4730,6 @@ alloc_existential_box\n   //   representation\n   // $T must be an AST type that conforms to P\n   // %1 will be of type $P\n-  // %1#1 will be of type $*T', where T' is the most abstracted lowering of T\n \n Allocates a boxed existential container of type ``$P`` with space to hold a\n value of type ``$T'``. The box is not fully initialized until a valid value\n@@ -5671,8 +5590,8 @@ the original enum value. For example::\n   entry(%x : $Foo):\n     switch_enum %x : $Foo,       \\\n       case #Foo.Nothing!enumelt: nothing, \\\n-      case #Foo.OneInt!enumelt.1:  one_int, \\\n-      case #Foo.TwoInts!enumelt.1: two_ints\n+      case #Foo.OneInt!enumelt:  one_int, \\\n+      case #Foo.TwoInts!enumelt: two_ints\n \n   nothing:\n     %zero = integer_literal $Int, 0\n@@ -5740,9 +5659,9 @@ dynamic_method_br\n   sil-terminator ::= 'dynamic_method_br' sil-operand ',' sil-decl-ref\n                        ',' sil-identifier ',' sil-identifier\n \n-  dynamic_method_br %0 : $P, #X.method!1, bb1, bb2\n+  dynamic_method_br %0 : $P, #X.method, bb1, bb2\n   // %0 must be of protocol type\n-  // #X.method!1 must be a reference to an @objc method of any class\n+  // #X.method must be a reference to an @objc method of any class\n   // or protocol type\n \n Looks up the implementation of an Objective-C method with the same\n@@ -5855,6 +5774,117 @@ The rules on generic substitutions are identical to those of ``apply``.\n Differentiable Programming\n ~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n+differentiable_function\n+```````````````````````\n+::\n+\n+  sil-instruction ::= 'differentiable_function'\n+                      sil-differentiable-function-parameter-indices\n+                      sil-value ':' sil-type\n+                      sil-differentiable-function-derivative-functions-clause?\n+\n+  sil-differentiable-function-parameter-indices ::=\n+      '[' 'parameters' [0-9]+ (' ' [0-9]+)* ']'\n+  sil-differentiable-derivative-functions-clause ::=\n+      'with_derivative'\n+      '{' sil-value ':' sil-type ',' sil-value ':' sil-type '}'\n+\n+  differentiable_function [parameters 0] %0 : $(T) -> T \\\n+    with_derivative {%1 : $(T) -> (T, (T) -> T), %2 : $(T) -> (T, (T) -> T)}\n+\n+Creates a ``@differentiable`` function from an original function operand and\n+derivative function operands (optional). There are two derivative function\n+kinds: a Jacobian-vector products (JVP) function and a vector-Jacobian products\n+(VJP) function.\n+\n+``[parameters ...]`` specifies parameter indices that the original function is\n+differentiable with respect to.\n+\n+The ``with_derivative`` clause specifies the derivative function operands\n+associated with the original function.\n+\n+The differentiation transformation canonicalizes all `differentiable_function`\n+instructions, generating derivative functions if necessary to fill in derivative\n+function operands.\n+\n+In raw SIL, the ``with_derivative`` clause is optional. In canonical SIL, the\n+``with_derivative`` clause is mandatory.\n+\n+\n+linear_function\n+```````````````\n+::\n+\n+  sil-instruction ::= 'linear_function'\n+                      sil-linear-function-parameter-indices\n+                      sil-value ':' sil-type\n+                      sil-linear-function-transpose-function-clause?\n+\n+  sil-linear-function-parameter-indices ::=\n+      '[' 'parameters' [0-9]+ (' ' [0-9]+)* ']'\n+  sil-linear-transpose-function-clause ::=\n+      with_transpose sil-value ':' sil-type\n+\n+  linear_function [parameters 0] %0 : $(T) -> T with_transpose %1 : $(T) -> T\n+\n+Bundles a function with its transpose function into a\n+``@differentiable(linear)`` function.\n+\n+``[parameters ...]`` specifies parameter indices that the original function is\n+linear with respect to.\n+\n+A ``with_transpose`` clause specifies the transpose function associated\n+with the original function. When a ``with_transpose`` clause is not specified,\n+the mandatory differentiation transform  will add a ``with_transpose`` clause to\n+the instruction.\n+\n+In raw SIL, the ``with_transpose`` clause is optional. In canonical SIL,\n+the ``with_transpose`` clause is mandatory.\n+\n+\n+differentiable_function_extract\n+```````````````````````````````\n+::\n+\n+  sil-instruction ::= 'differentiable_function_extract'\n+                      '[' sil-differentiable-function-extractee ']'\n+                      sil-value ':' sil-type\n+                      ('as' sil-type)?\n+\n+  sil-differentiable-function-extractee ::= 'original' | 'jvp' | 'vjp'\n+\n+  differentiable_function_extract [original] %0 : $@differentiable (T) -> T\n+  differentiable_function_extract [jvp] %0 : $@differentiable (T) -> T\n+  differentiable_function_extract [vjp] %0 : $@differentiable (T) -> T\n+  differentiable_function_extract [jvp] %0 : $@differentiable (T) -> T \\\n+    as $(@in_constant T) -> (T, (T.TangentVector) -> T.TangentVector)\n+\n+Extracts the original function or a derivative function from the given\n+``@differentiable`` function. The extractee is one of the following:\n+``[original]``, ``[jvp]``, or ``[vjp]``.\n+\n+In lowered SIL, an explicit extractee type may be provided. This is currently\n+used by the LoadableByAddress transformation, which rewrites function types.\n+\n+\n+linear_function_extract\n+```````````````````````\n+::\n+\n+  sil-instruction ::= 'linear_function_extract'\n+                      '[' sil-linear-function-extractee ']'\n+                      sil-value ':' sil-type\n+\n+  sil-linear-function-extractee ::= 'original' | 'transpose'\n+\n+  linear_function_extract [original] %0 : $@differentiable(linear) (T) -> T\n+  linear_function_extract [transpose] %0 : $@differentiable(linear) (T) -> T\n+\n+Extracts the original function or a transpose function from the given\n+``@differentiable(linear)`` function. The extractee is one of the following:\n+``[original]`` or ``[transpose]``.\n+\n+\n differentiability_witness_function\n ``````````````````````````````````\n ::"
                    },
                    {
                        "filename": "include/swift/ABI/Metadata.h",
                        "code": "@@ -2433,10 +2433,6 @@ struct TargetProtocolConformanceDescriptor final\n   using OverloadToken = typename TrailingObjects::template OverloadToken<T>;\n \n public:\n-  using WitnessTableAccessorFn\n-    = const TargetWitnessTable<Runtime> *(const TargetMetadata<Runtime>*,\n-                                          const TargetWitnessTable<Runtime> **);\n-\n   using GenericRequirementDescriptor =\n     TargetGenericRequirementDescriptor<Runtime>;\n "
                    },
                    {
                        "filename": "include/swift/ABI/MetadataValues.h",
                        "code": "@@ -764,6 +764,14 @@ enum class FunctionMetadataConvention: uint8_t {\n   CFunctionPointer = 3,\n };\n \n+/// Differentiability kind for function type metadata.\n+/// Duplicates `DifferentiabilityKind` in AutoDiff.h.\n+enum class FunctionMetadataDifferentiabilityKind: uint8_t {\n+  NonDifferentiable = 0b00,\n+  Normal = 0b01,\n+  Linear = 0b11\n+};\n+\n /// Flags in a function type metadata record.\n template <typename int_type>\n class TargetFunctionTypeFlags {\n@@ -777,6 +785,8 @@ class TargetFunctionTypeFlags {\n     ThrowsMask        = 0x01000000U,\n     ParamFlagsMask    = 0x02000000U,\n     EscapingMask      = 0x04000000U,\n+    DifferentiableMask  = 0x08000000U,\n+    LinearMask          = 0x10000000U\n   };\n   int_type Data;\n   \n@@ -801,6 +811,16 @@ class TargetFunctionTypeFlags {\n                                              (throws ? ThrowsMask : 0));\n   }\n \n+  constexpr TargetFunctionTypeFlags<int_type> withDifferentiabilityKind(\n+      FunctionMetadataDifferentiabilityKind differentiability) const {\n+    return TargetFunctionTypeFlags<int_type>(\n+        (Data & ~DifferentiableMask & ~LinearMask) |\n+        (differentiability == FunctionMetadataDifferentiabilityKind::Normal\n+             ? DifferentiableMask : 0) |\n+        (differentiability == FunctionMetadataDifferentiabilityKind::Linear\n+             ? LinearMask : 0));\n+  }\n+\n   constexpr TargetFunctionTypeFlags<int_type>\n   withParameterFlags(bool hasFlags) const {\n     return TargetFunctionTypeFlags<int_type>((Data & ~ParamFlagsMask) |\n@@ -829,6 +849,19 @@ class TargetFunctionTypeFlags {\n \n   bool hasParameterFlags() const { return bool(Data & ParamFlagsMask); }\n \n+  bool isDifferentiable() const {\n+    return getDifferentiabilityKind() >=\n+        FunctionMetadataDifferentiabilityKind::Normal;\n+  }\n+\n+  FunctionMetadataDifferentiabilityKind getDifferentiabilityKind() const {\n+    if (bool(Data & DifferentiableMask))\n+      return FunctionMetadataDifferentiabilityKind::Normal;\n+    if (bool(Data & LinearMask))\n+      return FunctionMetadataDifferentiabilityKind::Linear;\n+    return FunctionMetadataDifferentiabilityKind::NonDifferentiable;\n+  }\n+\n   int_type getIntValue() const {\n     return Data;\n   }\n@@ -849,9 +882,10 @@ using FunctionTypeFlags = TargetFunctionTypeFlags<size_t>;\n template <typename int_type>\n class TargetParameterTypeFlags {\n   enum : int_type {\n-    ValueOwnershipMask = 0x7F,\n-    VariadicMask       = 0x80,\n-    AutoClosureMask    = 0x100,\n+    ValueOwnershipMask    = 0x7F,\n+    VariadicMask          = 0x80,\n+    AutoClosureMask       = 0x100,\n+    NoDerivativeMask      = 0x200\n   };\n   int_type Data;\n \n@@ -881,6 +915,7 @@ class TargetParameterTypeFlags {\n   bool isNone() const { return Data == 0; }\n   bool isVariadic() const { return Data & VariadicMask; }\n   bool isAutoClosure() const { return Data & AutoClosureMask; }\n+  bool isNoDerivative() const { return Data & NoDerivativeMask; }\n \n   ValueOwnership getValueOwnership() const {\n     return (ValueOwnership)(Data & ValueOwnershipMask);"
                    },
                    {
                        "filename": "include/swift/AST/ASTContext.h",
                        "code": "@@ -332,32 +332,6 @@ class ASTContext final {\n   llvm::BumpPtrAllocator &\n   getAllocator(AllocationArena arena = AllocationArena::Permanent) const;\n \n-private:\n-  bool SemanticQueriesEnabled = false;\n-\n-public:\n-  /// Returns \\c true if legacy semantic AST queries are enabled.\n-  ///\n-  /// The request evaluator generally subsumes the use of this bit. However,\n-  /// there are clients - mostly SourceKit - that rely on the fact that this bit\n-  /// being \\c false causes some property wrapper requests to return null\n-  /// sentinel values. These clients should be migrated off of this interface\n-  /// to syntactic requests as soon as possible.\n-  ///\n-  /// rdar://60516325\n-  bool areLegacySemanticQueriesEnabled() const {\n-    return SemanticQueriesEnabled;\n-  }\n-\n-  /// Enable \"semantic queries\".\n-  ///\n-  /// Setting this bit tells property wrapper requests to return a semantic\n-  /// value.  It does not otherwise affect compiler behavior and should be\n-  /// removed as soon as possible.\n-  void setLegacySemanticQueriesEnabled() {\n-    SemanticQueriesEnabled = true;\n-  }\n-\n public:\n   /// Allocate - Allocate memory from the ASTContext bump pointer.\n   void *Allocate(unsigned long bytes, unsigned alignment,\n@@ -767,6 +741,19 @@ class ASTContext final {\n                        unsigned previousGeneration,\n                        llvm::TinyPtrVector<AbstractFunctionDecl *> &methods);\n \n+  /// Load derivative function configurations for the given\n+  /// AbstractFunctionDecl.\n+  ///\n+  /// \\param originalAFD The declaration whose derivative function\n+  /// configurations should be loaded.\n+  ///\n+  /// \\param previousGeneration The previous generation number. The AST already\n+  /// contains derivative function configurations loaded from any generation up\n+  /// to and including this one.\n+  void loadDerivativeFunctionConfigurations(\n+      AbstractFunctionDecl *originalAFD, unsigned previousGeneration,\n+      llvm::SetVector<AutoDiffConfig> &results);\n+\n   /// Retrieve the Clang module loader for this ASTContext.\n   ///\n   /// If there is no Clang module loader, returns a null pointer."
                    },
                    {
                        "filename": "include/swift/AST/ASTMangler.h",
                        "code": "@@ -80,7 +80,6 @@ class ASTMangler : public Mangler {\n     DynamicThunk,\n     SwiftAsObjCThunk,\n     ObjCAsSwiftThunk,\n-    DirectMethodReferenceThunk,\n   };\n \n   ASTMangler(bool DWARFMangling = false)\n@@ -98,14 +97,14 @@ class ASTMangler : public Mangler {\n   std::string mangleClosureEntity(const AbstractClosureExpr *closure,\n                                   SymbolKind SKind);\n \n-  std::string mangleEntity(const ValueDecl *decl, bool isCurried,\n+  std::string mangleEntity(const ValueDecl *decl,\n                            SymbolKind SKind = SymbolKind::Default);\n \n   std::string mangleDestructorEntity(const DestructorDecl *decl,\n                                      bool isDeallocating, SymbolKind SKind);\n \n   std::string mangleConstructorEntity(const ConstructorDecl *ctor,\n-                                      bool isAllocating, bool isCurried,\n+                                      bool isAllocating,\n                                       SymbolKind SKind = SymbolKind::Default);\n \n   std::string mangleIVarInitDestroyEntity(const ClassDecl *decl,\n@@ -154,6 +153,25 @@ class ASTMangler : public Mangler {\n                                              Type SelfType,\n                                              ModuleDecl *Module);\n \n+  /// Mangle the derivative function (JVP/VJP) for the given:\n+  /// - Mangled original function name.\n+  /// - Derivative function kind.\n+  /// - Derivative function configuration: parameter/result indices and\n+  ///   derivative generic signature.\n+  std::string\n+  mangleAutoDiffDerivativeFunctionHelper(StringRef name,\n+                                         AutoDiffDerivativeFunctionKind kind,\n+                                         AutoDiffConfig config);\n+\n+  /// Mangle the linear map (differential/pullback) for the given:\n+  /// - Mangled original function name.\n+  /// - Linear map kind.\n+  /// - Derivative function configuration: parameter/result indices and\n+  ///   derivative generic signature.\n+  std::string mangleAutoDiffLinearMapHelper(StringRef name,\n+                                            AutoDiffLinearMapKind kind,\n+                                            AutoDiffConfig config);\n+\n   /// Mangle a SIL differentiability witness key:\n   /// - Mangled original function name.\n   /// - Parameter indices.\n@@ -352,6 +370,9 @@ class ASTMangler : public Mangler {\n \n   void appendProtocolConformance(const ProtocolConformance *conformance);\n   void appendProtocolConformanceRef(const RootProtocolConformance *conformance);\n+  void appendAnyProtocolConformance(CanGenericSignature genericSig,\n+                                    CanType conformingType,\n+                                    ProtocolConformanceRef conformance);\n   void appendConcreteProtocolConformance(\n                                         const ProtocolConformance *conformance);\n   void appendDependentProtocolConformance(const ConformanceAccessPath &path);"
                    },
                    {
                        "filename": "include/swift/AST/ASTTypeIDZone.def",
                        "code": "@@ -30,6 +30,8 @@ SWIFT_TYPEID(TypePair)\n SWIFT_TYPEID(TypeWitnessAndDecl)\n SWIFT_TYPEID(Witness)\n SWIFT_TYPEID_NAMED(ClosureExpr *, ClosureExpr)\n+SWIFT_TYPEID_NAMED(CodeCompletionCallbacksFactory *,\n+                   CodeCompletionCallbacksFactory)\n SWIFT_TYPEID_NAMED(ConstructorDecl *, ConstructorDecl)\n SWIFT_TYPEID_NAMED(CustomAttr *, CustomAttr)\n SWIFT_TYPEID_NAMED(Decl *, Decl)\n@@ -47,7 +49,9 @@ SWIFT_TYPEID_NAMED(Optional<PropertyWrapperMutability>,\n                    PropertyWrapperMutability)\n SWIFT_TYPEID_NAMED(ParamDecl *, ParamDecl)\n SWIFT_TYPEID_NAMED(PatternBindingEntry *, PatternBindingEntry)\n+SWIFT_TYPEID_NAMED(PostfixOperatorDecl *, PostfixOperatorDecl)\n SWIFT_TYPEID_NAMED(PrecedenceGroupDecl *, PrecedenceGroupDecl)\n+SWIFT_TYPEID_NAMED(PrefixOperatorDecl *, PrefixOperatorDecl)\n SWIFT_TYPEID_NAMED(ProtocolDecl *, ProtocolDecl)\n SWIFT_TYPEID_NAMED(SourceFile *, SourceFile)\n SWIFT_TYPEID_NAMED(TypeAliasDecl *, TypeAliasDecl)"
                    },
                    {
                        "filename": "include/swift/AST/ASTTypeIDs.h",
                        "code": "@@ -24,6 +24,7 @@ namespace swift {\n class AbstractFunctionDecl;\n class BraceStmt;\n class ClosureExpr;\n+class CodeCompletionCallbacksFactory;\n class ConstructorDecl;\n class CustomAttr;\n class Decl;\n@@ -42,7 +43,9 @@ class OpaqueTypeDecl;\n class PatternBindingEntry;\n class ParamDecl;\n enum class ParamSpecifier : uint8_t;\n+class PostfixOperatorDecl;\n class PrecedenceGroupDecl;\n+class PrefixOperatorDecl;\n struct PropertyWrapperBackingPropertyInfo;\n struct PropertyWrapperTypeInfo;\n enum class CtorInitializerKind;"
                    },
                    {
                        "filename": "include/swift/AST/AccessRequests.h",
                        "code": "@@ -33,16 +33,15 @@ class ValueDecl;\n class AccessLevelRequest :\n     public SimpleRequest<AccessLevelRequest,\n                          AccessLevel(ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<AccessLevel> evaluate(Evaluator &evaluator,\n-                                       ValueDecl *decl) const;\n+  AccessLevel evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -57,16 +56,15 @@ class AccessLevelRequest :\n class SetterAccessLevelRequest :\n     public SimpleRequest<SetterAccessLevelRequest,\n                          AccessLevel(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<AccessLevel>\n-  evaluate(Evaluator &evaluator, AbstractStorageDecl *decl) const;\n+  AccessLevel evaluate(Evaluator &evaluator, AbstractStorageDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -81,15 +79,14 @@ using DefaultAndMax = std::pair<AccessLevel, AccessLevel>;\n class DefaultAndMaxAccessLevelRequest :\n     public SimpleRequest<DefaultAndMaxAccessLevelRequest,\n                          DefaultAndMax(ExtensionDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<DefaultAndMax>\n-  evaluate(Evaluator &evaluator, ExtensionDecl *decl) const;\n+  DefaultAndMax evaluate(Evaluator &evaluator, ExtensionDecl *decl) const;\n \n public:\n   // Separate caching."
                    },
                    {
                        "filename": "include/swift/AST/Attr.def",
                        "code": "@@ -552,6 +552,11 @@ DECL_ATTR(transpose, Transpose,\n   ABIStableToAdd | ABIBreakingToRemove | APIStableToAdd | APIBreakingToRemove,\n   99)\n \n+SIMPLE_DECL_ATTR(noDerivative, NoDerivative,\n+  OnAbstractFunction | OnVar | OnSubscript |\n+  ABIBreakingToAdd | ABIBreakingToRemove | APIBreakingToAdd | APIBreakingToRemove,\n+  100)\n+\n #undef TYPE_ATTR\n #undef DECL_ATTR_ALIAS\n #undef CONTEXTUAL_DECL_ATTR_ALIAS"
                    },
                    {
                        "filename": "include/swift/AST/Attr.h",
                        "code": "@@ -1675,12 +1675,11 @@ struct DeclNameRefWithLoc {\n   DeclNameLoc Loc;\n };\n \n-/// Attribute that marks a function as differentiable and optionally specifies\n-/// custom associated derivative functions: 'jvp' and 'vjp'.\n+/// Attribute that marks a function as differentiable.\n ///\n /// Examples:\n-///   @differentiable(jvp: jvpFoo where T : FloatingPoint)\n-///   @differentiable(wrt: (self, x, y), jvp: jvpFoo)\n+///   @differentiable(where T : FloatingPoint)\n+///   @differentiable(wrt: (self, x, y))\n class DifferentiableAttr final\n     : public DeclAttribute,\n       private llvm::TrailingObjects<DifferentiableAttr,\n@@ -1696,16 +1695,6 @@ class DifferentiableAttr final\n   bool Linear;\n   /// The number of parsed differentiability parameters specified in 'wrt:'.\n   unsigned NumParsedParameters = 0;\n-  /// The JVP function.\n-  Optional<DeclNameRefWithLoc> JVP;\n-  /// The VJP function.\n-  Optional<DeclNameRefWithLoc> VJP;\n-  /// The JVP function (optional), resolved by the type checker if JVP name is\n-  /// specified.\n-  FuncDecl *JVPFunction = nullptr;\n-  /// The VJP function (optional), resolved by the type checker if VJP name is\n-  /// specified.\n-  FuncDecl *VJPFunction = nullptr;\n   /// The differentiability parameter indices, resolved by the type checker.\n   /// The bit stores whether the parameter indices have been computed.\n   ///\n@@ -1720,36 +1709,35 @@ class DifferentiableAttr final\n   /// attribute's where clause requirements. This is set only if the attribute\n   /// has a where clause.\n   GenericSignature DerivativeGenericSignature;\n+  /// The source location of the implicitly inherited protocol requirement\n+  /// `@differentiable` attribute. Used for diagnostics, not serialized.\n+  ///\n+  /// This is set during conformance type-checking, only for implicit\n+  /// `@differentiable` attributes created for non-public protocol witnesses of\n+  /// protocol requirements with `@differentiable` attributes.\n+  SourceLoc ImplicitlyInheritedDifferentiableAttrLocation;\n \n   explicit DifferentiableAttr(bool implicit, SourceLoc atLoc,\n                               SourceRange baseRange, bool linear,\n                               ArrayRef<ParsedAutoDiffParameter> parameters,\n-                              Optional<DeclNameRefWithLoc> jvp,\n-                              Optional<DeclNameRefWithLoc> vjp,\n                               TrailingWhereClause *clause);\n \n   explicit DifferentiableAttr(Decl *original, bool implicit, SourceLoc atLoc,\n                               SourceRange baseRange, bool linear,\n                               IndexSubset *parameterIndices,\n-                              Optional<DeclNameRefWithLoc> jvp,\n-                              Optional<DeclNameRefWithLoc> vjp,\n                               GenericSignature derivativeGenericSignature);\n \n public:\n   static DifferentiableAttr *create(ASTContext &context, bool implicit,\n                                     SourceLoc atLoc, SourceRange baseRange,\n                                     bool linear,\n                                     ArrayRef<ParsedAutoDiffParameter> params,\n-                                    Optional<DeclNameRefWithLoc> jvp,\n-                                    Optional<DeclNameRefWithLoc> vjp,\n                                     TrailingWhereClause *clause);\n \n   static DifferentiableAttr *create(AbstractFunctionDecl *original,\n                                     bool implicit, SourceLoc atLoc,\n                                     SourceRange baseRange, bool linear,\n                                     IndexSubset *parameterIndices,\n-                                    Optional<DeclNameRefWithLoc> jvp,\n-                                    Optional<DeclNameRefWithLoc> vjp,\n                                     GenericSignature derivativeGenSig);\n \n   Decl *getOriginalDeclaration() const { return OriginalDeclaration; }\n@@ -1758,16 +1746,6 @@ class DifferentiableAttr final\n   /// Should only be used by parsing and deserialization.\n   void setOriginalDeclaration(Decl *originalDeclaration);\n \n-  /// Get the optional 'jvp:' function name and location.\n-  /// Use this instead of `getJVPFunction` to check whether the attribute has a\n-  /// registered JVP.\n-  Optional<DeclNameRefWithLoc> getJVP() const { return JVP; }\n-\n-  /// Get the optional 'vjp:' function name and location.\n-  /// Use this instead of `getVJPFunction` to check whether the attribute has a\n-  /// registered VJP.\n-  Optional<DeclNameRefWithLoc> getVJP() const { return VJP; }\n-\n private:\n   /// Returns true if the given `@differentiable` attribute has been\n   /// type-checked.\n@@ -1800,10 +1778,13 @@ class DifferentiableAttr final\n     DerivativeGenericSignature = derivativeGenSig;\n   }\n \n-  FuncDecl *getJVPFunction() const { return JVPFunction; }\n-  void setJVPFunction(FuncDecl *decl);\n-  FuncDecl *getVJPFunction() const { return VJPFunction; }\n-  void setVJPFunction(FuncDecl *decl);\n+  SourceLoc getImplicitlyInheritedDifferentiableAttrLocation() const {\n+    return ImplicitlyInheritedDifferentiableAttrLocation;\n+  }\n+  void getImplicitlyInheritedDifferentiableAttrLocation(SourceLoc loc) {\n+    assert(isImplicit());\n+    ImplicitlyInheritedDifferentiableAttrLocation = loc;\n+  }\n \n   /// Get the derivative generic environment for the given `@differentiable`\n   /// attribute and original function.\n@@ -1812,9 +1793,7 @@ class DifferentiableAttr final\n \n   // Print the attribute to the given stream.\n   // If `omitWrtClause` is true, omit printing the `wrt:` clause.\n-  // If `omitDerivativeFunctions` is true, omit printing derivative functions.\n-  void print(llvm::raw_ostream &OS, const Decl *D, bool omitWrtClause = false,\n-             bool omitDerivativeFunctions = false) const;\n+  void print(llvm::raw_ostream &OS, const Decl *D, bool omitWrtClause = false) const;\n \n   static bool classof(const DeclAttribute *DA) {\n     return DA->getKind() == DAK_Differentiable;"
                    },
                    {
                        "filename": "include/swift/AST/AutoDiff.h",
                        "code": "@@ -26,6 +26,7 @@\n #include \"swift/AST/TypeAlignments.h\"\n #include \"swift/Basic/Range.h\"\n #include \"swift/Basic/SourceLoc.h\"\n+#include \"llvm/ADT/StringExtras.h\"\n \n namespace swift {\n \n@@ -74,6 +75,74 @@ struct AutoDiffDerivativeFunctionKind {\n   }\n };\n \n+/// A component of a SIL `@differentiable` function-typed value.\n+struct NormalDifferentiableFunctionTypeComponent {\n+  enum innerty : unsigned { Original = 0, JVP = 1, VJP = 2 } rawValue;\n+\n+  NormalDifferentiableFunctionTypeComponent() = default;\n+  NormalDifferentiableFunctionTypeComponent(innerty rawValue)\n+      : rawValue(rawValue) {}\n+  NormalDifferentiableFunctionTypeComponent(\n+      AutoDiffDerivativeFunctionKind kind);\n+  explicit NormalDifferentiableFunctionTypeComponent(unsigned rawValue)\n+      : NormalDifferentiableFunctionTypeComponent((innerty)rawValue) {}\n+  explicit NormalDifferentiableFunctionTypeComponent(StringRef name);\n+  operator innerty() const { return rawValue; }\n+\n+  /// Returns the derivative function kind, if the component is a derivative\n+  /// function.\n+  Optional<AutoDiffDerivativeFunctionKind> getAsDerivativeFunctionKind() const;\n+};\n+\n+/// A component of a SIL `@differentiable(linear)` function-typed value.\n+struct LinearDifferentiableFunctionTypeComponent {\n+  enum innerty : unsigned {\n+    Original = 0,\n+    Transpose = 1,\n+  } rawValue;\n+\n+  LinearDifferentiableFunctionTypeComponent() = default;\n+  LinearDifferentiableFunctionTypeComponent(innerty rawValue)\n+      : rawValue(rawValue) {}\n+  explicit LinearDifferentiableFunctionTypeComponent(unsigned rawValue)\n+      : LinearDifferentiableFunctionTypeComponent((innerty)rawValue) {}\n+  explicit LinearDifferentiableFunctionTypeComponent(StringRef name);\n+  operator innerty() const { return rawValue; }\n+};\n+\n+/// A derivative function configuration, uniqued in `ASTContext`.\n+/// Identifies a specific derivative function given an original function.\n+class AutoDiffDerivativeFunctionIdentifier : public llvm::FoldingSetNode {\n+  const AutoDiffDerivativeFunctionKind kind;\n+  IndexSubset *const parameterIndices;\n+  GenericSignature derivativeGenericSignature;\n+\n+  AutoDiffDerivativeFunctionIdentifier(\n+      AutoDiffDerivativeFunctionKind kind, IndexSubset *parameterIndices,\n+      GenericSignature derivativeGenericSignature)\n+      : kind(kind), parameterIndices(parameterIndices),\n+        derivativeGenericSignature(derivativeGenericSignature) {}\n+\n+public:\n+  AutoDiffDerivativeFunctionKind getKind() const { return kind; }\n+  IndexSubset *getParameterIndices() const { return parameterIndices; }\n+  GenericSignature getDerivativeGenericSignature() const {\n+    return derivativeGenericSignature;\n+  }\n+\n+  static AutoDiffDerivativeFunctionIdentifier *\n+  get(AutoDiffDerivativeFunctionKind kind, IndexSubset *parameterIndices,\n+      GenericSignature derivativeGenericSignature, ASTContext &C);\n+\n+  void Profile(llvm::FoldingSetNodeID &ID) {\n+    ID.AddInteger(kind);\n+    ID.AddPointer(parameterIndices);\n+    auto derivativeCanGenSig =\n+        derivativeGenericSignature.getCanonicalSignature();\n+    ID.AddPointer(derivativeCanGenSig.getPointer());\n+  }\n+};\n+\n /// The kind of a differentiability witness function.\n struct DifferentiabilityWitnessFunctionKind {\n   enum innerty : uint8_t {\n@@ -95,6 +164,45 @@ struct DifferentiabilityWitnessFunctionKind {\n   Optional<AutoDiffDerivativeFunctionKind> getAsDerivativeFunctionKind() const;\n };\n \n+/// SIL-level automatic differentiation indices. Consists of:\n+/// - Parameter indices: indices of parameters to differentiate with respect to.\n+/// - Result index: index of the result to differentiate from.\n+// TODO(TF-913): Remove `SILAutoDiffIndices` in favor of `AutoDiffConfig`.\n+// `AutoDiffConfig` supports multiple result indices.\n+struct SILAutoDiffIndices {\n+  /// The index of the dependent result to differentiate from.\n+  unsigned source;\n+  /// The indices for independent parameters to differentiate with respect to.\n+  IndexSubset *parameters;\n+\n+  /*implicit*/ SILAutoDiffIndices(unsigned source, IndexSubset *parameters)\n+      : source(source), parameters(parameters) {}\n+\n+  bool operator==(const SILAutoDiffIndices &other) const;\n+\n+  bool operator!=(const SILAutoDiffIndices &other) const {\n+    return !(*this == other);\n+  };\n+\n+  /// Returns true if `parameterIndex` is a differentiability parameter index.\n+  bool isWrtParameter(unsigned parameterIndex) const {\n+    return parameterIndex < parameters->getCapacity() &&\n+           parameters->contains(parameterIndex);\n+  }\n+\n+  void print(llvm::raw_ostream &s = llvm::outs()) const;\n+  SWIFT_DEBUG_DUMP;\n+\n+  std::string mangle() const {\n+    std::string result = \"src_\" + llvm::utostr(source) + \"_wrt_\";\n+    interleave(\n+        parameters->getIndices(),\n+        [&](unsigned idx) { result += llvm::utostr(idx); },\n+        [&] { result += '_'; });\n+    return result;\n+  }\n+};\n+\n /// Identifies an autodiff derivative function configuration:\n /// - Parameter indices.\n /// - Result indices.\n@@ -110,6 +218,11 @@ struct AutoDiffConfig {\n       : parameterIndices(parameterIndices), resultIndices(resultIndices),\n         derivativeGenericSignature(derivativeGenericSignature) {}\n \n+  /// Returns the `SILAutoDiffIndices` corresponding to this config's indices.\n+  // TODO(TF-913): This is a temporary shim for incremental removal of\n+  // `SILAutoDiffIndices`. Eventually remove this.\n+  SILAutoDiffIndices getSILAutoDiffIndices() const;\n+\n   void print(llvm::raw_ostream &s = llvm::outs()) const;\n   SWIFT_DEBUG_DUMP;\n };\n@@ -282,6 +395,37 @@ void getFunctionSemanticResultTypes(\n     SmallVectorImpl<AutoDiffSemanticFunctionResultType> &result,\n     GenericEnvironment *genericEnv = nullptr);\n \n+/// Returns the lowered SIL parameter indices for the given AST parameter\n+/// indices and `AnyfunctionType`.\n+///\n+/// Notable lowering-related changes:\n+/// - AST tuple parameter types are exploded when lowered to SIL.\n+/// - AST curried `Self` parameter types become the last parameter when lowered\n+///   to SIL.\n+///\n+/// Examples:\n+///\n+///   AST function type: (A, B, C) -> R\n+///   AST parameter indices: 101, {A, C}\n+///   Lowered SIL function type: $(A, B, C) -> R\n+///   Lowered SIL parameter indices: 101\n+///\n+///   AST function type: (Self) -> (A, B, C) -> R\n+///   AST parameter indices: 1010, {Self, B}\n+///   Lowered SIL function type: $(A, B, C, Self) -> R\n+///   Lowered SIL parameter indices: 0101\n+///\n+///   AST function type: (A, (B, C), D) -> R\n+///   AST parameter indices: 110, {A, (B, C)}\n+///   Lowered SIL function type: $(A, B, C, D) -> R\n+///   Lowered SIL parameter indices: 1110\n+///\n+/// Note:\n+/// - The AST function type must not be curried unless it is a method.\n+///   Otherwise, the behavior is undefined.\n+IndexSubset *getLoweredParameterIndices(IndexSubset *astParameterIndices,\n+                                        AnyFunctionType *functionType);\n+\n /// \"Constrained\" derivative generic signatures require all differentiability\n /// parameters to conform to the `Differentiable` protocol.\n ///\n@@ -297,6 +441,33 @@ GenericSignature getConstrainedDerivativeGenericSignature(\n     GenericSignature derivativeGenSig, LookupConformanceFn lookupConformance,\n     bool isTranspose = false);\n \n+/// Retrieve config from the function name of a variant of\n+/// `Builtin.applyDerivative`, e.g. `Builtin.applyDerivative_jvp_arity2`.\n+/// Returns true if the function name is parsed successfully.\n+bool getBuiltinApplyDerivativeConfig(\n+    StringRef operationName, AutoDiffDerivativeFunctionKind &kind,\n+    unsigned &arity, bool &rethrows);\n+\n+/// Retrieve config from the function name of a variant of\n+/// `Builtin.applyTranspose`, e.g. `Builtin.applyTranspose_arity2`.\n+/// Returns true if the function name is parsed successfully.\n+bool getBuiltinApplyTransposeConfig(\n+  StringRef operationName, unsigned &arity, bool &rethrows);\n+\n+/// Retrieve config from the function name of a variant of\n+/// `Builtin.differentiableFunction` or `Builtin.linearFunction`, e.g.\n+/// `Builtin.differentiableFunction_arity1_throws`.\n+/// Returns true if the function name is parsed successfully.\n+bool getBuiltinDifferentiableOrLinearFunctionConfig(\n+    StringRef operationName, unsigned &arity, bool &throws);\n+\n+/// Retrieve config from the function name of a variant of\n+/// `Builtin.differentiableFunction` or `Builtin.linearFunction`, e.g.\n+/// `Builtin.differentiableFunction_arity1_throws`.\n+/// Returns true if the function name is parsed successfully.\n+bool getBuiltinDifferentiableOrLinearFunctionConfig(\n+    StringRef operationName, unsigned &arity, bool &throws);\n+\n } // end namespace autodiff\n \n } // end namespace swift"
                    },
                    {
                        "filename": "include/swift/AST/Builtins.def",
                        "code": "@@ -469,6 +469,18 @@ BUILTIN_SIL_OPERATION(ConvertStrongToUnownedUnsafe, \"convertStrongToUnownedUnsaf\n /// now.\n BUILTIN_SIL_OPERATION(ConvertUnownedUnsafeToGuaranteed, \"convertUnownedUnsafeToGuaranteed\", Special)\n \n+/// applyDerivative\n+BUILTIN_SIL_OPERATION(ApplyDerivative, \"applyDerivative\", Special)\n+\n+/// applyTranspose\n+BUILTIN_SIL_OPERATION(ApplyTranspose, \"applyTranspose\", Special)\n+\n+/// differentiableFunction\n+BUILTIN_SIL_OPERATION(DifferentiableFunction, \"differentiableFunction\", Special)\n+\n+/// linearFunction\n+BUILTIN_SIL_OPERATION(LinearFunction, \"linearFunction\", Special)\n+\n #undef BUILTIN_SIL_OPERATION\n \n // BUILTIN_RUNTIME_CALL - A call into a runtime function."
                    },
                    {
                        "filename": "include/swift/AST/Decl.h",
                        "code": "@@ -2186,6 +2186,9 @@ class PatternBindingDecl final : public Decl,\n   /// Can the pattern at index i be default initialized?\n   bool isDefaultInitializable(unsigned i) const;\n \n+  /// Can the property wrapper be used to provide default initialization?\n+  bool isDefaultInitializableViaPropertyWrapper(unsigned i) const;\n+\n   /// Does this pattern have a user-provided initializer expression?\n   bool isExplicitlyInitialized(unsigned i) const;\n \n@@ -2433,6 +2436,7 @@ class ValueDecl : public Decl {\n   friend class IsDynamicRequest;\n   friend class IsImplicitlyUnwrappedOptionalRequest;\n   friend class InterfaceTypeRequest;\n+  friend class CheckRedeclarationRequest;\n   friend class Decl;\n   SourceLoc getLocFromSource() const { return NameLoc; }\n protected:\n@@ -2454,24 +2458,24 @@ class ValueDecl : public Decl {\n     Bits.ValueDecl.AlreadyInLookupTable = value;\n   }\n \n-public:\n-  /// Return true if this protocol member is a protocol requirement.\n-  ///\n-  /// Asserts if this is not a member of a protocol.\n-  bool isProtocolRequirement() const;\n-\n   /// Determine whether we have already checked whether this\n   /// declaration is a redeclaration.\n-  bool alreadyCheckedRedeclaration() const { \n+  bool alreadyCheckedRedeclaration() const {\n     return Bits.ValueDecl.CheckedRedeclaration;\n   }\n \n   /// Set whether we have already checked this declaration as a\n   /// redeclaration.\n-  void setCheckedRedeclaration(bool checked) {\n-    Bits.ValueDecl.CheckedRedeclaration = checked;\n+  void setCheckedRedeclaration() {\n+    Bits.ValueDecl.CheckedRedeclaration = true;\n   }\n \n+public:\n+  /// Return true if this protocol member is a protocol requirement.\n+  ///\n+  /// Asserts if this is not a member of a protocol.\n+  bool isProtocolRequirement() const;\n+\n   void setUserAccessible(bool Accessible) {\n     Bits.ValueDecl.IsUserAccessible = Accessible;\n   }\n@@ -2492,6 +2496,10 @@ class ValueDecl : public Decl {\n   /// names.\n   DeclBaseName getBaseName() const { return Name.getBaseName(); }\n \n+  Identifier getBaseIdentifier() const {\n+    return Name.getBaseIdentifier();\n+  }\n+\n   /// Generates a DeclNameRef referring to this declaration with as much\n   /// specificity as possible.\n   DeclNameRef createNameRef() const {\n@@ -2697,6 +2705,11 @@ class ValueDecl : public Decl {\n     return !isObjC() && isDynamic();\n   }\n \n+  bool isEffectiveLinkageMoreVisibleThan(ValueDecl *other) const {\n+    return (std::min(getEffectiveAccess(), AccessLevel::Public) >\n+            std::min(other->getEffectiveAccess(), AccessLevel::Public));\n+  }\n+\n   /// Set whether this type is 'dynamic' or not.\n   void setIsDynamic(bool value);\n \n@@ -2815,12 +2828,12 @@ class TypeDecl : public ValueDecl {\n     ValueDecl(K, context, name, NameLoc), Inherited(inherited) {}\n \n public:\n-  Identifier getName() const { return getFullName().getBaseIdentifier(); }\n+  Identifier getName() const { return getBaseIdentifier(); }\n \n   /// Returns the string for the base name, or \"_\" if this is unnamed.\n   StringRef getNameStr() const {\n     assert(!getFullName().isSpecial() && \"Cannot get string for special names\");\n-    return hasName() ? getBaseName().getIdentifier().str() : \"_\";\n+    return hasName() ? getBaseIdentifier().str() : \"_\";\n   }\n \n   /// The type of this declaration's values. For the type of the\n@@ -3511,6 +3524,27 @@ class NominalTypeDecl : public GenericTypeDecl, public IterableDeclContext {\n   /// or \\c nullptr if it does not have one.\n   ConstructorDecl *getMemberwiseInitializer() const;\n \n+  /// Retrieves the effective memberwise initializer for this declaration, or\n+  /// \\c nullptr if it does not have one.\n+  ///\n+  /// An effective memberwise initializer is either a synthesized memberwise\n+  /// initializer or a user-defined initializer with the same type.\n+  ///\n+  /// The access level of the memberwise initializer is set to the minimum of:\n+  /// - Public, by default. This enables public nominal types to have public\n+  ///   memberwise initializers.\n+  ///   - The `public` default is important for synthesized member types, e.g.\n+  ///     `TangentVector` structs synthesized during `Differentiable` derived\n+  ///     conformances. Manually extending these types to define a public\n+  ///     memberwise initializer causes a redeclaration error.\n+  /// - The minimum access level of memberwise-initialized properties in the\n+  ///   nominal type declaration.\n+  ///\n+  /// Effective memberwise initializers are used only by derived conformances\n+  /// for `Self`-returning protocol requirements like `AdditiveArithmetic.+`.\n+  /// Such derived conformances require memberwise initialization.\n+  ConstructorDecl *getEffectiveMemberwiseInitializer();\n+\n   /// Whether this declaration has a synthesized zero parameter default\n   /// initializer.\n   bool hasDefaultInitializer() const;\n@@ -4167,6 +4201,22 @@ struct SelfReferenceKind {\n       other(other) { }\n };\n \n+/// The set of known protocols for which derived conformances are supported.\n+enum class KnownDerivableProtocolKind : uint8_t {\n+  RawRepresentable,\n+  OptionSet,\n+  CaseIterable,\n+  Comparable,\n+  Equatable,\n+  Hashable,\n+  BridgedNSError,\n+  CodingKey,\n+  Encodable,\n+  Decodable,\n+  AdditiveArithmetic,\n+  Differentiable,\n+};\n+\n /// ProtocolDecl - A declaration of a protocol, for example:\n ///\n ///   protocol Drawable {\n@@ -4244,8 +4294,6 @@ class ProtocolDecl final : public NominalTypeDecl {\n     Bits.ProtocolDecl.ExistentialTypeSupported = supported;\n   }\n \n-  ArrayRef<ProtocolDecl *> getInheritedProtocolsSlow();\n-\n   bool hasLazyRequirementSignature() const {\n     return Bits.ProtocolDecl.HasLazyRequirementSignature;\n   }\n@@ -4256,7 +4304,8 @@ class ProtocolDecl final : public NominalTypeDecl {\n   friend class ProtocolRequiresClassRequest;\n   friend class ExistentialConformsToSelfRequest;\n   friend class ExistentialTypeSupportedRequest;\n-\n+  friend class InheritedProtocolsRequest;\n+  \n public:\n   ProtocolDecl(DeclContext *DC, SourceLoc ProtocolLoc, SourceLoc NameLoc,\n                Identifier Name, MutableArrayRef<TypeLoc> Inherited,\n@@ -4265,12 +4314,7 @@ class ProtocolDecl final : public NominalTypeDecl {\n   using Decl::getASTContext;\n \n   /// Retrieve the set of protocols inherited from this protocol.\n-  ArrayRef<ProtocolDecl *> getInheritedProtocols() const {\n-    if (Bits.ProtocolDecl.InheritedProtocolsValid)\n-      return InheritedProtocols;\n-\n-    return const_cast<ProtocolDecl *>(this)->getInheritedProtocolsSlow();\n-  }\n+  ArrayRef<ProtocolDecl *> getInheritedProtocols() const;\n \n   /// Determine whether this protocol has a superclass.\n   bool hasSuperclass() const { return (bool)getSuperclassDecl(); }\n@@ -4365,6 +4409,13 @@ class ProtocolDecl final : public NominalTypeDecl {\n private:\n   void computeKnownProtocolKind() const;\n \n+  bool areInheritedProtocolsValid() const {\n+    return Bits.ProtocolDecl.InheritedProtocolsValid;\n+  }\n+  void setInheritedProtocolsValid() {\n+    Bits.ProtocolDecl.InheritedProtocolsValid = true;\n+  }\n+\n public:\n   /// If this is known to be a compiler-known protocol, returns the kind.\n   /// Otherwise returns None.\n@@ -4378,6 +4429,8 @@ class ProtocolDecl final : public NominalTypeDecl {\n     return static_cast<KnownProtocolKind>(Bits.ProtocolDecl.KnownProtocol - 2);\n   }\n \n+  Optional<KnownDerivableProtocolKind> getKnownDerivableProtocolKind() const;\n+\n   /// Check whether this protocol is of a specific, known protocol kind.\n   bool isSpecificProtocol(KnownProtocolKind kind) const {\n     if (auto knownKind = getKnownProtocolKind())\n@@ -4880,12 +4933,12 @@ class VarDecl : public AbstractStorageDecl {\n \n   SourceRange getSourceRange() const;\n \n-  Identifier getName() const { return getFullName().getBaseIdentifier(); }\n+  Identifier getName() const { return getBaseIdentifier(); }\n \n   /// Returns the string for the base name, or \"_\" if this is unnamed.\n   StringRef getNameStr() const {\n     assert(!getFullName().isSpecial() && \"Cannot get string for special names\");\n-    return hasName() ? getBaseName().getIdentifier().str() : \"_\";\n+    return hasName() ? getBaseIdentifier().str() : \"_\";\n   }\n \n   /// Get the type of the variable within its context. If the context is generic,\n@@ -5111,15 +5164,17 @@ class VarDecl : public AbstractStorageDecl {\n   void setTopLevelGlobal(bool b) { Bits.VarDecl.IsTopLevelGlobal = b; }\n   \n   /// Retrieve the custom attributes that attach property wrappers to this\n-  /// property. The returned list contains all of the attached property wrapper attributes in source order,\n-  /// which means the outermost wrapper attribute is provided first.\n+  /// property. The returned list contains all of the attached property wrapper\n+  /// attributes in source order, which means the outermost wrapper attribute\n+  /// is provided first.\n   llvm::TinyPtrVector<CustomAttr *> getAttachedPropertyWrappers() const;\n \n   /// Whether this property has any attached property wrappers.\n   bool hasAttachedPropertyWrapper() const;\n   \n-  /// Whether all of the attached property wrappers have an init(initialValue:) initializer.\n-  bool allAttachedPropertyWrappersHaveInitialValueInit() const;\n+  /// Whether all of the attached property wrappers have an init(wrappedValue:)\n+  /// initializer.\n+  bool allAttachedPropertyWrappersHaveWrappedValueInit() const;\n   \n   /// Retrieve the type of the attached property wrapper as a contextual\n   /// type.\n@@ -5183,9 +5238,21 @@ class VarDecl : public AbstractStorageDecl {\n   /// \\end\n   ///\n   /// Or when there is no initializer but each composed property wrapper has\n-  /// a suitable `init(initialValue:)`.\n+  /// a suitable `init(wrappedValue:)`.\n   bool isPropertyMemberwiseInitializedWithWrappedType() const;\n \n+  /// Whether the innermost property wrapper's initializer's 'wrappedValue' parameter\n+  /// is marked with '@autoclosure' and '@escaping'.\n+  bool isInnermostPropertyWrapperInitUsesEscapingAutoClosure() const;\n+\n+  /// Return the interface type of the value used for the 'wrappedValue:'\n+  /// parameter when initializing a property wrapper.\n+  ///\n+  /// If the property has an attached property wrapper and the 'wrappedValue:'\n+  /// parameter is an autoclosure, return a function type returning the stored\n+  /// value. Otherwise, return the interface type of the stored value.\n+  Type getPropertyWrapperInitValueInterfaceType() const;\n+\n   /// If this property is the backing storage for a property with an attached\n   /// property wrapper, return the original property.\n   ///\n@@ -5757,6 +5824,7 @@ class AbstractFunctionDecl : public GenericContext, public ValueDecl {\n private:\n   ParameterList *Params;\n \n+private:\n   /// The generation at which we last loaded derivative function configurations.\n   unsigned DerivativeFunctionConfigGeneration = 0;\n   /// Prepare to traverse the list of derivative function configurations.\n@@ -5771,6 +5839,13 @@ class AbstractFunctionDecl : public GenericContext, public ValueDecl {\n   struct DerivativeFunctionConfigurationList;\n   DerivativeFunctionConfigurationList *DerivativeFunctionConfigs = nullptr;\n \n+public:\n+  /// Get all derivative function configurations.\n+  ArrayRef<AutoDiffConfig> getDerivativeFunctionConfigurations();\n+\n+  /// Add the given derivative function configuration.\n+  void addDerivativeFunctionConfiguration(AutoDiffConfig config);\n+\n protected:\n   // If a function has a body at all, we have either a parsed body AST node or\n   // we have saved the end location of the unparsed body.\n@@ -5838,7 +5913,7 @@ class AbstractFunctionDecl : public GenericContext, public ValueDecl {\n   /// Returns the string for the base name, or \"_\" if this is unnamed.\n   StringRef getNameStr() const {\n     assert(!getFullName().isSpecial() && \"Cannot get string for special names\");\n-    return hasName() ? getBaseName().getIdentifier().str() : \"_\";\n+    return hasName() ? getBaseIdentifier().str() : \"_\";\n   }\n \n   /// Should this declaration be treated as if annotated with transparent\n@@ -5983,11 +6058,6 @@ class AbstractFunctionDecl : public GenericContext, public ValueDecl {\n   /// vtable.\n   bool needsNewVTableEntry() const;\n \n-  bool isEffectiveLinkageMoreVisibleThan(ValueDecl *other) const {\n-    return (std::min(getEffectiveAccess(), AccessLevel::Public) >\n-            std::min(other->getEffectiveAccess(), AccessLevel::Public));\n-  }\n-\n   bool isSynthesized() const {\n     return Bits.AbstractFunctionDecl.Synthesized;\n   }\n@@ -6095,12 +6165,6 @@ class AbstractFunctionDecl : public GenericContext, public ValueDecl {\n   /// constructor.\n   bool hasDynamicSelfResult() const;\n \n-  /// Get all derivative function configurations.\n-  ArrayRef<AutoDiffConfig> getDerivativeFunctionConfigurations();\n-\n-  /// Add the given derivative function configuration.\n-  void addDerivativeFunctionConfiguration(AutoDiffConfig config);\n-\n   using DeclContext::operator new;\n   using Decl::getASTContext;\n };\n@@ -6197,8 +6261,6 @@ class FuncDecl : public AbstractFunctionDecl {\n                           TypeLoc FnRetType, DeclContext *Parent,\n                           ClangNode ClangN = ClangNode());\n \n-  Identifier getName() const { return getFullName().getBaseIdentifier(); }\n-\n   bool isStatic() const;\n \n   /// \\returns the way 'static'/'class' was spelled in the source.\n@@ -6541,12 +6603,10 @@ class EnumElementDecl : public DeclContext, public ValueDecl {\n                   LiteralExpr *RawValueExpr,\n                   DeclContext *DC);\n \n-  Identifier getName() const { return getFullName().getBaseIdentifier(); }\n-\n   /// Returns the string for the base name, or \"_\" if this is unnamed.\n   StringRef getNameStr() const {\n     assert(!getFullName().isSpecial() && \"Cannot get string for special names\");\n-    return hasName() ? getBaseName().getIdentifier().str() : \"_\";\n+    return hasName() ? getBaseIdentifier().str() : \"_\";\n   }\n \n   Type getArgumentInterfaceType() const;\n@@ -7051,6 +7111,28 @@ class PrecedenceGroupDecl : public Decl {\n   }\n };\n \n+/// The fixity of an OperatorDecl.\n+enum class OperatorFixity : uint8_t {\n+  Infix,\n+  Prefix,\n+  Postfix\n+};\n+\n+inline void simple_display(llvm::raw_ostream &out, OperatorFixity fixity) {\n+  switch (fixity) {\n+  case OperatorFixity::Infix:\n+    out << \"infix\";\n+    return;\n+  case OperatorFixity::Prefix:\n+    out << \"prefix\";\n+    return;\n+  case OperatorFixity::Postfix:\n+    out << \"postfix\";\n+    return;\n+  }\n+  llvm_unreachable(\"Unhandled case in switch\");\n+}\n+\n /// Abstract base class of operator declarations.\n class OperatorDecl : public Decl {\n   SourceLoc OperatorLoc, NameLoc;\n@@ -7076,6 +7158,21 @@ class OperatorDecl : public Decl {\n       : Decl(kind, DC), OperatorLoc(OperatorLoc), NameLoc(NameLoc), name(Name),\n         DesignatedNominalTypes(DesignatedNominalTypes) {}\n \n+  /// Retrieve the operator's fixity, corresponding to the concrete subclass\n+  /// of the OperatorDecl.\n+  OperatorFixity getFixity() const {\n+    switch (getKind()) {\n+#define DECL(Id, Name) case DeclKind::Id: llvm_unreachable(\"Not an operator!\");\n+#define OPERATOR_DECL(Id, Name)\n+#include \"swift/AST/DeclNodes.def\"\n+    case DeclKind::InfixOperator:\n+      return OperatorFixity::Infix;\n+    case DeclKind::PrefixOperator:\n+      return OperatorFixity::Prefix;\n+    case DeclKind::PostfixOperator:\n+      return OperatorFixity::Postfix;\n+    }\n+  }\n \n   SourceLoc getOperatorLoc() const { return OperatorLoc; }\n   SourceLoc getNameLoc() const { return NameLoc; }"
                    },
                    {
                        "filename": "include/swift/AST/DeclContext.h",
                        "code": "@@ -552,31 +552,30 @@ class alignas(1 << DeclContextAlignInBits) DeclContext {\n   ///\n   /// \\param lookupKind The kind of lookup to perform.\n   ///\n-  /// \\param diagnostics If non-null, will be populated with the set of\n-  /// diagnostics that should be emitted for this declaration context.\n   /// FIXME: This likely makes more sense on IterableDeclContext or\n   /// something similar.\n   SmallVector<ProtocolDecl *, 2>\n   getLocalProtocols(ConformanceLookupKind lookupKind\n-                      = ConformanceLookupKind::All,\n-                    SmallVectorImpl<ConformanceDiagnostic> *diagnostics\n-                      = nullptr) const;\n+                      = ConformanceLookupKind::All) const;\n \n   /// Retrieve the set of protocol conformances associated with this\n   /// declaration context.\n   ///\n   /// \\param lookupKind The kind of lookup to perform.\n   ///\n-  /// \\param diagnostics If non-null, will be populated with the set of\n-  /// diagnostics that should be emitted for this declaration context.\n-  ///\n   /// FIXME: This likely makes more sense on IterableDeclContext or\n   /// something similar.\n   SmallVector<ProtocolConformance *, 2>\n   getLocalConformances(ConformanceLookupKind lookupKind\n-                         = ConformanceLookupKind::All,\n-                       SmallVectorImpl<ConformanceDiagnostic> *diagnostics\n-                         = nullptr) const;\n+                         = ConformanceLookupKind::All) const;\n+\n+  /// Retrieve diagnostics discovered while expanding conformances for this\n+  /// declaration context. This operation then removes those diagnostics from\n+  /// consideration, so subsequent calls to this function with the same\n+  /// declaration context that have not had any new extensions bound\n+  /// will see an empty array.\n+  SmallVector<ConformanceDiagnostic, 4>\n+  takeConformanceDiagnostics() const;\n \n   /// Retrieves a list of separately imported overlays which are shadowing\n   /// \\p declaring. If any \\p overlays are returned, qualified lookups into"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -676,9 +676,6 @@ namespace swift {\n     /// Print diagnostic names after their messages\n     bool printDiagnosticNames = false;\n \n-    /// Use educational notes when available.\n-    bool useEducationalNotes = false;\n-\n     /// Path to diagnostic documentation directory.\n     std::string diagnosticDocumentationPath = \"\";\n \n@@ -730,9 +727,6 @@ namespace swift {\n       return printDiagnosticNames;\n     }\n \n-    void setUseEducationalNotes(bool val) { useEducationalNotes = val; }\n-    bool getUseEducationalNotes() const { return useEducationalNotes; }\n-\n     void setDiagnosticDocumentationPath(std::string path) {\n       diagnosticDocumentationPath = path;\n     }"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsFrontend.def",
                        "code": "@@ -383,20 +383,20 @@ REMARK(interface_file_lock_timed_out,none,\n \n // Dependency Verifier Diagnostics\n ERROR(dependency_cascading_mismatch,none,\n-      \"expected %select{cascading|non-cascading}0 dependency; found \"\n-      \"%select{cascading|non-cascading}1 dependency instead\",\n+      \"expected %select{non-cascading|cascading}0 dependency; found \"\n+      \"%select{non-cascading|cascading}1 dependency instead\",\n       (bool, bool))\n ERROR(potential_dependency_cascading_mismatch,none,\n-      \"expected %select{cascading|non-cascading}0 potential member dependency; \"\n-      \"found %select{cascading|non-cascading}1 potential member dependency \"\n+      \"expected %select{non-cascading|cascading}0 potential member dependency; \"\n+      \"found %select{non-cascading|cascading}1 potential member dependency \"\n       \"instead\", (bool, bool))\n ERROR(missing_member_dependency,none,\n       \"expected \"\n       \"%select{%error|provided|member|potential member|dynamic member}0 \"\n       \"dependency does not exist: %1\",\n       (/*Expectation::Kind*/uint8_t, StringRef))\n ERROR(unexpected_dependency,none,\n-      \"unexpected %0 %select{%error|%error||potential member|dynamic member}1 \"\n+      \"unexpected %0 %select{%error|%error|member|potential member|dynamic member}1 \"\n       \"dependency: %2\", (StringRef, /*Expectation::Kind*/uint8_t, StringRef))\n ERROR(unexpected_provided_entity,none,\n       \"unexpected provided entity: %0\", (StringRef))"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.def",
                        "code": "@@ -504,6 +504,9 @@ ERROR(expected_sil_colon,none,\n       \"expected ':' before %0\", (StringRef))\n ERROR(expected_sil_tuple_index,none,\n       \"expected tuple element index\", ())\n+ERROR(invalid_index_subset,none,\n+      \"invalid index subset; expected '[SU]+' where 'S' represents set indices \"\n+      \"and 'U' represents unset indices\", ())\n \n // SIL Values\n ERROR(sil_value_redefinition,none,\n@@ -1579,24 +1582,14 @@ ERROR(attr_implements_expected_member_name,PointsToFirstBadToken,\n       \"expected a member name as second parameter in '_implements' attribute\", ())\n \n // differentiable\n-// TODO(TF-1001): Remove diagnostic when deprecated `jvp:`, `vjp:` are removed.\n-ERROR(attr_differentiable_expected_function_name,PointsToFirstBadToken,\n-      \"expected a %0 function name\", (StringRef))\n ERROR(attr_differentiable_expected_parameter_list,PointsToFirstBadToken,\n       \"expected a list of parameters to differentiate with respect to\", ())\n-// TODO(TF-1001): Remove diagnostic when deprecated `jvp:`, `vjp:` are removed.\n ERROR(attr_differentiable_use_wrt_not_withrespectto,none,\n       \"use 'wrt:' to specify parameters to differentiate with respect to\", ())\n ERROR(attr_differentiable_expected_label,none,\n-      \"expected either 'wrt:' or a function specifier label, e.g. 'jvp:', \"\n-      \"or 'vjp:'\", ())\n+      \"expected 'wrt:' or 'where' in '@differentiable' attribute\", ())\n ERROR(attr_differentiable_unexpected_argument,none,\n       \"unexpected argument '%0' in '@differentiable' attribute\", (StringRef))\n-// TODO(TF-1001): Remove diagnostic when deprecated `jvp:`, `vjp:` are removed.\n-WARNING(attr_differentiable_jvp_vjp_deprecated_warning,none,\n-        \"'jvp:' and 'vjp:' arguments in '@differentiable' attribute are \"\n-        \"deprecated; use '@derivative' attribute for derivative registration \"\n-        \"instead\", ())\n \n // differentiation `wrt` parameters clause\n ERROR(expected_colon_after_label,PointsToFirstBadToken,\n@@ -1625,6 +1618,20 @@ ERROR(sil_autodiff_expected_parameter_index,PointsToFirstBadToken,\n       \"expected the index of a parameter to differentiate with respect to\", ())\n ERROR(sil_autodiff_expected_result_index,PointsToFirstBadToken,\n       \"expected the index of a result to differentiate from\", ())\n+ERROR(sil_inst_autodiff_operand_list_expected_lbrace,PointsToFirstBadToken,\n+      \"expected '{' to start a derivative function list\", ())\n+ERROR(sil_inst_autodiff_operand_list_expected_comma,PointsToFirstBadToken,\n+      \"expected ',' between operands in a derivative function list\", ())\n+ERROR(sil_inst_autodiff_operand_list_expected_rbrace,PointsToFirstBadToken,\n+      \"expected '}' to start a derivative function list\", ())\n+ERROR(sil_inst_autodiff_expected_differentiable_extractee_kind,PointsToFirstBadToken,\n+      \"expected an extractee kind attribute, which can be one of '[original]', \"\n+      \"'[jvp]', and '[vjp]'\", ())\n+ERROR(sil_inst_autodiff_expected_linear_extractee_kind,PointsToFirstBadToken,\n+      \"expected an extractee kind attribute, which can be one of '[original]' \"\n+      \"and '[transpose]'\", ())\n+ERROR(sil_inst_autodiff_expected_function_type_operand,PointsToFirstBadToken,\n+      \"expected an operand of a function type\", ())\n ERROR(sil_inst_autodiff_expected_differentiability_witness_kind,PointsToFirstBadToken,\n       \"expected a differentiability witness kind, which can be one of '[jvp]', \"\n       \"'[vjp]', or '[transpose]'\", ())\n@@ -1658,9 +1665,6 @@ ERROR(redundant_class_requirement,none,\n       \"redundant 'class' requirement\", ())\n ERROR(late_class_requirement,none,\n       \"'class' must come first in the requirement list\", ())\n-ERROR(where_toplevel_nongeneric,none,\n-      \"'where' clause cannot be attached to non-generic \"\n-      \"top-level declaration\", ())\n ERROR(where_inside_brackets,none,\n         \"'where' clause next to generic parameters is obsolete, \"\n         \"must be written following the declaration's type\", ())"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -184,6 +184,9 @@ ERROR(value_type_comparison_with_nil_illegal,none,\n ERROR(cannot_match_expr_pattern_with_value,none,\n       \"expression pattern of type %0 cannot match values of type %1\",\n       (Type, Type))\n+ERROR(cannot_match_expr_tuple_pattern_with_nontuple_value,none,\n+      \"tuple pattern cannot match values of non-tuple type %0\",\n+      (Type))\n ERROR(cannot_match_unresolved_expr_pattern_with_value,none,\n       \"pattern cannot match values of type %0\",\n       (Type))\n@@ -661,7 +664,7 @@ NOTE(add_return_type_note,none,\n      \"did you mean to add a return type?\", ())\n \n //------------------------------------------------------------------------------\n-// MARK: Name Binding\n+// MARK: Import Resolution\n //------------------------------------------------------------------------------\n \n ERROR(sema_no_import,Fatal,\n@@ -1200,8 +1203,16 @@ ERROR(c_function_pointer_from_method,none,\n ERROR(c_function_pointer_from_generic_function,none,\n       \"a C function pointer cannot be formed from a reference to a generic \"\n       \"function\", ())\n+ERROR(unsupported_linear_to_differentiable_conversion,none,\n+      \"conversion from '@differentiable(linear)' to '@differentiable' is not \"\n+      \"yet supported\", ())\n ERROR(invalid_autoclosure_forwarding,none,\n       \"add () to forward @autoclosure parameter\", ())\n+ERROR(invalid_differentiable_function_conversion_expr,none,\n+      \"a '@differentiable%select{|(linear)}0' function can only be formed from \"\n+      \"a reference to a 'func' or a literal closure\", (bool))\n+NOTE(invalid_differentiable_function_conversion_parameter,none,\n+     \"did you mean to take a '%0' closure?\", (StringRef))\n ERROR(invalid_autoclosure_pointer_conversion,none,\n       \"cannot perform pointer conversion of value of type %0 to autoclosure \"\n       \"result type %1\",\n@@ -1575,7 +1586,7 @@ NOTE(unstable_mangled_name_add_objc,none,\n      \"for compatibility with existing archives, use '@objc' \"\n      \"to record the Swift 3 runtime name\", ())\n \n-// Generic types\n+// Generic declarations\n ERROR(unsupported_type_nested_in_generic_function,none,\n       \"type %0 cannot be nested in generic function %1\",\n       (Identifier, DeclName))\n@@ -1591,6 +1602,12 @@ ERROR(unsupported_type_nested_in_protocol_extension,none,\n ERROR(unsupported_nested_protocol,none,\n       \"protocol %0 cannot be nested inside another declaration\",\n       (Identifier))\n+ERROR(where_nongeneric_ctx,none,\n+      \"'where' clause on non-generic member declaration requires a \"\n+      \"generic context\", ())\n+ERROR(where_nongeneric_toplevel,none,\n+      \"'where' clause cannot be applied to a non-generic top-level \"\n+      \"declaration\", ())\n \n // Type aliases\n ERROR(type_alias_underlying_type_access,none,\n@@ -1875,8 +1892,9 @@ ERROR(requirement_restricts_self,none,\n       \"'Self'\",\n       (DescriptiveDeclKind, DeclName, StringRef, unsigned, StringRef))\n ERROR(witness_argument_name_mismatch,none,\n-      \"%select{method|initializer}0 %1 has different argument labels from those \"\n-      \"required by protocol %2 (%3)\", (bool, DeclName, Type, DeclName))\n+      \"%0 %1 has different argument labels \"\n+      \"from those required by protocol %2 (%3)\",\n+      (DescriptiveDeclKind, DeclName, Type, DeclName))\n ERROR(witness_initializer_not_required,none,\n       \"initializer requirement %0 can only be satisfied by a 'required' \"\n       \"initializer in%select{| the definition of}1 non-final class %2\",\n@@ -2102,6 +2120,9 @@ NOTE(protocol_witness_throws_conflict,none,\n      \"candidate throws, but protocol does not allow it\", ())\n NOTE(protocol_witness_not_objc,none,\n      \"candidate is explicitly '@nonobjc'\", ())\n+NOTE(protocol_witness_enum_case_payload, none,\n+     \"candidate is an enum case with associated values, \"\n+     \"but protocol does not allow it\", ())\n \n NOTE(protocol_witness_type,none,\n      \"possibly intended match\", ())\n@@ -2668,6 +2689,8 @@ ERROR(cannot_synthesize_in_crossfile_extension,none,\n       \"implementation of %0 cannot be automatically synthesized in an extension \"\n       \"in a different file to the type\", (Type))\n \n+ERROR(broken_additive_arithmetic_requirement,none,\n+      \"AdditiveArithmetic protocol is broken: unexpected requirement\", ())\n ERROR(broken_case_iterable_requirement,none,\n       \"CaseIterable protocol is broken: unexpected requirement\", ())\n ERROR(broken_raw_representable_requirement,none,\n@@ -2696,6 +2719,19 @@ ERROR(broken_encodable_requirement,none,\n       \"Encodable protocol is broken: unexpected requirement\", ())\n ERROR(broken_decodable_requirement,none,\n       \"Decodable protocol is broken: unexpected requirement\", ())\n+ERROR(broken_differentiable_requirement,none,\n+      \"Differentiable protocol is broken: unexpected requirement\", ())\n+WARNING(differentiable_nondiff_type_implicit_noderivative_fixit,none,\n+      \"stored property %0 has no derivative because %1 does not conform to \"\n+      \"'Differentiable'; add an explicit '@noDerivative' attribute\"\n+      \"%select{|, or conform %2 to 'AdditiveArithmetic'}3\",\n+      (Identifier, Type, Identifier, bool))\n+WARNING(differentiable_let_property_implicit_noderivative_fixit,none,\n+      \"synthesis of the 'Differentiable.move(along:)' requirement for %1 \"\n+      \"requires all stored properties to be mutable; use 'var' instead, or add \"\n+      \"an explicit '@noDerivative' attribute\"\n+      \"%select{|, or conform %1 to 'AdditiveArithmetic'}2\",\n+      (Identifier, Identifier, bool))\n \n NOTE(codable_extraneous_codingkey_case_here,none,\n      \"CodingKey case %0 does not match any stored properties\", (Identifier))\n@@ -2722,6 +2758,19 @@ NOTE(decodable_suggest_overriding_init_here,none,\n NOTE(codable_suggest_overriding_init_here,none,\n      \"did you mean to override 'init(from:)' and 'encode(to:)'?\", ())\n \n+WARNING(decodable_property_will_not_be_decoded, none,\n+        \"immutable property will not be decoded because it is declared with \"\n+        \"an initial value which cannot be overwritten\", ())\n+NOTE(decodable_property_init_or_codingkeys_implicit, none,\n+     \"set the initial value via the initializer or explicitly define a \"\n+     \"CodingKeys enum %select{including|without}0 a %1 case to silence \"\n+     \"this warning\", (unsigned, DeclName))\n+NOTE(decodable_property_init_or_codingkeys_explicit, none,\n+     \"set the initial value via the initializer or remove the %0 case from \"\n+     \"the CodingKeys enum to silence this warning\", (DeclName))\n+NOTE(decodable_make_property_mutable, none,\n+     \"make the property mutable instead\", ())\n+\n NOTE(missing_member_type_conformance_prevents_synthesis, none,\n      \"%select{associated value|stored property}0 type %1 does not conform to \"\n      \"protocol %2, preventing synthesized conformance \"\n@@ -2755,10 +2804,6 @@ ERROR(dynamic_self_stored_property_init,none,\n ERROR(dynamic_self_default_arg,none,\n       \"covariant 'Self' type cannot be referenced from a default argument expression\", ())\n \n-ERROR(where_nongeneric_ctx,none,\n-      \"'where' clause on non-generic member declaration requires a \"\n-      \"generic context\", ())\n-\n //------------------------------------------------------------------------------\n // MARK: Type Check Attributes\n //------------------------------------------------------------------------------\n@@ -2912,6 +2957,8 @@ ERROR(implements_attr_protocol_not_conformed_to,none,\n ERROR(differentiable_attr_no_vjp_or_jvp_when_linear,none,\n       \"cannot specify 'vjp:' or 'jvp:' for linear functions; use '@transpose' \"\n       \"attribute for transpose registration instead\", ())\n+ERROR(differentiable_attr_void_result,none,\n+      \"cannot differentiate void function %0\", (DeclName))\n ERROR(differentiable_attr_overload_not_found,none,\n       \"%0 does not have expected type %1\", (DeclNameRef, Type))\n // TODO(TF-482): Change duplicate `@differentiable` attribute diagnostic to also\n@@ -2936,12 +2983,6 @@ ERROR(differentiable_attr_result_not_differentiable,none,\n ERROR(differentiable_attr_protocol_req_where_clause,none,\n       \"'@differentiable' attribute on protocol requirement cannot specify \"\n       \"'where' clause\", ())\n-ERROR(differentiable_attr_protocol_req_assoc_func,none,\n-      \"'@differentiable' attribute on protocol requirement cannot specify \"\n-      \"'jvp:' or 'vjp:'\", ())\n-ERROR(differentiable_attr_stored_property_variable_unsupported,none,\n-      \"'@differentiable' attribute on stored property cannot specify \"\n-      \"'jvp:' or 'vjp:'\", ())\n ERROR(differentiable_attr_class_member_dynamic_self_result_unsupported,none,\n       \"'@differentiable' attribute cannot be declared on class members \"\n       \"returning 'Self'\", ())\n@@ -2960,6 +3001,12 @@ ERROR(overriding_decl_missing_differentiable_attr,none,\n       \"overriding declaration is missing attribute '%0'\", (StringRef))\n NOTE(protocol_witness_missing_differentiable_attr,none,\n      \"candidate is missing attribute '%0'\", (StringRef))\n+NOTE(protocol_witness_missing_differentiable_attr_nonpublic_other_file,none,\n+     \"non-public %1 %2 must have explicit '%0' attribute to satisfy \"\n+     \"requirement %3 %4 (in protocol %6) because it is declared in a different \"\n+     \"file than the conformance of %5 to %6\",\n+     (StringRef, DescriptiveDeclKind, DeclName, DescriptiveDeclKind, DeclName,\n+      Type, Type))\n \n // @derivative\n ERROR(derivative_attr_expected_result_tuple,none,\n@@ -2997,6 +3044,23 @@ ERROR(derivative_attr_original_already_has_derivative,none,\n NOTE(derivative_attr_duplicate_note,none,\n      \"other attribute declared here\", ())\n \n+// @transpose\n+ERROR(transpose_attr_invalid_linearity_parameter_or_result,none,\n+      \"cannot transpose with respect to original %select{result|parameter}1 \"\n+      \"'%0' that does not conform to 'Differentiable' and satisfy \"\n+      \"'%0 == %0.TangentVector'\", (StringRef, /*isParameter*/ bool))\n+ERROR(transpose_attr_overload_not_found,none,\n+      \"could not find function %0 with expected type %1\", (DeclName, Type))\n+ERROR(transpose_attr_cannot_use_named_wrt_params,none,\n+      \"cannot use named 'wrt' parameters in '@transpose(of:)' attribute, found \"\n+      \"%0\", (Identifier))\n+ERROR(transpose_attr_wrt_self_must_be_static,none,\n+     \"the transpose of an instance method must be a 'static' method in the \"\n+     \"same type when 'self' is a linearity parameter\", ())\n+NOTE(transpose_attr_wrt_self_self_type_mismatch_note,none,\n+     \"the transpose is declared in %0 but the original function is declared in \"\n+     \"%1\", (Type, Type))\n+\n // Automatic differentiation attributes\n ERROR(autodiff_attr_original_decl_invalid_kind,none,\n       \"%0 is not a 'func', 'init', 'subscript', or 'var' computed property \"\n@@ -4010,6 +4074,18 @@ ERROR(opaque_type_in_protocol_requirement,none,\n ERROR(attr_only_on_parameters_of_differentiable,none,\n       \"'%0' may only be used on parameters of '@differentiable' function \"\n       \"types\", (StringRef))\n+ERROR(differentiable_function_type_invalid_parameter,none,\n+      \"parameter type '%0' does not conform to 'Differentiable'\"\n+      \"%select{| and satisfy '%0 == %0.TangentVector'}1, but the enclosing \"\n+      \"function type is '@differentiable%select{|(linear)}1'\"\n+      \"%select{|; did you want to add '@noDerivative' to this parameter?}2\",\n+      (StringRef, /*tangentVectorEqualsSelf*/ bool,\n+       /*hasValidDifferentiabilityParameter*/ bool))\n+ERROR(differentiable_function_type_invalid_result,none,\n+      \"result type '%0' does not conform to 'Differentiable'\"\n+      \"%select{| and satisfy '%0 == %0.TangentVector'}1, but the enclosing \"\n+      \"function type is '@differentiable%select{|(linear)}1'\",\n+      (StringRef, bool))\n \n // SIL\n ERROR(opened_non_protocol,none,"
                    },
                    {
                        "filename": "include/swift/AST/Evaluator.h",
                        "code": "@@ -19,6 +19,7 @@\n #define SWIFT_AST_EVALUATOR_H\n \n #include \"swift/AST/AnyRequest.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n #include \"swift/Basic/AnyValue.h\"\n #include \"swift/Basic/Debug.h\"\n #include \"swift/Basic/Defer.h\"\n@@ -47,14 +48,20 @@ class DiagnosticEngine;\n class Evaluator;\n class UnifiedStatsReporter;\n \n+namespace detail {\n+// Remove this when the compiler bumps to C++17.\n+template <typename...>\n+using void_t = void;\n+}\n+\n /// An \"abstract\" request function pointer, which is the storage type\n /// used for each of the\n using AbstractRequestFunction = void(void);\n \n /// Form the specific request function for the given request type.\n template<typename Request>\n using RequestFunction =\n-  llvm::Expected<typename Request::OutputType>(const Request &, Evaluator &);\n+  typename Request::OutputType(const Request &, Evaluator &);\n \n /// Pretty stack trace handler for an arbitrary request.\n template<typename Request>\n@@ -224,6 +231,38 @@ class Evaluator {\n   /// so all clients must cope with cycles.\n   llvm::DenseMap<AnyRequest, std::vector<AnyRequest>> dependencies;\n \n+  /// A stack of dependency sources in the order they were evaluated.\n+  llvm::SmallVector<evaluator::DependencySource, 8> dependencySources;\n+\n+  /// An RAII type that manages manipulating the evaluator's\n+  /// dependency source stack. It is specialized to be zero-cost for\n+  /// requests that are not dependency sources.\n+  template <typename Request, typename = detail::void_t<>>\n+  struct IncrementalDependencyStackRAII {\n+    IncrementalDependencyStackRAII(Evaluator &E, const Request &Req) {}\n+  };\n+\n+  template <typename Request>\n+  struct IncrementalDependencyStackRAII<\n+      Request, typename std::enable_if<Request::isDependencySource>::type> {\n+    NullablePtr<Evaluator> Eval;\n+    IncrementalDependencyStackRAII(Evaluator &E, const Request &Req) {\n+      auto Source = Req.readDependencySource(E);\n+      // If there is no source to introduce, bail. This can occur if\n+      // a request originates in the context of a module.\n+      if (!Source.getPointer()) {\n+        return;\n+      }\n+      E.dependencySources.emplace_back(Source);\n+      Eval = &E;\n+    }\n+\n+    ~IncrementalDependencyStackRAII() {\n+      if (Eval.isNonNull())\n+        Eval.get()->dependencySources.pop_back();\n+    }\n+  };\n+\n   /// Retrieve the request function for the given zone and request IDs.\n   AbstractRequestFunction *getAbstractRequestFunction(uint8_t zoneID,\n                                                       uint8_t requestID) const;\n@@ -264,6 +303,7 @@ class Evaluator {\n            typename std::enable_if<Request::isEverCached>::type * = nullptr>\n   llvm::Expected<typename Request::OutputType>\n   operator()(const Request &request) {\n+    IncrementalDependencyStackRAII<Request> incDeps{*this, request};\n     // The request can be cached, but check a predicate to determine\n     // whether this particular instance is cached. This allows more\n     // fine-grained control over which instances get cache.\n@@ -279,6 +319,7 @@ class Evaluator {\n            typename std::enable_if<!Request::isEverCached>::type * = nullptr>\n   llvm::Expected<typename Request::OutputType>\n   operator()(const Request &request) {\n+    IncrementalDependencyStackRAII<Request> incDeps{*this, request};\n     return getResultUncached(request);\n   }\n \n@@ -366,7 +407,9 @@ class Evaluator {\n     FrontendStatsTracer statsTracer = make_tracer(stats, request);\n     if (stats) reportEvaluatedRequest(*stats, request);\n \n-    return getRequestFunction<Request>()(request, *this);\n+    auto &&r = getRequestFunction<Request>()(request, *this);\n+    reportEvaluatedResult<Request>(request, r);\n+    return std::move(r);\n   }\n \n   /// Get the result of a request, consulting an external cache\n@@ -377,8 +420,10 @@ class Evaluator {\n   llvm::Expected<typename Request::OutputType>\n   getResultCached(const Request &request) {\n     // If there is a cached result, return it.\n-    if (auto cached = request.getCachedResult())\n+    if (auto cached = request.getCachedResult()) {\n+      reportEvaluatedResult<Request>(request, *cached);\n       return *cached;\n+    }\n \n     // Compute the result.\n     auto result = getResultUncached(request);\n@@ -403,7 +448,9 @@ class Evaluator {\n     // If we already have an entry for this request in the cache, return it.\n     auto known = cache.find_as(request);\n     if (known != cache.end()) {\n-      return known->second.template castTo<typename Request::OutputType>();\n+      auto r = known->second.template castTo<typename Request::OutputType>();\n+      reportEvaluatedResult<Request>(request, r);\n+      return r;\n     }\n \n     // Compute the result.\n@@ -416,6 +463,62 @@ class Evaluator {\n     return result;\n   }\n \n+private:\n+  // Report the result of evaluating a request that is not a dependency sink -\n+  // which is to say do nothing.\n+  template <typename Request,\n+            typename std::enable_if<!Request::isDependencySink>::type * = nullptr>\n+  void reportEvaluatedResult(const Request &r,\n+                             const typename Request::OutputType &o) {}\n+\n+  // Report the result of evaluating a request that is a dependency sink.\n+  template <typename Request,\n+            typename std::enable_if<Request::isDependencySink>::type * = nullptr>\n+  void reportEvaluatedResult(const Request &r,\n+                             const typename Request::OutputType &o) {\n+    if (auto *tracker = getActiveDependencyTracker())\n+      r.writeDependencySink(*this, *tracker, o);\n+  }\n+\n+  /// If there is an active dependency source, returns its\n+  /// \\c ReferencedNameTracker. Else, returns \\c nullptr.\n+  ReferencedNameTracker *getActiveDependencyTracker() const {\n+    if (auto *source = getActiveDependencySourceOrNull())\n+      return source->getRequestBasedReferencedNameTracker();\n+    return nullptr;\n+  }\n+\n+public:\n+  /// Returns \\c true if the scope of the current active source cascades.\n+  ///\n+  /// If there is no active scope, the result always cascades.\n+  bool isActiveSourceCascading() const {\n+    return getActiveSourceScope() == evaluator::DependencyScope::Cascading;\n+  }\n+\n+  /// Returns the scope of the current active scope.\n+  ///\n+  /// If there is no active scope, the result always cascades.\n+  evaluator::DependencyScope getActiveSourceScope() const {\n+    if (dependencySources.empty()) {\n+      return evaluator::DependencyScope::Cascading;\n+    }\n+    return dependencySources.back().getInt();\n+  }\n+\n+  /// Returns the active dependency's source file, or \\c nullptr if no\n+  /// dependency source is active.\n+  ///\n+  /// The use of this accessor is strongly discouraged, as it implies that a\n+  /// dependency sink is seeking to filter out names based on the files they\n+  /// come from. Existing callers are being migrated to more reasonable ways\n+  /// of judging the relevancy of a dependency.\n+  SourceFile *getActiveDependencySourceOrNull() const {\n+    if (dependencySources.empty())\n+      return nullptr;\n+    return dependencySources.back().getPointer();\n+  }\n+\n public:\n   /// Print the dependencies of the given request as a tree.\n   ///"
                    },
                    {
                        "filename": "include/swift/AST/EvaluatorDependencies.h",
                        "code": "@@ -0,0 +1,106 @@\n+//===--- EvaluatorDependencies.h - Auto-Incremental Dependencies -*- C++ -*-===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines data structures to support the request evaluator's\n+// automatic incremental dependency tracking functionality.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SWIFT_AST_EVALUATOR_DEPENDENCIES_H\n+#define SWIFT_AST_EVALUATOR_DEPENDENCIES_H\n+\n+#include \"swift/AST/AttrKind.h\"\n+#include \"swift/AST/SourceFile.h\"\n+#include \"llvm/ADT/PointerIntPair.h\"\n+\n+namespace swift {\n+\n+namespace evaluator {\n+\n+/// The \"scope\" of a dependency edge tracked by the evaluator.\n+///\n+/// Dependency scopes come in two flavors: cascading and private. A private\n+/// edge captures dependencies discovered in contexts that are not visible to\n+/// to other files. For example, a conformance to a private protocol, or the use\n+/// of any names inside of a function body. A cascading edge, by contrast,\n+/// captures dependencies discovered in the remaining visible contexts. These\n+/// are types with at least \\c internal visibility, names defined or used\n+/// outside of function bodies with at least \\c internal visibility, etc. A\n+/// dependency that has cascading scope is so-named because upon traversing the\n+/// edge, a reader such as the driver should continue transitively evaluating\n+/// further dependency edges.\n+///\n+/// A cascading edge is always conservatively correct to produce, but it comes\n+/// at the cost of increased resources spent (and possibly even wasted!) during\n+/// incremental compilation. A private edge, by contrast, is more efficient for\n+/// incremental compilation but it is harder to safely use.\n+///\n+/// To ensure that these edges are registered consistently with the correct\n+/// scopes, requests that act as the source of dependency edges are required\n+/// to specify a \\c DependencyScope under which all evaluated sub-requests will\n+/// register their dependency edges. In this way, \\c DependencyScope values\n+/// form a stack-like structure and are pushed and popped by the evaluator\n+/// during the course of request evaluation.\n+///\n+/// When determining the kind of scope a request should use, always err on the\n+/// side of a cascading scope unless there is absolute proof any discovered\n+/// dependencies will be private. Inner requests may also defensively choose to\n+/// flip the dependency scope from private to cascading in the name of safety.\n+enum class DependencyScope : bool {\n+  Private = false,\n+  Cascading = true,\n+};\n+\n+/// Returns a \\c DependencyScope appropriate for the given (formal) access level.\n+///\n+/// :warning: This function exists to bridge the old manual reference\n+/// dependencies code to the new evaluator-based reference dependencies code.\n+/// The manual code often made private/cascading scope judgements based on the\n+/// access level of a declaration. While this makes some sense intuitively, it\n+/// does not necessarily capture an accurate picture of where real incremental\n+/// dependencies lie. For example, references to formally private types can\n+/// \"escape\" to contexts that have no reference to the private name if, say,\n+/// the layout of that private type is taken into consideration by\n+/// SILGen or IRGen in a separate file that references the declaration\n+/// transitively. However, due to the density of the current dependency\n+/// graph, redundancy in registered dependency edges, and the liberal use of\n+/// cascading edges, we may be saved from the worst consequences of this\n+/// modelling choice.\n+///\n+/// The use of access-levels for dependency decisions is an anti-pattern that\n+/// should be revisited once finer-grained dependencies are explored more\n+/// thoroughly.\n+inline DependencyScope getScopeForAccessLevel(AccessLevel l) {\n+  switch (l) {\n+  case AccessLevel::Private:\n+  case AccessLevel::FilePrivate:\n+    return DependencyScope::Private;\n+  case AccessLevel::Internal:\n+  case AccessLevel::Public:\n+  case AccessLevel::Open:\n+    return DependencyScope::Cascading;\n+  }\n+}\n+\n+// A \\c DependencySource is currently defined to be a parent source file and\n+// an associated dependency scope.\n+//\n+// The \\c SourceFile instance is an artifact of the current dependency system,\n+// and should be scrapped if possible. It currently encodes the idea that\n+// edges in the incremental dependency graph invalidate entire files instead\n+// of individual contexts.\n+using DependencySource = llvm::PointerIntPair<SourceFile *, 1, DependencyScope>;\n+} // end namespace evaluator\n+\n+} // end namespace swift\n+\n+#endif // SWIFT_AST_EVALUATOR_DEPENDENCIES_H"
                    },
                    {
                        "filename": "include/swift/AST/Expr.h",
                        "code": "@@ -1333,9 +1333,9 @@ class SuperRefExpr : public Expr {\n   }\n };\n \n-/// A reference to a type in expression context, spelled out as a TypeLoc. Sema\n-/// forms this expression as a result of name binding.  This always has\n-/// MetaTypetype.\n+/// A reference to a type in expression context, spelled out as a TypeLoc.\n+///\n+/// The type of this expression is always \\c MetaTypeType.\n class TypeExpr : public Expr {\n   TypeLoc Info;\n   TypeExpr(Type Ty);\n@@ -2966,6 +2966,61 @@ class UnevaluatedInstanceExpr : public ImplicitConversionExpr {\n   }\n };\n \n+class DifferentiableFunctionExpr : public ImplicitConversionExpr {\n+public:\n+  DifferentiableFunctionExpr(Expr *subExpr, Type ty)\n+      : ImplicitConversionExpr(ExprKind::DifferentiableFunction, subExpr, ty) {}\n+\n+  static bool classof(const Expr *E) {\n+    return E->getKind() == ExprKind::DifferentiableFunction;\n+  }\n+};\n+\n+class LinearFunctionExpr : public ImplicitConversionExpr {\n+public:\n+  LinearFunctionExpr(Expr *subExpr, Type ty)\n+      : ImplicitConversionExpr(ExprKind::LinearFunction, subExpr, ty) {}\n+\n+  static bool classof(const Expr *E) {\n+    return E->getKind() == ExprKind::LinearFunction;\n+  }\n+};\n+\n+class DifferentiableFunctionExtractOriginalExpr\n+    : public ImplicitConversionExpr {\n+public:\n+  DifferentiableFunctionExtractOriginalExpr(Expr *subExpr, Type ty)\n+      : ImplicitConversionExpr(ExprKind::DifferentiableFunctionExtractOriginal,\n+                               subExpr, ty) {}\n+\n+  static bool classof(const Expr *E) {\n+    return E->getKind() == ExprKind::DifferentiableFunctionExtractOriginal;\n+  }\n+};\n+\n+class LinearFunctionExtractOriginalExpr : public ImplicitConversionExpr {\n+public:\n+  LinearFunctionExtractOriginalExpr(Expr *subExpr, Type ty)\n+      : ImplicitConversionExpr(ExprKind::LinearFunctionExtractOriginal,\n+                               subExpr, ty) {}\n+\n+  static bool classof(const Expr *E) {\n+    return E->getKind() == ExprKind::LinearFunctionExtractOriginal;\n+  }\n+};\n+\n+class LinearToDifferentiableFunctionExpr : public ImplicitConversionExpr {\n+public:\n+  LinearToDifferentiableFunctionExpr(Expr *subExpr, Type ty)\n+      : ImplicitConversionExpr(\n+            ExprKind::LinearToDifferentiableFunction, subExpr, ty) {}\n+\n+  static bool classof(const Expr *E) {\n+    return E->getKind() == ExprKind::LinearToDifferentiableFunction;\n+  }\n+};\n+\n+\n /// Use an opaque type to abstract a value of the underlying concrete type.\n class UnderlyingToOpaqueExpr : public ImplicitConversionExpr {\n public:\n@@ -4776,7 +4831,7 @@ class AssignExpr : public Expr {\n };\n \n /// A pattern production that has been parsed but hasn't been resolved\n-/// into a complete pattern. Name binding converts these into standalone pattern\n+/// into a complete pattern. Pattern checking converts these into standalone pattern\n /// nodes or raises an error if a pattern production appears in an invalid\n /// position.\n class UnresolvedPatternExpr : public Expr {"
                    },
                    {
                        "filename": "include/swift/AST/ExprNodes.def",
                        "code": "@@ -170,7 +170,12 @@ ABSTRACT_EXPR(ImplicitConversion, Expr)\n   EXPR(ForeignObjectConversion, ImplicitConversionExpr)\n   EXPR(UnevaluatedInstance, ImplicitConversionExpr)\n   EXPR(UnderlyingToOpaque, ImplicitConversionExpr)\n-  EXPR_RANGE(ImplicitConversion, Load, UnderlyingToOpaque)\n+  EXPR(DifferentiableFunction, ImplicitConversionExpr)\n+  EXPR(LinearFunction, ImplicitConversionExpr)\n+  EXPR(DifferentiableFunctionExtractOriginal, ImplicitConversionExpr)\n+  EXPR(LinearFunctionExtractOriginal, ImplicitConversionExpr)\n+  EXPR(LinearToDifferentiableFunction, ImplicitConversionExpr)\n+  EXPR_RANGE(ImplicitConversion, Load, LinearToDifferentiableFunction)\n ABSTRACT_EXPR(ExplicitCast, Expr)\n   ABSTRACT_EXPR(CheckedCast, ExplicitCastExpr)\n     EXPR(ForcedCheckedCast, CheckedCastExpr)"
                    },
                    {
                        "filename": "include/swift/AST/FileUnit.h",
                        "code": "@@ -30,6 +30,9 @@ class FileUnit : public DeclContext {\n #pragma clang diagnostic pop\n   virtual void anchor();\n \n+  friend class DirectOperatorLookupRequest;\n+  friend class DirectPrecedenceGroupLookupRequest;\n+\n   // FIXME: Stick this in a PointerIntPair.\n   const FileUnitKind Kind;\n \n@@ -107,6 +110,25 @@ class FileUnit : public DeclContext {\n                                const ModuleDecl *importedModule,\n                                SmallVectorImpl<Identifier> &spiGroups) const {};\n \n+protected:\n+  /// Look up an operator declaration. Do not call directly, use\n+  /// \\c DirectOperatorLookupRequest instead.\n+  ///\n+  /// \\param name The operator name (\"+\", \">>\", etc.)\n+  ///\n+  /// \\param fixity One of Prefix, Infix, or Postfix.\n+  virtual void\n+  lookupOperatorDirect(Identifier name, OperatorFixity fixity,\n+                       TinyPtrVector<OperatorDecl *> &results) const {}\n+\n+  /// Look up a precedence group. Do not call directly, use\n+  /// \\c DirectPrecedenceGroupLookupRequest instead.\n+  ///\n+  /// \\param name The precedence group name.\n+  virtual void lookupPrecedenceGroupDirect(\n+      Identifier name, TinyPtrVector<PrecedenceGroupDecl *> &results) const {}\n+\n+public:\n   /// Returns the comment attached to the given declaration.\n   ///\n   /// This function is an implementation detail for comment serialization.\n@@ -174,6 +196,13 @@ class FileUnit : public DeclContext {\n               SmallVectorImpl<Decl*> &Results,\n               llvm::function_ref<bool(DeclAttributes)> matchAttributes) const;\n \n+  /// Finds all operator decls in this file.\n+  ///\n+  /// This does a simple local lookup, not recursively looking through imports.\n+  /// The order of the results is not guaranteed to be meaningful.\n+  virtual void\n+  getOperatorDecls(SmallVectorImpl<OperatorDecl *> &results) const {}\n+\n   /// Finds all precedence group decls in this file.\n   ///\n   /// This does a simple local lookup, not recursively looking through imports.\n@@ -342,22 +371,6 @@ class LoadedFile : public FileUnit {\n     return StringRef();\n   }\n \n-  /// Look up an operator declaration.\n-  ///\n-  /// \\param name The operator name (\"+\", \">>\", etc.)\n-  ///\n-  /// \\param fixity One of PrefixOperator, InfixOperator, or PostfixOperator.\n-  virtual OperatorDecl *lookupOperator(Identifier name, DeclKind fixity) const {\n-    return nullptr;\n-  }\n-\n-  /// Look up a precedence group.\n-  ///\n-  /// \\param name The precedence group name.\n-  virtual PrecedenceGroupDecl *lookupPrecedenceGroup(Identifier name) const {\n-    return nullptr;\n-  }\n-\n   /// Returns the Swift module that overlays a Clang module.\n   virtual ModuleDecl *getOverlayModule() const { return nullptr; }\n "
                    },
                    {
                        "filename": "include/swift/AST/IRGenOptions.h",
                        "code": "@@ -280,6 +280,9 @@ class IRGenOptions {\n   /// Whether to disable shadow copies for local variables on the stack. This is\n   /// only used for testing.\n   unsigned DisableDebuggerShadowCopies : 1;\n+  \n+  /// Whether to disable using mangled names for accessing concrete type metadata.\n+  unsigned DisableConcreteTypeMetadataMangledNameAccessors : 1;\n \n   /// Path to the profdata file to be used for PGO, or the empty string.\n   std::string UseProfile = \"\";\n@@ -327,6 +330,7 @@ class IRGenOptions {\n         UseSwiftCall(false), UseTypeLayoutValueHandling(true), GenerateProfile(false),\n         EnableDynamicReplacementChaining(false),\n         DisableRoundTripDebugTypes(false), DisableDebuggerShadowCopies(false),\n+        DisableConcreteTypeMetadataMangledNameAccessors(false),\n         CmdArgs(), SanitizeCoverage(llvm::SanitizerCoverageOptions()),\n         TypeInfoFilter(TypeInfoDumpFilter::All) {}\n "
                    },
                    {
                        "filename": "include/swift/AST/IRGenRequests.h",
                        "code": "@@ -18,6 +18,7 @@\n #define SWIFT_IRGen_REQUESTS_H\n \n #include \"swift/AST/ASTTypeIDs.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n #include \"swift/AST/SimpleRequest.h\"\n #include \"swift/Basic/PrimarySpecificPaths.h\"\n #include \"llvm/ADT/StringSet.h\"\n@@ -116,33 +117,37 @@ void reportEvaluatedRequest(UnifiedStatsReporter &stats,\n class IRGenSourceFileRequest\n     : public SimpleRequest<IRGenSourceFileRequest,\n                            std::unique_ptr<llvm::Module>(IRGenDescriptor),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached|RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::unique_ptr<llvm::Module>>\n+  std::unique_ptr<llvm::Module>\n   evaluate(Evaluator &evaluator, IRGenDescriptor desc) const;\n \n public:\n   bool isCached() const { return true; }\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n class IRGenWholeModuleRequest\n     : public SimpleRequest<IRGenWholeModuleRequest,\n                            std::unique_ptr<llvm::Module>(IRGenDescriptor),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::unique_ptr<llvm::Module>>\n+  std::unique_ptr<llvm::Module>\n   evaluate(Evaluator &evaluator, IRGenDescriptor desc) const;\n \n public:"
                    },
                    {
                        "filename": "include/swift/AST/Identifier.h",
                        "code": "@@ -168,6 +168,10 @@ class Identifier {\n   /// Null identifiers come after all other identifiers.\n   int compare(Identifier other) const;\n \n+  friend llvm::hash_code hash_value(Identifier ident) {\n+    return llvm::hash_value(ident.getAsOpaquePointer());\n+  }\n+\n   bool operator==(Identifier RHS) const { return Pointer == RHS.Pointer; }\n   bool operator!=(Identifier RHS) const { return !(*this==RHS); }\n "
                    },
                    {
                        "filename": "include/swift/AST/ImportCache.h",
                        "code": "@@ -148,7 +148,7 @@ class alignas(ModuleDecl::ImportedModule) ImportCache {\n                                  const DeclContext *dc);\n \n   /// This is a hack to cope with main file parsing and REPL parsing, where\n-  /// we can add ImportDecls after name binding.\n+  /// we can add ImportDecls after import resolution.\n   void clear() {\n     ImportSetForDC.clear();\n   }"
                    },
                    {
                        "filename": "include/swift/AST/KnownIdentifiers.def",
                        "code": "@@ -204,7 +204,13 @@ IDENTIFIER_(nsError)\n IDENTIFIER(OSLogMessage)\n \n // Differentiable programming\n+IDENTIFIER(along)\n+IDENTIFIER(differential)\n+IDENTIFIER(direction)\n+IDENTIFIER(move)\n+IDENTIFIER(pullback)\n IDENTIFIER(TangentVector)\n+IDENTIFIER(zero)\n \n #undef IDENTIFIER\n #undef IDENTIFIER_"
                    },
                    {
                        "filename": "include/swift/AST/KnownProtocols.def",
                        "code": "@@ -84,6 +84,7 @@ PROTOCOL_(DestructorSafeContainer)\n \n PROTOCOL(StringInterpolationProtocol)\n \n+PROTOCOL(AdditiveArithmetic)\n PROTOCOL(Differentiable)\n \n EXPRESSIBLE_BY_LITERAL_PROTOCOL(ExpressibleByArrayLiteral, \"Array\", false)"
                    },
                    {
                        "filename": "include/swift/AST/Module.h",
                        "code": "@@ -165,6 +165,9 @@ class OverlayFile;\n ///\n /// \\sa FileUnit\n class ModuleDecl : public DeclContext, public TypeDecl {\n+  friend class DirectOperatorLookupRequest;\n+  friend class DirectPrecedenceGroupLookupRequest;\n+\n public:\n   typedef ArrayRef<Located<Identifier>> AccessPathTy;\n   typedef std::pair<ModuleDecl::AccessPathTy, ModuleDecl*> ImportedModule;\n@@ -335,6 +338,31 @@ class ModuleDecl : public DeclContext, public TypeDecl {\n   void getDeclaredCrossImportBystanders(\n       SmallVectorImpl<Identifier> &bystanderNames);\n \n+  /// A lazily populated  mapping from each declared cross import overlay this\n+  /// module transitively underlies to its bystander and immediate underlying\n+  /// module.\n+  llvm::SmallDenseMap<ModuleDecl *, std::pair<Identifier, ModuleDecl *>, 1>\n+  declaredCrossImportsTransitive;\n+\n+  /// Determines if the given \\p overlay is a declarared cross-import overlay of\n+  /// this module, or an of its transitively declared overlay modules.\n+  ///\n+  /// This is used by tooling to map overlays to their underlying modules, and t\n+  bool isUnderlyingModuleOfCrossImportOverlay(const ModuleDecl *overlay);\n+\n+  /// If \\p overlay is a transitively declared cross-import overlay of this\n+  /// module, gets the list of bystander modules that need to be imported\n+  /// alongside this module for the overlay to be loaded.\n+  void getAllBystandersForCrossImportOverlay(\n+      ModuleDecl *overlay, SmallVectorImpl<Identifier> &bystanders);\n+\n+  /// Walks and loads the declared cross-import overlays of this module,\n+  /// transitively, to find all overlays this module underlies.\n+  ///\n+  /// This is used by tooling to present these overlays as part of this module.\n+  void findDeclaredCrossImportOverlaysTransitive(\n+      SmallVectorImpl<ModuleDecl *> &overlays);\n+\n   /// Convenience accessor for clients that know what kind of file they're\n   /// dealing with.\n   SourceFile &getMainSourceFile(SourceFileKind expectedKind) const;\n@@ -595,6 +623,12 @@ class ModuleDecl : public DeclContext, public TypeDecl {\n   /// The order of the results is not guaranteed to be meaningful.\n   void getLocalTypeDecls(SmallVectorImpl<TypeDecl*> &Results) const;\n \n+  /// Finds all operator decls of this module.\n+  ///\n+  /// This does a simple local lookup, not recursively looking through imports.\n+  /// The order of the results is not guaranteed to be meaningful.\n+  void getOperatorDecls(SmallVectorImpl<OperatorDecl *> &results) const;\n+\n   /// Finds all precedence group decls of this module.\n   ///\n   /// This does a simple local lookup, not recursively looking through imports."
                    },
                    {
                        "filename": "include/swift/AST/ModuleLoader.h",
                        "code": "@@ -36,6 +36,7 @@ class DependencyCollector;\n namespace swift {\n \n class AbstractFunctionDecl;\n+struct AutoDiffConfig;\n class ClangImporterOptions;\n class ClassDecl;\n class FileUnit;\n@@ -153,6 +154,23 @@ class ModuleLoader {\n                  unsigned previousGeneration,\n                  llvm::TinyPtrVector<AbstractFunctionDecl *> &methods) = 0;\n \n+  /// Load derivative function configurations for the given\n+  /// AbstractFunctionDecl.\n+  ///\n+  /// \\param originalAFD The declaration whose derivative function\n+  /// configurations should be loaded.\n+  ///\n+  /// \\param previousGeneration The previous generation number. The AST already\n+  /// contains derivative function configurations loaded from any generation up\n+  /// to and including this one.\n+  ///\n+  /// \\param results The result list of derivative function configurations.\n+  /// This list will be extended with any methods found in subsequent\n+  /// generations.\n+  virtual void loadDerivativeFunctionConfigurations(\n+      AbstractFunctionDecl *originalAFD, unsigned previousGeneration,\n+      llvm::SetVector<AutoDiffConfig> &results) {};\n+\n   /// Verify all modules loaded by this loader.\n   virtual void verifyAllModules() { }\n "
                    },
                    {
                        "filename": "include/swift/AST/NameLookup.h",
                        "code": "@@ -263,9 +263,9 @@ enum class DeclVisibilityKind {\n   /// \\endcode\n   MemberOfCurrentNominal,\n \n-  /// Declaration that is a requirement of a protocol implemented by the\n-  /// immediately enclosing nominal decl, in case the nominal decl does not\n-  /// supply a witness for this requirement.\n+  /// Declaration is a requirement \u2013 in case the nominal decl does not supply\n+  /// a corresponding witness \u2013 or an extension member of a protocol\n+  /// conformed to by the immediately enclosing nominal decl.\n   ///\n   /// For example, 'foo' is visible at (1) because of this.\n   /// \\code\n@@ -278,7 +278,12 @@ enum class DeclVisibilityKind {\n   ///   }\n   /// }\n   /// \\endcode\n-  MemberOfProtocolImplementedByCurrentNominal,\n+  MemberOfProtocolConformedToByCurrentNominal,\n+\n+  /// Declaration is a derived requirement of a protocol conformed to by the\n+  /// immediately enclosing nominal decl (a witness for a synthesized\n+  /// conformance).\n+  MemberOfProtocolDerivedByCurrentNominal,\n \n   /// Declaration is a member of the superclass of the immediately enclosing\n   /// nominal decl.\n@@ -467,6 +472,7 @@ void lookupVisibleMemberDecls(VisibleDeclConsumer &Consumer,\n                               Type BaseTy,\n                               const DeclContext *CurrDC,\n                               bool includeInstanceMembers,\n+                              bool includeDerivedRequirements,\n                               GenericSignatureBuilder *GSB = nullptr);\n \n namespace namelookup {"
                    },
                    {
                        "filename": "include/swift/AST/NameLookupRequests.h",
                        "code": "@@ -18,6 +18,10 @@\n \n #include \"swift/AST/SimpleRequest.h\"\n #include \"swift/AST/ASTTypeIDs.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n+#include \"swift/AST/FileUnit.h\"\n+#include \"swift/AST/Identifier.h\"\n+#include \"swift/AST/NameLookup.h\"\n #include \"swift/Basic/Statistic.h\"\n #include \"llvm/ADT/Hashing.h\"\n #include \"llvm/ADT/TinyPtrVector.h\"\n@@ -77,7 +81,7 @@ class InheritedDeclsReferencedRequest :\n                        DirectlyReferencedTypeDecls(\n                          llvm::PointerUnion<TypeDecl *, ExtensionDecl *>,\n                          unsigned),\n-                       CacheKind::Uncached> // FIXME: Cache these\n+                       RequestFlags::Uncached> // FIXME: Cache these\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -121,7 +125,7 @@ class InheritedDeclsReferencedRequest :\n class UnderlyingTypeDeclsReferencedRequest :\n   public SimpleRequest<UnderlyingTypeDeclsReferencedRequest,\n                        DirectlyReferencedTypeDecls(TypeAliasDecl *),\n-                       CacheKind::Uncached> // FIXME: Cache these\n+                       RequestFlags::Uncached> // FIXME: Cache these\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -143,15 +147,15 @@ class UnderlyingTypeDeclsReferencedRequest :\n class SuperclassDeclRequest :\n     public SimpleRequest<SuperclassDeclRequest,\n                          ClassDecl *(NominalTypeDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ClassDecl *>\n+  ClassDecl *\n   evaluate(Evaluator &evaluator, NominalTypeDecl *subject) const;\n \n public:\n@@ -161,20 +165,48 @@ class SuperclassDeclRequest :\n   void cacheResult(ClassDecl *value) const;\n };\n \n+class InheritedProtocolsRequest\n+    : public SimpleRequest<\n+          InheritedProtocolsRequest, ArrayRef<ProtocolDecl *>(ProtocolDecl *),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySink |\n+              RequestFlags::DependencySource> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  // Evaluation.\n+  ArrayRef<ProtocolDecl *>\n+  evaluate(Evaluator &evaluator, ProtocolDecl *PD) const;\n+\n+public:\n+  // Caching\n+  bool isCached() const { return true; }\n+  Optional<ArrayRef<ProtocolDecl *>> getCachedResult() const;\n+  void cacheResult(ArrayRef<ProtocolDecl *> value) const;\n+\n+public:\n+  // Incremental dependencies\n+  evaluator::DependencySource readDependencySource(Evaluator &e) const;\n+  void writeDependencySink(Evaluator &evaluator, ReferencedNameTracker &tracker,\n+                           ArrayRef<ProtocolDecl *> result) const;\n+};\n+\n /// Requests whether or not this class has designated initializers that are\n /// not public or @usableFromInline.\n class HasMissingDesignatedInitializersRequest :\n     public SimpleRequest<HasMissingDesignatedInitializersRequest,\n                          bool(ClassDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, ClassDecl *subject) const;\n \n public:\n@@ -185,25 +217,30 @@ class HasMissingDesignatedInitializersRequest :\n };\n \n /// Request the nominal declaration extended by a given extension declaration.\n-class ExtendedNominalRequest :\n-    public SimpleRequest<ExtendedNominalRequest,\n-                         NominalTypeDecl *(ExtensionDecl *),\n-                         CacheKind::SeparatelyCached> {\n+class ExtendedNominalRequest\n+    : public SimpleRequest<\n+          ExtendedNominalRequest, NominalTypeDecl *(ExtensionDecl *),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySink> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<NominalTypeDecl *>\n+  NominalTypeDecl *\n   evaluate(Evaluator &evaluator, ExtensionDecl *ext) const;\n \n public:\n   // Separate caching.\n   bool isCached() const { return true; }\n   Optional<NominalTypeDecl *> getCachedResult() const;\n   void cacheResult(NominalTypeDecl *value) const;\n+\n+public:\n+  // Incremental dependencies\n+  void writeDependencySink(Evaluator &evaluator, ReferencedNameTracker &tracker,\n+                           NominalTypeDecl *result) const;\n };\n \n struct SelfBounds {\n@@ -217,7 +254,7 @@ class SelfBoundsFromWhereClauseRequest :\n     public SimpleRequest<SelfBoundsFromWhereClauseRequest,\n                          SelfBounds(llvm::PointerUnion<TypeDecl *,\n                                                        ExtensionDecl *>),\n-                         CacheKind::Uncached> {\n+                         RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -235,7 +272,7 @@ class SelfBoundsFromWhereClauseRequest :\n class TypeDeclsFromWhereClauseRequest :\n     public SimpleRequest<TypeDeclsFromWhereClauseRequest,\n                          DirectlyReferencedTypeDecls(ExtensionDecl *),\n-                         CacheKind::Uncached> {\n+                         RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -252,15 +289,15 @@ class TypeDeclsFromWhereClauseRequest :\n class CustomAttrNominalRequest :\n     public SimpleRequest<CustomAttrNominalRequest,\n                          NominalTypeDecl *(CustomAttr *, DeclContext *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<NominalTypeDecl *>\n+  NominalTypeDecl *\n   evaluate(Evaluator &evaluator, CustomAttr *attr, DeclContext *dc) const;\n \n public:\n@@ -269,39 +306,43 @@ class CustomAttrNominalRequest :\n };\n \n /// Finds or synthesizes a destructor for the given class.\n-class GetDestructorRequest :\n-    public SimpleRequest<GetDestructorRequest,\n-                         DestructorDecl *(ClassDecl *),\n-                         CacheKind::SeparatelyCached> {\n+class GetDestructorRequest\n+    : public SimpleRequest<GetDestructorRequest, DestructorDecl *(ClassDecl *),\n+                           RequestFlags::SeparatelyCached |\n+                               RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<DestructorDecl *>\n+  DestructorDecl *\n   evaluate(Evaluator &evaluator, ClassDecl *classDecl) const;\n \n public:\n   // Caching\n   bool isCached() const { return true; }\n   Optional<DestructorDecl *> getCachedResult() const;\n   void cacheResult(DestructorDecl *value) const;\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n class GenericParamListRequest :\n     public SimpleRequest<GenericParamListRequest,\n                          GenericParamList *(GenericContext *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n   \n private:\n   friend SimpleRequest;\n   \n   // Evaluation.\n-  llvm::Expected<GenericParamList *>\n+  GenericParamList *\n   evaluate(Evaluator &evaluator, GenericContext *value) const;\n   \n public:\n@@ -316,15 +357,15 @@ class ExpandASTScopeRequest\n     : public SimpleRequest<ExpandASTScopeRequest,\n                            ast_scope::ASTScopeImpl *(ast_scope::ASTScopeImpl *,\n                                                      ast_scope::ScopeCreator *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ast_scope::ASTScopeImpl *>\n+  ast_scope::ASTScopeImpl *\n   evaluate(Evaluator &evaluator, ast_scope::ASTScopeImpl *,\n            ast_scope::ScopeCreator *) const;\n \n@@ -376,16 +417,23 @@ SourceLoc extractNearestSourceLoc(const UnqualifiedLookupDescriptor &desc);\n class UnqualifiedLookupRequest\n     : public SimpleRequest<UnqualifiedLookupRequest,\n                            LookupResult(UnqualifiedLookupDescriptor),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached | RequestFlags::DependencySource |\n+                               RequestFlags::DependencySink> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<LookupResult> evaluate(Evaluator &evaluator,\n-                                        UnqualifiedLookupDescriptor desc) const;\n+  LookupResult evaluate(Evaluator &evaluator,\n+                        UnqualifiedLookupDescriptor desc) const;\n+\n+public:\n+  // Incremental dependencies\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n+  void writeDependencySink(Evaluator &eval, ReferencedNameTracker &tracker,\n+                           LookupResult res) const;\n };\n \n using QualifiedLookupResult = SmallVector<ValueDecl *, 4>;\n@@ -396,15 +444,15 @@ class LookupInModuleRequest\n                            QualifiedLookupResult(\n                                const DeclContext *, DeclName, NLKind,\n                                namelookup::ResolutionKind, const DeclContext *),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<QualifiedLookupResult>\n+  QualifiedLookupResult\n   evaluate(Evaluator &evaluator, const DeclContext *moduleOrFile, DeclName name,\n            NLKind lookupKind, namelookup::ResolutionKind resolutionKind,\n            const DeclContext *moduleScopeContext) const;\n@@ -415,56 +463,72 @@ class AnyObjectLookupRequest\n     : public SimpleRequest<AnyObjectLookupRequest,\n                            QualifiedLookupResult(const DeclContext *,\n                                                  DeclNameRef, NLOptions),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached | RequestFlags::DependencySink> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n-  llvm::Expected<QualifiedLookupResult> evaluate(Evaluator &evaluator,\n-                                                 const DeclContext *dc,\n-                                                 DeclNameRef name,\n-                                                 NLOptions options) const;\n+  QualifiedLookupResult evaluate(Evaluator &evaluator,\n+                                 const DeclContext *dc,\n+                                 DeclNameRef name,\n+                                 NLOptions options) const;\n+\n+public:\n+  // Incremental dependencies\n+  void writeDependencySink(Evaluator &eval, ReferencedNameTracker &tracker,\n+                           QualifiedLookupResult l) const;\n };\n \n class ModuleQualifiedLookupRequest\n     : public SimpleRequest<ModuleQualifiedLookupRequest,\n                            QualifiedLookupResult(const DeclContext *,\n                                                  ModuleDecl *, DeclNameRef,\n                                                  NLOptions),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached | RequestFlags::DependencySource |\n+                              RequestFlags::DependencySink> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<QualifiedLookupResult> evaluate(Evaluator &evaluator,\n-                                                 const DeclContext *DC,\n-                                                 ModuleDecl *mod, DeclNameRef name,\n-                                                 NLOptions opts) const;\n+  QualifiedLookupResult evaluate(Evaluator &evaluator,\n+                                 const DeclContext *DC,\n+                                 ModuleDecl *mod, DeclNameRef name,\n+                                 NLOptions opts) const;\n+\n+public:\n+  // Incremental dependencies\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n+  void writeDependencySink(Evaluator &eval, ReferencedNameTracker &tracker,\n+                           QualifiedLookupResult lookupResult) const;\n };\n \n class QualifiedLookupRequest\n     : public SimpleRequest<QualifiedLookupRequest,\n                            QualifiedLookupResult(const DeclContext *,\n                                                  SmallVector<NominalTypeDecl *, 4>,\n                                                  DeclNameRef, NLOptions),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached | RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<QualifiedLookupResult>\n+  QualifiedLookupResult\n   evaluate(Evaluator &evaluator, const DeclContext *DC,\n            SmallVector<NominalTypeDecl *, 4> decls,\n            DeclNameRef name,\n            NLOptions opts) const;\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n /// The input type for a direct lookup request.\n@@ -503,16 +567,196 @@ SourceLoc extractNearestSourceLoc(const DirectLookupDescriptor &desc);\n class DirectLookupRequest\n     : public SimpleRequest<DirectLookupRequest,\n                            TinyPtrVector<ValueDecl *>(DirectLookupDescriptor),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached|RequestFlags::DependencySink> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<TinyPtrVector<ValueDecl *>>\n+  TinyPtrVector<ValueDecl *>\n   evaluate(Evaluator &evaluator, DirectLookupDescriptor desc) const;\n+\n+public:\n+  // Incremental dependencies\n+  void writeDependencySink(Evaluator &evaluator, ReferencedNameTracker &tracker,\n+                           TinyPtrVector<ValueDecl *> result) const;\n+};\n+\n+class OperatorLookupDescriptor final {\n+public:\n+  using Storage = llvm::PointerUnion<FileUnit *, ModuleDecl *>;\n+  Storage fileOrModule;\n+  Identifier name;\n+  bool isCascading;\n+  SourceLoc diagLoc;\n+\n+private:\n+  OperatorLookupDescriptor(Storage fileOrModule, Identifier name,\n+                           bool isCascading, SourceLoc diagLoc)\n+      : fileOrModule(fileOrModule), name(name), isCascading(isCascading),\n+        diagLoc(diagLoc) {}\n+\n+public:\n+  /// Retrieves the files to perform lookup in.\n+  ArrayRef<FileUnit *> getFiles() const;\n+\n+  /// If this is for a module lookup, returns the module. Otherwise returns\n+  /// \\c nullptr.\n+  ModuleDecl *getModule() const {\n+    return fileOrModule.dyn_cast<ModuleDecl *>();\n+  }\n+\n+  friend llvm::hash_code hash_value(const OperatorLookupDescriptor &desc) {\n+    return llvm::hash_combine(desc.fileOrModule, desc.name, desc.isCascading);\n+  }\n+\n+  friend bool operator==(const OperatorLookupDescriptor &lhs,\n+                         const OperatorLookupDescriptor &rhs) {\n+    return lhs.fileOrModule == rhs.fileOrModule && lhs.name == rhs.name &&\n+           lhs.isCascading == rhs.isCascading;\n+  }\n+\n+  friend bool operator!=(const OperatorLookupDescriptor &lhs,\n+                         const OperatorLookupDescriptor &rhs) {\n+    return !(lhs == rhs);\n+  }\n+\n+  static OperatorLookupDescriptor forFile(FileUnit *file, Identifier name,\n+                                          bool isCascading, SourceLoc diagLoc) {\n+    return OperatorLookupDescriptor(file, name, isCascading, diagLoc);\n+  }\n+\n+  static OperatorLookupDescriptor forModule(ModuleDecl *mod, Identifier name,\n+                                            bool isCascading,\n+                                            SourceLoc diagLoc) {\n+    return OperatorLookupDescriptor(mod, name, isCascading, diagLoc);\n+  }\n+};\n+\n+void simple_display(llvm::raw_ostream &out,\n+                    const OperatorLookupDescriptor &desc);\n+\n+SourceLoc extractNearestSourceLoc(const OperatorLookupDescriptor &desc);\n+\n+template <typename OperatorType>\n+class LookupOperatorRequest\n+    : public SimpleRequest<LookupOperatorRequest<OperatorType>,\n+                           OperatorType *(OperatorLookupDescriptor),\n+                           RequestFlags::Cached|RequestFlags::DependencySink> {\n+  using SimpleRequest<LookupOperatorRequest<OperatorType>,\n+                      OperatorType *(OperatorLookupDescriptor),\n+                      RequestFlags::Cached |\n+                          RequestFlags::DependencySink>::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest<LookupOperatorRequest<OperatorType>,\n+                       OperatorType *(OperatorLookupDescriptor),\n+                       RequestFlags::Cached|RequestFlags::DependencySink>;\n+\n+  // Evaluation.\n+  OperatorType *evaluate(Evaluator &evaluator,\n+                         OperatorLookupDescriptor desc) const;\n+\n+public:\n+  // Cached.\n+  bool isCached() const { return true; }\n+\n+public:\n+  // Incremental dependencies\n+  void writeDependencySink(Evaluator &evaluator, ReferencedNameTracker &tracker,\n+                           OperatorType *o) const;\n+};\n+\n+using LookupPrefixOperatorRequest = LookupOperatorRequest<PrefixOperatorDecl>;\n+using LookupInfixOperatorRequest = LookupOperatorRequest<InfixOperatorDecl>;\n+using LookupPostfixOperatorRequest = LookupOperatorRequest<PostfixOperatorDecl>;\n+using LookupPrecedenceGroupRequest = LookupOperatorRequest<PrecedenceGroupDecl>;\n+\n+/// Looks up an operator in a given file or module without looking through\n+/// imports.\n+class DirectOperatorLookupRequest\n+    : public SimpleRequest<DirectOperatorLookupRequest,\n+                           TinyPtrVector<OperatorDecl *>(\n+                               OperatorLookupDescriptor, OperatorFixity),\n+                           RequestFlags::Uncached> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  TinyPtrVector<OperatorDecl *>\n+  evaluate(Evaluator &evaluator, OperatorLookupDescriptor descriptor,\n+           OperatorFixity fixity) const;\n+};\n+\n+/// Looks up an precedencegroup in a given file or module without looking\n+/// through imports.\n+class DirectPrecedenceGroupLookupRequest\n+    : public SimpleRequest<DirectPrecedenceGroupLookupRequest,\n+                           TinyPtrVector<PrecedenceGroupDecl *>(\n+                               OperatorLookupDescriptor),\n+                           RequestFlags::Uncached> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  TinyPtrVector<PrecedenceGroupDecl *>\n+  evaluate(Evaluator &evaluator, OperatorLookupDescriptor descriptor) const;\n+};\n+\n+class LookupConformanceDescriptor final {\n+public:\n+  ModuleDecl *Mod;\n+  Type Ty;\n+  ProtocolDecl *PD;\n+\n+  LookupConformanceDescriptor(ModuleDecl *Mod, Type Ty, ProtocolDecl *PD)\n+      : Mod(Mod), Ty(Ty), PD(PD) {}\n+\n+  friend llvm::hash_code hash_value(const LookupConformanceDescriptor &desc) {\n+    return llvm::hash_combine(desc.Mod, desc.Ty.getPointer(), desc.PD);\n+  }\n+\n+  friend bool operator==(const LookupConformanceDescriptor &lhs,\n+                         const LookupConformanceDescriptor &rhs) {\n+    return lhs.Mod == rhs.Mod && lhs.Ty.getPointer() == rhs.Ty.getPointer() &&\n+           lhs.PD == rhs.PD;\n+  }\n+\n+  friend bool operator!=(const LookupConformanceDescriptor &lhs,\n+                         const LookupConformanceDescriptor &rhs) {\n+    return !(lhs == rhs);\n+  }\n+};\n+\n+void simple_display(llvm::raw_ostream &out,\n+                    const LookupConformanceDescriptor &desc);\n+\n+SourceLoc extractNearestSourceLoc(const LookupConformanceDescriptor &desc);\n+\n+class LookupConformanceInModuleRequest\n+    : public SimpleRequest<LookupConformanceInModuleRequest,\n+                           ProtocolConformanceRef(LookupConformanceDescriptor),\n+                           RequestFlags::Uncached|RequestFlags::DependencySink> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  // Evaluation.\n+  ProtocolConformanceRef evaluate(\n+      Evaluator &evaluator, LookupConformanceDescriptor desc) const;\n+\n+public:\n+  // Incremental dependencies\n+  void writeDependencySink(Evaluator &evaluator, ReferencedNameTracker &tracker,\n+                           ProtocolConformanceRef result) const;\n };\n \n #define SWIFT_TYPEID_ZONE NameLookup"
                    },
                    {
                        "filename": "include/swift/AST/NameLookupTypeIDZone.def",
                        "code": "@@ -24,6 +24,13 @@ SWIFT_REQUEST(NameLookup, CustomAttrNominalRequest,\n SWIFT_REQUEST(NameLookup, DirectLookupRequest,\n               TinyPtrVector<ValueDecl *>(DirectLookupDescriptor), Uncached,\n               NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, DirectOperatorLookupRequest,\n+              TinyPtrVector<OperatorDecl *>(OperatorLookupDescriptor,\n+                                            OperatorFixity),\n+              Uncached, NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, DirectPrecedenceGroupLookupRequest,\n+              TinyPtrVector<PrecedenceGroupDecl *>(OperatorLookupDescriptor),\n+              Uncached, NoLocationInfo)\n SWIFT_REQUEST(NameLookup, ExpandASTScopeRequest,\n               ast_scope::ASTScopeImpl* (ast_scope::ASTScopeImpl*, ast_scope::ScopeCreator*),\n               SeparatelyCached,\n@@ -40,6 +47,12 @@ SWIFT_REQUEST(NameLookup, InheritedDeclsReferencedRequest,\n               DirectlyReferencedTypeDecls(\n                   llvm::PointerUnion<TypeDecl *, ExtensionDecl *>, unsigned),\n               Uncached, HasNearestLocation)\n+SWIFT_REQUEST(NameLookup, InheritedProtocolsRequest,\n+              ArrayRef<ProtocolDecl *>(ProtocolDecl *), SeparatelyCached,\n+              NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, LookupConformanceInModuleRequest,\n+              ProtocolConformanceRef(LookupConformanceDescriptor),\n+              Uncached, NoLocationInfo)\n SWIFT_REQUEST(NameLookup, LookupInModuleRequest,\n               QualifiedLookupResult(const DeclContext *, DeclName, NLKind,\n                                     namelookup::ResolutionKind,\n@@ -71,3 +84,16 @@ SWIFT_REQUEST(NameLookup, UnderlyingTypeDeclsReferencedRequest,\n SWIFT_REQUEST(NameLookup, UnqualifiedLookupRequest,\n               LookupResult(UnqualifiedLookupDescriptor), Uncached,\n               NoLocationInfo)\n+\n+SWIFT_REQUEST(NameLookup, LookupPrefixOperatorRequest,\n+              PrefixOperatorDecl *(OperatorLookupDescriptor),\n+              Cached, NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, LookupInfixOperatorRequest,\n+              InfixOperatorDecl *(OperatorLookupDescriptor),\n+              Cached, NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, LookupPostfixOperatorRequest,\n+              PostfixOperatorDecl *(OperatorLookupDescriptor),\n+              Cached, NoLocationInfo)\n+SWIFT_REQUEST(NameLookup, LookupPrecedenceGroupRequest,\n+              PrecedenceGroupDecl *(OperatorLookupDescriptor),\n+              Cached, NoLocationInfo)"
                    },
                    {
                        "filename": "include/swift/AST/ParseRequests.h",
                        "code": "@@ -17,6 +17,7 @@\n #define SWIFT_PARSE_REQUESTS_H\n \n #include \"swift/AST/ASTTypeIDs.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n #include \"swift/AST/SimpleRequest.h\"\n \n namespace swift {\n@@ -42,7 +43,7 @@ void simple_display(llvm::raw_ostream &out, const FingerprintAndMembers &value);\n class ParseMembersRequest\n     : public SimpleRequest<ParseMembersRequest,\n                            FingerprintAndMembers(IterableDeclContext *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -62,7 +63,7 @@ class ParseMembersRequest\n class ParseAbstractFunctionBodyRequest :\n     public SimpleRequest<ParseAbstractFunctionBodyRequest,\n                          BraceStmt *(AbstractFunctionDecl *),\n-                         CacheKind::SeparatelyCached>\n+                         RequestFlags::SeparatelyCached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -82,9 +83,9 @@ class ParseAbstractFunctionBodyRequest :\n \n /// Parse the top-level decls of a SourceFile.\n class ParseSourceFileRequest\n-    : public SimpleRequest<ParseSourceFileRequest,\n-                           ArrayRef<Decl *>(SourceFile *),\n-                           CacheKind::SeparatelyCached> {\n+    : public SimpleRequest<\n+          ParseSourceFileRequest, ArrayRef<Decl *>(SourceFile *),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -99,6 +100,30 @@ class ParseSourceFileRequest\n   bool isCached() const { return true; }\n   Optional<ArrayRef<Decl *>> getCachedResult() const;\n   void cacheResult(ArrayRef<Decl *> decls) const;\n+\n+public:\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n+};\n+\n+void simple_display(llvm::raw_ostream &out,\n+                    const CodeCompletionCallbacksFactory *factory);\n+\n+class CodeCompletionSecondPassRequest\n+    : public SimpleRequest<CodeCompletionSecondPassRequest,\n+                           bool(SourceFile *, CodeCompletionCallbacksFactory *),\n+                           RequestFlags::Uncached|RequestFlags::DependencySource> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  // Evaluation.\n+  bool evaluate(Evaluator &evaluator, SourceFile *SF,\n+                CodeCompletionCallbacksFactory *Factory) const;\n+\n+public:\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n /// The zone number for the parser."
                    },
                    {
                        "filename": "include/swift/AST/ParseTypeIDZone.def",
                        "code": "@@ -14,6 +14,9 @@\n //\n //===----------------------------------------------------------------------===//\n \n+SWIFT_REQUEST(Parse, CodeCompletionSecondPassRequest,\n+              bool (SourceFile *, CodeCompletionCallbacksFactory *),\n+              Uncached, NoLocationInfo)\n SWIFT_REQUEST(Parse, ParseMembersRequest,\n               FingerprintAndMembers(IterableDeclContext *), Cached, NoLocationInfo)\n SWIFT_REQUEST(Parse, ParseAbstractFunctionBodyRequest,"
                    },
                    {
                        "filename": "include/swift/AST/PrintOptions.h",
                        "code": "@@ -276,7 +276,10 @@ struct PrintOptions {\n   /// Prints type variables and unresolved types in an expanded notation suitable\n   /// for debugging.\n   bool PrintTypesForDebugging = false;\n-  \n+\n+  /// Whether this print option is for printing .swiftinterface file\n+  bool IsForSwiftInterface = false;\n+\n   /// How to print opaque return types.\n   enum class OpaqueReturnTypePrintingMode {\n     /// 'some P1 & P2'.\n@@ -429,6 +432,13 @@ struct PrintOptions {\n   /// The information for converting archetypes to specialized types.\n   llvm::Optional<TypeTransformContext> TransformContext;\n \n+  /// Before printing the name of a ModuleDecl, this callback will be called and\n+  /// the name of the ModuleDecl it returns will be printed instead. This is\n+  /// currently used to present cross import overlays as if they were their\n+  /// underlying module.\n+  std::function<const ModuleDecl*(const ModuleDecl *)> mapModuleToUnderlying =\n+    [] (const ModuleDecl *D) { return D; };\n+\n   bool PrintAsMember = false;\n   \n   /// Whether to print parameter specifiers as 'let' and 'var'."
                    },
                    {
                        "filename": "include/swift/AST/PropertyWrappers.h",
                        "code": "@@ -43,6 +43,10 @@ struct PropertyWrapperTypeInfo {\n     HasInitialValueInit\n   } wrappedValueInit = NoWrappedValueInit;\n \n+  /// Whether the init(wrappedValue:), if it exists, has the wrappedValue\n+  /// argument as an escaping autoclosure.\n+  bool isWrappedValueInitUsingEscapingAutoClosure = false;\n+\n   /// The initializer that will be called to default-initialize a\n   /// value with an attached property wrapper.\n   enum {"
                    },
                    {
                        "filename": "include/swift/AST/SILGenRequests.h",
                        "code": "@@ -18,6 +18,7 @@\n #define SWIFT_SILGEN_REQUESTS_H\n \n #include \"swift/AST/ASTTypeIDs.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n #include \"swift/AST/SimpleRequest.h\"\n \n namespace swift {\n@@ -81,33 +82,37 @@ SourceLoc extractNearestSourceLoc(const SILGenDescriptor &desc);\n class SILGenSourceFileRequest :\n     public SimpleRequest<SILGenSourceFileRequest,\n                          std::unique_ptr<SILModule>(SILGenDescriptor),\n-                         CacheKind::Uncached> {\n+                         RequestFlags::Uncached|RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::unique_ptr<SILModule>>\n+  std::unique_ptr<SILModule>\n   evaluate(Evaluator &evaluator, SILGenDescriptor desc) const;\n \n public:\n   bool isCached() const { return true; }\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n class SILGenWholeModuleRequest :\n     public SimpleRequest<SILGenWholeModuleRequest,\n                          std::unique_ptr<SILModule>(SILGenDescriptor),\n-                         CacheKind::Uncached> {\n+                         RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::unique_ptr<SILModule>>\n+  std::unique_ptr<SILModule>\n   evaluate(Evaluator &evaluator, SILGenDescriptor desc) const;\n \n public:"
                    },
                    {
                        "filename": "include/swift/AST/SILOptimizerRequests.h",
                        "code": "@@ -18,6 +18,7 @@\n #define SWIFT_SILOPTIMIZER_REQUESTS_H\n \n #include \"swift/AST/ASTTypeIDs.h\"\n+#include \"swift/AST/EvaluatorDependencies.h\"\n #include \"swift/AST/SimpleRequest.h\"\n \n namespace swift {\n@@ -50,17 +51,17 @@ llvm::hash_code hash_value(const SILPipelineExecutionDescriptor &desc);\n /// Executes a SIL pipeline plan on a SIL module.\n class ExecuteSILPipelineRequest\n     : public SimpleRequest<ExecuteSILPipelineRequest,\n-                           bool(SILPipelineExecutionDescriptor),\n-                           CacheKind::Uncached> {\n+                           evaluator::SideEffect(SILPipelineExecutionDescriptor),\n+                           RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                SILPipelineExecutionDescriptor desc) const;\n+  evaluator::SideEffect\n+  evaluate(Evaluator &evaluator, SILPipelineExecutionDescriptor desc) const;\n };\n \n void simple_display(llvm::raw_ostream &out,"
                    },
                    {
                        "filename": "include/swift/AST/SILOptimizerTypeIDZone.def",
                        "code": "@@ -15,4 +15,5 @@\n //===----------------------------------------------------------------------===//\n \n SWIFT_REQUEST(SILOptimizer, ExecuteSILPipelineRequest,\n-              bool(SILPipelineExecutionDescriptor), Uncached, NoLocationInfo)\n+              evaluator::SideEffect(SILPipelineExecutionDescriptor),\n+              Uncached, NoLocationInfo)"
                    },
                    {
                        "filename": "include/swift/AST/SimpleRequest.h",
                        "code": "@@ -32,17 +32,41 @@ namespace swift {\n class Evaluator;\n \n /// Describes how the result for a particular request will be cached.\n-enum class CacheKind {\n+enum class RequestFlags {\n   /// The result for a particular request should never be cached.\n-  Uncached,\n+  Uncached = 1 << 0,\n   /// The result for a particular request should be cached within the\n   /// evaluator itself.\n-  Cached,\n+  Cached = 1 << 1,\n   /// The result of a particular request will be cached via some separate\n   /// mechanism, such as a mutable data structure.\n-  SeparatelyCached,\n+  SeparatelyCached = 1 << 2,\n+  /// This request introduces the source component of a source-sink\n+  /// incremental dependency pair and defines a new dependency scope.\n+  ///\n+  /// This bit is optional.  High-level requests\n+  /// (e.g. \\c TypeCheckSourceFileRequest) will require it.\n+  ///\n+  /// For further discussion on incremental dependencies\n+  /// see DependencyAnalysis.rst.\n+  DependencySource = 1 << 3,\n+  /// This request introduces the sink component of a source-sink\n+  /// incremental dependency pair and is a consumer of the current\n+  /// dependency scope.\n+  ///\n+  /// This bit is optional. Name lookup requests\n+  /// (e.g. \\c DirectLookupRequest) will require it.\n+  ///\n+  /// For further discussion on incremental dependencies\n+  /// see DependencyAnalysis.rst.\n+  DependencySink = 1 << 4,\n };\n \n+static constexpr inline RequestFlags operator|(RequestFlags lhs, RequestFlags rhs) {\n+  return RequestFlags(static_cast<std::underlying_type<RequestFlags>::type>(lhs) |\n+                   static_cast<std::underlying_type<RequestFlags>::type>(rhs));\n+}\n+\n /// -------------------------------------------------------------------------\n /// Extracting the source location \"nearest\" a request.\n /// -------------------------------------------------------------------------\n@@ -123,6 +147,29 @@ namespace detail {\n   }\n }\n \n+namespace detail {\n+constexpr bool cacheContains(RequestFlags kind, RequestFlags needle) {\n+  using cache_t = std::underlying_type<RequestFlags>::type;\n+  return (static_cast<cache_t>(kind) & static_cast<cache_t>(needle))\n+      == static_cast<cache_t>(needle);\n+}\n+constexpr bool isEverCached(RequestFlags kind) {\n+  return !cacheContains(kind, RequestFlags::Uncached);\n+}\n+\n+constexpr bool hasExternalCache(RequestFlags kind) {\n+  return cacheContains(kind, RequestFlags::SeparatelyCached);\n+}\n+\n+constexpr bool isDependencySource(RequestFlags kind) {\n+  return cacheContains(kind, RequestFlags::DependencySource);\n+}\n+\n+constexpr bool isDependencySink(RequestFlags kind) {\n+  return cacheContains(kind, RequestFlags::DependencySink);\n+}\n+} // end namespace detail\n+\n /// Extract the first, nearest source location from a tuple.\n template<typename First, typename ...Rest,\n          typename = typename std::enable_if<\n@@ -148,9 +195,9 @@ SourceLoc extractNearestSourceLoc(const std::tuple<First, Rest...> &value) {\n ///\n /// The \\c Derived class needs to implement several operations. The most\n /// important one takes an evaluator and the input values, then computes the\n-/// final result, optionally bubbling up errors from recursive evaulations:\n+/// final result:\n /// \\code\n-///   llvm::Expected<Output> evaluate(Evaluator &evaluator, Inputs...) const;\n+///   Output evaluate(Evaluator &evaluator, Inputs...) const;\n /// \\endcode\n ///\n /// Cycle diagnostics can be handled in one of two ways. Either the \\c Derived\n@@ -170,17 +217,36 @@ SourceLoc extractNearestSourceLoc(const std::tuple<First, Rest...> &value) {\n /// the source location from the first input that provides one.\n ///\n /// Value caching is determined by the \\c Caching parameter. When\n-/// \\c Caching == CacheKind::SeparatelyCached, the \\c Derived class is\n+/// \\c Caching == RequestFlags::SeparatelyCached, the \\c Derived class is\n /// responsible for implementing the two operations responsible to managing\n /// the cache:\n /// \\code\n ///   Optional<Output> getCachedResult() const;\n ///   void cacheResult(Output value) const;\n /// \\endcode\n-template<typename Derived, typename Signature, CacheKind Caching>\n+///\n+/// Incremental dependency tracking occurs automatically during\n+/// request evaluation. To support that system, high-level requests that define\n+/// dependency sources should override \\c readDependencySource()\n+/// and specify \\c RequestFlags::DependencySource in addition to one of\n+/// the 3 caching kinds defined above.\n+/// \\code\n+///   evaluator::DependencySource readDependencySource(Evaluator &) const;\n+/// \\endcode\n+///\n+/// Requests that define dependency sinks should instead override\n+/// \\c writeDependencySink() and use the given evaluator and request\n+/// result to write an edge into the dependency tracker. In addition,\n+/// \\c RequestFlags::DependencySource should be specified along with\n+/// one of the 3 caching kinds defined above.\n+/// \\code\n+///   void writeDependencySink(Evaluator &,\n+///                            ReferencedNameTracker &, Output) const;\n+/// \\endcode\n+template<typename Derived, typename Signature, RequestFlags Caching>\n class SimpleRequest;\n \n-template<typename Derived, CacheKind Caching, typename Output,\n+template<typename Derived, RequestFlags Caching, typename Output,\n          typename ...Inputs>\n class SimpleRequest<Derived, Output(Inputs...), Caching> {\n   std::tuple<Inputs...> storage;\n@@ -194,7 +260,7 @@ class SimpleRequest<Derived, Output(Inputs...), Caching> {\n   }\n \n   template<size_t ...Indices>\n-  llvm::Expected<Output>\n+  Output\n   callDerived(Evaluator &evaluator, std::index_sequence<Indices...>) const {\n     static_assert(sizeof...(Indices) > 0, \"Subclass must define evaluate()\");\n     return asDerived().evaluate(evaluator, std::get<Indices>(storage)...);\n@@ -205,16 +271,20 @@ class SimpleRequest<Derived, Output(Inputs...), Caching> {\n   const std::tuple<Inputs...> &getStorage() const { return storage; }\n \n public:\n-  static const bool isEverCached = (Caching != CacheKind::Uncached);\n-  static const bool hasExternalCache = (Caching == CacheKind::SeparatelyCached);\n+  constexpr static bool isEverCached = detail::isEverCached(Caching);\n+  constexpr static bool hasExternalCache = detail::hasExternalCache(Caching);\n+\n+public:\n+  constexpr static bool isDependencySource = detail::isDependencySource(Caching);\n+  constexpr static bool isDependencySink = detail::isDependencySink(Caching);\n \n   using OutputType = Output;\n   \n   explicit SimpleRequest(const Inputs& ...inputs)\n     : storage(inputs...) { }\n \n   /// Request evaluation function that will be registered with the evaluator.\n-  static llvm::Expected<OutputType>\n+  static OutputType\n   evaluateRequest(const Derived &request, Evaluator &evaluator) {\n     return request.callDerived(evaluator,\n                                std::index_sequence_for<Inputs...>());"
                    },
                    {
                        "filename": "include/swift/AST/SourceFile.h",
                        "code": "@@ -23,9 +23,8 @@ class PersistentParserState;\n /// A file containing Swift source code.\n ///\n /// This is a .swift or .sil file (or a virtual file, such as the contents of\n-/// the REPL). Since it contains raw source, it must be parsed and name-bound\n-/// before being used for anything; a full type-check is also necessary for\n-/// IR generation.\n+/// the REPL). Since it contains raw source, it must be type checked for IR\n+/// generation.\n class SourceFile final : public FileUnit {\n   friend class ParseSourceFileRequest;\n \n@@ -128,7 +127,7 @@ class SourceFile final : public FileUnit {\n \n   /// This is the list of modules that are imported by this module.\n   ///\n-  /// This is filled in by the Name Binding phase.\n+  /// This is filled in by the import resolution phase.\n   ArrayRef<ImportedModuleDesc> Imports;\n \n   /// A unique identifier representing this file; used to mark private decls\n@@ -143,6 +142,7 @@ class SourceFile final : public FileUnit {\n \n   /// If non-null, used to track name lookups that happen within this file.\n   Optional<ReferencedNameTracker> ReferencedNames;\n+  Optional<ReferencedNameTracker> RequestReferencedNames;\n \n   /// The class in this file marked \\@NS/UIApplicationMain.\n   ClassDecl *MainClass = nullptr;\n@@ -194,6 +194,16 @@ class SourceFile final : public FileUnit {\n   /// mechanism which is not SourceFile-dependent.)\n   SeparatelyImportedOverlayMap separatelyImportedOverlays;\n \n+  using SeparatelyImportedOverlayReverseMap =\n+    llvm::SmallDenseMap<ModuleDecl *, ModuleDecl *>;\n+\n+  /// A lazily populated mapping from a separately imported overlay to its\n+  /// underlying shadowed module.\n+  ///\n+  /// This is used by tooling to substitute the name of the underlying module\n+  /// wherever the overlay's name would otherwise be reported.\n+  SeparatelyImportedOverlayReverseMap separatelyImportedOverlaysReversed;\n+\n   /// A pointer to PersistentParserState with a function reference to its\n   /// deleter to handle the fact that it's forward declared.\n   using ParserStatePtr =\n@@ -301,23 +311,15 @@ class SourceFile final : public FileUnit {\n   /// List of Objective-C member conflicts we have found during type checking.\n   std::vector<ObjCMethodConflict> ObjCMethodConflicts;\n \n-  template <typename T>\n-  using OperatorMap = llvm::DenseMap<Identifier,llvm::PointerIntPair<T,1,bool>>;\n-\n-  OperatorMap<InfixOperatorDecl*> InfixOperators;\n-  OperatorMap<PostfixOperatorDecl*> PostfixOperators;\n-  OperatorMap<PrefixOperatorDecl*> PrefixOperators;\n-  OperatorMap<PrecedenceGroupDecl*> PrecedenceGroups;\n-\n   /// Describes what kind of file this is, which can affect some type checking\n   /// and other behavior.\n   const SourceFileKind Kind;\n \n   enum ASTStage_t {\n-    /// The source file is not name bound or type checked.\n+    /// The source file has not had its imports resolved or been type checked.\n     Unprocessed,\n-    /// Name binding has completed.\n-    NameBound,\n+    /// Import resolution has completed.\n+    ImportsResolved,\n     /// Type checking has completed.\n     TypeChecked\n   };\n@@ -382,6 +384,7 @@ class SourceFile final : public FileUnit {\n   /// \\returns true if the overlay was added; false if it already existed.\n   bool addSeparatelyImportedOverlay(ModuleDecl *overlay,\n                                     ModuleDecl *declaring) {\n+    separatelyImportedOverlaysReversed.clear();\n     return std::get<1>(separatelyImportedOverlays[declaring].insert(overlay));\n   }\n \n@@ -399,6 +402,12 @@ class SourceFile final : public FileUnit {\n     overlays.append(value.begin(), value.end());\n   }\n \n+  /// Retrieves a module shadowed by the provided separately imported overlay\n+  /// \\p shadowed. If such a module is returned, it should be presented to users\n+  /// as owning the symbols in \\p overlay.\n+  ModuleDecl *\n+  getModuleShadowedBySeparatelyImportedOverlay(const ModuleDecl *overlay);\n+\n   void cacheVisibleDecls(SmallVectorImpl<ValueDecl *> &&globals) const;\n   const SmallVectorImpl<ValueDecl *> &getCachedVisibleDecls() const;\n \n@@ -419,8 +428,21 @@ class SourceFile final : public FileUnit {\n          ObjCSelector selector,\n          SmallVectorImpl<AbstractFunctionDecl *> &results) const override;\n \n+protected:\n+  virtual void\n+  lookupOperatorDirect(Identifier name, OperatorFixity fixity,\n+                       TinyPtrVector<OperatorDecl *> &results) const override;\n+\n+  virtual void lookupPrecedenceGroupDirect(\n+      Identifier name,\n+      TinyPtrVector<PrecedenceGroupDecl *> &results) const override;\n+\n+public:\n   virtual void getTopLevelDecls(SmallVectorImpl<Decl*> &results) const override;\n \n+  virtual void\n+  getOperatorDecls(SmallVectorImpl<OperatorDecl *> &results) const override;\n+\n   virtual void\n   getPrecedenceGroups(SmallVectorImpl<PrecedenceGroupDecl*> &results) const override;\n \n@@ -444,34 +466,33 @@ class SourceFile final : public FileUnit {\n \n   virtual bool walk(ASTWalker &walker) override;\n \n-  /// @{\n-\n-  /// Look up the given operator in this file.\n-  ///\n-  /// The file must be name-bound already. If the operator is not found, or if\n-  /// there is an ambiguity, returns null.\n-  ///\n-  /// \\param isCascading If true, the lookup of this operator may affect\n-  /// downstream files.\n-  InfixOperatorDecl *lookupInfixOperator(Identifier name, bool isCascading,\n-                                         SourceLoc diagLoc = {});\n-  PrefixOperatorDecl *lookupPrefixOperator(Identifier name, bool isCascading,\n-                                           SourceLoc diagLoc = {});\n-  PostfixOperatorDecl *lookupPostfixOperator(Identifier name, bool isCascading,\n-                                             SourceLoc diagLoc = {});\n-  PrecedenceGroupDecl *lookupPrecedenceGroup(Identifier name, bool isCascading,\n-                                             SourceLoc diagLoc = {});\n-  /// @}\n-\n-  ReferencedNameTracker *getReferencedNameTracker() {\n+  ReferencedNameTracker *getLegacyReferencedNameTracker() {\n     return ReferencedNames ? ReferencedNames.getPointer() : nullptr;\n   }\n-  const ReferencedNameTracker *getReferencedNameTracker() const {\n+  const ReferencedNameTracker *getLegacyReferencedNameTracker() const {\n     return ReferencedNames ? ReferencedNames.getPointer() : nullptr;\n   }\n \n+  ReferencedNameTracker *getRequestBasedReferencedNameTracker() {\n+    return RequestReferencedNames ? RequestReferencedNames.getPointer() : nullptr;\n+  }\n+  const ReferencedNameTracker *getRequestBasedReferencedNameTracker() const {\n+    return RequestReferencedNames ? RequestReferencedNames.getPointer() : nullptr;\n+  }\n+\n+  /// Creates and installs the referenced name trackers in this source file.\n+  ///\n+  /// This entrypoint must be called before incremental compilation can proceed,\n+  /// else reference dependencies will not be registered.\n   void createReferencedNameTracker();\n \n+  /// Retrieves the name tracker instance corresponding to\n+  /// \\c EnableRequestBasedIncrementalDependencies\n+  ///\n+  /// If incremental dependencies tracking is not enabled or \\c createReferencedNameTracker()\n+  /// has not been invoked on this source file, the result is \\c nullptr.\n+  const ReferencedNameTracker *getConfiguredReferencedNameTracker() const;\n+\n   /// The buffer ID for the file that was imported, or None if there\n   /// is no associated buffer.\n   Optional<unsigned> getBufferID() const {"
                    },
                    {
                        "filename": "include/swift/AST/TBDGenRequests.h",
                        "code": "@@ -84,16 +84,15 @@ using TBDFileAndSymbols =\n class GenerateTBDRequest\n     : public SimpleRequest<GenerateTBDRequest,\n                            TBDFileAndSymbols(TBDGenDescriptor),\n-                           CacheKind::Uncached> {\n+                           RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<TBDFileAndSymbols> evaluate(Evaluator &evaluator,\n-                                             TBDGenDescriptor desc) const;\n+  TBDFileAndSymbols evaluate(Evaluator &evaluator, TBDGenDescriptor desc) const;\n };\n \n /// Report that a request of the given kind is being evaluated, so it"
                    },
                    {
                        "filename": "include/swift/AST/TypeCheckRequests.h",
                        "code": "@@ -37,6 +37,7 @@ class AccessorDecl;\n enum class AccessorKind;\n class ContextualPattern;\n class DefaultArgumentExpr;\n+class ClosureExpr;\n class GenericParamList;\n class PrecedenceGroupDecl;\n struct PropertyWrapperBackingPropertyInfo;\n@@ -64,7 +65,7 @@ class InheritedTypeRequest :\n                          Type(llvm::PointerUnion<TypeDecl *, ExtensionDecl *>,\n                               unsigned,\n                               TypeResolutionStage),\n-                         CacheKind::SeparatelyCached>\n+                         RequestFlags::SeparatelyCached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -73,7 +74,7 @@ class InheritedTypeRequest :\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator,\n            llvm::PointerUnion<TypeDecl *, ExtensionDecl *> decl,\n            unsigned index,\n@@ -90,44 +91,52 @@ class InheritedTypeRequest :\n };\n \n /// Request the superclass type for the given class.\n-class SuperclassTypeRequest :\n-    public SimpleRequest<SuperclassTypeRequest,\n-                         Type(NominalTypeDecl *, TypeResolutionStage),\n-                         CacheKind::SeparatelyCached> {\n+class SuperclassTypeRequest\n+    : public SimpleRequest<\n+          SuperclassTypeRequest, Type(NominalTypeDecl *, TypeResolutionStage),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySink |\n+              RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, NominalTypeDecl *classDecl,\n            TypeResolutionStage stage) const;\n \n public:\n   // Cycle handling\n   void diagnoseCycle(DiagnosticEngine &diags) const;\n \n+public:\n   // Separate caching.\n   bool isCached() const;\n   Optional<Type> getCachedResult() const;\n   void cacheResult(Type value) const;\n+\n+public:\n+  // Incremental dependencies\n+  evaluator::DependencySource readDependencySource(Evaluator &e) const;\n+  void writeDependencySink(Evaluator &eval,\n+                           ReferencedNameTracker &tracker, Type t) const;\n };\n \n /// Request the raw type of the given enum.\n class EnumRawTypeRequest :\n     public SimpleRequest<EnumRawTypeRequest,\n                          Type(EnumDecl *, TypeResolutionStage),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, EnumDecl *enumDecl,\n            TypeResolutionStage stage) const;\n \n@@ -146,15 +155,15 @@ class EnumRawTypeRequest :\n class OverriddenDeclsRequest :\n   public SimpleRequest<OverriddenDeclsRequest,\n                        llvm::TinyPtrVector<ValueDecl *>(ValueDecl *),\n-                       CacheKind::SeparatelyCached> {\n+                       RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<llvm::TinyPtrVector<ValueDecl *>>\n+  llvm::TinyPtrVector<ValueDecl *>\n   evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n@@ -168,15 +177,15 @@ class OverriddenDeclsRequest :\n class IsObjCRequest :\n     public SimpleRequest<IsObjCRequest,\n                          bool(ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -191,16 +200,16 @@ void simple_display(llvm::raw_ostream &out, CtorInitializerKind initKind);\n class InitKindRequest :\n     public SimpleRequest<InitKindRequest,\n                          CtorInitializerKind(ConstructorDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<CtorInitializerKind>\n-      evaluate(Evaluator &evaluator, ConstructorDecl *decl) const;\n+  CtorInitializerKind\n+  evaluate(Evaluator &evaluator, ConstructorDecl *decl) const;\n \n public:\n   // Caching.\n@@ -211,15 +220,15 @@ class InitKindRequest :\n class ProtocolRequiresClassRequest :\n     public SimpleRequest<ProtocolRequiresClassRequest,\n                          bool(ProtocolDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -237,15 +246,15 @@ class ProtocolRequiresClassRequest :\n class ExistentialConformsToSelfRequest :\n     public SimpleRequest<ExistentialConformsToSelfRequest,\n                          bool(ProtocolDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -263,15 +272,15 @@ class ExistentialConformsToSelfRequest :\n class ExistentialTypeSupportedRequest :\n     public SimpleRequest<ExistentialTypeSupportedRequest,\n                          bool(ProtocolDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -288,15 +297,15 @@ class ExistentialTypeSupportedRequest :\n class IsFinalRequest :\n     public SimpleRequest<IsFinalRequest,\n                          bool(ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -309,15 +318,15 @@ class IsFinalRequest :\n class IsDynamicRequest :\n     public SimpleRequest<IsDynamicRequest,\n                          bool(ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -330,16 +339,16 @@ class IsDynamicRequest :\n class RequirementSignatureRequest :\n     public SimpleRequest<RequirementSignatureRequest,\n                          ArrayRef<Requirement>(ProtocolDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ArrayRef<Requirement>> evaluate(Evaluator &evaluator,\n-                                                 ProtocolDecl *proto) const;\n+  ArrayRef<Requirement>\n+  evaluate(Evaluator &evaluator, ProtocolDecl *proto) const;\n \n public:\n   // Separate caching.\n@@ -352,15 +361,15 @@ class RequirementSignatureRequest :\n class DefaultDefinitionTypeRequest :\n     public SimpleRequest<DefaultDefinitionTypeRequest,\n                          Type(AssociatedTypeDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &evaluator, AssociatedTypeDecl *decl) const;\n+  Type evaluate(Evaluator &evaluator, AssociatedTypeDecl *decl) const;\n \n public:\n   // Caching.\n@@ -428,7 +437,7 @@ class RequirementRequest :\n     public SimpleRequest<RequirementRequest,\n                          Requirement(WhereClauseOwner, unsigned,\n                                      TypeResolutionStage),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -439,10 +448,10 @@ class RequirementRequest :\n   RequirementRepr &getRequirement() const;\n \n   // Evaluation.\n-  llvm::Expected<Requirement> evaluate(Evaluator &evaluator,\n-                                       WhereClauseOwner,\n-                                       unsigned index,\n-                                       TypeResolutionStage stage) const;\n+  Requirement evaluate(Evaluator &evaluator,\n+                       WhereClauseOwner,\n+                       unsigned index,\n+                       TypeResolutionStage stage) const;\n \n public:\n   // Source location\n@@ -461,7 +470,7 @@ class RequirementRequest :\n class USRGenerationRequest :\n     public SimpleRequest<USRGenerationRequest,\n                          std::string(const ValueDecl*),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -470,7 +479,7 @@ class USRGenerationRequest :\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::string> evaluate(Evaluator &eval, const ValueDecl *d) const;\n+  std::string evaluate(Evaluator &eval, const ValueDecl *d) const;\n \n public:\n   // Caching\n@@ -481,7 +490,7 @@ class USRGenerationRequest :\n class MangleLocalTypeDeclRequest :\n     public SimpleRequest<MangleLocalTypeDeclRequest,\n                          std::string(const TypeDecl*),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -490,7 +499,7 @@ class MangleLocalTypeDeclRequest :\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<std::string> evaluate(Evaluator &eval, const TypeDecl *d) const;\n+  std::string evaluate(Evaluator &eval, const TypeDecl *d) const;\n \n public:\n   // Caching\n@@ -503,16 +512,15 @@ void simple_display(llvm::raw_ostream &out, const KnownProtocolKind);\n class DefaultTypeRequest\n     : public SimpleRequest<DefaultTypeRequest,\n                            Type(KnownProtocolKind, const DeclContext *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &eval, KnownProtocolKind,\n-                                const DeclContext *) const;\n+  Type evaluate(Evaluator &eval, KnownProtocolKind, const DeclContext *) const;\n \n public:\n   // Caching\n@@ -525,16 +533,16 @@ class DefaultTypeRequest\n class PropertyWrapperTypeInfoRequest\n   : public SimpleRequest<PropertyWrapperTypeInfoRequest,\n                          PropertyWrapperTypeInfo(NominalTypeDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<PropertyWrapperTypeInfo>\n-      evaluate(Evaluator &eval, NominalTypeDecl *nominal) const;\n+  PropertyWrapperTypeInfo\n+  evaluate(Evaluator &eval, NominalTypeDecl *nominal) const;\n \n public:\n   // Caching\n@@ -546,15 +554,15 @@ class PropertyWrapperTypeInfoRequest\n class AttachedPropertyWrappersRequest :\n     public SimpleRequest<AttachedPropertyWrappersRequest,\n                          llvm::TinyPtrVector<CustomAttr *>(VarDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<llvm::TinyPtrVector<CustomAttr *>>\n+  llvm::TinyPtrVector<CustomAttr *>\n   evaluate(Evaluator &evaluator, VarDecl *) const;\n \n public:\n@@ -567,15 +575,15 @@ class AttachedPropertyWrappersRequest :\n class AttachedPropertyWrapperTypeRequest :\n     public SimpleRequest<AttachedPropertyWrapperTypeRequest,\n                          Type(VarDecl *, unsigned),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, VarDecl *var, unsigned i) const;\n \n public:\n@@ -588,15 +596,15 @@ class AttachedPropertyWrapperTypeRequest :\n class PropertyWrapperBackingPropertyTypeRequest :\n     public SimpleRequest<PropertyWrapperBackingPropertyTypeRequest,\n                          Type(VarDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, VarDecl *var) const;\n \n public:\n@@ -608,15 +616,15 @@ class PropertyWrapperBackingPropertyTypeRequest :\n class PropertyWrapperMutabilityRequest :\n     public SimpleRequest<PropertyWrapperMutabilityRequest,\n                          Optional<PropertyWrapperMutability> (VarDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Optional<PropertyWrapperMutability>>\n+  Optional<PropertyWrapperMutability>\n   evaluate(Evaluator &evaluator, VarDecl *var) const;\n \n public:\n@@ -629,15 +637,15 @@ class PropertyWrapperMutabilityRequest :\n class PropertyWrapperBackingPropertyInfoRequest :\n     public SimpleRequest<PropertyWrapperBackingPropertyInfoRequest,\n                          PropertyWrapperBackingPropertyInfo(VarDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<PropertyWrapperBackingPropertyInfo>\n+  PropertyWrapperBackingPropertyInfo\n   evaluate(Evaluator &evaluator, VarDecl *var) const;\n \n public:\n@@ -649,15 +657,15 @@ class PropertyWrapperBackingPropertyInfoRequest :\n class StructuralTypeRequest :\n     public SimpleRequest<StructuralTypeRequest,\n                          Type(TypeAliasDecl*),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &eval, TypeAliasDecl *d) const;\n+  Type evaluate(Evaluator &eval, TypeAliasDecl *d) const;\n \n public:\n   // Caching.\n@@ -668,16 +676,15 @@ class StructuralTypeRequest :\n class ResilienceExpansionRequest :\n     public SimpleRequest<ResilienceExpansionRequest,\n                          ResilienceExpansion(DeclContext*),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ResilienceExpansion> evaluate(Evaluator &eval,\n-                                               DeclContext *context) const;\n+  ResilienceExpansion evaluate(Evaluator &eval, DeclContext *context) const;\n \n public:\n   // Caching.\n@@ -692,15 +699,15 @@ void simple_display(llvm::raw_ostream &out,\n class AttachedFunctionBuilderRequest :\n     public SimpleRequest<AttachedFunctionBuilderRequest,\n                          CustomAttr *(ValueDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<CustomAttr *>\n+  CustomAttr *\n   evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n@@ -713,14 +720,14 @@ class AttachedFunctionBuilderRequest :\n class FunctionBuilderTypeRequest :\n     public SimpleRequest<FunctionBuilderTypeRequest,\n                          Type(ValueDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n@@ -732,15 +739,15 @@ class FunctionBuilderTypeRequest :\n class SelfAccessKindRequest :\n     public SimpleRequest<SelfAccessKindRequest,\n                          SelfAccessKind(FuncDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<SelfAccessKind>\n+  SelfAccessKind\n   evaluate(Evaluator &evaluator, FuncDecl *func) const;\n \n public:\n@@ -754,15 +761,15 @@ class SelfAccessKindRequest :\n class IsGetterMutatingRequest :\n     public SimpleRequest<IsGetterMutatingRequest,\n                          bool(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *func) const;\n \n public:\n@@ -776,15 +783,15 @@ class IsGetterMutatingRequest :\n class IsSetterMutatingRequest :\n     public SimpleRequest<IsSetterMutatingRequest,\n                          bool(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *func) const;\n \n public:\n@@ -798,15 +805,15 @@ class IsSetterMutatingRequest :\n class OpaqueReadOwnershipRequest :\n     public SimpleRequest<OpaqueReadOwnershipRequest,\n                          OpaqueReadOwnership(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<OpaqueReadOwnership>\n+  OpaqueReadOwnership\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *storage) const;\n \n public:\n@@ -820,15 +827,15 @@ class OpaqueReadOwnershipRequest :\n class LazyStoragePropertyRequest :\n     public SimpleRequest<LazyStoragePropertyRequest,\n                          VarDecl *(VarDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<VarDecl *>\n+  VarDecl *\n   evaluate(Evaluator &evaluator, VarDecl *lazyVar) const;\n \n public:\n@@ -843,20 +850,24 @@ class LazyStoragePropertyRequest :\n class TypeCheckFunctionBodyUntilRequest :\n     public SimpleRequest<TypeCheckFunctionBodyUntilRequest,\n                          bool(AbstractFunctionDecl *, SourceLoc),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached|RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, AbstractFunctionDecl *func,\n            SourceLoc endTypeCheckLoc) const;\n \n public:\n   bool isCached() const { return true; }\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n /// Request to obtain a list of stored properties in a nominal type.\n@@ -866,15 +877,15 @@ class TypeCheckFunctionBodyUntilRequest :\n class StoredPropertiesRequest :\n     public SimpleRequest<StoredPropertiesRequest,\n                          ArrayRef<VarDecl *>(NominalTypeDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ArrayRef<VarDecl *>>\n+  ArrayRef<VarDecl *>\n   evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n \n public:\n@@ -890,15 +901,15 @@ class StoredPropertiesRequest :\n class StoredPropertiesAndMissingMembersRequest :\n     public SimpleRequest<StoredPropertiesAndMissingMembersRequest,\n                          ArrayRef<Decl *>(NominalTypeDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ArrayRef<Decl *>>\n+  ArrayRef<Decl *>\n   evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n \n public:\n@@ -908,15 +919,15 @@ class StoredPropertiesAndMissingMembersRequest :\n class StorageImplInfoRequest :\n     public SimpleRequest<StorageImplInfoRequest,\n                          StorageImplInfo(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<StorageImplInfo>\n+  StorageImplInfo\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *decl) const;\n \n public:\n@@ -929,15 +940,15 @@ class StorageImplInfoRequest :\n class RequiresOpaqueAccessorsRequest :\n     public SimpleRequest<RequiresOpaqueAccessorsRequest,\n                          bool(VarDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, VarDecl *decl) const;\n \n public:\n@@ -950,15 +961,15 @@ class RequiresOpaqueAccessorsRequest :\n class RequiresOpaqueModifyCoroutineRequest :\n     public SimpleRequest<RequiresOpaqueModifyCoroutineRequest,\n                          bool(AbstractStorageDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *decl) const;\n \n public:\n@@ -971,15 +982,15 @@ class RequiresOpaqueModifyCoroutineRequest :\n class IsAccessorTransparentRequest :\n     public SimpleRequest<IsAccessorTransparentRequest,\n                          bool(AccessorDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, AccessorDecl *decl) const;\n \n public:\n@@ -993,15 +1004,15 @@ class SynthesizeAccessorRequest :\n     public SimpleRequest<SynthesizeAccessorRequest,\n                          AccessorDecl *(AbstractStorageDecl *,\n                                         AccessorKind),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<AccessorDecl *>\n+  AccessorDecl *\n   evaluate(Evaluator &evaluator, AbstractStorageDecl *decl,\n            AccessorKind kind) const;\n \n@@ -1015,15 +1026,15 @@ class SynthesizeAccessorRequest :\n class EmittedMembersRequest :\n     public SimpleRequest<EmittedMembersRequest,\n                          DeclRange(ClassDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<DeclRange>\n+  DeclRange\n   evaluate(Evaluator &evaluator, ClassDecl *classDecl) const;\n \n public:\n@@ -1036,15 +1047,15 @@ class EmittedMembersRequest :\n class IsImplicitlyUnwrappedOptionalRequest :\n     public SimpleRequest<IsImplicitlyUnwrappedOptionalRequest,\n                          bool(ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, ValueDecl *value) const;\n \n public:\n@@ -1057,16 +1068,17 @@ class IsImplicitlyUnwrappedOptionalRequest :\n class ClassAncestryFlagsRequest :\n     public SimpleRequest<ClassAncestryFlagsRequest,\n                          AncestryFlags (ClassDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<AncestryFlags>\n+  AncestryFlags\n   evaluate(Evaluator &evaluator, ClassDecl *value) const;\n+\n public:\n   // Caching.\n   bool isCached() const { return true; }\n@@ -1079,15 +1091,15 @@ class AbstractGenericSignatureRequest :\n                          GenericSignature (GenericSignatureImpl *,\n                                            SmallVector<GenericTypeParamType *, 2>,\n                                            SmallVector<Requirement, 2>),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<GenericSignature>\n+  GenericSignature\n   evaluate(Evaluator &evaluator,\n            GenericSignatureImpl *baseSignature,\n            SmallVector<GenericTypeParamType *, 2> addedParameters,\n@@ -1111,15 +1123,15 @@ class InferredGenericSignatureRequest :\n                                             SmallVector<Requirement, 2>,\n                                             SmallVector<TypeLoc, 2>,\n                                             bool),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<GenericSignature>\n+  GenericSignature\n   evaluate(Evaluator &evaluator,\n            ModuleDecl *module,\n            GenericSignatureImpl *baseSignature,\n@@ -1146,15 +1158,15 @@ void simple_display(llvm::raw_ostream &out, const TypeLoc source);\n class ExtendedTypeRequest\n     : public SimpleRequest<ExtendedTypeRequest,\n                            Type(ExtensionDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &eval, ExtensionDecl *) const;\n+  Type evaluate(Evaluator &eval, ExtensionDecl *) const;\n public:\n   // Caching.\n   bool isCached() const { return true; }\n@@ -1163,15 +1175,15 @@ class ExtendedTypeRequest\n class FunctionOperatorRequest :\n     public SimpleRequest<FunctionOperatorRequest,\n                          OperatorDecl *(FuncDecl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n   \n private:\n   friend SimpleRequest;\n   \n   // Evaluation.\n-  llvm::Expected<OperatorDecl *>\n+  OperatorDecl *\n   evaluate(Evaluator &evaluator, FuncDecl *value) const;\n   \n public:\n@@ -1182,15 +1194,15 @@ class FunctionOperatorRequest :\n class GenericSignatureRequest :\n     public SimpleRequest<GenericSignatureRequest,\n                          GenericSignature (GenericContext *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n   \n private:\n   friend SimpleRequest;\n   \n   // Evaluation.\n-  llvm::Expected<GenericSignature>\n+  GenericSignature\n   evaluate(Evaluator &evaluator, GenericContext *value) const;\n   \n public:\n@@ -1204,16 +1216,15 @@ class GenericSignatureRequest :\n class UnderlyingTypeRequest :\n     public SimpleRequest<UnderlyingTypeRequest,\n                          Type(TypeAliasDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &evaluator,\n-                                TypeAliasDecl *decl) const;\n+  Type evaluate(Evaluator &evaluator, TypeAliasDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1227,15 +1238,15 @@ class UnderlyingTypeRequest :\n class OperatorPrecedenceGroupRequest\n     : public SimpleRequest<OperatorPrecedenceGroupRequest,\n                            PrecedenceGroupDecl *(InfixOperatorDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<PrecedenceGroupDecl *>\n+  PrecedenceGroupDecl *\n   evaluate(Evaluator &evaluator, InfixOperatorDecl *PGD) const;\n \n public:\n@@ -1246,16 +1257,16 @@ class OperatorPrecedenceGroupRequest\n /// Computes the raw values for an enum type.\n class EnumRawValuesRequest :\n     public SimpleRequest<EnumRawValuesRequest,\n-                         bool (EnumDecl *, TypeResolutionStage),\n-                         CacheKind::SeparatelyCached> {\n+                         evaluator::SideEffect (EnumDecl *, TypeResolutionStage),\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n   \n private:\n   friend SimpleRequest;\n   \n   // Evaluation.\n-  llvm::Expected<bool>\n+  evaluator::SideEffect\n   evaluate(Evaluator &evaluator, EnumDecl *ED, TypeResolutionStage stage) const;\n   \n public:\n@@ -1265,22 +1276,22 @@ class EnumRawValuesRequest :\n                            \n   // Separate caching.\n   bool isCached() const;\n-  Optional<bool> getCachedResult() const;\n-  void cacheResult(bool value) const;\n+  Optional<evaluator::SideEffect> getCachedResult() const;\n+  void cacheResult(evaluator::SideEffect value) const;\n };\n \n /// Determines if an override is ABI compatible with its base method.\n class IsABICompatibleOverrideRequest\n     : public SimpleRequest<IsABICompatibleOverrideRequest, bool(ValueDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1291,14 +1302,14 @@ class IsABICompatibleOverrideRequest\n class OpaqueResultTypeRequest\n     : public SimpleRequest<OpaqueResultTypeRequest,\n                            OpaqueTypeDecl *(ValueDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n-  llvm::Expected<OpaqueTypeDecl *>\n+  OpaqueTypeDecl *\n   evaluate(Evaluator &evaluator, ValueDecl *VD) const;\n \n public:\n@@ -1310,15 +1321,15 @@ class OpaqueResultTypeRequest\n class IsStaticRequest :\n     public SimpleRequest<IsStaticRequest,\n                          bool(FuncDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool>\n+  bool\n   evaluate(Evaluator &evaluator, FuncDecl *value) const;\n \n public:\n@@ -1334,16 +1345,15 @@ class IsStaticRequest :\n class NeedsNewVTableEntryRequest\n     : public SimpleRequest<NeedsNewVTableEntryRequest,\n                            bool(AbstractFunctionDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                AbstractFunctionDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, AbstractFunctionDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -1356,15 +1366,15 @@ class NeedsNewVTableEntryRequest\n class ParamSpecifierRequest\n     : public SimpleRequest<ParamSpecifierRequest,\n                            ParamSpecifier(ParamDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ParamSpecifier>\n+  ParamSpecifier\n   evaluate(Evaluator &evaluator, ParamDecl *decl) const;\n \n public:\n@@ -1378,7 +1388,7 @@ class ParamSpecifierRequest\n class ResultTypeRequest\n     : public SimpleRequest<ResultTypeRequest,\n                            Type(ValueDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n@@ -1388,7 +1398,7 @@ class ResultTypeRequest\n   TypeLoc &getResultTypeLoc() const;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n+  Type evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -1401,15 +1411,15 @@ class PatternBindingEntryRequest\n     : public SimpleRequest<PatternBindingEntryRequest,\n                            const PatternBindingEntry *(PatternBindingDecl *,\n                                                        unsigned),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<const PatternBindingEntry *>\n+  const PatternBindingEntry *\n   evaluate(Evaluator &evaluator, PatternBindingDecl *PBD, unsigned i) const;\n \n public:\n@@ -1421,16 +1431,15 @@ class PatternBindingEntryRequest\n \n class NamingPatternRequest\n     : public SimpleRequest<NamingPatternRequest, NamedPattern *(VarDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<NamedPattern *> evaluate(Evaluator &evaluator,\n-                                          VarDecl *VD) const;\n+  NamedPattern * evaluate(Evaluator &evaluator, VarDecl *VD) const;\n \n public:\n   // Separate caching.\n@@ -1442,15 +1451,15 @@ class NamingPatternRequest\n class InterfaceTypeRequest :\n     public SimpleRequest<InterfaceTypeRequest,\n                          Type (ValueDecl *),\n-                         CacheKind::SeparatelyCached> {\n+                         RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type>\n+  Type\n   evaluate(Evaluator &evaluator, ValueDecl *decl) const;\n \n public:\n@@ -1494,18 +1503,18 @@ struct PrecedenceGroupDescriptor {\n \n void simple_display(llvm::raw_ostream &out, const PrecedenceGroupDescriptor &d);\n \n-class LookupPrecedenceGroupRequest\n-    : public SimpleRequest<LookupPrecedenceGroupRequest,\n+class ValidatePrecedenceGroupRequest\n+    : public SimpleRequest<ValidatePrecedenceGroupRequest,\n                            PrecedenceGroupDecl *(PrecedenceGroupDescriptor),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<PrecedenceGroupDecl *>\n+  PrecedenceGroupDecl *\n   evaluate(Evaluator &evaluator, PrecedenceGroupDescriptor descriptor) const;\n \n public:\n@@ -1524,16 +1533,15 @@ class LookupPrecedenceGroupRequest\n /// values.\n class AreAllStoredPropertiesDefaultInitableRequest\n     : public SimpleRequest<AreAllStoredPropertiesDefaultInitableRequest,\n-                           bool(NominalTypeDecl *), CacheKind::Cached> {\n+                           bool(NominalTypeDecl *), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                NominalTypeDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1545,16 +1553,15 @@ class AreAllStoredPropertiesDefaultInitableRequest\n /// conformance.\n class HasUserDefinedDesignatedInitRequest\n     : public SimpleRequest<HasUserDefinedDesignatedInitRequest,\n-                           bool(NominalTypeDecl *), CacheKind::Cached> {\n+                           bool(NominalTypeDecl *), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                NominalTypeDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1564,15 +1571,15 @@ class HasUserDefinedDesignatedInitRequest\n /// Checks whether this type has a synthesized memberwise initializer.\n class HasMemberwiseInitRequest\n     : public SimpleRequest<HasMemberwiseInitRequest, bool(StructDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, StructDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, StructDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1583,16 +1590,39 @@ class HasMemberwiseInitRequest\n class SynthesizeMemberwiseInitRequest\n     : public SimpleRequest<SynthesizeMemberwiseInitRequest,\n                            ConstructorDecl *(NominalTypeDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  // Evaluation.\n+  ConstructorDecl *evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n+\n+public:\n+  // Caching.\n+  bool isCached() const { return true; }\n+};\n+\n+/// Resolves the effective memberwise initializer for a given type.\n+///\n+/// An effective memberwise initializer is either a synthesized memberwise\n+/// initializer or a user-defined initializer with the same type.\n+///\n+/// See `NominalTypeDecl::getEffectiveMemberwiseInitializer` for details.\n+class ResolveEffectiveMemberwiseInitRequest\n+    : public SimpleRequest<ResolveEffectiveMemberwiseInitRequest,\n+                           ConstructorDecl *(NominalTypeDecl *),\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ConstructorDecl *> evaluate(Evaluator &evaluator,\n-                                             NominalTypeDecl *decl) const;\n+  ConstructorDecl *evaluate(Evaluator &evaluator, NominalTypeDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1603,15 +1633,15 @@ class SynthesizeMemberwiseInitRequest\n /// initializer.\n class HasDefaultInitRequest\n     : public SimpleRequest<HasDefaultInitRequest, bool(NominalTypeDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n+  bool evaluate(Evaluator &evaluator,\n                                 NominalTypeDecl *decl) const;\n \n public:\n@@ -1623,16 +1653,16 @@ class HasDefaultInitRequest\n class SynthesizeDefaultInitRequest\n     : public SimpleRequest<SynthesizeDefaultInitRequest,\n                            ConstructorDecl *(NominalTypeDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ConstructorDecl *> evaluate(Evaluator &evaluator,\n-                                             NominalTypeDecl *decl) const;\n+  ConstructorDecl * evaluate(Evaluator &evaluator,\n+                             NominalTypeDecl *decl) const;\n \n public:\n   // Caching.\n@@ -1642,17 +1672,17 @@ class SynthesizeDefaultInitRequest\n class CompareDeclSpecializationRequest\n     : public SimpleRequest<CompareDeclSpecializationRequest,\n                            bool(DeclContext *, ValueDecl *, ValueDecl *, bool),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, DeclContext *DC,\n-                                ValueDecl *VD1, ValueDecl *VD2,\n-                                bool dynamic) const;\n+  bool evaluate(Evaluator &evaluator, DeclContext *DC,\n+                ValueDecl *VD1, ValueDecl *VD2,\n+                bool dynamic) const;\n \n public:\n   // Caching.\n@@ -1663,15 +1693,15 @@ class CompareDeclSpecializationRequest\n /// convenience initializers.\n class InheritsSuperclassInitializersRequest\n     : public SimpleRequest<InheritsSuperclassInitializersRequest,\n-                           bool(ClassDecl *), CacheKind::SeparatelyCached> {\n+                           bool(ClassDecl *), RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ClassDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ClassDecl *decl) const;\n \n public:\n   // Separate caching.\n@@ -1692,17 +1722,19 @@ enum class ImplicitMemberAction : uint8_t {\n \n class ResolveImplicitMemberRequest\n     : public SimpleRequest<ResolveImplicitMemberRequest,\n-                           bool(NominalTypeDecl *, ImplicitMemberAction),\n-                           CacheKind::Uncached> {\n+                           evaluator::SideEffect(NominalTypeDecl *,\n+                                                 ImplicitMemberAction),\n+                           RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, NominalTypeDecl *NTD,\n-                                ImplicitMemberAction action) const;\n+  evaluator::SideEffect\n+  evaluate(Evaluator &evaluator, NominalTypeDecl *NTD,\n+           ImplicitMemberAction action) const;\n \n public:\n   // Separate caching.\n@@ -1713,15 +1745,15 @@ class TypeWitnessRequest\n     : public SimpleRequest<TypeWitnessRequest,\n                            TypeWitnessAndDecl(NormalProtocolConformance *,\n                                               AssociatedTypeDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<TypeWitnessAndDecl>\n+  TypeWitnessAndDecl\n   evaluate(Evaluator &evaluator, NormalProtocolConformance *conformance,\n            AssociatedTypeDecl *ATD) const;\n \n@@ -1735,17 +1767,17 @@ class TypeWitnessRequest\n class ValueWitnessRequest\n     : public SimpleRequest<ValueWitnessRequest,\n                            Witness(NormalProtocolConformance *, ValueDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Witness> evaluate(Evaluator &evaluator,\n-                                   NormalProtocolConformance *conformance,\n-                                   ValueDecl *VD) const;\n+  Witness evaluate(Evaluator &evaluator,\n+                   NormalProtocolConformance *conformance,\n+                   ValueDecl *VD) const;\n \n public:\n   // Separate caching.\n@@ -1768,15 +1800,15 @@ enum class FunctionBuilderBodyPreCheck : uint8_t {\n class PreCheckFunctionBuilderRequest\n     : public SimpleRequest<PreCheckFunctionBuilderRequest,\n                            FunctionBuilderBodyPreCheck(AnyFunctionRef),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<FunctionBuilderBodyPreCheck>\n+  FunctionBuilderBodyPreCheck\n   evaluate(Evaluator &evaluator, AnyFunctionRef fn) const;\n \n public:\n@@ -1788,15 +1820,15 @@ class PreCheckFunctionBuilderRequest\n /// hierarchy.\n class HasCircularInheritanceRequest\n     : public SimpleRequest<HasCircularInheritanceRequest, bool(ClassDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ClassDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ClassDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -1811,15 +1843,15 @@ class HasCircularInheritanceRequest\n /// inherited protocols.\n class HasCircularInheritedProtocolsRequest\n     : public SimpleRequest<HasCircularInheritedProtocolsRequest,\n-                           bool(ProtocolDecl *), CacheKind::Cached> {\n+                           bool(ProtocolDecl *), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, ProtocolDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -1833,15 +1865,15 @@ class HasCircularInheritedProtocolsRequest\n /// Computes whether an enum's raw value has a circular reference.\n class HasCircularRawValueRequest\n     : public SimpleRequest<HasCircularRawValueRequest, bool(EnumDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, EnumDecl *decl) const;\n+  bool evaluate(Evaluator &evaluator, EnumDecl *decl) const;\n \n public:\n   // Cycle handling.\n@@ -1856,15 +1888,15 @@ class HasCircularRawValueRequest\n class DefaultArgumentInitContextRequest\n     : public SimpleRequest<DefaultArgumentInitContextRequest,\n                            Initializer *(ParamDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Initializer *> evaluate(Evaluator &evaluator,\n+  Initializer * evaluate(Evaluator &evaluator,\n                                          ParamDecl *param) const;\n \n public:\n@@ -1878,15 +1910,15 @@ class DefaultArgumentInitContextRequest\n /// parameter.\n class DefaultArgumentExprRequest\n     : public SimpleRequest<DefaultArgumentExprRequest, Expr *(ParamDecl *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Expr *> evaluate(Evaluator &evaluator, ParamDecl *param) const;\n+  Expr *evaluate(Evaluator &evaluator, ParamDecl *param) const;\n \n public:\n   // Separate caching.\n@@ -1900,16 +1932,15 @@ class DefaultArgumentExprRequest\n class CallerSideDefaultArgExprRequest\n     : public SimpleRequest<CallerSideDefaultArgExprRequest,\n                            Expr *(DefaultArgumentExpr *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Expr *> evaluate(Evaluator &evaluator,\n-                                  DefaultArgumentExpr *defaultExpr) const;\n+  Expr * evaluate(Evaluator &evaluator, DefaultArgumentExpr *defaultExpr) const;\n \n public:\n   // Separate caching.\n@@ -1922,16 +1953,15 @@ class CallerSideDefaultArgExprRequest\n /// implementation of a \\c callAsFunction method.\n class IsCallableNominalTypeRequest\n     : public SimpleRequest<IsCallableNominalTypeRequest,\n-                           bool(CanType, DeclContext *), CacheKind::Cached> {\n+                           bool(CanType, DeclContext *), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, CanType ty,\n-                                DeclContext *dc) const;\n+  bool evaluate(Evaluator &evaluator, CanType ty, DeclContext *dc) const;\n \n public:\n   // Cached.\n@@ -1940,54 +1970,59 @@ class IsCallableNominalTypeRequest\n \n class DynamicallyReplacedDeclRequest\n     : public SimpleRequest<DynamicallyReplacedDeclRequest,\n-                           ValueDecl *(ValueDecl *), CacheKind::Cached> {\n+                           ValueDecl *(ValueDecl *), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ValueDecl *> evaluate(Evaluator &evaluator,\n-                                       ValueDecl *VD) const;\n+  ValueDecl * evaluate(Evaluator &evaluator, ValueDecl *VD) const;\n \n public:\n   // Caching.\n   bool isCached() const { return true; }\n };\n \n-class TypeCheckSourceFileRequest :\n-    public SimpleRequest<TypeCheckSourceFileRequest,\n-                         bool (SourceFile *), CacheKind::SeparatelyCached> {\n+class TypeCheckSourceFileRequest\n+    : public SimpleRequest<\n+          TypeCheckSourceFileRequest, evaluator::SideEffect(SourceFile *),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySource> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, SourceFile *SF) const;\n+  evaluator::SideEffect\n+  evaluate(Evaluator &evaluator, SourceFile *SF) const;\n \n public:\n   // Separate caching.\n   bool isCached() const { return true; }\n-  Optional<bool> getCachedResult() const;\n-  void cacheResult(bool result) const;\n+  Optional<evaluator::SideEffect> getCachedResult() const;\n+  void cacheResult(evaluator::SideEffect) const;\n+\n+public:\n+  // Incremental dependencies.\n+  evaluator::DependencySource readDependencySource(Evaluator &) const;\n };\n \n /// Computes whether the specified type or a super-class/super-protocol has the\n /// @dynamicMemberLookup attribute on it.\n class HasDynamicMemberLookupAttributeRequest\n     : public SimpleRequest<HasDynamicMemberLookupAttributeRequest,\n-                           bool(CanType), CacheKind::Cached> {\n+                           bool(CanType), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, CanType ty) const;\n+  bool evaluate(Evaluator &evaluator, CanType ty) const;\n \n public:\n   bool isCached() const {\n@@ -2002,15 +2037,15 @@ class HasDynamicMemberLookupAttributeRequest\n /// @dynamicCallable attribute on it.\n class HasDynamicCallableAttributeRequest\n     : public SimpleRequest<HasDynamicCallableAttributeRequest,\n-                           bool(CanType), CacheKind::Cached> {\n+                           bool(CanType), RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, CanType ty) const;\n+  bool evaluate(Evaluator &evaluator, CanType ty) const;\n \n public:\n   bool isCached() const {\n@@ -2028,16 +2063,15 @@ class HasDynamicCallableAttributeRequest\n /// allowed.\n class PatternTypeRequest\n     : public SimpleRequest<PatternTypeRequest, Type(ContextualPattern),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(\n-      Evaluator &evaluator, ContextualPattern pattern) const;\n+  Type evaluate(Evaluator &evaluator, ContextualPattern pattern) const;\n \n public:\n   bool isCached() const { return true; }\n@@ -2051,15 +2085,15 @@ class PatternTypeRequest\n class SPIGroupsRequest :\n     public SimpleRequest<SPIGroupsRequest,\n                          llvm::ArrayRef<Identifier>(const Decl *),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<llvm::ArrayRef<Identifier>>\n+  llvm::ArrayRef<Identifier>\n   evaluate(Evaluator &evaluator, const Decl *decl) const;\n \n public:\n@@ -2078,16 +2112,16 @@ class SPIGroupsRequest :\n class DifferentiableAttributeTypeCheckRequest\n     : public SimpleRequest<DifferentiableAttributeTypeCheckRequest,\n                            IndexSubset *(DifferentiableAttr *),\n-                           CacheKind::SeparatelyCached> {\n+                           RequestFlags::SeparatelyCached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<IndexSubset *> evaluate(Evaluator &evaluator,\n-                                         DifferentiableAttr *attr) const;\n+  IndexSubset * evaluate(Evaluator &evaluator,\n+                         DifferentiableAttr *attr) const;\n \n public:\n   // Separate caching.\n@@ -2100,16 +2134,16 @@ class DifferentiableAttributeTypeCheckRequest\n class TypeEraserHasViableInitRequest\n     : public SimpleRequest<TypeEraserHasViableInitRequest,\n                            bool(TypeEraserAttr *, ProtocolDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator, TypeEraserAttr *attr,\n-                                ProtocolDecl *protocol) const;\n+  bool evaluate(Evaluator &evaluator, TypeEraserAttr *attr,\n+                ProtocolDecl *protocol) const;\n \n public:\n   bool isCached() const { return true; }\n@@ -2126,21 +2160,106 @@ class TypeEraserHasViableInitRequest\n class ScopedImportLookupRequest\n     : public SimpleRequest<ScopedImportLookupRequest,\n                            ArrayRef<ValueDecl *>(ImportDecl *),\n-                           CacheKind::Cached> {\n+                           RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n-  llvm::Expected<ArrayRef<ValueDecl *>> evaluate(Evaluator &evaluator,\n-                                                 ImportDecl *import) const;\n+  ArrayRef<ValueDecl *>\n+  evaluate(Evaluator &evaluator, ImportDecl *import) const;\n \n public:\n   // Cached.\n   bool isCached() const { return true; }\n };\n \n+/// Determine whether closure body has any explicit `return`\n+/// statements which could produce a non-void result.\n+class ClosureHasExplicitResultRequest\n+    : public SimpleRequest<ClosureHasExplicitResultRequest, bool(ClosureExpr *),\n+                           RequestFlags::Cached> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  bool evaluate(Evaluator &evaluator, ClosureExpr *closure) const;\n+\n+public:\n+  bool isCached() const { return true; }\n+};\n+\n+using ProtocolConformanceLookupResult = SmallVector<ProtocolConformance *, 2>;\n+void simple_display(llvm::raw_ostream &out, ConformanceLookupKind kind);\n+\n+/// Lookup and expand all conformances in the given context.\n+///\n+/// This request specifically accomodates algorithms for retrieving all\n+/// conformances in the primary, even those that are unstated in source but\n+/// are implied by other conformances, inherited from other types, or synthesized\n+/// by the compiler. A simple case of this is the following:\n+///\n+/// \\code\n+/// protocol P {}\n+/// protocol Q : P {}\n+/// extension T : Q {}\n+/// \\endcode\n+///\n+/// Here, a conformance to \\c Q has been stated, but a conformance to \\c P\n+/// must also be reported so it can be checked as well.\n+class LookupAllConformancesInContextRequest\n+    : public SimpleRequest<LookupAllConformancesInContextRequest,\n+                           ProtocolConformanceLookupResult(const DeclContext *),\n+                           RequestFlags::Uncached |\n+                               RequestFlags::DependencySink |\n+                               RequestFlags::DependencySource> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+private:\n+  friend SimpleRequest;\n+\n+  // Evaluation.\n+  ProtocolConformanceLookupResult\n+  evaluate(Evaluator &evaluator, const DeclContext *DC) const;\n+\n+public:\n+  // Incremental dependencies\n+  evaluator::DependencySource readDependencySource(Evaluator &eval) const;\n+  void writeDependencySink(Evaluator &eval, ReferencedNameTracker &tracker,\n+                           ProtocolConformanceLookupResult r) const;\n+};\n+\n+class CheckRedeclarationRequest\n+    : public SimpleRequest<\n+          CheckRedeclarationRequest, evaluator::SideEffect(ValueDecl *),\n+          RequestFlags::SeparatelyCached | RequestFlags::DependencySource |\n+              RequestFlags::DependencySink> {\n+public:\n+  using SimpleRequest::SimpleRequest;\n+\n+ private:\n+  friend SimpleRequest;\n+\n+   // Evaluation.\n+  evaluator::SideEffect\n+  evaluate(Evaluator &evaluator, ValueDecl *VD) const;\n+\n+ public:\n+  // Separate caching.\n+  bool isCached() const { return true; }\n+  Optional<evaluator::SideEffect> getCachedResult() const;\n+  void cacheResult(evaluator::SideEffect) const;\n+\n+public:\n+  evaluator::DependencySource readDependencySource(Evaluator &eval) const;\n+  void writeDependencySink(Evaluator &eval, ReferencedNameTracker &tracker,\n+                           evaluator::SideEffect) const;\n+};\n+\n // Allow AnyValue to compare two Type values, even though Type doesn't\n // support ==.\n template<>"
                    },
                    {
                        "filename": "include/swift/AST/TypeCheckerTypeIDZone.def",
                        "code": "@@ -29,6 +29,9 @@ SWIFT_REQUEST(TypeChecker, AttachedPropertyWrappersRequest,\n               NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, CallerSideDefaultArgExprRequest,\n               Expr *(DefaultArgumentExpr *), SeparatelyCached, NoLocationInfo)\n+SWIFT_REQUEST(TypeChecker, CheckRedeclarationRequest,\n+              evaluator::SideEffect(ValueDecl *),\n+              Uncached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, ClassAncestryFlagsRequest,\n               AncestryFlags(ClassDecl *), Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, CompareDeclSpecializationRequest,\n@@ -55,8 +58,8 @@ SWIFT_REQUEST(TypeChecker, DynamicallyReplacedDeclRequest,\n SWIFT_REQUEST(TypeChecker, EmittedMembersRequest, DeclRange(ClassDecl *),\n               SeparatelyCached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, EnumRawValuesRequest,\n-              bool (EnumDecl *, TypeResolutionStage), SeparatelyCached,\n-              NoLocationInfo)\n+              evaluator::SideEffect (EnumDecl *, TypeResolutionStage),\n+              SeparatelyCached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, EnumRawTypeRequest,\n               Type(EnumDecl *, TypeResolutionStage), SeparatelyCached,\n               NoLocationInfo)\n@@ -117,7 +120,7 @@ SWIFT_REQUEST(TypeChecker, IsSetterMutatingRequest, bool(AbstractStorageDecl *),\n               SeparatelyCached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, LazyStoragePropertyRequest, VarDecl *(VarDecl *),\n               Cached, NoLocationInfo)\n-SWIFT_REQUEST(TypeChecker, LookupPrecedenceGroupRequest,\n+SWIFT_REQUEST(TypeChecker, ValidatePrecedenceGroupRequest,\n               PrecedenceGroupDecl *(DeclContext *, Identifier, SourceLoc),\n               Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, MangleLocalTypeDeclRequest,\n@@ -182,7 +185,8 @@ SWIFT_REQUEST(TypeChecker, SynthesizeAccessorRequest,\n               AccessorDecl *(AbstractStorageDecl *, AccessorKind),\n               SeparatelyCached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, TypeCheckFunctionBodyUntilRequest,\n-              bool(AbstractFunctionDecl *, SourceLoc), Cached, NoLocationInfo)\n+              bool(AbstractFunctionDecl *, SourceLoc),\n+              Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, UnderlyingTypeRequest, Type(TypeAliasDecl *),\n               SeparatelyCached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, USRGenerationRequest, std::string(const ValueDecl *),\n@@ -207,13 +211,15 @@ SWIFT_REQUEST(TypeChecker, PreCheckFunctionBuilderRequest,\n               FunctionBuilderClosurePreCheck(AnyFunctionRef),\n               Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, ResolveImplicitMemberRequest,\n-              bool(NominalTypeDecl *, ImplicitMemberAction), Uncached,\n-              NoLocationInfo)\n+              evaluator::SideEffect(NominalTypeDecl *, ImplicitMemberAction),\n+              Uncached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, SPIGroupsRequest,\n               llvm::ArrayRef<Identifier>(Decl *),\n               Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, SynthesizeMemberwiseInitRequest,\n               ConstructorDecl *(NominalTypeDecl *), Cached, NoLocationInfo)\n+SWIFT_REQUEST(TypeChecker, ResolveEffectiveMemberwiseInitRequest,\n+              ConstructorDecl *(NominalTypeDecl *), Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, HasDefaultInitRequest,\n               bool(NominalTypeDecl *), Cached, NoLocationInfo)\n SWIFT_REQUEST(TypeChecker, SynthesizeDefaultInitRequest,\n@@ -232,3 +238,8 @@ SWIFT_REQUEST(TypeChecker, PatternTypeRequest,\n               Cached, HasNearestLocation)\n SWIFT_REQUEST(TypeChecker, ScopedImportLookupRequest,\n               ArrayRef<ValueDecl *>(ImportDecl *), Cached, NoLocationInfo)\n+SWIFT_REQUEST(TypeChecker, ClosureHasExplicitResultRequest,\n+              bool(ClosureExpr *), Cached, NoLocationInfo)\n+SWIFT_REQUEST(TypeChecker, LookupAllConformancesInContextRequest,\n+              ProtocolConformanceLookupResult(const DeclContext *),\n+              Uncached, NoLocationInfo)"
                    },
                    {
                        "filename": "include/swift/AST/TypeRepr.h",
                        "code": "@@ -263,7 +263,7 @@ class ComponentIdentTypeRepr : public IdentTypeRepr {\n   /// component.\n   ///\n   /// The initial parsed representation is always an identifier, and\n-  /// name binding will resolve this to a specific declaration.\n+  /// name lookup will resolve this to a specific declaration.\n   llvm::PointerUnion<DeclNameRef, TypeDecl *> IdOrDecl;\n \n   /// The declaration context from which the bound declaration was\n@@ -282,7 +282,8 @@ class ComponentIdentTypeRepr : public IdentTypeRepr {\n   /// correction.\n   void overwriteNameRef(DeclNameRef newId) { IdOrDecl = newId; }\n \n-  /// Return true if this has been name-bound already.\n+  /// Return true if this name has been resolved to a type decl. This happens\n+  /// during type resolution.\n   bool isBound() const { return IdOrDecl.is<TypeDecl *>(); }\n \n   TypeDecl *getBoundDecl() const { return IdOrDecl.dyn_cast<TypeDecl*>(); }"
                    },
                    {
                        "filename": "include/swift/AST/Types.h",
                        "code": "@@ -1271,10 +1271,11 @@ class NominalOrBoundGenericNominalType : public AnyGenericType {\n };\n DEFINE_EMPTY_CAN_TYPE_WRAPPER(NominalOrBoundGenericNominalType, AnyGenericType)\n \n-/// ErrorType - This represents a type that was erroneously constructed.  This\n-/// is produced when parsing types and when name binding type aliases, and is\n-/// installed in declaration that use these erroneous types.  All uses of a\n-/// declaration of invalid type should be ignored and not re-diagnosed.\n+/// ErrorType - Represents the type of an erroneously constructed declaration,\n+/// expression, or type. When creating ErrorTypes, an associated error\n+/// diagnostic should always be emitted. That way when later stages of\n+/// compilation encounter an ErrorType installed by earlier phases they do not\n+/// have to emit further diagnostics to abort compilation.\n class ErrorType final : public TypeBase {\n   friend class ASTContext;\n   // The Error type is always canonical.\n@@ -3353,6 +3354,8 @@ class AnyFunctionType : public TypeBase {\n       IndexSubset *parameterIndices, AutoDiffLinearMapKind kind,\n       LookupConformanceFn lookupConformance, bool makeSelfParamFirst = false);\n \n+  AnyFunctionType *getWithoutDifferentiability() const;\n+\n   /// True if the parameter declaration it is attached to is guaranteed\n   /// to not persist the closure for longer than the duration of the call.\n   bool isNoEscape() const {\n@@ -6408,11 +6411,11 @@ inline ArrayRef<AnyFunctionType::Param> AnyFunctionType::getParams() const {\n     llvm_unreachable(\"Undefined function type\");\n   }\n }\n-  \n+\n /// If this is a method in a type or extension thereof, compute\n /// and return a parameter to be used for the 'self' argument.  The type of\n /// the parameter is the empty Type() if no 'self' argument should exist. This\n-/// can only be used after name binding has resolved types.\n+/// can only be used after types have been resolved.\n ///\n /// \\param isInitializingCtor Specifies whether we're computing the 'self'\n /// type of an initializing constructor, which accepts an instance 'self'"
                    },
                    {
                        "filename": "include/swift/Basic/BlotMapVector.h",
                        "code": "@@ -66,15 +66,40 @@ class BlotMapVector {\n     return Vector[Pair.first->second].getValue().second;\n   }\n \n-  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &InsertPair) {\n-    auto Pair = Map.insert(std::make_pair(InsertPair.first, size_t(0)));\n-    if (Pair.second) {\n-      size_t Num = Vector.size();\n-      Pair.first->second = Num;\n-      Vector.push_back(InsertPair);\n-      return std::make_pair(Vector.begin() + Num, true);\n+  template <typename... Ts>\n+  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n+    auto Pair = Map.insert(std::make_pair(std::move(Key), size_t(0)));\n+    if (!Pair.second) {\n+      return std::make_pair(Vector.begin() + Pair.first->second, false);\n+    }\n+\n+    size_t Num = Vector.size();\n+    Pair.first->second = Num;\n+    Vector.emplace_back(\n+        std::make_pair(Pair.first->first, ValueT(std::forward<Ts>(Args)...)));\n+    return std::make_pair(Vector.begin() + Num, true);\n+  }\n+\n+  template <typename... Ts>\n+  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n+    auto Pair = Map.insert(std::make_pair(std::move(Key), size_t(0)));\n+    if (!Pair.second) {\n+      return std::make_pair(Vector.begin() + Pair.first->second, false);\n     }\n-    return std::make_pair(Vector.begin() + Pair.first->second, false);\n+\n+    size_t Num = Vector.size();\n+    Pair.first->second = Num;\n+    Vector.emplace_back(\n+        std::make_pair(Pair.first->first, ValueT(std::forward<Ts>(Args)...)));\n+    return std::make_pair(Vector.begin() + Num, true);\n+  }\n+\n+  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &InsertPair) {\n+    return try_emplace(InsertPair.first, InsertPair.second);\n+  }\n+\n+  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &InsertPair) {\n+    return try_emplace(InsertPair.first, InsertPair.second);\n   }\n \n   iterator find(const KeyT &Key) {"
                    },
                    {
                        "filename": "include/swift/Basic/CTypeIDZone.def",
                        "code": "@@ -35,6 +35,7 @@ SWIFT_TYPEID_NAMED(void, Void)\n SWIFT_TYPEID_NAMED(std::string, String)\n \n // C++ standard library types.\n+SWIFT_TYPEID_NAMED(evaluator::SideEffect, SideEffect)\n SWIFT_TYPEID_TEMPLATE1_NAMED(std::vector, Vector, typename T, T)\n SWIFT_TYPEID_TEMPLATE1_NAMED(std::unique_ptr, UniquePtr, typename T, T)\n "
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -55,9 +55,9 @@ class DiagnosticOptions {\n   // When printing diagnostics, include the diagnostic name at the end\n   bool PrintDiagnosticNames = false;\n \n-  /// If set to true, display educational note content to the user if available.\n+  /// If set to true, include educational notes in printed output if available.\n   /// Educational notes are documentation which supplement diagnostics.\n-  bool EnableEducationalNotes = false;\n+  bool PrintEducationalNotes = false;\n \n   // If set to true, use the more descriptive experimental formatting style for\n   // diagnostics."
                    },
                    {
                        "filename": "include/swift/Basic/LangOptions.h",
                        "code": "@@ -296,6 +296,11 @@ namespace swift {\n     /// incrementals parsing.\n     bool BuildSyntaxTree = false;\n \n+    /// Whether parsing is occurring for creation of syntax tree only, and no typechecking will occur after\n+    /// parsing e.g. when parsing for SwiftSyntax. This is intended to affect parsing, e.g. disable\n+    /// unnecessary name lookups that are not useful for pure syntactic parsing.\n+    bool ParseForSyntaxTreeOnly = false;\n+\n     /// Whether to verify the parsed syntax tree and emit related diagnostics.\n     bool VerifySyntaxTree = false;\n \n@@ -322,9 +327,16 @@ namespace swift {\n     /// `@differentiable` declaration attribute, etc.\n     bool EnableExperimentalDifferentiableProgramming = false;\n \n+    /// Whether to enable experimental `AdditiveArithmetic` derived\n+    /// conformances.\n+    bool EnableExperimentalAdditiveArithmeticDerivedConformances = false;\n+\n     /// Enable verification when every SubstitutionMap is constructed.\n     bool VerifyAllSubstitutionMaps = false;\n \n+    /// If set to \\c false, fall back to the legacy manual reference name tracking code.\n+    bool EnableRequestBasedIncrementalDependencies = true;\n+\n     /// Sets the target we are building for and updates platform conditions\n     /// to match.\n     ///"
                    },
                    {
                        "filename": "include/swift/Basic/MultiMapCache.h",
                        "code": "@@ -0,0 +1,105 @@\n+//===--- MultiMapCache.h --------------------------------------------------===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SWIFT_BASIC_MULTIMAPCACHE_H\n+#define SWIFT_BASIC_MULTIMAPCACHE_H\n+\n+#include \"swift/Basic/LLVM.h\"\n+#include \"llvm/ADT/DenseMap.h\"\n+\n+namespace swift {\n+\n+/// A CRTP write-once multi-map cache that can be small. It uses a DenseMap\n+/// internally, so it can be used as a cache without needing to be frozen like\n+/// FrozenMultiMap (which uses only a vector internally). The Impl class\n+/// implements the method constructValuesForKey that is used to compute the\n+/// actual cache value.\n+///\n+/// NOTE: constructValuesForKeys is assumed to take a KeyTy and a\n+/// SmallVectorImpl<ValueTy>. It must append all results to that accumulator and\n+/// not read any contents of the accumulator.\n+///\n+/// NOTE: We store the (size, length) of each ArrayRef<ValueTy> instead of\n+/// storing the ArrayRef to avoid data invalidation issues caused by SmallVector\n+/// switching from small to large representations.\n+///\n+/// For an example of a subclass implementation see:\n+/// unittests/Basic/MultiMapCacheTest.cpp.\n+template <typename ImplType, typename KeyTy, typename ValueTy,\n+          typename MapTy =\n+              llvm::DenseMap<KeyTy, Optional<std::tuple<unsigned, unsigned>>>,\n+          typename VectorTy = std::vector<ValueTy>,\n+          typename VectorTyImpl = VectorTy>\n+class MultiMapCache {\n+  MapTy valueToDataOffsetIndexMap;\n+  VectorTy data;\n+\n+  constexpr static unsigned ArrayStartOffset = 0;\n+  constexpr static unsigned ArrayLengthOffset = 1;\n+\n+  constexpr ImplType &asImpl() const {\n+    auto *self = const_cast<MultiMapCache *>(this);\n+    return reinterpret_cast<ImplType &>(*self);\n+  }\n+\n+public:\n+  void clear() {\n+    valueToDataOffsetIndexMap.clear();\n+    data.clear();\n+  }\n+\n+  bool empty() const { return valueToDataOffsetIndexMap.empty(); }\n+  unsigned size() const { return valueToDataOffsetIndexMap.size(); }\n+\n+  Optional<ArrayRef<ValueTy>> get(const KeyTy &key) {\n+    auto iter = valueToDataOffsetIndexMap.try_emplace(key, None);\n+\n+    // If we already have a cached value, just return the cached value.\n+    if (!iter.second) {\n+      return iter.first->second.map(\n+          [&](std::tuple<unsigned, unsigned> startLengthRange) {\n+            return llvm::makeArrayRef(data).slice(\n+                std::get<ArrayStartOffset>(startLengthRange),\n+                std::get<ArrayLengthOffset>(startLengthRange));\n+          });\n+    }\n+\n+    // Otherwise, try to compute the value. If we failed conservatively, return\n+    // None. The iter value already had None by default set to it, this just\n+    // makes it so that we do not need to have a memory dependency and can just\n+    // exit.\n+    unsigned initialOffset = data.size();\n+\n+    // We assume that constructValuesForKey /only/ inserts to the end of data\n+    // and does not inspect any other values in the data array.\n+    if (!asImpl().constructValuesForKey(key, data)) {\n+      return None;\n+    }\n+\n+    // Otherwise, compute our our length, compute our initial ArrayRef<ValueTy>,\n+    // update the map with the start, length, and return the resulting ArrayRef.\n+    unsigned length = data.size() - initialOffset;\n+    iter.first->second = std::make_tuple(initialOffset, length);\n+    auto result = llvm::makeArrayRef(data).slice(initialOffset, length);\n+    return result;\n+  }\n+};\n+\n+template <typename ImplType, typename KeyTy, typename ValueTy>\n+using SmallMultiMapCache = MultiMapCache<\n+    ImplType, KeyTy, ValueTy,\n+    llvm::SmallDenseMap<KeyTy, Optional<std::tuple<unsigned, unsigned>>, 8>,\n+    SmallVector<ValueTy, 32>, SmallVectorImpl<ValueTy>>;\n+\n+} // namespace swift\n+\n+#endif"
                    },
                    {
                        "filename": "include/swift/Basic/Statistics.def",
                        "code": "@@ -130,10 +130,8 @@ FRONTEND_STATISTIC(AST, NumLocalTypeDecls)\n /// Number of Objective-C declarations in the AST context.\n FRONTEND_STATISTIC(AST, NumObjCMethods)\n \n-/// Number of infix, postfix, and prefix operators in the AST context.\n-FRONTEND_STATISTIC(AST, NumInfixOperators)\n-FRONTEND_STATISTIC(AST, NumPostfixOperators)\n-FRONTEND_STATISTIC(AST, NumPrefixOperators)\n+/// Number of operators in the AST context.\n+FRONTEND_STATISTIC(AST, NumOperators)\n \n /// Number of precedence groups in the AST context.\n FRONTEND_STATISTIC(AST, NumPrecedenceGroups)"
                    },
                    {
                        "filename": "include/swift/Basic/TypeID.h",
                        "code": "@@ -66,6 +66,29 @@ constexpr uint64_t formTypeID(uint8_t zone, uint8_t type) {\n   return (uint64_t(zone) << 8) | uint64_t(type);\n }\n \n+namespace evaluator {\n+/// The return type of requests that execute side effects.\n+///\n+/// In general, it is not appropriate to use the request evaluator framework to\n+/// execute a request for the sake of its side effects. However, there are\n+/// operations we would currently like to be requests because it makes modelling\n+/// some aspect of their implementation particularly nice. For example, an\n+/// operation that emits diagnostics to run some checking code in a primary\n+/// file may be desirable to requestify because it should be run only once per\n+/// declaration, but it has no coherent return value. Another category of\n+/// side-effecting requests are those that adapt existing parts of the compiler that\n+/// do not yet behave in a \"functional\" manner to have a functional interface. Consider\n+/// the request to run the SIL Optimizer. In theory, it should be a request that takes in\n+/// a SILModule and returns a SILModule. In practice, it is a request that executes\n+/// effects against a SILModule.\n+///\n+/// To make these requests stand out - partially in the hope we can return and\n+/// refactor them to behave in a more well-structured manner, partially because\n+/// they cannot return \\c void or we will get template substitution failures - we\n+/// annotate them as computing an \\c evaluator::SideEffect.\n+using SideEffect = std::tuple<>;\n+}\n+\n // Define the C type zone (zone 0).\n #define SWIFT_TYPEID_ZONE C\n #define SWIFT_TYPEID_HEADER \"swift/Basic/CTypeIDZone.def\""
                    },
                    {
                        "filename": "include/swift/Demangling/DemangleNodes.def",
                        "code": "@@ -68,6 +68,10 @@ NODE(DependentProtocolConformanceInherited)\n NODE(DependentProtocolConformanceAssociated)\n CONTEXT_NODE(Destructor)\n CONTEXT_NODE(DidSet)\n+NODE(DifferentiableFunctionType)\n+NODE(EscapingDifferentiableFunctionType)\n+NODE(LinearFunctionType)\n+NODE(EscapingLinearFunctionType)\n NODE(Directness)\n NODE(DynamicAttribute)\n NODE(DirectMethodReferenceAttribute)\n@@ -109,6 +113,8 @@ NODE(Identifier)\n NODE(Index)\n CONTEXT_NODE(IVarInitializer)\n CONTEXT_NODE(IVarDestroyer)\n+NODE(ImplDifferentiable)\n+NODE(ImplLinear)\n NODE(ImplEscaping)\n NODE(ImplConvention)\n NODE(ImplFunctionAttribute)"
                    },
                    {
                        "filename": "include/swift/Demangling/TypeDecoder.h",
                        "code": "@@ -181,33 +181,53 @@ enum class ImplFunctionRepresentation {\n   Closure\n };\n \n+enum class ImplFunctionDifferentiabilityKind {\n+  NonDifferentiable,\n+  Normal,\n+  Linear\n+};\n+\n class ImplFunctionTypeFlags {\n   unsigned Rep : 3;\n   unsigned Pseudogeneric : 1;\n   unsigned Escaping : 1;\n+  unsigned DifferentiabilityKind : 2;\n \n public:\n-  ImplFunctionTypeFlags() : Rep(0), Pseudogeneric(0), Escaping(0) {}\n+  ImplFunctionTypeFlags()\n+      : Rep(0), Pseudogeneric(0), Escaping(0), DifferentiabilityKind(0) {}\n \n-  ImplFunctionTypeFlags(ImplFunctionRepresentation rep,\n-                        bool pseudogeneric, bool noescape)\n-      : Rep(unsigned(rep)), Pseudogeneric(pseudogeneric), Escaping(noescape) {}\n+  ImplFunctionTypeFlags(ImplFunctionRepresentation rep, bool pseudogeneric,\n+                        bool noescape,\n+                        ImplFunctionDifferentiabilityKind diffKind)\n+      : Rep(unsigned(rep)), Pseudogeneric(pseudogeneric), Escaping(noescape),\n+        DifferentiabilityKind(unsigned(diffKind)) {}\n \n   ImplFunctionTypeFlags\n   withRepresentation(ImplFunctionRepresentation rep) const {\n-    return ImplFunctionTypeFlags(rep, Pseudogeneric, Escaping);\n+    return ImplFunctionTypeFlags(\n+        rep, Pseudogeneric, Escaping,\n+        ImplFunctionDifferentiabilityKind(DifferentiabilityKind));\n   }\n \n   ImplFunctionTypeFlags\n   withEscaping() const {\n-    return ImplFunctionTypeFlags(ImplFunctionRepresentation(Rep),\n-                                 Pseudogeneric, true);\n+    return ImplFunctionTypeFlags(\n+        ImplFunctionRepresentation(Rep), Pseudogeneric, true,\n+        ImplFunctionDifferentiabilityKind(DifferentiabilityKind));\n   }\n   \n   ImplFunctionTypeFlags\n   withPseudogeneric() const {\n-    return ImplFunctionTypeFlags(ImplFunctionRepresentation(Rep),\n-                                 true, Escaping);\n+    return ImplFunctionTypeFlags(\n+        ImplFunctionRepresentation(Rep), true, Escaping,\n+        ImplFunctionDifferentiabilityKind(DifferentiabilityKind));\n+  }\n+\n+  ImplFunctionTypeFlags\n+  withDifferentiabilityKind(ImplFunctionDifferentiabilityKind diffKind) const {\n+    return ImplFunctionTypeFlags(ImplFunctionRepresentation(Rep), Pseudogeneric,\n+                                 Escaping, diffKind);\n   }\n \n   ImplFunctionRepresentation getRepresentation() const {\n@@ -217,6 +237,10 @@ class ImplFunctionTypeFlags {\n   bool isEscaping() const { return Escaping; }\n \n   bool isPseudogeneric() const { return Pseudogeneric; }\n+\n+  ImplFunctionDifferentiabilityKind getDifferentiabilityKind() const {\n+    return ImplFunctionDifferentiabilityKind(DifferentiabilityKind);\n+  }\n };\n \n #if SWIFT_OBJC_INTEROP\n@@ -494,6 +518,10 @@ class TypeDecoder {\n     case NodeKind::NoEscapeFunctionType:\n     case NodeKind::AutoClosureType:\n     case NodeKind::EscapingAutoClosureType:\n+    case NodeKind::DifferentiableFunctionType:\n+    case NodeKind::EscapingDifferentiableFunctionType:\n+    case NodeKind::LinearFunctionType:\n+    case NodeKind::EscapingLinearFunctionType:\n     case NodeKind::FunctionType: {\n       if (Node->getNumChildren() < 2)\n         return BuiltType();\n@@ -507,6 +535,15 @@ class TypeDecoder {\n           flags.withConvention(FunctionMetadataConvention::CFunctionPointer);\n       } else if (Node->getKind() == NodeKind::ThinFunctionType) {\n         flags = flags.withConvention(FunctionMetadataConvention::Thin);\n+      } else if (Node->getKind() == NodeKind::DifferentiableFunctionType ||\n+               Node->getKind() ==\n+                   NodeKind::EscapingDifferentiableFunctionType) {\n+        flags = flags.withDifferentiabilityKind(\n+            FunctionMetadataDifferentiabilityKind::Normal);\n+      } else if (Node->getKind() == NodeKind::LinearFunctionType ||\n+                 Node->getKind() == NodeKind::EscapingLinearFunctionType) {\n+        flags = flags.withDifferentiabilityKind(\n+            FunctionMetadataDifferentiabilityKind::Linear);\n       }\n \n       bool isThrow =\n@@ -527,7 +564,11 @@ class TypeDecoder {\n               .withEscaping(\n                           Node->getKind() == NodeKind::FunctionType ||\n                           Node->getKind() == NodeKind::EscapingAutoClosureType ||\n-                          Node->getKind() == NodeKind::EscapingObjCBlock);\n+                          Node->getKind() == NodeKind::EscapingObjCBlock ||\n+                          Node->getKind() ==\n+                              NodeKind::EscapingDifferentiableFunctionType ||\n+                          Node->getKind() ==\n+                              NodeKind::EscapingLinearFunctionType);\n \n       auto result = decodeMangledType(Node->getChild(isThrow ? 2 : 1));\n       if (!result) return BuiltType();\n@@ -565,6 +606,14 @@ class TypeDecoder {\n             flags =\n               flags.withRepresentation(ImplFunctionRepresentation::Block);\n           }\n+        } else if (child->getKind() == NodeKind::ImplDifferentiable) {\n+          flags = flags.withDifferentiabilityKind(\n+              ImplFunctionDifferentiabilityKind::Normal);\n+        } else if (child->getKind() == NodeKind::ImplLinear) {\n+          flags = flags.withDifferentiabilityKind(\n+              ImplFunctionDifferentiabilityKind::Linear);\n+        } else if (child->getKind() == NodeKind::ImplEscaping) {\n+          flags = flags.withEscaping();\n         } else if (child->getKind() == NodeKind::ImplEscaping) {\n           flags = flags.withEscaping();\n         } else if (child->getKind() == NodeKind::ImplParameter) {"
                    },
                    {
                        "filename": "include/swift/Frontend/DiagnosticVerifier.h",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -18,30 +18,90 @@\n #ifndef SWIFT_FRONTEND_DIAGNOSTIC_VERIFIER_H\n #define SWIFT_FRONTEND_DIAGNOSTIC_VERIFIER_H\n \n+#include \"llvm/ADT/SmallString.h\"\n+#include \"swift/AST/DiagnosticConsumer.h\"\n #include \"swift/Basic/LLVM.h\"\n \n namespace swift {\n-  class DependencyTracker;\n-  class FileUnit;\n-  class SourceManager;\n-  class SourceFile;\n-\n-  /// Set up the specified source manager so that diagnostics are captured\n-  /// instead of being printed.\n-  void enableDiagnosticVerifier(SourceManager &SM);\n-\n-  /// Verify that captured diagnostics meet with the expectations of the source\n-  /// files corresponding to the specified \\p BufferIDs and tear down our\n-  /// support for capturing and verifying diagnostics.\n-  ///\n-  /// This returns true if there are any mismatches found.\n-  bool verifyDiagnostics(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n-                         bool autoApplyFixes, bool ignoreUnknown);\n-\n-  bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n-                          ArrayRef<FileUnit *> SFs);\n-  bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n-                          ArrayRef<SourceFile *> SFs);\n-}\n+class DependencyTracker;\n+class FileUnit;\n+class SourceManager;\n+class SourceFile;\n+\n+// MARK: - DependencyVerifier\n+\n+bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n+                        ArrayRef<FileUnit *> SFs);\n+bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n+                        ArrayRef<SourceFile *> SFs);\n+\n+// MARK: - DiagnosticVerifier\n+struct ExpectedFixIt;\n+\n+struct CapturedDiagnosticInfo {\n+  llvm::SmallString<128> Message;\n+  llvm::SmallString<32> FileName;\n+  DiagnosticKind Classification;\n+  SourceLoc Loc;\n+  unsigned Line;\n+  unsigned Column;\n+  SmallVector<DiagnosticInfo::FixIt, 2> FixIts;\n+\n+  CapturedDiagnosticInfo(llvm::SmallString<128> Message,\n+                         llvm::SmallString<32> FileName,\n+                         DiagnosticKind Classification, SourceLoc Loc,\n+                         unsigned Line, unsigned Column,\n+                         SmallVector<DiagnosticInfo::FixIt, 2> FixIts)\n+      : Message(Message), FileName(FileName), Classification(Classification),\n+        Loc(Loc), Line(Line), Column(Column), FixIts(FixIts) {}\n+};\n+/// This class implements support for -verify mode in the compiler.  It\n+/// buffers up diagnostics produced during compilation, then checks them\n+/// against expected-error markers in the source file.\n+class DiagnosticVerifier : public DiagnosticConsumer {\n+  SourceManager &SM;\n+  std::vector<CapturedDiagnosticInfo> CapturedDiagnostics;\n+  ArrayRef<unsigned> BufferIDs;\n+  bool AutoApplyFixes;\n+  bool IgnoreUnknown;\n+\n+public:\n+  explicit DiagnosticVerifier(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n+                              bool AutoApplyFixes, bool IgnoreUnknown)\n+      : SM(SM), BufferIDs(BufferIDs), AutoApplyFixes(AutoApplyFixes),\n+        IgnoreUnknown(IgnoreUnknown) {}\n+\n+  virtual void handleDiagnostic(SourceManager &SM,\n+                                const DiagnosticInfo &Info) override;\n+\n+  virtual bool finishProcessing() override;\n+\n+private:\n+  /// Result of verifying a file.\n+  struct Result {\n+    /// Were there any errors? All of the following are considered errors:\n+    /// - Expected diagnostics that were not present\n+    /// - Unexpected diagnostics that were present\n+    /// - Errors in the definition of expected diagnostics\n+    bool HadError;\n+    bool HadUnexpectedDiag;\n+  };\n+\n+  /// verifyFile - After the file has been processed, check to see if we\n+  /// got all of the expected diagnostics and check to see if there were any\n+  /// unexpected ones.\n+  Result verifyFile(unsigned BufferID);\n+\n+  bool checkForFixIt(const ExpectedFixIt &Expected,\n+                     const CapturedDiagnosticInfo &D, StringRef buffer);\n+\n+  // Render the verifier syntax for a given set of fix-its.\n+  std::string renderFixits(ArrayRef<DiagnosticInfo::FixIt> fixits,\n+                           StringRef InputFile);\n+\n+  void printRemainingDiagnostics() const;\n+};\n+\n+} // end namespace swift\n \n #endif"
                    },
                    {
                        "filename": "include/swift/Frontend/Frontend.h",
                        "code": "@@ -31,6 +31,7 @@\n #include \"swift/Basic/SourceManager.h\"\n #include \"swift/ClangImporter/ClangImporter.h\"\n #include \"swift/ClangImporter/ClangImporterOptions.h\"\n+#include \"swift/Frontend/DiagnosticVerifier.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n #include \"swift/Frontend/ModuleInterfaceSupport.h\"\n #include \"swift/Migrator/MigratorOptions.h\"\n@@ -405,6 +406,7 @@ class CompilerInstance {\n   std::unique_ptr<ASTContext> Context;\n   std::unique_ptr<Lowering::TypeConverter> TheSILTypes;\n   std::unique_ptr<SILModule> TheSILModule;\n+  std::unique_ptr<DiagnosticVerifier> DiagVerifier;\n \n   /// Null if no tracker.\n   std::unique_ptr<DependencyTracker> DepTracker;\n@@ -585,6 +587,7 @@ class CompilerInstance {\n   bool setUpInputs();\n   bool setUpASTContextIfNeeded();\n   void setupStatsReporter();\n+  void setupDiagnosticVerifierIfNeeded();\n   Optional<unsigned> setUpCodeCompletionBuffer();\n \n   /// Set up all state in the CompilerInstance to process the given input file.\n@@ -623,7 +626,7 @@ class CompilerInstance {\n   void performParseOnly(bool EvaluateConditionals = false,\n                         bool CanDelayBodies = true);\n \n-  /// Parses and performs name binding on all input files.\n+  /// Parses and performs import resolution on all input files.\n   ///\n   /// This is similar to a parse-only invocation, but module imports will also\n   /// be processed."
                    },
                    {
                        "filename": "include/swift/Frontend/FrontendOptions.h",
                        "code": "@@ -82,6 +82,9 @@ class FrontendOptions {\n   /// Emit index data for imported serialized swift system modules.\n   bool IndexSystemModules = false;\n \n+  /// If indexing system modules, don't index the stdlib.\n+  bool IndexIgnoreStdlib = false;\n+\n   /// The module for which we should verify all of the generic signatures.\n   std::string VerifyGenericSignaturesInModule;\n "
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -31,6 +31,7 @@ class AnnotatedSourceSnippet;\n class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   llvm::raw_ostream &Stream;\n   bool ForceColors = false;\n+  bool PrintEducationalNotes = false;\n   bool DidErrorOccur = false;\n   bool ExperimentalFormattingEnabled = false;\n   // The current snippet used to display an error/warning/remark and the notes\n@@ -40,6 +41,7 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   // Educational notes which are buffered until the consumer is finished\n   // constructing a snippet.\n   SmallVector<std::string, 1> BufferedEducationalNotes;\n+  bool SuppressOutput = false;\n \n public:\n   PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs());\n@@ -59,12 +61,20 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n     llvm::sys::Process::UseANSIEscapeCodes(true);\n   }\n \n+  void setPrintEducationalNotes(bool ShouldPrint) {\n+    PrintEducationalNotes = ShouldPrint;\n+  }\n+\n   void enableExperimentalFormatting() { ExperimentalFormattingEnabled = true; }\n \n   bool didErrorOccur() {\n     return DidErrorOccur;\n   }\n \n+  void setSuppressOutput(bool suppressOutput) {\n+    SuppressOutput = suppressOutput;\n+  }\n+\n private:\n   void printDiagnostic(SourceManager &SM, const DiagnosticInfo &Info);\n };"
                    },
                    {
                        "filename": "include/swift/IDE/IDERequests.h",
                        "code": "@@ -60,7 +60,7 @@ void simple_display(llvm::raw_ostream &out, const CursorInfoOwner &owner);\n class CursorInfoRequest:\n     public SimpleRequest<CursorInfoRequest,\n                          ide::ResolvedCursorInfo(CursorInfoOwner),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -69,8 +69,8 @@ class CursorInfoRequest:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ide::ResolvedCursorInfo> evaluate(Evaluator &evaluator,\n-    CursorInfoOwner CI) const;\n+  ide::ResolvedCursorInfo evaluate(Evaluator &evaluator,\n+                                   CursorInfoOwner CI) const;\n \n public:\n   // Caching\n@@ -121,7 +121,7 @@ void simple_display(llvm::raw_ostream &out, const RangeInfoOwner &owner);\n class RangeInfoRequest:\n     public SimpleRequest<RangeInfoRequest,\n                          ide::ResolvedRangeInfo(RangeInfoOwner),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -130,8 +130,8 @@ class RangeInfoRequest:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ide::ResolvedRangeInfo> evaluate(Evaluator &evaluator,\n-    RangeInfoOwner CI) const;\n+  ide::ResolvedRangeInfo evaluate(Evaluator &evaluator,\n+                                  RangeInfoOwner CI) const;\n \n public:\n   // Caching\n@@ -149,7 +149,7 @@ class RangeInfoRequest:\n class ProvideDefaultImplForRequest:\n     public SimpleRequest<ProvideDefaultImplForRequest,\n                          ArrayRef<ValueDecl*>(ValueDecl*),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -158,8 +158,8 @@ class ProvideDefaultImplForRequest:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ArrayRef<ValueDecl*>> evaluate(Evaluator &evaluator,\n-    ValueDecl* VD) const;\n+  ArrayRef<ValueDecl*> evaluate(Evaluator &evaluator,\n+                                ValueDecl* VD) const;\n \n public:\n   // Caching\n@@ -211,16 +211,16 @@ struct OverridenDeclsOwner {\n class CollectOverriddenDeclsRequest:\n     public SimpleRequest<CollectOverriddenDeclsRequest,\n                          ArrayRef<ValueDecl*>(OverridenDeclsOwner),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ArrayRef<ValueDecl*>> evaluate(Evaluator &evaluator,\n-    OverridenDeclsOwner Owner) const;\n+  ArrayRef<ValueDecl*> evaluate(Evaluator &evaluator,\n+                                OverridenDeclsOwner Owner) const;\n \n public:\n   // Caching\n@@ -262,7 +262,7 @@ struct ProtocolNameOwner {\n class ResolveProtocolNameRequest:\n     public SimpleRequest<ResolveProtocolNameRequest,\n                          ProtocolDecl*(ProtocolNameOwner),\n-                         CacheKind::Cached>\n+                         RequestFlags::Cached>\n {\n public:\n   using SimpleRequest::SimpleRequest;\n@@ -271,8 +271,8 @@ class ResolveProtocolNameRequest:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<ProtocolDecl*> evaluate(Evaluator &evaluator,\n-    ProtocolNameOwner Input) const;\n+  ProtocolDecl *evaluate(Evaluator &evaluator,\n+                         ProtocolNameOwner Input) const;\n \n public:\n   // Caching"
                    },
                    {
                        "filename": "include/swift/IRGen/Linking.h",
                        "code": "@@ -554,9 +554,7 @@ class LinkEntity {\n   LinkEntity() = default;\n \n   static bool isValidResilientMethodRef(SILDeclRef declRef) {\n-    if (declRef.isForeign ||\n-        declRef.isDirectReference ||\n-        declRef.isCurried)\n+    if (declRef.isForeign)\n       return false;\n \n     auto *decl = declRef.getDecl();"
                    },
                    {
                        "filename": "include/swift/Index/IndexRecord.h",
                        "code": "@@ -36,14 +36,18 @@ namespace index {\n /// \\param indexSystemModules If true, emit index data for imported serialized\n /// swift system modules.\n ///\n+/// \\param skipStdlib If indexing system modules, don't index the standard\n+/// library.\n+///\n /// \\param isDebugCompilation true for non-optimized compiler invocation.\n ///\n /// \\param targetTriple The target for this compilation.\n ///\n /// \\param dependencyTracker The set of dependencies seen while building.\n bool indexAndRecord(SourceFile *primarySourceFile, StringRef indexUnitToken,\n                     StringRef indexStorePath, bool indexSystemModules,\n-                    bool isDebugCompilation, StringRef targetTriple,\n+                    bool skipStdlib, bool isDebugCompilation,\n+                    StringRef targetTriple,\n                     const DependencyTracker &dependencyTracker);\n \n /// Index the given module and store the results to \\p indexStorePath.\n@@ -64,15 +68,18 @@ bool indexAndRecord(SourceFile *primarySourceFile, StringRef indexUnitToken,\n /// \\param indexSystemModules If true, emit index data for imported serialized\n /// swift system modules.\n ///\n+/// \\param skipStdlib If indexing system modules, don't index the standard\n+/// library.\n+///\n /// \\param isDebugCompilation true for non-optimized compiler invocation.\n ///\n /// \\param targetTriple The target for this compilation.\n ///\n /// \\param dependencyTracker The set of dependencies seen while building.\n bool indexAndRecord(ModuleDecl *module, ArrayRef<std::string> indexUnitTokens,\n                     StringRef moduleUnitToken, StringRef indexStorePath,\n-                    bool indexSystemModules, bool isDebugCompilation,\n-                    StringRef targetTriple,\n+                    bool indexSystemModules, bool skipStdlib,\n+                    bool isDebugCompilation, StringRef targetTriple,\n                     const DependencyTracker &dependencyTracker);\n // FIXME: indexUnitTokens could be StringRef, but that creates an impedance\n // mismatch in the caller."
                    },
                    {
                        "filename": "include/swift/Option/FrontendOptions.td",
                        "code": "@@ -130,9 +130,6 @@ def enable_cross_import_overlays : Flag<[\"-\"], \"enable-cross-import-overlays\">,\n   HelpText<\"Automatically import declared cross-import overlays.\">;\n def disable_cross_import_overlays : Flag<[\"-\"], \"disable-cross-import-overlays\">,\n   HelpText<\"Do not automatically import declared cross-import overlays.\">;\n-\n-def enable_educational_notes : Flag<[\"-\"], \"enable-educational-notes\">,\n-  HelpText<\"Show educational notes, if available.\">;\n   \n def enable_experimental_diagnostic_formatting :\n   Flag<[\"-\"], \"enable-experimental-diagnostic-formatting\">,\n@@ -510,6 +507,10 @@ def disable_debugger_shadow_copies : Flag<[\"-\"], \"disable-debugger-shadow-copies\n            \"This option is only useful for testing the compiler.\">,\n   Flags<[FrontendOption, HelpHidden]>;\n \n+def disable_concrete_type_metadata_mangled_name_accessors : Flag<[\"-\"], \"disable-concrete-type-metadata-mangled-name-accessors\">,\n+  HelpText<\"Disable concrete type metadata access by mangled name\">,\n+  Flags<[FrontendOption, HelpHidden]>;\n+  \n def playground : Flag<[\"-\"], \"playground\">,\n   HelpText<\"Apply the playground semantics and transformation\">;\n \n@@ -600,6 +601,10 @@ def external_pass_pipeline_filename : Separate<[\"-\"], \"external-pass-pipeline-fi\n def index_system_modules : Flag<[\"-\"], \"index-system-modules\">,\n   HelpText<\"Emit index data for imported serialized swift system modules\">;\n \n+def index_ignore_stdlib :\n+  Flag<[\"-\"], \"index-ignore-stdlib\">,\n+  HelpText<\"Avoid emitting index data for the standard library.\">;\n+\n def dump_interface_hash : Flag<[\"-\"], \"dump-interface-hash\">,\n    HelpText<\"Parse input file(s) and dump interface token hash(es)\">,\n    ModeOpt;"
                    },
                    {
                        "filename": "include/swift/Option/Options.td",
                        "code": "@@ -372,6 +372,9 @@ def no_color_diagnostics : Flag<[\"-\"], \"no-color-diagnostics\">,\n def debug_diagnostic_names : Flag<[\"-\"], \"debug-diagnostic-names\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild, HelpHidden]>,\n   HelpText<\"Include diagnostic names when printing\">;\n+def print_educational_notes : Flag<[\"-\"], \"print-educational-notes\">,\n+  Flags<[FrontendOption, DoesNotAffectIncrementalBuild]>,\n+  HelpText<\"Include educational notes in printed diagnostic output, if available\">;\n \n def module_cache_path : Separate<[\"-\"], \"module-cache-path\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild, ArgumentIsPath]>,\n@@ -495,10 +498,16 @@ def disable_bridging_pch : Flag<[\"-\"], \"disable-bridging-pch\">,\n   HelpText<\"Disable automatic generation of bridging PCH files\">;\n \n // Experimental feature options\n-def enable_experimental_differentiable_programming : Flag<[\"-\"], \"enable-experimental-differentiable-programming\">,\n+def enable_experimental_differentiable_programming :\n+  Flag<[\"-\"], \"enable-experimental-differentiable-programming\">,\n   Flags<[FrontendOption]>,\n   HelpText<\"Enable experimental differentiable programming features\">;\n \n+def enable_experimental_additive_arithmetic_derivation :\n+  Flag<[\"-\"], \"enable-experimental-additive-arithmetic-derivation\">,\n+  Flags<[FrontendOption]>,\n+  HelpText<\"Enable experimental 'AdditiveArithmetic' derived conformances\">;\n+\n def enable_experimental_concise_pound_file : Flag<[\"-\"],\n     \"enable-experimental-concise-pound-file\">,\n   Flags<[FrontendOption]>,\n@@ -1024,6 +1033,16 @@ def disable_parser_lookup : Flag<[\"-\"], \"disable-parser-lookup\">,\n   Flags<[FrontendOption]>,\n   HelpText<\"Disable parser lookup & use ast scope lookup only (experimental)\">;\n \n+def enable_request_based_incremental_dependencies : Flag<[\"-\"],\n+  \"enable-request-based-incremental-dependencies\">,\n+  Flags<[FrontendOption]>,\n+  HelpText<\"Enable request-based name tracking\">;\n+\n+def disable_request_based_incremental_dependencies : Flag<[\"-\"],\n+  \"disable-request-based-incremental-dependencies\">,\n+  Flags<[FrontendOption]>,\n+  HelpText<\"Disable request-based name tracking\">;\n+\n def index_file : Flag<[\"-\"], \"index-file\">,\n   HelpText<\"Produce index data for a source file\">, ModeOpt,\n   Flags<[NoInteractiveOption, DoesNotAffectIncrementalBuild]>;"
                    },
                    {
                        "filename": "include/swift/Parse/Parser.h",
                        "code": "@@ -1010,8 +1010,6 @@ class Parser {\n   /// Parse the arguments inside the @differentiable attribute.\n   bool parseDifferentiableAttributeArguments(\n       bool &linear, SmallVectorImpl<ParsedAutoDiffParameter> &params,\n-      Optional<DeclNameRefWithLoc> &jvpSpec,\n-      Optional<DeclNameRefWithLoc> &vjpSpec,\n       TrailingWhereClause *&whereClause);\n \n   /// Parse a differentiability parameters clause, i.e. the 'wrt:' clause in"
                    },
                    {
                        "filename": "include/swift/Parse/Scope.h",
                        "code": "@@ -170,7 +170,7 @@ inline ValueDecl *ScopeInfo::lookupValueName(DeclNameRef Name) {\n   assert(CurScope && \"no scope\");\n   // If we found nothing, or we found a decl at the top-level, return nothing.\n   // We ignore results at the top-level because we may have overloading that\n-  // will be resolved properly by name binding.\n+  // will be resolved properly by name lookup.\n   std::pair<unsigned, ValueDecl *> Res = HT.lookup(CurScope->HTScope,\n                                                    Name.getFullName());\n   if (Res.first < ResolvableDepth)"
                    },
                    {
                        "filename": "include/swift/Reflection/ReflectionContext.h",
                        "code": "@@ -541,15 +541,35 @@ class ReflectionContext\n   }\n   \n   /// Returns true if the address falls within a registered image.\n-  bool ownsAddress(RemoteAddress Address) {\n+  bool ownsAddressRaw(RemoteAddress Address) {\n     for (auto Range : imageRanges) {\n       auto Start = std::get<0>(Range);\n       auto End = std::get<1>(Range);\n       if (Start.getAddressData() <= Address.getAddressData()\n           && Address.getAddressData() < End.getAddressData())\n         return true;\n     }\n-  \n+\n+    return false;\n+  }\n+\n+  /// Returns true if the address is known to the reflection context.\n+  /// Currently, that means that either the address falls within a registered\n+  /// image, or the address points to a Metadata whose type context descriptor\n+  /// is within a registered image.\n+  bool ownsAddress(RemoteAddress Address) {\n+    if (ownsAddressRaw(Address))\n+      return true;\n+\n+    // This is usually called on a Metadata address which might have been\n+    // on the heap. Try reading it and looking up its type context descriptor\n+    // instead.\n+    if (auto Metadata = readMetadata(Address.getAddressData()))\n+      if (auto DescriptorAddress =\n+          super::readAddressOfNominalTypeDescriptor(Metadata, true))\n+        if (ownsAddressRaw(RemoteAddress(DescriptorAddress)))\n+          return true;\n+\n     return false;\n   }\n   \n@@ -711,181 +731,41 @@ class ReflectionContext\n     }\n   }\n \n+  /// Projects the value of an enum.\n+  ///\n+  /// Takes the address and typeref for an enum and determines the\n+  /// index of the currently-selected case within the enum.\n+  /// You can use this index with `swift_reflection_childOfTypeRef`\n+  /// to get detailed information about the specific case.\n+  ///\n+  /// Returns true if the enum case could be successfully determined.  In\n+  /// particular, note that this code may return false for valid in-memory data\n+  /// if the compiler used a strategy we do not yet understand.\n   bool projectEnumValue(RemoteAddress EnumAddress,\n                         const TypeRef *EnumTR,\n                         int *CaseIndex) {\n-    if (EnumTR == nullptr)\n-      return false;\n-    auto EnumTI = getTypeInfo(EnumTR);\n-    if (EnumTI == nullptr)\n+    // Get the TypeInfo and sanity-check it\n+    if (EnumTR == nullptr) {\n       return false;\n-\n-    auto EnumRecordTI = dyn_cast<const RecordTypeInfo>(EnumTI);\n-    if (EnumRecordTI == nullptr)\n-      return false;\n-    auto EnumSize = EnumRecordTI->getSize();\n-\n-    auto Fields = EnumRecordTI->getFields();\n-    auto FieldCount = Fields.size();\n-    if (FieldCount == 0) {\n-      return false;  // No fields?\n-    }\n-    if (FieldCount == 1) {\n-      *CaseIndex = 0; // Only possible field\n-      return true;\n-    }\n-\n-    switch (EnumRecordTI->getRecordKind()) {\n-\n-    case RecordKind::NoPayloadEnum: {\n-      if (EnumSize == 0) {\n-        *CaseIndex = 0;\n-        return true;\n-      }\n-      return getReader().readInteger(EnumAddress, EnumSize, CaseIndex);\n-    }\n-\n-    case RecordKind::SinglePayloadEnum: {\n-      FieldInfo PayloadCase = Fields[0];\n-      if (!PayloadCase.TR)\n-        return false;\n-      unsigned long NonPayloadCaseCount = FieldCount - 1;\n-      unsigned long PayloadExtraInhabitants = PayloadCase.TI.getNumExtraInhabitants();\n-      unsigned Discriminator = 0;\n-      auto PayloadSize = PayloadCase.TI.getSize();\n-      if (NonPayloadCaseCount >= PayloadExtraInhabitants) {\n-        // There are more cases than inhabitants, we need a separate discriminator.\n-        auto TagInfo = getEnumTagCounts(PayloadSize, NonPayloadCaseCount, 1);\n-        auto TagSize = TagInfo.numTagBytes;\n-        auto TagAddress = RemoteAddress(EnumAddress.getAddressData() + PayloadSize);\n-        if (!getReader().readInteger(TagAddress, TagSize, &Discriminator)) {\n-          printf(\">>>> readXI failed to read discriminator\\n\\n\");\n-          return false;\n-        }\n-      }\n-\n-      if (PayloadSize == 0) {\n-        // Payload carries no information, so discriminator fully determines the case\n-        *CaseIndex = Discriminator;\n-        return true;\n-      } else if (Discriminator == 0) {\n-        // The payload area carries all the information...\n-        if (PayloadExtraInhabitants == 0) {\n-          *CaseIndex = 0;\n-          return true;\n-        }\n-        int XITag = 0;\n-        if (!PayloadCase.TI.readExtraInhabitantIndex(getReader(), EnumAddress, &XITag)) {\n-          return false;\n-        }\n-        if (XITag < 0) { // Valid (not extra) inhabitant\n-          *CaseIndex = 0; // Payload case is always #0\n-          return true;\n-        } else if ((unsigned)XITag <= NonPayloadCaseCount) {\n-          *CaseIndex = XITag + 1;\n-          return true;\n-        }\n-        return false;\n-      } else {\n-        // No payload: Payload area is reused for more cases\n-        uint32_t PayloadTag = 0;\n-        auto PayloadTagSize = std::min(PayloadSize, decltype(PayloadSize)(sizeof(PayloadTag)));\n-        if (!getReader().readInteger(EnumAddress, PayloadTagSize, &PayloadTag)) {\n-          return false;\n-        }\n-        auto XICases = 1U + PayloadExtraInhabitants; // Cases coded with XIs when discriminator = 0\n-        auto PayloadCases = 1U << (PayloadTagSize * 8U);\n-        *CaseIndex = XICases + (Discriminator - 1) * PayloadCases + PayloadTag;\n-        return true;\n-      }\n-    }\n-\n-    case RecordKind::MultiPayloadEnum: {\n-      // Collect basic statistics about the enum\n-      unsigned long PayloadCaseCount = 0;\n-      unsigned long NonPayloadCaseCount = 0;\n-      unsigned long PayloadSize = 0;\n-      for (auto Field : Fields) {\n-        if (Field.TR != 0) {\n-          PayloadCaseCount += 1;\n-          if (Field.TI.getSize() > PayloadSize) {\n-            PayloadSize = Field.TI.getSize();\n-          }\n-        } else {\n-          NonPayloadCaseCount += 1;\n-        }\n-      }\n-      if (EnumSize > PayloadSize) {\n-        // If the compiler laid this out with a separate tag, use that.\n-        unsigned tag = 0;\n-        auto TagSize = EnumSize - PayloadSize;\n-        auto TagAddress = remote::RemoteAddress(EnumAddress.getAddressData() + PayloadSize);\n-        if (!getReader().readInteger(TagAddress, TagSize, &tag)\n-           || tag >= Fields.size()) {\n-          return false;\n-        }\n-        if (tag < PayloadCaseCount) {\n-          *CaseIndex = tag;\n-          return true;\n-        }\n-        auto PayloadTagSize = std::min(PayloadSize, 4UL);\n-        // Treat the tag as a page selector; payload carries the offset within the page\n-        auto Page = tag - PayloadCaseCount;\n-        // Zero for 32-bit because we'll never have more than one page\n-        auto PageSize = PayloadTagSize >= 4 ? 0 : 1 << (PayloadSize * 8U);\n-        auto PageStart = Page * PageSize;\n-        unsigned PayloadTag;\n-        if (!getReader().readInteger(EnumAddress, PayloadTagSize, &PayloadTag)) {\n-          return false;\n-        }\n-        *CaseIndex = PageStart + PayloadTag + PayloadCaseCount;\n-        return true;\n-      } else {\n-        // XXX TODO: If the payloads have common spare bits (e.g., all pointers)\n-        // then use those to decode the case.\n-        return false;\n-      }\n-      break;\n-    }\n-\n-    default:\n-      // Unknown record kind.\n-      break;\n     }\n-    return false;\n-  }\n-\n-  bool getEnumCaseTypeRef(const TypeRef *EnumTR,\n-                          unsigned CaseIndex,\n-                          std::string &Name,\n-                          const TypeRef **OutPayloadTR) {\n-    *OutPayloadTR = nullptr;\n-\n-    if (EnumTR == nullptr)\n-      return false;\n-\n-    auto EnumTI = getTypeInfo(EnumTR);\n-    if (EnumTI == nullptr)\n+    auto TI = getTypeInfo(EnumTR);\n+    if (TI == nullptr) {\n       return false;\n-\n-    auto EnumRecordTI = dyn_cast<const RecordTypeInfo>(EnumTI);\n-    if (EnumRecordTI == nullptr)\n-      return false;\n-\n-    auto NumCases = EnumRecordTI->getNumFields();\n-    if (CaseIndex >= NumCases) {\n+    }\n+    auto EnumTI = dyn_cast<const EnumTypeInfo>(TI);\n+    if (EnumTI == nullptr){\n       return false;\n-    } else {\n-      const auto Case = EnumRecordTI->getFields()[CaseIndex];\n-      Name = Case.Name;\n-      *OutPayloadTR = Case.TR;\n-      return true;\n     }\n+    return EnumTI->projectEnumValue(getReader(), EnumAddress, CaseIndex);\n   }\n \n   /// Return a description of the layout of a value with the given type.\n   const TypeInfo *getTypeInfo(const TypeRef *TR) {\n-    return getBuilder().getTypeConverter().getTypeInfo(TR);\n+    if (TR == nullptr) {\n+      return nullptr;\n+    } else {\n+      return getBuilder().getTypeConverter().getTypeInfo(TR);\n+    }\n   }\n \n private:"
                    },
                    {
                        "filename": "include/swift/Reflection/TypeLowering.h",
                        "code": "@@ -42,6 +42,23 @@ class EnumTypeInfoBuilder;\n class RecordTypeInfoBuilder;\n class ExistentialTypeInfoBuilder;\n \n+enum class EnumKind : unsigned {\n+  // An enum with no payload cases. The record will have no fields, but\n+  // will have the correct size.\n+  NoPayloadEnum,\n+\n+  // An enum with a single payload case and zero or more no-payload\n+  // cases.  The no-payload cases may be encoded with an extra tag\n+  // byte or as invalid payload values (\"extra inhabitants\").\n+  SinglePayloadEnum,\n+\n+  // An enum with multiple payload cases and zero or more non-payload\n+  // cases.  The selector that indicates what case is currently active\n+  // may be encoded in unused \"spare bits\" common to all payloads and/or\n+  // may use a separate tag byte.\n+  MultiPayloadEnum,\n+};\n+\n enum class RecordKind : unsigned {\n   Invalid,\n \n@@ -51,18 +68,6 @@ enum class RecordKind : unsigned {\n   // A Swift struct type.\n   Struct,\n \n-  // An enum with no payload cases. The record will have no fields, but\n-  // will have the correct size.\n-  NoPayloadEnum,\n-\n-  // An enum with a single payload case. The record consists of a single\n-  // field, being the enum payload.\n-  SinglePayloadEnum,\n-\n-  // An enum with multiple payload cases. The record consists of a multiple\n-  // fields, one for each enum payload.\n-  MultiPayloadEnum,\n-\n   // A Swift-native function is always a function pointer followed by a\n   // retainable, nullable context pointer.\n   ThickFunction,\n@@ -107,6 +112,7 @@ enum class TypeInfoKind : unsigned {\n   Record,\n   Reference,\n   Invalid,\n+  Enum,\n };\n \n class TypeInfo {\n@@ -209,6 +215,65 @@ class RecordTypeInfo : public TypeInfo {\n   }\n };\n \n+/// Enums\n+class EnumTypeInfo : public TypeInfo {\n+  EnumKind SubKind;\n+  std::vector<FieldInfo> Cases;\n+\n+protected:\n+  EnumTypeInfo(unsigned Size, unsigned Alignment,\n+               unsigned Stride, unsigned NumExtraInhabitants,\n+               bool BitwiseTakable,\n+               EnumKind SubKind, const std::vector<FieldInfo> &Cases)\n+    : TypeInfo(TypeInfoKind::Enum, Size, Alignment, Stride,\n+               NumExtraInhabitants, BitwiseTakable),\n+      SubKind(SubKind), Cases(Cases) {}\n+\n+public:\n+  EnumKind getEnumKind() const { return SubKind; }\n+  const std::vector<FieldInfo> &getCases() const { return Cases; }\n+  unsigned getNumCases() const { return Cases.size(); }\n+  unsigned getNumPayloadCases() const {\n+    auto Cases = getCases();\n+    return std::count_if(Cases.begin(), Cases.end(),\n+                         [](const FieldInfo &Case){return Case.TR != 0;});\n+  }\n+  // Size of the payload area.\n+  unsigned getPayloadSize() const {\n+    return EnumTypeInfo::getPayloadSizeForCases(Cases);\n+  }\n+\n+  static unsigned getPayloadSizeForCases(const std::vector<FieldInfo> &Cases) {\n+    unsigned size = 0;\n+    for (auto Case : Cases) {\n+      if (Case.TR != 0 && Case.TI.getSize() > size) {\n+        size = Case.TI.getSize();\n+      }\n+    }\n+    return size;\n+  }\n+\n+  // Returns true if this enum is `Optional`\n+  // (This was factored out of a piece of code that was just\n+  // checking the EnumKind.  This is vastly better than that,\n+  // but could probably be improved further.)\n+  bool isOptional() const {\n+    return\n+      SubKind == EnumKind::SinglePayloadEnum\n+      && Cases.size() == 2\n+      && Cases[0].Name == \"some\"\n+      && Cases[1].Name == \"none\";\n+  }\n+\n+  virtual bool projectEnumValue(remote::MemoryReader &reader,\n+                                remote::RemoteAddress address,\n+                                int *CaseIndex) const = 0;\n+\n+  static bool classof(const TypeInfo *TI) {\n+    return TI->getKind() == TypeInfoKind::Enum;\n+  }\n+};\n+\n /// References to classes, closure contexts and anything else with an\n /// 'isa' pointer\n class ReferenceTypeInfo : public TypeInfo {"
                    },
                    {
                        "filename": "include/swift/Remote/MemoryReader.h",
                        "code": "@@ -62,21 +62,29 @@ class MemoryReader {\n   }\n \n   /// Attempts to read an integer of the specified size from the given\n-  /// address in the remote process.\n+  /// address in the remote process.  Following `storeEnumElement`\n+  /// in EnumImpl.h, this reads arbitrary-size integers by ignoring\n+  /// high-order bits that are outside the range of `IntegerType`.\n   ///\n-  /// Returns false if the operation failed, or the request size is\n-  /// larger than the provided destination.\n+  /// Returns false if the operation failed.\n   template <typename IntegerType>\n   bool readInteger(RemoteAddress address, size_t bytes, IntegerType *dest) {\n     *dest = 0;\n-    if ((bytes > sizeof(IntegerType))\n-        || !readBytes(address, (uint8_t *)dest, bytes)) {\n-      return false;\n-    }\n+    size_t readSize = std::min(bytes, sizeof(IntegerType));\n     // FIXME: Assumes host and target have the same endianness.\n     // TODO: Query DLQ for endianness of target, compare to endianness of host.\n #if defined(__BIG_ENDIAN__)\n-    *dest >>= (sizeof(IntegerType) - bytes);\n+    // Read low-order bits of source ...\n+    if (!readBytes(address + (bytes - readSize), (uint8_t *)dest, readSize)) {\n+      return false;\n+    }\n+    // ... align result to low-order bits of *dest\n+    *dest >>= 8 * (sizeof(IntegerType) - readSize);\n+#else\n+    // Read from low-order bytes of integer\n+    if (!readBytes(address, (uint8_t *)dest, readSize)) {\n+      return false;\n+    }\n #endif\n     return true;\n   }"
                    },
                    {
                        "filename": "include/swift/Remote/MetadataReader.h",
                        "code": "@@ -1682,32 +1682,16 @@ class MetadataReader {\n     return nullptr;\n   }\n \n-private:\n-  template <template <class R> class M>\n-  MetadataRef _readMetadata(StoredPointer address) {\n-    return _readMetadata(address, sizeof(M<Runtime>));\n-  }\n-\n-  MetadataRef _readMetadata(StoredPointer address, size_t sizeAfter) {\n-    auto size = sizeAfter;\n-    uint8_t *buffer = (uint8_t *) malloc(size);\n-    if (!Reader->readBytes(RemoteAddress(address), buffer, size)) {\n-      free(buffer);\n-      return nullptr;\n-    }\n-\n-    auto metadata = reinterpret_cast<TargetMetadata<Runtime>*>(buffer);\n-    MetadataCache.insert(std::make_pair(address, OwnedMetadataRef(metadata)));\n-    return MetadataRef(address, metadata);\n-  }\n-\n   StoredPointer\n   readAddressOfNominalTypeDescriptor(MetadataRef &metadata,\n                                      bool skipArtificialSubclasses = false) {\n     switch (metadata->getKind()) {\n     case MetadataKind::Class: {\n       auto classMeta = cast<TargetClassMetadata<Runtime>>(metadata);\n       while (true) {\n+        if (!classMeta->isTypeMetadata())\n+          return 0;\n+\n         StoredSignedPointer descriptorAddressSigned = classMeta->getDescriptionAsSignedPointer();\n         StoredPointer descriptorAddress = stripSignedPointer(descriptorAddressSigned);\n \n@@ -1753,7 +1737,26 @@ class MetadataReader {\n       return 0;\n     }\n   }\n-  \n+\n+private:\n+  template <template <class R> class M>\n+  MetadataRef _readMetadata(StoredPointer address) {\n+    return _readMetadata(address, sizeof(M<Runtime>));\n+  }\n+\n+  MetadataRef _readMetadata(StoredPointer address, size_t sizeAfter) {\n+    auto size = sizeAfter;\n+    uint8_t *buffer = (uint8_t *) malloc(size);\n+    if (!Reader->readBytes(RemoteAddress(address), buffer, size)) {\n+      free(buffer);\n+      return nullptr;\n+    }\n+\n+    auto metadata = reinterpret_cast<TargetMetadata<Runtime>*>(buffer);\n+    MetadataCache.insert(std::make_pair(address, OwnedMetadataRef(metadata)));\n+    return MetadataRef(address, metadata);\n+  }\n+\n   /// Returns Optional(ParentContextDescriptorRef()) if there's no parent descriptor.\n   /// Returns None if there was an error reading the parent descriptor.\n   Optional<ParentContextDescriptorRef>"
                    },
                    {
                        "filename": "include/swift/Remote/RemoteAddress.h",
                        "code": "@@ -47,6 +47,18 @@ class RemoteAddress {\n   uint64_t getAddressData() const {\n     return Data;\n   }\n+\n+  template<typename IntegerType>\n+  RemoteAddress& operator+=(const IntegerType& rhs) {\n+    Data += rhs;\n+    return *this;\n+  }\n+\n+  template<typename IntegerType>\n+  friend RemoteAddress operator+(RemoteAddress lhs,\n+                                 const IntegerType& rhs) {\n+    return lhs += rhs;\n+  }\n };\n \n /// A symbolic relocated absolute pointer value."
                    },
                    {
                        "filename": "include/swift/Runtime/HeapObject.h",
                        "code": "@@ -1082,7 +1082,14 @@ struct TypeNamePair {\n ///   -> (UnsafePointer<UInt8>, Int)\n SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_API\n TypeNamePair\n-swift_getTypeName(const Metadata *type, bool qualified);  \n+swift_getTypeName(const Metadata *type, bool qualified);\n+\n+/// Return the mangled name of a Swift type represented by a metadata object.\n+/// func _getMangledTypeName(_ type: Any.Type)\n+///   -> (UnsafePointer<UInt8>, Int)\n+SWIFT_CC(swift) SWIFT_RUNTIME_STDLIB_API\n+TypeNamePair\n+swift_getMangledTypeName(const Metadata *type);\n \n } // end namespace swift\n "
                    },
                    {
                        "filename": "include/swift/SIL/AbstractionPattern.h",
                        "code": "@@ -188,6 +188,65 @@ class AbstractionPattern {\n     /// The partially-applied curried imported type of a C++ method. OrigType is\n     /// valid and is a function type. CXXMethod is valid.\n     PartialCurriedCXXMethodType,\n+    /// A Swift function whose parameters and results are opaque. This is\n+    /// like `AP::Type<T>((T) -> T)`, except that the number of parameters is\n+    /// unspecified.\n+    ///\n+    /// This is used to construct the abstraction pattern for the\n+    /// derivative function of a function with opaque abstraction pattern. See\n+    /// `OpaqueDerivativeFunction`.\n+    OpaqueFunction,\n+    /// A Swift function whose parameters are opaque and whose result is the\n+    /// tuple abstraction pattern `(AP::Opaque, AP::OpaqueFunction)`.\n+    ///\n+    /// Purpose: when we reabstract `@differentiable` function-typed values\n+    /// using the`AP::Opaque` pattern, we use `AP::Opaque` to reabstract the\n+    /// original function in the bundle and `AP::OpaqueDerivativeFunction` to\n+    /// reabstract the derivative functions in the bundle. This preserves the\n+    /// `@differentiable` function invariant that the derivative type\n+    /// (`SILFunctionType::getAutoDiffDerivativeFunctionType()`) of the original\n+    /// function is equal to the type of the derivative function. For example:\n+    ///\n+    ///   differentiable_function\n+    ///     [parameters 0]\n+    ///     %0 : $@callee_guaranteed (Float) -> Float\n+    ///     with_derivative {\n+    ///       %1 : $@callee_guaranteed (Float) -> (\n+    ///         Float,\n+    ///         @owned @callee_guaranteed (Float) -> Float\n+    ///       ),\n+    ///       %2 : $@callee_guaranteed (Float) -> (\n+    ///         Float,\n+    ///         @owned @callee_guaranteed (Float) -> Float\n+    ///       )\n+    ///     }\n+    ///\n+    /// The invariant-respecting abstraction of this value to `AP::Opaque` is:\n+    ///\n+    ///   differentiable_function\n+    ///     [parameters 0]\n+    ///     %3 : $@callee_guaranteed (@in_guaranteed Float) -> @out Float\n+    ///     with_derivative {\n+    ///       %4 : $@callee_guaranteed (@in_guaranteed Float) -> (\n+    ///         @out Float,\n+    ///         @owned @callee_guaranteed (@in_guaranteed Float) -> @out Float\n+    ///       ),\n+    ///       %5 : $@callee_guaranteed (@in_guaranteed Float) -> (\n+    ///         @out Float,\n+    ///         @owned @callee_guaranteed (@in_guaranteed Float) -> @out Float\n+    ///       )\n+    ///     }\n+    ///\n+    /// In particular:\n+    ///\n+    /// - The reabstraction %0 => %3 uses pattern `AP::Opaque`.\n+    /// - The reabstraction %1 => %4 uses pattern\n+    ///   `AP::OpaqueDerivativeFunction`, which maximally abstracts all the\n+    ///   parameters, and abstracts the result as the tuple\n+    ///   `(AP::Opaque, AP::OpaqueFunction)`.\n+    /// - The reabstraction %2 => %5 similarly uses pattern\n+    ///   `AP::OpaqueDerivativeFunction`.\n+    OpaqueDerivativeFunction,\n   };\n \n   class EncodedForeignErrorInfo {\n@@ -238,7 +297,7 @@ class AbstractionPattern {\n   static constexpr const unsigned NumOtherDataBits = 28;\n   static constexpr const unsigned MaxOtherData = (1 << NumOtherDataBits) - 1;\n \n-  unsigned TheKind : 32 - NumOtherDataBits;\n+  unsigned TheKind : 33 - NumOtherDataBits;\n   unsigned OtherData : NumOtherDataBits;\n   CanType OrigType;\n   union {\n@@ -384,6 +443,14 @@ class AbstractionPattern {\n     return AbstractionPattern(Kind::Invalid);\n   }\n \n+  static AbstractionPattern getOpaqueFunction() {\n+    return AbstractionPattern(Kind::OpaqueFunction);\n+  }\n+\n+  static AbstractionPattern getOpaqueDerivativeFunction() {\n+    return AbstractionPattern(Kind::OpaqueDerivativeFunction);\n+  }\n+\n   bool hasGenericSignature() const {\n     switch (getKind()) {\n     case Kind::Type:\n@@ -402,6 +469,8 @@ class AbstractionPattern {\n     case Kind::Invalid:\n     case Kind::Opaque:\n     case Kind::Tuple:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       return false;\n     }\n     llvm_unreachable(\"Unhandled AbstractionPatternKind in switch\");\n@@ -730,6 +799,10 @@ class AbstractionPattern {\n       llvm_unreachable(\"opaque pattern has no type\");\n     case Kind::Tuple:\n       llvm_unreachable(\"open-coded tuple pattern has no type\");\n+    case Kind::OpaqueFunction:\n+      llvm_unreachable(\"opaque function pattern has no type\");\n+    case Kind::OpaqueDerivativeFunction:\n+      llvm_unreachable(\"opaque derivative function pattern has no type\");\n     case Kind::ClangType:\n     case Kind::CurriedObjCMethodType:\n     case Kind::PartialCurriedObjCMethodType:\n@@ -763,6 +836,8 @@ class AbstractionPattern {\n     case Kind::Invalid:\n     case Kind::Opaque:\n     case Kind::Tuple:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       llvm_unreachable(\"type cannot be replaced on pattern without type\");\n     case Kind::ClangType:\n     case Kind::CurriedObjCMethodType:\n@@ -798,6 +873,8 @@ class AbstractionPattern {\n     case Kind::Tuple:\n     case Kind::Type:\n     case Kind::Discard:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       return false;\n     case Kind::ClangType:\n     case Kind::PartialCurriedObjCMethodType:\n@@ -854,6 +931,11 @@ class AbstractionPattern {\n     return CXXMethod;\n   }\n \n+  bool isOpaqueFunctionOrOpaqueDerivativeFunction() const {\n+    return (getKind() == Kind::OpaqueFunction ||\n+            getKind() == Kind::OpaqueDerivativeFunction);\n+  }\n+\n   EncodedForeignErrorInfo getEncodedForeignErrorInfo() const {\n     assert(hasStoredForeignErrorInfo());\n     return EncodedForeignErrorInfo::fromOpaqueValue(OtherData);\n@@ -876,6 +958,8 @@ class AbstractionPattern {\n     case Kind::CXXMethodType:\n     case Kind::CurriedCXXMethodType:\n     case Kind::PartialCurriedCXXMethodType:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       return false;\n     case Kind::PartialCurriedObjCMethodType:\n     case Kind::CurriedObjCMethodType:\n@@ -897,6 +981,9 @@ class AbstractionPattern {\n       return typename CanTypeWrapperTraits<TYPE>::type();\n     case Kind::Tuple:\n       return typename CanTypeWrapperTraits<TYPE>::type();\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n+      return typename CanTypeWrapperTraits<TYPE>::type();\n     case Kind::ClangType:\n     case Kind::PartialCurriedObjCMethodType:\n     case Kind::CurriedObjCMethodType:\n@@ -935,6 +1022,8 @@ class AbstractionPattern {\n     case Kind::CXXMethodType:\n     case Kind::CurriedCXXMethodType:\n     case Kind::PartialCurriedCXXMethodType:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       // We assume that the Clang type might provide additional structure.\n       return false;\n     case Kind::Type:\n@@ -962,6 +1051,8 @@ class AbstractionPattern {\n     case Kind::CXXMethodType:\n     case Kind::CurriedCXXMethodType:\n     case Kind::PartialCurriedCXXMethodType:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       return false;\n     case Kind::Tuple:\n       return true;\n@@ -987,6 +1078,8 @@ class AbstractionPattern {\n     case Kind::CXXMethodType:\n     case Kind::CurriedCXXMethodType:\n     case Kind::PartialCurriedCXXMethodType:\n+    case Kind::OpaqueFunction:\n+    case Kind::OpaqueDerivativeFunction:\n       llvm_unreachable(\"pattern is not a tuple\");      \n     case Kind::Tuple:\n       return getNumTupleElements_Stored();\n@@ -1022,6 +1115,17 @@ class AbstractionPattern {\n   /// it.\n   AbstractionPattern getReferenceStorageReferentType() const;\n \n+  /// Given that the value being abstracted is a function type, return the\n+  /// abstraction pattern for the derivative function.\n+  ///\n+  /// The arguments are the same as the arguments to\n+  /// `AnyFunctionType::getAutoDiffDerivativeFunctionType()`.\n+  AbstractionPattern getAutoDiffDerivativeFunctionType(\n+      IndexSubset *parameterIndices, AutoDiffDerivativeFunctionKind kind,\n+      LookupConformanceFn lookupConformance,\n+      GenericSignature derivativeGenericSignature = GenericSignature(),\n+      bool makeSelfParamFirst = false);\n+\n   void dump() const LLVM_ATTRIBUTE_USED;\n   void print(raw_ostream &OS) const;\n };"
                    },
                    {
                        "filename": "include/swift/SIL/ApplySite.h",
                        "code": "@@ -590,6 +590,32 @@ class FullApplySite : public ApplySite {\n \n namespace llvm {\n \n+template<>\n+struct PointerLikeTypeTraits<swift::ApplySite> {\n+public:\n+  static inline void *getAsVoidPointer(swift::ApplySite apply) {\n+    return (void*)apply.getInstruction();\n+  }\n+  static inline swift::ApplySite getFromVoidPointer(void *pointer) {\n+    return swift::ApplySite((swift::SILInstruction*)pointer);\n+  }\n+  enum { NumLowBitsAvailable =\n+         PointerLikeTypeTraits<swift::SILNode *>::NumLowBitsAvailable };\n+};\n+\n+template<>\n+struct PointerLikeTypeTraits<swift::FullApplySite> {\n+public:\n+  static inline void *getAsVoidPointer(swift::FullApplySite apply) {\n+    return (void*)apply.getInstruction();\n+  }\n+  static inline swift::FullApplySite getFromVoidPointer(void *pointer) {\n+    return swift::FullApplySite((swift::SILInstruction*)pointer);\n+  }\n+  enum { NumLowBitsAvailable =\n+         PointerLikeTypeTraits<swift::SILNode *>::NumLowBitsAvailable };\n+};\n+\n // An ApplySite casts like a SILInstruction*.\n template <> struct simplify_type<const ::swift::ApplySite> {\n   using SimpleType = ::swift::SILInstruction *;"
                    },
                    {
                        "filename": "include/swift/SIL/LinearLifetimeChecker.h",
                        "code": "@@ -28,103 +28,8 @@ class SILInstruction;\n class SILModule;\n class SILValue;\n class DeadEndBlocks;\n-\n-namespace ownership {\n-\n-struct ErrorBehaviorKind {\n-  enum inner_t {\n-    Invalid = 0,\n-    ReturnFalse = 1,\n-    PrintMessage = 2,\n-    Assert = 4,\n-    ReturnFalseOnLeak = 8,\n-    PrintMessageAndReturnFalse = PrintMessage | ReturnFalse,\n-    PrintMessageAndAssert = PrintMessage | Assert,\n-    ReturnFalseOnLeakAssertOtherwise = ReturnFalseOnLeak | Assert,\n-  } Value;\n-\n-  ErrorBehaviorKind() : Value(Invalid) {}\n-  ErrorBehaviorKind(inner_t Inner) : Value(Inner) { assert(Value != Invalid); }\n-\n-  bool shouldAssert() const {\n-    assert(Value != Invalid);\n-    return Value & Assert;\n-  }\n-\n-  bool shouldReturnFalseOnLeak() const {\n-    assert(Value != Invalid);\n-    return Value & ReturnFalseOnLeak;\n-  }\n-\n-  bool shouldPrintMessage() const {\n-    assert(Value != Invalid);\n-    return Value & PrintMessage;\n-  }\n-\n-  bool shouldReturnFalse() const {\n-    assert(Value != Invalid);\n-    return Value & ReturnFalse;\n-  }\n-};\n-\n-} // end namespace ownership\n-\n-class LinearLifetimeError {\n-  ownership::ErrorBehaviorKind errorBehavior;\n-  bool foundUseAfterFree = false;\n-  bool foundLeak = false;\n-  bool foundOverConsume = false;\n-\n-public:\n-  LinearLifetimeError(ownership::ErrorBehaviorKind errorBehavior)\n-      : errorBehavior(errorBehavior) {}\n-\n-  bool getFoundError() const {\n-    return foundUseAfterFree || foundLeak || foundOverConsume;\n-  }\n-\n-  bool getFoundLeak() const { return foundLeak; }\n-\n-  bool getFoundUseAfterFree() const { return foundUseAfterFree; }\n-\n-  bool getFoundOverConsume() const { return foundOverConsume; }\n-\n-  void handleLeak(llvm::function_ref<void()> &&messagePrinterFunc) {\n-    foundLeak = true;\n-\n-    if (errorBehavior.shouldPrintMessage())\n-      messagePrinterFunc();\n-\n-    if (errorBehavior.shouldReturnFalseOnLeak())\n-      return;\n-\n-    // We already printed out our error if we needed to, so don't pass it along.\n-    handleError([]() {});\n-  }\n-\n-  void handleOverConsume(llvm::function_ref<void()> &&messagePrinterFunc) {\n-    foundOverConsume = true;\n-    handleError(std::move(messagePrinterFunc));\n-  }\n-\n-  void handleUseAfterFree(llvm::function_ref<void()> &&messagePrinterFunc) {\n-    foundUseAfterFree = true;\n-    handleError(std::move(messagePrinterFunc));\n-  }\n-\n-private:\n-  void handleError(llvm::function_ref<void()> &&messagePrinterFunc) {\n-    if (errorBehavior.shouldPrintMessage())\n-      messagePrinterFunc();\n-\n-    if (errorBehavior.shouldReturnFalse()) {\n-      return;\n-    }\n-\n-    assert(errorBehavior.shouldAssert() && \"At this point, we should assert\");\n-    llvm_unreachable(\"triggering standard assertion failure routine\");\n-  }\n-};\n+class SILOwnershipVerifier;\n+class SILValueOwnershipChecker;\n \n /// A class used to validate linear lifetime with respect to an SSA-like\n /// definition.\n@@ -140,6 +45,14 @@ class LinearLifetimeError {\n /// uses must not be reachable from each other and jointly post-dominate all\n /// consuming uses as well as the defining block/instruction.\n class LinearLifetimeChecker {\n+public:\n+  class Error;\n+  struct ErrorBehaviorKind;\n+\n+private:\n+  friend class SILOwnershipVerifier;\n+  friend class SILValueOwnershipChecker;\n+\n   SmallPtrSetImpl<SILBasicBlock *> &visitedBlocks;\n   DeadEndBlocks &deadEndBlocks;\n \n@@ -148,6 +61,24 @@ class LinearLifetimeChecker {\n                         DeadEndBlocks &deadEndBlocks)\n       : visitedBlocks(visitedBlocks), deadEndBlocks(deadEndBlocks) {}\n \n+  /// Returns true that \\p value forms a linear lifetime with consuming uses \\p\n+  /// consumingUses, non consuming uses \\p nonConsumingUses. Returns false\n+  /// otherwise.\n+  bool validateLifetime(SILValue value, ArrayRef<Operand *> consumingUses,\n+                        ArrayRef<Operand *> nonConsumingUses);\n+\n+  /// Given a value and a consuming use of that value, compute a non-unique\n+  /// minimal set of insertion points that together with \\p consumingUse\n+  /// post-dominate and end the lifetime of \\p value.\n+  ///\n+  /// Returns true if we completed the consuming use set and discovered that \\p\n+  /// consumingUse is not strongly control equivalent to value (meaning\n+  /// consumingUse is not in the same loop in the loop nest as value).\n+  bool completeConsumingUseSet(\n+      SILValue value, Operand *consumingUse,\n+      function_ref<void(SILBasicBlock::iterator insertPt)> visitor);\n+\n+private:\n   /// Returns true if:\n   ///\n   /// 1. No consuming uses are reachable from any other consuming use, from any\n@@ -164,22 +95,19 @@ class LinearLifetimeChecker {\n   /// error.\n   /// \\p leakingBlocks If non-null a list of blocks where the value was detected\n   /// to leak. Can be used to insert missing destroys.\n-  LinearLifetimeError\n-  checkValue(SILValue value, ArrayRef<Operand *> consumingUses,\n-             ArrayRef<Operand *> nonConsumingUses,\n-             ownership::ErrorBehaviorKind errorBehavior,\n-             SmallVectorImpl<SILBasicBlock *> *leakingBlocks = nullptr);\n-\n-  /// Returns true that \\p value forms a linear lifetime with consuming uses \\p\n-  /// consumingUses, non consuming uses \\p nonConsumingUses. Returns false\n-  /// otherwise.\n-  bool validateLifetime(SILValue value, ArrayRef<Operand *> consumingUses,\n-                        ArrayRef<Operand *> nonConsumingUses) {\n-    return !checkValue(value, consumingUses, nonConsumingUses,\n-                       ownership::ErrorBehaviorKind::ReturnFalse,\n-                       nullptr /*leakingBlocks*/)\n-                .getFoundError();\n-  }\n+  Error checkValue(SILValue value, ArrayRef<Operand *> consumingUses,\n+                   ArrayRef<Operand *> nonConsumingUses,\n+                   ErrorBehaviorKind errorBehavior);\n+\n+  Error checkValue(SILValue value, ArrayRef<Operand *> consumingUses,\n+                   ArrayRef<Operand *> nonConsumingUses,\n+                   ErrorBehaviorKind errorBehavior,\n+                   function_ref<void(SILBasicBlock *)> leakingBlockCallback);\n+\n+  Error checkValueImpl(\n+      SILValue value, ArrayRef<Operand *> consumingUses,\n+      ArrayRef<Operand *> nonConsumingUses, ErrorBehaviorKind errorBehavior,\n+      Optional<function_ref<void(SILBasicBlock *)>> leakingBlockCallback);\n };\n \n } // namespace swift"
                    },
                    {
                        "filename": "include/swift/SIL/OwnershipUtils.h",
                        "code": "@@ -66,7 +66,7 @@ bool isOwnedForwardingInstruction(SILInstruction *inst);\n /// previous terminator.\n bool isOwnedForwardingValue(SILValue value);\n \n-struct BorrowScopeOperandKind {\n+struct BorrowingOperandKind {\n   enum Kind {\n     BeginBorrow,\n     BeginApply,\n@@ -75,61 +75,61 @@ struct BorrowScopeOperandKind {\n \n   Kind value;\n \n-  BorrowScopeOperandKind(Kind newValue) : value(newValue) {}\n-  BorrowScopeOperandKind(const BorrowScopeOperandKind &other)\n+  BorrowingOperandKind(Kind newValue) : value(newValue) {}\n+  BorrowingOperandKind(const BorrowingOperandKind &other)\n       : value(other.value) {}\n   operator Kind() const { return value; }\n \n-  static Optional<BorrowScopeOperandKind> get(SILInstructionKind kind) {\n+  static Optional<BorrowingOperandKind> get(SILInstructionKind kind) {\n     switch (kind) {\n     default:\n       return None;\n     case SILInstructionKind::BeginBorrowInst:\n-      return BorrowScopeOperandKind(BeginBorrow);\n+      return BorrowingOperandKind(BeginBorrow);\n     case SILInstructionKind::BeginApplyInst:\n-      return BorrowScopeOperandKind(BeginApply);\n+      return BorrowingOperandKind(BeginApply);\n     case SILInstructionKind::BranchInst:\n-      return BorrowScopeOperandKind(Branch);\n+      return BorrowingOperandKind(Branch);\n     }\n   }\n \n   void print(llvm::raw_ostream &os) const;\n   SWIFT_DEBUG_DUMP { print(llvm::dbgs()); }\n };\n \n-llvm::raw_ostream &operator<<(llvm::raw_ostream &os,\n-                              BorrowScopeOperandKind kind);\n+llvm::raw_ostream &operator<<(llvm::raw_ostream &os, BorrowingOperandKind kind);\n \n-struct BorrowScopeIntroducingValue;\n+struct BorrowedValue;\n \n /// An operand whose user instruction introduces a new borrow scope for the\n-/// operand's value. The value of the operand must be considered as implicitly\n-/// borrowed until the user's corresponding end scope instruction.\n+/// operand's value. By executing the given user, the operand's value becomes\n+/// borrowed and thus the incoming value must implicitly be borrowed until the\n+/// user's corresponding end scope instruction.\n ///\n /// NOTE: We do not require that the guaranteed scope be represented by a\n /// guaranteed value in the same function: see begin_apply. In such cases, we\n /// require instead an end_* instruction to mark the end of the scope's region.\n-struct BorrowScopeOperand {\n-  BorrowScopeOperandKind kind;\n+struct BorrowingOperand {\n+  BorrowingOperandKind kind;\n   Operand *op;\n \n-  BorrowScopeOperand(Operand *op)\n-      : kind(*BorrowScopeOperandKind::get(op->getUser()->getKind())), op(op) {}\n-  BorrowScopeOperand(const BorrowScopeOperand &other)\n+  BorrowingOperand(Operand *op)\n+      : kind(*BorrowingOperandKind::get(op->getUser()->getKind())), op(op) {}\n+  BorrowingOperand(const BorrowingOperand &other)\n       : kind(other.kind), op(other.op) {}\n-  BorrowScopeOperand &operator=(const BorrowScopeOperand &other) {\n+  BorrowingOperand &operator=(const BorrowingOperand &other) {\n     kind = other.kind;\n     op = other.op;\n     return *this;\n   }\n \n   /// If value is a borrow introducer return it after doing some checks.\n-  static Optional<BorrowScopeOperand> get(Operand *op) {\n+  static Optional<BorrowingOperand> get(Operand *op) {\n     auto *user = op->getUser();\n-    auto kind = BorrowScopeOperandKind::get(user->getKind());\n+    auto kind = BorrowingOperandKind::get(user->getKind());\n     if (!kind)\n       return None;\n-    return BorrowScopeOperand(*kind, op);\n+    return BorrowingOperand(*kind, op);\n   }\n \n   void visitEndScopeInstructions(function_ref<void(Operand *)> func) const;\n@@ -138,10 +138,10 @@ struct BorrowScopeOperand {\n   /// values and produces a new scope afterwards.\n   bool consumesGuaranteedValues() const {\n     switch (kind) {\n-    case BorrowScopeOperandKind::BeginBorrow:\n-    case BorrowScopeOperandKind::BeginApply:\n+    case BorrowingOperandKind::BeginBorrow:\n+    case BorrowingOperandKind::BeginApply:\n       return false;\n-    case BorrowScopeOperandKind::Branch:\n+    case BorrowingOperandKind::Branch:\n       return true;\n     }\n     llvm_unreachable(\"Covered switch isn't covered?!\");\n@@ -151,10 +151,10 @@ struct BorrowScopeOperand {\n   /// for owned values.\n   bool canAcceptOwnedValues() const {\n     switch (kind) {\n-    case BorrowScopeOperandKind::BeginBorrow:\n-    case BorrowScopeOperandKind::BeginApply:\n+    case BorrowingOperandKind::BeginBorrow:\n+    case BorrowingOperandKind::BeginApply:\n       return true;\n-    case BorrowScopeOperandKind::Branch:\n+    case BorrowingOperandKind::Branch:\n       return false;\n     }\n     llvm_unreachable(\"Covered switch isn't covered?!\");\n@@ -166,24 +166,24 @@ struct BorrowScopeOperand {\n   bool areAnyUserResultsBorrowIntroducers() const {\n     // TODO: Can we derive this by running a borrow introducer check ourselves?\n     switch (kind) {\n-    case BorrowScopeOperandKind::BeginBorrow:\n-    case BorrowScopeOperandKind::Branch:\n+    case BorrowingOperandKind::BeginBorrow:\n+    case BorrowingOperandKind::Branch:\n       return true;\n-    case BorrowScopeOperandKind::BeginApply:\n+    case BorrowingOperandKind::BeginApply:\n       return false;\n     }\n     llvm_unreachable(\"Covered switch isn't covered?!\");\n   }\n \n   /// Visit all of the results of the operand's user instruction that are\n   /// consuming uses.\n-  void visitUserResultConsumingUses(function_ref<void(Operand *)> visitor);\n+  void visitUserResultConsumingUses(function_ref<void(Operand *)> visitor) const;\n \n   /// Visit all of the \"results\" of the user of this operand that are borrow\n   /// scope introducers for the specific scope that this borrow scope operand\n   /// summarizes.\n-  void visitBorrowIntroducingUserResults(\n-      function_ref<void(BorrowScopeIntroducingValue)> visitor);\n+  void\n+  visitBorrowIntroducingUserResults(function_ref<void(BorrowedValue)> visitor) const;\n \n   /// Passes to visitor all of the consuming uses of this use's using\n   /// instruction.\n@@ -192,22 +192,22 @@ struct BorrowScopeOperand {\n   /// guaranteed scope by using a worklist and checking if any of the operands\n   /// are BorrowScopeOperands.\n   void visitConsumingUsesOfBorrowIntroducingUserResults(\n-      function_ref<void(Operand *)> visitor);\n+      function_ref<void(Operand *)> visitor) const;\n \n   void print(llvm::raw_ostream &os) const;\n   SWIFT_DEBUG_DUMP { print(llvm::dbgs()); }\n \n private:\n   /// Internal constructor for failable static constructor. Please do not expand\n   /// its usage since it assumes the code passed in is well formed.\n-  BorrowScopeOperand(BorrowScopeOperandKind kind, Operand *op)\n+  BorrowingOperand(BorrowingOperandKind kind, Operand *op)\n       : kind(kind), op(op) {}\n };\n \n llvm::raw_ostream &operator<<(llvm::raw_ostream &os,\n-                              const BorrowScopeOperand &operand);\n+                              const BorrowingOperand &operand);\n \n-struct BorrowScopeIntroducingValueKind {\n+struct BorrowedValueKind {\n   /// Enum we use for exhaustive pattern matching over borrow scope introducers.\n   enum Kind {\n     LoadBorrow,\n@@ -216,35 +216,34 @@ struct BorrowScopeIntroducingValueKind {\n     Phi,\n   };\n \n-  static Optional<BorrowScopeIntroducingValueKind> get(SILValue value) {\n+  static Optional<BorrowedValueKind> get(SILValue value) {\n     if (value.getOwnershipKind() != ValueOwnershipKind::Guaranteed)\n       return None;\n     switch (value->getKind()) {\n     default:\n       return None;\n     case ValueKind::LoadBorrowInst:\n-      return BorrowScopeIntroducingValueKind(LoadBorrow);\n+      return BorrowedValueKind(LoadBorrow);\n     case ValueKind::BeginBorrowInst:\n-      return BorrowScopeIntroducingValueKind(BeginBorrow);\n+      return BorrowedValueKind(BeginBorrow);\n     case ValueKind::SILFunctionArgument:\n-      return BorrowScopeIntroducingValueKind(SILFunctionArgument);\n+      return BorrowedValueKind(SILFunctionArgument);\n     case ValueKind::SILPhiArgument: {\n       if (llvm::any_of(value->getParentBlock()->getPredecessorBlocks(),\n                        [](SILBasicBlock *block) {\n                          return !isa<BranchInst>(block->getTerminator());\n                        })) {\n         return None;\n       }\n-      return BorrowScopeIntroducingValueKind(Phi);\n+      return BorrowedValueKind(Phi);\n     }\n     }\n   }\n \n   Kind value;\n \n-  BorrowScopeIntroducingValueKind(Kind newValue) : value(newValue) {}\n-  BorrowScopeIntroducingValueKind(const BorrowScopeIntroducingValueKind &other)\n-      : value(other.value) {}\n+  BorrowedValueKind(Kind newValue) : value(newValue) {}\n+  BorrowedValueKind(const BorrowedValueKind &other) : value(other.value) {}\n   operator Kind() const { return value; }\n \n   /// Is this a borrow scope that begins and ends within the same function and\n@@ -255,11 +254,11 @@ struct BorrowScopeIntroducingValueKind {\n   /// of the scope.\n   bool isLocalScope() const {\n     switch (value) {\n-    case BorrowScopeIntroducingValueKind::BeginBorrow:\n-    case BorrowScopeIntroducingValueKind::LoadBorrow:\n-    case BorrowScopeIntroducingValueKind::Phi:\n+    case BorrowedValueKind::BeginBorrow:\n+    case BorrowedValueKind::LoadBorrow:\n+    case BorrowedValueKind::Phi:\n       return true;\n-    case BorrowScopeIntroducingValueKind::SILFunctionArgument:\n+    case BorrowedValueKind::SILFunctionArgument:\n       return false;\n     }\n     llvm_unreachable(\"Covered switch isnt covered?!\");\n@@ -269,13 +268,12 @@ struct BorrowScopeIntroducingValueKind {\n   SWIFT_DEBUG_DUMP { print(llvm::dbgs()); }\n };\n \n-llvm::raw_ostream &operator<<(llvm::raw_ostream &os,\n-                              BorrowScopeIntroducingValueKind kind);\n+llvm::raw_ostream &operator<<(llvm::raw_ostream &os, BorrowedValueKind kind);\n \n struct InteriorPointerOperand;\n \n-/// A higher level construct for working with values that represent the\n-/// introduction of a new borrow scope.\n+/// A higher level construct for working with values that act as a \"borrow\n+/// introducer\" for a new borrow scope.\n ///\n /// DISCUSSION: A \"borrow introducer\" is a SILValue that represents the\n /// beginning of a borrow scope that the ownership verifier validates. The idea\n@@ -290,19 +288,19 @@ struct InteriorPointerOperand;\n /// guaranteed results are borrow introducers. In practice this means that\n /// borrow introducers can not have guaranteed results that are not creating a\n /// new borrow scope. No such instructions exist today.\n-struct BorrowScopeIntroducingValue {\n-  BorrowScopeIntroducingValueKind kind;\n+struct BorrowedValue {\n+  BorrowedValueKind kind;\n   SILValue value;\n \n   /// If value is a borrow introducer return it after doing some checks.\n   ///\n   /// This is the only way to construct a BorrowScopeIntroducingValue. We make\n   /// the primary constructor private for this reason.\n-  static Optional<BorrowScopeIntroducingValue> get(SILValue value) {\n-    auto kind = BorrowScopeIntroducingValueKind::get(value);\n+  static Optional<BorrowedValue> get(SILValue value) {\n+    auto kind = BorrowedValueKind::get(value);\n     if (!kind)\n       return None;\n-    return BorrowScopeIntroducingValue(*kind, value);\n+    return BorrowedValue(*kind, value);\n   }\n \n   /// If this value is introducing a local scope, gather all local end scope\n@@ -359,13 +357,12 @@ struct BorrowScopeIntroducingValue {\n private:\n   /// Internal constructor for failable static constructor. Please do not expand\n   /// its usage since it assumes the code passed in is well formed.\n-  BorrowScopeIntroducingValue(BorrowScopeIntroducingValueKind kind,\n-                              SILValue value)\n+  BorrowedValue(BorrowedValueKind kind, SILValue value)\n       : kind(kind), value(value) {}\n };\n \n llvm::raw_ostream &operator<<(llvm::raw_ostream &os,\n-                              const BorrowScopeIntroducingValue &value);\n+                              const BorrowedValue &value);\n \n /// Look up the def-use graph starting at use \\p inputOperand, recording any\n /// \"borrow\" introducing values that we find into \\p out. If at any point, we\n@@ -376,16 +373,15 @@ llvm::raw_ostream &operator<<(llvm::raw_ostream &os,\n /// NOTE: This may return multiple borrow introducing values in cases where\n /// there are phi-like nodes in the IR like any true phi block arguments or\n /// aggregate literal instructions (struct, tuple, enum, etc.).\n-bool getAllBorrowIntroducingValues(\n-    SILValue value, SmallVectorImpl<BorrowScopeIntroducingValue> &out);\n+bool getAllBorrowIntroducingValues(SILValue value,\n+                                   SmallVectorImpl<BorrowedValue> &out);\n \n /// Look up through the def-use chain of \\p inputValue, looking for an initial\n /// \"borrow\" introducing value. If at any point, we find two introducers or we\n /// find a point in the chain we do not understand, we bail and return false. If\n /// we are able to understand all of the def-use graph and only find a single\n /// introducer, then we return a .some(BorrowScopeIntroducingValue).\n-Optional<BorrowScopeIntroducingValue>\n-getSingleBorrowIntroducingValue(SILValue inputValue);\n+Optional<BorrowedValue> getSingleBorrowIntroducingValue(SILValue inputValue);\n \n struct InteriorPointerOperandKind {\n   enum Kind : uint8_t {\n@@ -441,7 +437,7 @@ struct InteriorPointerOperand {\n   /// projection. Returns true if we were able to find all borrow introducing\n   /// values.\n   bool visitBaseValueScopeEndingUses(function_ref<void(Operand *)> func) const {\n-    SmallVector<BorrowScopeIntroducingValue, 4> introducers;\n+    SmallVector<BorrowedValue, 4> introducers;\n     if (!getAllBorrowIntroducingValues(operand->get(), introducers))\n       return false;\n     for (const auto &introducer : introducers) {"
                    },
                    {
                        "filename": "include/swift/SIL/SILBuilder.h",
                        "code": "@@ -2164,6 +2164,46 @@ class SILBuilder {\n   // Differentiable programming instructions\n   //===--------------------------------------------------------------------===//\n \n+  DifferentiableFunctionInst *createDifferentiableFunction(\n+      SILLocation Loc, IndexSubset *ParameterIndices, SILValue OriginalFunction,\n+      Optional<std::pair<SILValue, SILValue>> JVPAndVJPFunctions = None) {\n+    return insert(DifferentiableFunctionInst::create(\n+        getModule(), getSILDebugLocation(Loc), ParameterIndices,\n+        OriginalFunction, JVPAndVJPFunctions, hasOwnership()));\n+  }\n+\n+  LinearFunctionInst *createLinearFunction(\n+      SILLocation Loc, IndexSubset *ParameterIndices, SILValue OriginalFunction,\n+      Optional<SILValue> TransposeFunction = None) {\n+    return insert(LinearFunctionInst::create(\n+        getModule(), getSILDebugLocation(Loc), ParameterIndices,\n+        OriginalFunction, TransposeFunction, hasOwnership()));\n+  }\n+\n+  /// Note: explicit extractee type may be specified only in lowered SIL.\n+  DifferentiableFunctionExtractInst *createDifferentiableFunctionExtract(\n+      SILLocation Loc, NormalDifferentiableFunctionTypeComponent Extractee,\n+      SILValue Function, Optional<SILType> ExtracteeType = None) {\n+    return insert(new (getModule()) DifferentiableFunctionExtractInst(\n+        getModule(), getSILDebugLocation(Loc), Extractee, Function,\n+        ExtracteeType));\n+  }\n+\n+  DifferentiableFunctionExtractInst *\n+  createDifferentiableFunctionExtractOriginal(SILLocation Loc,\n+                                              SILValue TheFunction) {\n+    return insert(new (getModule()) DifferentiableFunctionExtractInst(\n+        getModule(), getSILDebugLocation(Loc),\n+        NormalDifferentiableFunctionTypeComponent::Original, TheFunction));\n+  }\n+\n+  LinearFunctionExtractInst *createLinearFunctionExtract(\n+      SILLocation Loc, LinearDifferentiableFunctionTypeComponent Extractee,\n+      SILValue TheFunction) {\n+    return insert(new (getModule()) LinearFunctionExtractInst(\n+        getModule(), getSILDebugLocation(Loc), Extractee, TheFunction));\n+  }\n+\n   /// Note: explicit function type may be specified only in lowered SIL.\n   DifferentiabilityWitnessFunctionInst *createDifferentiabilityWitnessFunction(\n       SILLocation Loc, DifferentiabilityWitnessFunctionKind WitnessKind,"
                    },
                    {
                        "filename": "include/swift/SIL/SILCloner.h",
                        "code": "@@ -2827,6 +2827,55 @@ void SILCloner<ImplClass>::visitKeyPathInst(KeyPathInst *Inst) {\n                               opValues, getOpType(Inst->getType())));\n }\n \n+template <typename ImplClass>\n+void SILCloner<ImplClass>::visitDifferentiableFunctionInst(\n+    DifferentiableFunctionInst *Inst) {\n+  getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));\n+  Optional<std::pair<SILValue, SILValue>> derivativeFns = None;\n+  if (Inst->hasDerivativeFunctions())\n+    derivativeFns = std::make_pair(getOpValue(Inst->getJVPFunction()),\n+                                   getOpValue(Inst->getVJPFunction()));\n+  recordClonedInstruction(\n+      Inst, getBuilder().createDifferentiableFunction(\n+                getOpLocation(Inst->getLoc()), Inst->getParameterIndices(),\n+                getOpValue(Inst->getOriginalFunction()), derivativeFns));\n+}\n+\n+template<typename ImplClass>\n+void SILCloner<ImplClass>::visitLinearFunctionInst(LinearFunctionInst *Inst) {\n+  getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));\n+  auto transpose = Inst->getOptionalTransposeFunction();\n+  if (transpose)\n+    transpose = getOpValue(*transpose);\n+  recordClonedInstruction(\n+      Inst, getBuilder().createLinearFunction(\n+                getOpLocation(Inst->getLoc()), Inst->getParameterIndices(),\n+                getOpValue(Inst->getOriginalFunction()), transpose));\n+}\n+\n+template <typename ImplClass>\n+void SILCloner<ImplClass>::visitDifferentiableFunctionExtractInst(\n+    DifferentiableFunctionExtractInst *Inst) {\n+  getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));\n+  Optional<SILType> explicitExtracteeType = None;\n+  if (Inst->hasExplicitExtracteeType())\n+    explicitExtracteeType = Inst->getType();\n+  recordClonedInstruction(\n+      Inst, getBuilder().createDifferentiableFunctionExtract(\n+                getOpLocation(Inst->getLoc()), Inst->getExtractee(),\n+                getOpValue(Inst->getOperand()), explicitExtracteeType));\n+}\n+\n+template<typename ImplClass>\n+void SILCloner<ImplClass>::\n+visitLinearFunctionExtractInst(LinearFunctionExtractInst *Inst) {\n+  getBuilder().setCurrentDebugScope(getOpScope(Inst->getDebugScope()));\n+  recordClonedInstruction(\n+      Inst, getBuilder().createLinearFunctionExtract(\n+                getOpLocation(Inst->getLoc()), Inst->getExtractee(),\n+                getOpValue(Inst->getFunctionOperand())));\n+}\n+\n template <typename ImplClass>\n void SILCloner<ImplClass>::visitDifferentiabilityWitnessFunctionInst(\n     DifferentiabilityWitnessFunctionInst *Inst) {"
                    },
                    {
                        "filename": "include/swift/SIL/SILDeclRef.h",
                        "code": "@@ -34,6 +34,7 @@ namespace swift {\n   enum class EffectsKind : uint8_t;\n   class AbstractFunctionDecl;\n   class AbstractClosureExpr;\n+  class AutoDiffDerivativeFunctionIdentifier;\n   class ValueDecl;\n   class FuncDecl;\n   class ClosureExpr;\n@@ -143,26 +144,23 @@ struct SILDeclRef {\n   Loc loc;\n   /// The Kind of this SILDeclRef.\n   Kind kind : 4;\n-  /// True if the SILDeclRef is a curry thunk.\n-  unsigned isCurried : 1;\n   /// True if this references a foreign entry point for the referenced decl.\n   unsigned isForeign : 1;\n-  /// True if this is a direct reference to a class's method implementation\n-  /// that isn't dynamically dispatched.\n-  unsigned isDirectReference : 1;\n   /// The default argument index for a default argument getter.\n   unsigned defaultArgIndex : 10;\n-  \n+  /// The derivative function identifier.\n+  AutoDiffDerivativeFunctionIdentifier *derivativeFunctionIdentifier = nullptr;\n+\n   /// Produces a null SILDeclRef.\n-  SILDeclRef() : loc(), kind(Kind::Func),\n-                 isCurried(0), isForeign(0), isDirectReference(0),\n-                 defaultArgIndex(0) {}\n-  \n+  SILDeclRef()\n+      : loc(), kind(Kind::Func), isForeign(0), defaultArgIndex(0),\n+        derivativeFunctionIdentifier(nullptr) {}\n+\n   /// Produces a SILDeclRef of the given kind for the given decl.\n-  explicit SILDeclRef(ValueDecl *decl, Kind kind,\n-                      bool isCurried = false,\n-                      bool isForeign = false);\n-  \n+  explicit SILDeclRef(\n+      ValueDecl *decl, Kind kind, bool isForeign = false,\n+      AutoDiffDerivativeFunctionIdentifier *derivativeId = nullptr);\n+\n   /// Produces a SILDeclRef for the given ValueDecl or\n   /// AbstractClosureExpr:\n   /// - If 'loc' is a func or closure, this returns a Func SILDeclRef.\n@@ -174,14 +172,7 @@ struct SILDeclRef {\n   ///   for the containing ClassDecl.\n   /// - If 'loc' is a global VarDecl, this returns its GlobalAccessor\n   ///   SILDeclRef.\n-  ///\n-  /// If 'isCurried' is true, the loc must be a method or enum element;\n-  /// the SILDeclRef will then refer to a curry thunk with type\n-  /// (Self) -> (Args...) -> Result, rather than a direct reference to\n-  /// the actual method whose lowered type is (Args..., Self) -> Result.\n-  explicit SILDeclRef(Loc loc,\n-                      bool isCurried = false,\n-                      bool isForeign = false);\n+  explicit SILDeclRef(Loc loc, bool isForeign = false);\n \n   /// Produce a SIL constant for a default argument generator.\n   static SILDeclRef getDefaultArgGenerator(Loc loc, unsigned defaultArgIndex);\n@@ -289,17 +280,14 @@ struct SILDeclRef {\n   llvm::hash_code getHashCode() const {\n     return llvm::hash_combine(loc.getOpaqueValue(),\n                               static_cast<int>(kind),\n-                              isCurried, isForeign, isDirectReference,\n-                              defaultArgIndex);\n+                              isForeign, defaultArgIndex);\n   }\n \n   bool operator==(SILDeclRef rhs) const {\n-    return loc.getOpaqueValue() == rhs.loc.getOpaqueValue()\n-      && kind == rhs.kind\n-      && isCurried == rhs.isCurried\n-      && isForeign == rhs.isForeign\n-      && isDirectReference == rhs.isDirectReference\n-      && defaultArgIndex == rhs.defaultArgIndex;\n+    return loc.getOpaqueValue() == rhs.loc.getOpaqueValue() &&\n+           kind == rhs.kind && isForeign == rhs.isForeign &&\n+           defaultArgIndex == rhs.defaultArgIndex &&\n+           derivativeFunctionIdentifier == rhs.derivativeFunctionIdentifier;\n   }\n   bool operator!=(SILDeclRef rhs) const {\n     return !(*this == rhs);\n@@ -309,32 +297,38 @@ struct SILDeclRef {\n   void dump() const;\n \n   unsigned getParameterListCount() const;\n-  \n-  // Returns the SILDeclRef for an entity at a shallower uncurry level.\n-  SILDeclRef asCurried(bool curried = true) const {\n-    assert(!isCurried && \"can't safely go to deeper uncurry level\");\n-    // Curry thunks are never foreign.\n-    bool willBeForeign = isForeign && !curried;\n-    bool willBeDirect = isDirectReference;\n-    return SILDeclRef(loc.getOpaqueValue(), kind,\n-                      curried, willBeDirect, willBeForeign,\n-                      defaultArgIndex);\n-  }\n-  \n+\n   /// Returns the foreign (or native) entry point corresponding to the same\n   /// decl.\n   SILDeclRef asForeign(bool foreign = true) const {\n-    assert(!isCurried);\n-    return SILDeclRef(loc.getOpaqueValue(), kind,\n-                      isCurried, isDirectReference, foreign, defaultArgIndex);\n+    return SILDeclRef(loc.getOpaqueValue(), kind, foreign, defaultArgIndex,\n+                      derivativeFunctionIdentifier);\n   }\n-  \n-  SILDeclRef asDirectReference(bool direct = true) const {\n-    SILDeclRef r = *this;\n-    // The 'direct' distinction only makes sense for curry thunks.\n-    if (r.isCurried)\n-      r.isDirectReference = direct;\n-    return r;\n+\n+  /// Returns the entry point for the corresponding autodiff derivative\n+  /// function.\n+  SILDeclRef asAutoDiffDerivativeFunction(\n+      AutoDiffDerivativeFunctionIdentifier *derivativeId) const {\n+    assert(!derivativeFunctionIdentifier);\n+    SILDeclRef declRef = *this;\n+    declRef.derivativeFunctionIdentifier = derivativeId;\n+    return declRef;\n+  }\n+\n+  /// Returns the entry point for the original function corresponding to an\n+  /// autodiff derivative function.\n+  SILDeclRef asAutoDiffOriginalFunction() const {\n+    assert(derivativeFunctionIdentifier);\n+    SILDeclRef declRef = *this;\n+    declRef.derivativeFunctionIdentifier = nullptr;\n+    return declRef;\n+  }\n+\n+  /// Returns this `SILDeclRef` replacing `loc` with `decl`.\n+  SILDeclRef withDecl(ValueDecl *decl) const {\n+    SILDeclRef result = *this;\n+    result.loc = decl;\n+    return result;\n   }\n \n   /// True if the decl ref references a thunk from a natively foreign\n@@ -406,19 +400,12 @@ struct SILDeclRef {\n private:\n   friend struct llvm::DenseMapInfo<swift::SILDeclRef>;\n   /// Produces a SILDeclRef from an opaque value.\n-  explicit SILDeclRef(void *opaqueLoc,\n-                      Kind kind,\n-                      bool isCurried,\n-                      bool isDirectReference,\n-                      bool isForeign,\n-                      unsigned defaultArgIndex)\n-    : loc(Loc::getFromOpaqueValue(opaqueLoc)),\n-      kind(kind),\n-      isCurried(isCurried),\n-      isForeign(isForeign), isDirectReference(isDirectReference),\n-      defaultArgIndex(defaultArgIndex)\n-  {}\n-\n+  explicit SILDeclRef(void *opaqueLoc, Kind kind, bool isForeign,\n+                      unsigned defaultArgIndex,\n+                      AutoDiffDerivativeFunctionIdentifier *derivativeId)\n+      : loc(Loc::getFromOpaqueValue(opaqueLoc)), kind(kind),\n+        isForeign(isForeign), defaultArgIndex(defaultArgIndex),\n+        derivativeFunctionIdentifier(derivativeId) {}\n };\n \n inline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, SILDeclRef C) {\n@@ -439,21 +426,21 @@ template<> struct DenseMapInfo<swift::SILDeclRef> {\n   using UnsignedInfo = DenseMapInfo<unsigned>;\n \n   static SILDeclRef getEmptyKey() {\n-    return SILDeclRef(PointerInfo::getEmptyKey(), Kind::Func,\n-                      false, false, false, 0);\n+    return SILDeclRef(PointerInfo::getEmptyKey(), Kind::Func, false, 0,\n+                      nullptr);\n   }\n   static SILDeclRef getTombstoneKey() {\n-    return SILDeclRef(PointerInfo::getTombstoneKey(), Kind::Func,\n-                      false, false, false, 0);\n+    return SILDeclRef(PointerInfo::getTombstoneKey(), Kind::Func, false, 0,\n+                      nullptr);\n   }\n   static unsigned getHashValue(swift::SILDeclRef Val) {\n     unsigned h1 = PointerInfo::getHashValue(Val.loc.getOpaqueValue());\n     unsigned h2 = UnsignedInfo::getHashValue(unsigned(Val.kind));\n     unsigned h3 = (Val.kind == Kind::DefaultArgGenerator)\n                     ? UnsignedInfo::getHashValue(Val.defaultArgIndex)\n-                    : UnsignedInfo::getHashValue(Val.isCurried);\n+                    : 0;\n     unsigned h4 = UnsignedInfo::getHashValue(Val.isForeign);\n-    unsigned h5 = UnsignedInfo::getHashValue(Val.isDirectReference);\n+    unsigned h5 = PointerInfo::getHashValue(Val.derivativeFunctionIdentifier);\n     return h1 ^ (h2 << 4) ^ (h3 << 9) ^ (h4 << 7) ^ (h5 << 11);\n   }\n   static bool isEqual(swift::SILDeclRef const &LHS,"
                    },
                    {
                        "filename": "include/swift/SIL/SILInstruction.h",
                        "code": "@@ -7976,6 +7976,198 @@ class TryApplyInst final\n          const GenericSpecializationInformation *SpecializationInfo);\n };\n \n+/// DifferentiableFunctionInst - creates a `@differentiable` function-typed\n+/// value from an original function operand and derivative function operands\n+/// (optional). The differentiation transform canonicalizes\n+/// `differentiable_function` instructions, filling in derivative function\n+/// operands if missing.\n+class DifferentiableFunctionInst final\n+    : public InstructionBaseWithTrailingOperands<\n+          SILInstructionKind::DifferentiableFunctionInst,\n+          DifferentiableFunctionInst, OwnershipForwardingSingleValueInst> {\n+private:\n+  friend SILBuilder;\n+  /// Differentiability parameter indices.\n+  IndexSubset *ParameterIndices;\n+  /// Indicates whether derivative function operands (JVP/VJP) exist.\n+  bool HasDerivativeFunctions;\n+\n+  DifferentiableFunctionInst(SILDebugLocation DebugLoc,\n+                             IndexSubset *ParameterIndices,\n+                             SILValue OriginalFunction,\n+                             ArrayRef<SILValue> DerivativeFunctions,\n+                             bool HasOwnership);\n+\n+  static SILType getDifferentiableFunctionType(SILValue OriginalFunction,\n+                                               IndexSubset *ParameterIndices);\n+\n+  static ValueOwnershipKind\n+  getMergedOwnershipKind(SILValue OriginalFunction,\n+                         ArrayRef<SILValue> DerivativeFunctions);\n+\n+public:\n+  static DifferentiableFunctionInst *\n+  create(SILModule &Module, SILDebugLocation Loc, IndexSubset *ParameterIndices,\n+         SILValue OriginalFunction,\n+         Optional<std::pair<SILValue, SILValue>> VJPAndJVPFunctions,\n+         bool HasOwnership);\n+\n+  /// Returns the original function operand.\n+  SILValue getOriginalFunction() const { return getOperand(0); }\n+\n+  /// Returns differentiability parameter indices.\n+  IndexSubset *getParameterIndices() const { return ParameterIndices; }\n+\n+  /// Returns true if derivative functions (JVP/VJP) exist.\n+  bool hasDerivativeFunctions() const { return HasDerivativeFunctions; }\n+\n+  /// Returns the derivative function operands if they exist.\n+  /// Otherwise, return `None`.\n+  Optional<std::pair<SILValue, SILValue>>\n+  getOptionalDerivativeFunctionPair() const {\n+    if (!HasDerivativeFunctions)\n+      return None;\n+    return std::make_pair(getOperand(1), getOperand(2));\n+  }\n+\n+  ArrayRef<Operand> getDerivativeFunctionArray() const {\n+    return getAllOperands().drop_front();\n+  }\n+\n+  /// Returns the JVP function operand.\n+  SILValue getJVPFunction() const {\n+    assert(HasDerivativeFunctions);\n+    return getOperand(1);\n+  }\n+\n+  /// Returns the VJP function operand.\n+  SILValue getVJPFunction() const {\n+    assert(HasDerivativeFunctions);\n+    return getOperand(2);\n+  }\n+\n+  /// Returns the derivative function operand (JVP or VJP) with the given kind.\n+  SILValue getDerivativeFunction(AutoDiffDerivativeFunctionKind kind) const {\n+    switch (kind) {\n+    case AutoDiffDerivativeFunctionKind::JVP:\n+      return getJVPFunction();\n+    case AutoDiffDerivativeFunctionKind::VJP:\n+      return getVJPFunction();\n+    }\n+  }\n+};\n+\n+/// LinearFunctionInst - given a function, its derivative and traspose functions,\n+/// create an `@differentiable(linear)` function that represents a bundle of these.\n+class LinearFunctionInst final :\n+    public InstructionBaseWithTrailingOperands<\n+               SILInstructionKind::LinearFunctionInst,\n+               LinearFunctionInst, OwnershipForwardingSingleValueInst> {\n+private:\n+  friend SILBuilder;\n+  /// Parameters to differentiate with respect to.\n+  IndexSubset *ParameterIndices;\n+  /// Indicates whether a transpose function exists.\n+  bool HasTransposeFunction;\n+\n+  static SILType getLinearFunctionType(\n+      SILValue OriginalFunction, IndexSubset *ParameterIndices);\n+\n+public:\n+  LinearFunctionInst(SILDebugLocation Loc, IndexSubset *ParameterIndices,\n+                     SILValue OriginalFunction,\n+                     Optional<SILValue> TransposeFunction, bool HasOwnership);\n+\n+  static LinearFunctionInst *create(SILModule &Module, SILDebugLocation Loc,\n+                                    IndexSubset *ParameterIndices,\n+                                    SILValue OriginalFunction,\n+                                    Optional<SILValue> TransposeFunction,\n+                                    bool HasOwnership);\n+\n+  IndexSubset *getParameterIndices() const { return ParameterIndices; }\n+  bool hasTransposeFunction() const { return HasTransposeFunction; }\n+  SILValue getOriginalFunction() const { return getOperand(0); }\n+  Optional<SILValue> getOptionalTransposeFunction() const {\n+    return HasTransposeFunction ? Optional<SILValue>(getOperand(1)) : None;\n+  }\n+  SILValue getTransposeFunction() const {\n+    assert(HasTransposeFunction);\n+    return getOperand(1);\n+  }\n+};\n+\n+/// DifferentiableFunctionExtractInst - extracts either the original or\n+/// derivative function value from a `@differentiable` function.\n+class DifferentiableFunctionExtractInst\n+    : public UnaryInstructionBase<\n+          SILInstructionKind::DifferentiableFunctionExtractInst,\n+          SingleValueInstruction> {\n+private:\n+  /// The extractee.\n+  NormalDifferentiableFunctionTypeComponent Extractee;\n+  /// True if the instruction has an explicit extractee type.\n+  bool HasExplicitExtracteeType;\n+\n+  static SILType\n+  getExtracteeType(SILValue function,\n+                   NormalDifferentiableFunctionTypeComponent extractee,\n+                   SILModule &module);\n+\n+public:\n+  /// Note: explicit extractee type may be specified only in lowered SIL.\n+  explicit DifferentiableFunctionExtractInst(\n+      SILModule &module, SILDebugLocation debugLoc,\n+      NormalDifferentiableFunctionTypeComponent extractee, SILValue function,\n+      Optional<SILType> extracteeType = None);\n+\n+  NormalDifferentiableFunctionTypeComponent getExtractee() const {\n+    return Extractee;\n+  }\n+\n+  AutoDiffDerivativeFunctionKind getDerivativeFunctionKind() const {\n+    auto kind = Extractee.getAsDerivativeFunctionKind();\n+    assert(kind);\n+    return *kind;\n+  }\n+\n+  bool hasExplicitExtracteeType() const { return HasExplicitExtracteeType; }\n+};\n+\n+/// LinearFunctionExtractInst - given an `@differentiable(linear)` function\n+/// representing a bundle of the original function and the transpose function,\n+/// extract the specified function.\n+class LinearFunctionExtractInst\n+    : public InstructionBase<\n+          SILInstructionKind::LinearFunctionExtractInst,\n+          SingleValueInstruction> {\n+private:\n+  /// The extractee.\n+  LinearDifferentiableFunctionTypeComponent extractee;\n+  /// The list containing the `@differentiable(linear)` function operand.\n+  FixedOperandList<1> operands;\n+\n+  static SILType\n+  getExtracteeType(SILValue function,\n+                   LinearDifferentiableFunctionTypeComponent extractee,\n+                   SILModule &module);\n+\n+public:\n+  explicit LinearFunctionExtractInst(\n+      SILModule &module, SILDebugLocation debugLoc,\n+      LinearDifferentiableFunctionTypeComponent extractee,\n+      SILValue theFunction);\n+\n+  LinearDifferentiableFunctionTypeComponent getExtractee() const {\n+    return extractee;\n+  }\n+\n+  SILValue getFunctionOperand() const { return operands[0].get(); }\n+  ArrayRef<Operand> getAllOperands() const { return operands.asArray(); }\n+  MutableArrayRef<Operand> getAllOperands() { return operands.asArray(); }\n+};\n+\n+/// DifferentiabilityWitnessFunctionInst - Looks up a differentiability witness\n+/// function for a given original function.\n class DifferentiabilityWitnessFunctionInst\n     : public InstructionBase<\n           SILInstructionKind::DifferentiabilityWitnessFunctionInst,"
                    },
                    {
                        "filename": "include/swift/SIL/SILNodes.def",
                        "code": "@@ -692,6 +692,16 @@ ABSTRACT_VALUE_AND_INST(SingleValueInstruction, ValueBase, SILInstruction)\n                     SingleValueInstruction, None, DoesNotRelease)\n \n   // Differentiable programming\n+  SINGLE_VALUE_INST(DifferentiableFunctionInst, differentiable_function,\n+                    SingleValueInstruction, None, DoesNotRelease)\n+  SINGLE_VALUE_INST(LinearFunctionInst, linear_function,\n+                    SingleValueInstruction, None, DoesNotRelease)\n+  SINGLE_VALUE_INST(DifferentiableFunctionExtractInst,\n+                    differentiable_function_extract,\n+                    SingleValueInstruction, None, DoesNotRelease)\n+  SINGLE_VALUE_INST(LinearFunctionExtractInst,\n+                    linear_function_extract,\n+                    SingleValueInstruction, None, DoesNotRelease)\n   SINGLE_VALUE_INST(DifferentiabilityWitnessFunctionInst,\n                     differentiability_witness_function,\n                     SingleValueInstruction, None, DoesNotRelease)"
                    },
                    {
                        "filename": "include/swift/SIL/SILVTableVisitor.h",
                        "code": "@@ -37,9 +37,9 @@ struct SortedFuncList {\n     Mangle::ASTMangler mangler;\n     std::string mangledName;\n     if (auto *cd = dyn_cast<ConstructorDecl>(afd))\n-      mangledName = mangler.mangleConstructorEntity(cd, 0, 0);\n+      mangledName = mangler.mangleConstructorEntity(cd, 0);\n     else\n-      mangledName = mangler.mangleEntity(afd, 0);\n+      mangledName = mangler.mangleEntity(afd);\n \n     elts.push_back(std::make_pair(mangledName, afd));\n   }\n@@ -86,7 +86,24 @@ template <class T> class SILVTableVisitor {\n   void maybeAddMethod(FuncDecl *fd) {\n     assert(!fd->hasClangNode());\n \n-    maybeAddEntry(SILDeclRef(fd, SILDeclRef::Kind::Func));\n+    SILDeclRef constant(fd, SILDeclRef::Kind::Func);\n+    maybeAddEntry(constant);\n+\n+    for (auto *diffAttr : fd->getAttrs().getAttributes<DifferentiableAttr>()) {\n+      auto jvpConstant = constant.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::JVP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(), fd->getASTContext()));\n+      maybeAddEntry(jvpConstant);\n+\n+      auto vjpConstant = constant.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::VJP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(), fd->getASTContext()));\n+      maybeAddEntry(vjpConstant);\n+    }\n   }\n \n   void maybeAddConstructor(ConstructorDecl *cd) {\n@@ -96,7 +113,24 @@ template <class T> class SILVTableVisitor {\n     // The initializing entry point for designated initializers is only\n     // necessary for super.init chaining, which is sufficiently constrained\n     // to never need dynamic dispatch.\n-    maybeAddEntry(SILDeclRef(cd, SILDeclRef::Kind::Allocator));\n+    SILDeclRef constant(cd, SILDeclRef::Kind::Allocator);\n+    maybeAddEntry(constant);\n+\n+    for (auto *diffAttr : cd->getAttrs().getAttributes<DifferentiableAttr>()) {\n+      auto jvpConstant = constant.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::JVP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(), cd->getASTContext()));\n+      maybeAddEntry(jvpConstant);\n+\n+      auto vjpConstant = constant.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::VJP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(), cd->getASTContext()));\n+      maybeAddEntry(vjpConstant);\n+    }\n   }\n \n   void maybeAddAccessors(AbstractStorageDecl *asd) {"
                    },
                    {
                        "filename": "include/swift/SIL/SILWitnessVisitor.h",
                        "code": "@@ -122,14 +122,19 @@ template <class T> class SILWitnessVisitor : public ASTVisitor<T> {\n \n   void visitAbstractStorageDecl(AbstractStorageDecl *sd) {\n     sd->visitOpaqueAccessors([&](AccessorDecl *accessor) {\n-      if (SILDeclRef::requiresNewWitnessTableEntry(accessor))\n+      if (SILDeclRef::requiresNewWitnessTableEntry(accessor)) {\n         asDerived().addMethod(SILDeclRef(accessor, SILDeclRef::Kind::Func));\n+        addAutoDiffDerivativeMethodsIfRequired(accessor,\n+                                               SILDeclRef::Kind::Func);\n+      }\n     });\n   }\n \n   void visitConstructorDecl(ConstructorDecl *cd) {\n-    if (SILDeclRef::requiresNewWitnessTableEntry(cd))\n+    if (SILDeclRef::requiresNewWitnessTableEntry(cd)) {\n       asDerived().addMethod(SILDeclRef(cd, SILDeclRef::Kind::Allocator));\n+      addAutoDiffDerivativeMethodsIfRequired(cd, SILDeclRef::Kind::Allocator);\n+    }\n   }\n \n   void visitAccessorDecl(AccessorDecl *func) {\n@@ -138,8 +143,10 @@ template <class T> class SILWitnessVisitor : public ASTVisitor<T> {\n \n   void visitFuncDecl(FuncDecl *func) {\n     assert(!isa<AccessorDecl>(func));\n-    if (SILDeclRef::requiresNewWitnessTableEntry(func))\n+    if (SILDeclRef::requiresNewWitnessTableEntry(func)) {\n       asDerived().addMethod(SILDeclRef(func, SILDeclRef::Kind::Func));\n+      addAutoDiffDerivativeMethodsIfRequired(func, SILDeclRef::Kind::Func);\n+    }\n   }\n \n   void visitMissingMemberDecl(MissingMemberDecl *placeholder) {\n@@ -166,6 +173,26 @@ template <class T> class SILWitnessVisitor : public ASTVisitor<T> {\n   void visitPoundDiagnosticDecl(PoundDiagnosticDecl *pdd) {\n     // We don't care about diagnostics at this stage.\n   }\n+\n+private:\n+  void addAutoDiffDerivativeMethodsIfRequired(AbstractFunctionDecl *AFD,\n+                                              SILDeclRef::Kind kind) {\n+    SILDeclRef declRef(AFD, kind);\n+    for (auto *diffAttr : AFD->getAttrs().getAttributes<DifferentiableAttr>()) {\n+      asDerived().addMethod(declRef.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::JVP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(),\n+              AFD->getASTContext())));\n+      asDerived().addMethod(declRef.asAutoDiffDerivativeFunction(\n+          AutoDiffDerivativeFunctionIdentifier::get(\n+              AutoDiffDerivativeFunctionKind::VJP,\n+              diffAttr->getParameterIndices(),\n+              diffAttr->getDerivativeGenericSignature(),\n+              AFD->getASTContext())));\n+    }\n+  }\n };\n \n } // end namespace swift"
                    },
                    {
                        "filename": "include/swift/SILOptimizer/Analysis/ArraySemantic.h",
                        "code": "@@ -45,6 +45,9 @@ enum class ArrayCallKind {\n   kArrayUninitializedIntrinsic\n };\n \n+/// Return true is the given function is an array semantics call.\n+ArrayCallKind getArraySemanticsKind(SILFunction *f);\n+\n /// Wrapper around array semantic calls.\n class ArraySemanticsCall {\n   ApplyInst *SemanticsCall;"
                    },
                    {
                        "filename": "include/swift/SILOptimizer/PassManager/Passes.def",
                        "code": "@@ -253,6 +253,8 @@ PASS(PredictableMemoryAccessOptimizations, \"predictable-memaccess-opts\",\n      \"Predictable Memory Access Optimizations for Diagnostics\")\n PASS(PredictableDeadAllocationElimination, \"predictable-deadalloc-elim\",\n      \"Eliminate dead temporary allocations after diagnostics\")\n+PASS(RedundantPhiElimination, \"redundant-phi-elimination\",\n+     \"Redundant Phi Block Argument Elimination\")\n PASS(ReleaseDevirtualizer, \"release-devirtualizer\",\n      \"SIL release Devirtualization\")\n PASS(RetainSinking, \"retain-sinking\","
                    },
                    {
                        "filename": "include/swift/SILOptimizer/Utils/InstOptUtils.h",
                        "code": "@@ -499,6 +499,10 @@ bool calleesAreStaticallyKnowable(SILModule &module, SILDeclRef decl);\n /// be reached by calling the function represented by Decl?\n bool calleesAreStaticallyKnowable(SILModule &module, AbstractFunctionDecl *afd);\n \n+/// Do we have enough information to determine all callees that could\n+/// be reached by calling the function represented by Decl?\n+bool calleesAreStaticallyKnowable(SILModule &module, EnumElementDecl *eed);\n+\n // Attempt to get the instance for , whose static type is the same as\n // its exact dynamic type, returning a null SILValue() if we cannot find it.\n // The information that a static type is the same as the exact dynamic,"
                    },
                    {
                        "filename": "include/swift/Sema/IDETypeCheckingRequests.h",
                        "code": "@@ -64,16 +64,15 @@ struct DeclApplicabilityOwner {\n class IsDeclApplicableRequest:\n     public SimpleRequest<IsDeclApplicableRequest,\n                          bool(DeclApplicabilityOwner),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                DeclApplicabilityOwner Owner) const;\n+  bool evaluate(Evaluator &evaluator, DeclApplicabilityOwner Owner) const;\n \n public:\n   // Caching\n@@ -162,16 +161,15 @@ struct TypeRelationCheckInput {\n class TypeRelationCheckRequest:\n     public SimpleRequest<TypeRelationCheckRequest,\n                          bool(TypeRelationCheckInput),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<bool> evaluate(Evaluator &evaluator,\n-                                TypeRelationCheckInput Owner) const;\n+  bool evaluate(Evaluator &evaluator, TypeRelationCheckInput Owner) const;\n \n public:\n   // Caching\n@@ -186,15 +184,15 @@ class TypeRelationCheckRequest:\n class RootAndResultTypeOfKeypathDynamicMemberRequest:\n     public SimpleRequest<RootAndResultTypeOfKeypathDynamicMemberRequest,\n                          TypePair(SubscriptDecl*),\n-                         CacheKind::Cached> {\n+                         RequestFlags::Cached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<TypePair> evaluate(Evaluator &evaluator, SubscriptDecl* SD) const;\n+  TypePair evaluate(Evaluator &evaluator, SubscriptDecl* SD) const;\n \n public:\n   // Caching\n@@ -206,15 +204,15 @@ class RootAndResultTypeOfKeypathDynamicMemberRequest:\n class RootTypeOfKeypathDynamicMemberRequest:\n     public SimpleRequest<RootTypeOfKeypathDynamicMemberRequest,\n                          Type(SubscriptDecl*),\n-                         /*Cached in the request above*/CacheKind::Uncached> {\n+                         /*Cached in the request above*/RequestFlags::Uncached> {\n public:\n   using SimpleRequest::SimpleRequest;\n \n private:\n   friend SimpleRequest;\n \n   // Evaluation.\n-  llvm::Expected<Type> evaluate(Evaluator &evaluator, SubscriptDecl* SD) const {\n+  Type evaluate(Evaluator &evaluator, SubscriptDecl* SD) const {\n     return evaluateOrDefault(SD->getASTContext().evaluator,\n       RootAndResultTypeOfKeypathDynamicMemberRequest{SD}, TypePair()).\n         FirstTy;"
                    },
                    {
                        "filename": "include/swift/Serialization/SerializedModuleLoader.h",
                        "code": "@@ -184,6 +184,10 @@ class SerializedModuleLoaderBase : public ModuleLoader {\n                  unsigned previousGeneration,\n                  llvm::TinyPtrVector<AbstractFunctionDecl *> &methods) override;\n \n+  virtual void loadDerivativeFunctionConfigurations(\n+      AbstractFunctionDecl *originalAFD, unsigned previousGeneration,\n+      llvm::SetVector<AutoDiffConfig> &results) override;\n+\n   virtual void verifyAllModules() override;\n };\n \n@@ -328,12 +332,16 @@ class SerializedASTFile final : public LoadedFile {\n   lookupNestedType(Identifier name,\n                    const NominalTypeDecl *parent) const override;\n \n-  virtual OperatorDecl *lookupOperator(Identifier name,\n-                                       DeclKind fixity) const override;\n+protected:\n+  virtual void\n+  lookupOperatorDirect(Identifier name, OperatorFixity fixity,\n+                       TinyPtrVector<OperatorDecl *> &results) const override;\n \n-  virtual PrecedenceGroupDecl *\n-  lookupPrecedenceGroup(Identifier name) const override;\n+  virtual void lookupPrecedenceGroupDirect(\n+      Identifier name,\n+      TinyPtrVector<PrecedenceGroupDecl *> &results) const override;\n \n+public:\n   virtual void lookupVisibleDecls(ModuleDecl::AccessPathTy accessPath,\n                                   VisibleDeclConsumer &consumer,\n                                   NLKind lookupKind) const override;\n@@ -376,6 +384,9 @@ class SerializedASTFile final : public LoadedFile {\n       SmallVectorImpl<Decl*> &Results,\n       llvm::function_ref<bool(DeclAttributes)> matchAttributes) const override;\n \n+  virtual void\n+  getOperatorDecls(SmallVectorImpl<OperatorDecl *> &results) const override;\n+\n   virtual void\n   getPrecedenceGroups(SmallVectorImpl<PrecedenceGroupDecl*> &Results) const override;\n "
                    },
                    {
                        "filename": "include/swift/Serialization/SerializedSILLoader.h",
                        "code": "@@ -13,6 +13,7 @@\n #ifndef SWIFT_SERIALIZATION_SILLOADER_H\n #define SWIFT_SERIALIZATION_SILLOADER_H\n \n+#include \"swift/AST/AutoDiff.h\"\n #include \"swift/AST/Decl.h\"\n #include \"swift/AST/Identifier.h\"\n #include \"swift/SIL/Notifications.h\"\n@@ -102,6 +103,9 @@ class SerializedSILLoader {\n   /// Deserialize all Properties in all SILModules.\n   void getAllProperties();\n \n+  /// Deserialize all DifferentiabilityWitnesses in all SILModules.\n+  void getAllDifferentiabilityWitnesses();\n+\n   SerializedSILLoader(const SerializedSILLoader &) = delete;\n   SerializedSILLoader(SerializedSILLoader &&) = delete;\n   SerializedSILLoader &operator=(const SerializedSILLoader &) = delete;"
                    },
                    {
                        "filename": "include/swift/Subsystems.h",
                        "code": "@@ -118,33 +118,32 @@ namespace swift {\n                               bool TokenizeInterpolatedString = true,\n                               ArrayRef<Token> SplitTokens = ArrayRef<Token>());\n \n-  /// Once parsing is complete, this walks the AST to resolve imports, record\n-  /// operators, and do other top-level validation.\n-  void performNameBinding(SourceFile &SF);\n+  /// This walks the AST to resolve imports.\n+  void performImportResolution(SourceFile &SF);\n \n   /// Once type-checking is complete, this instruments code with calls to an\n   /// intrinsic that record the expected values of local variables so they can\n   /// be compared against the results from the debugger.\n   void performDebuggerTestingTransform(SourceFile &SF);\n \n-  /// Once parsing and name-binding are complete, this optionally transforms the\n-  /// ASTs to add calls to external logging functions.\n+  /// Once type checking is complete, this optionally transforms the ASTs to add\n+  /// calls to external logging functions.\n   ///\n   /// \\param HighPerformance True if the playground transform should omit\n   /// instrumentation that has a high runtime performance impact.\n   void performPlaygroundTransform(SourceFile &SF, bool HighPerformance);\n   \n-  /// Once parsing and name-binding are complete this optionally walks the ASTs\n-  /// to add calls to externally provided functions that simulate\n-  /// \"program counter\"-like debugging events. See the comment at the top of\n-  /// lib/Sema/PCMacro.cpp for a description of the calls inserted.\n+  /// Once type checking is complete this optionally walks the ASTs to add calls\n+  /// to externally provided functions that simulate \"program counter\"-like\n+  /// debugging events. See the comment at the top of lib/Sema/PCMacro.cpp for a\n+  /// description of the calls inserted.\n   void performPCMacro(SourceFile &SF);\n \n   /// Bind all 'extension' visible from \\p SF to the extended nominal.\n   void bindExtensions(SourceFile &SF);\n \n-  /// Once parsing and name-binding are complete, this walks the AST to resolve\n-  /// types and diagnose problems therein.\n+  /// Once import resolution is complete, this walks the AST to resolve types\n+  /// and diagnose problems therein.\n   void performTypeChecking(SourceFile &SF);\n \n   /// Now that we have type-checked an entire module, perform any type"
                    },
                    {
                        "filename": "include/swift/SwiftRemoteMirror/SwiftRemoteMirror.h",
                        "code": "@@ -116,7 +116,7 @@ SWIFT_REMOTE_MIRROR_LINKAGE\n int\n swift_reflection_ownsObject(SwiftReflectionContextRef ContextRef, uintptr_t Object);\n \n-/// Returns whether the given address is within an image added to this\n+/// Returns whether the given address is associated with an image added to this\n /// library. Images must be added using swift_reflection_addImage, not\n /// swift_reflection_addReflectionInfo, for this function to work\n /// properly. If addReflectionInfo is used, the return value will always\n@@ -149,6 +149,16 @@ swift_reflection_typeRefForMangledTypeName(SwiftReflectionContextRef ContextRef,\n                                            const char *MangledName,\n                                            uint64_t Length);\n \n+/// Returns the demangled name for a typeref, or NULL if the name couldn't be\n+/// created.\n+///\n+/// The returned string is heap allocated and the caller must free() it when\n+/// done.\n+SWIFT_REMOTE_MIRROR_LINKAGE\n+char *\n+swift_reflection_copyDemangledNameForTypeRef(\n+  SwiftReflectionContextRef ContextRef, swift_typeref_t OpaqueTypeRef);\n+\n /// Returns a structure describing the layout of a value of a typeref.\n /// For classes, this returns the reference value itself.\n SWIFT_REMOTE_MIRROR_LINKAGE\n@@ -231,6 +241,8 @@ int swift_reflection_projectExistential(SwiftReflectionContextRef ContextRef,\n ///\n /// Takes the address and typeref for an enum and determines the\n /// index of the currently-selected case within the enum.\n+/// You can use this index with `swift_reflection_childOfTypeRef`\n+/// to get detailed information about the specific case.\n ///\n /// Returns true if the enum case could be successfully determined.\n /// In particular, note that this code may fail for valid in-memory data\n@@ -241,21 +253,6 @@ int swift_reflection_projectEnumValue(SwiftReflectionContextRef ContextRef,\n                                       swift_typeref_t EnumTypeRef,\n                                       int *CaseIndex);\n \n-/// Finds information about a particular enum case.\n-///\n-/// Given an enum typeref and index of a case, returns:\n-/// * Typeref of the associated payload or zero if there is no payload\n-/// * Name of the case if known.\n-///\n-/// The Name points to a freshly-allocated C string on the heap.  You\n-/// are responsible for freeing the string when you are finished.\n-SWIFT_REMOTE_MIRROR_LINKAGE\n-int swift_reflection_getEnumCaseTypeRef(SwiftReflectionContextRef ContextRef,\n-                                        swift_typeref_t EnumTypeRef,\n-                                        int CaseIndex,\n-                                        char **CaseName,\n-                                        swift_typeref_t *PayloadTypeRef);\n-\n /// Dump a brief description of the typeref as a tree to stderr.\n SWIFT_REMOTE_MIRROR_LINKAGE\n void swift_reflection_dumpTypeRef(swift_typeref_t OpaqueTypeRef);"
                    },
                    {
                        "filename": "include/swift/SwiftRemoteMirror/SwiftRemoteMirrorLegacyInterop.h",
                        "code": "@@ -101,6 +101,11 @@ swift_reflection_interop_typeRefForMangledTypeName(\n   const char *MangledName,\n   uint64_t Length);\n \n+static inline char *\n+swift_reflection_interop_copyDemangledNameForTypeRef(\n+  SwiftReflectionInteropContextRef ContextRef,\n+  swift_typeref_interop_t OpaqueTypeRef);\n+\n static inline swift_typeinfo_t\n swift_reflection_interop_infoForTypeRef(SwiftReflectionInteropContextRef ContextRef,\n                                         swift_typeref_interop_t OpaqueTypeRef);\n@@ -250,6 +255,9 @@ struct SwiftReflectionFunctions {\n                                            const char *MangledName,\n                                            uint64_t Length);\n \n+  char * (*copyDemangledNameForTypeRef)(\n+  SwiftReflectionContextRef ContextRef, swift_typeref_t OpaqueTypeRef);\n+\n   swift_typeinfo_t (*infoForTypeRef)(SwiftReflectionContextRef ContextRef,\n                                       swift_typeref_t OpaqueTypeRef);\n \n@@ -354,7 +362,7 @@ swift_reflection_interop_libraryOwnsAddress(\n   // Search the images list to see if the address is in one of them.\n   struct SwiftReflectionInteropContextLegacyImageRangeList *Node =\n     ContextRef->LegacyImageRangeList;\n-  while (Node != nullptr) {\n+  while (Node != NULL) {\n     if (Node->Start <= Address && Address < Node->End)\n       return 1;\n     Node = Node->Next;\n@@ -381,7 +389,7 @@ swift_reflection_interop_libraryForAddress(\n       return Library;\n     }\n   }\n-  return nullptr;\n+  return NULL;\n }\n \n static inline uintptr_t\n@@ -409,7 +417,7 @@ swift_reflection_interop_libraryForObject(\n       if (Library->IsLegacy)\n         return Library;\n     }\n-    return nullptr;\n+    return NULL;\n   }\n   \n   return swift_reflection_interop_libraryForAddress(ContextRef, Metadata);\n@@ -418,7 +426,7 @@ swift_reflection_interop_libraryForObject(\n static inline int\n swift_reflection_interop_loadFunctions(struct SwiftReflectionInteropContext *Context,\n                                        void *Handle) {\n-  if (Handle == nullptr)\n+  if (Handle == NULL)\n     return 0;\n \n   struct SwiftReflectionInteropContextLibrary *Library = &Context\n@@ -430,7 +438,7 @@ swift_reflection_interop_loadFunctions(struct SwiftReflectionInteropContext *Con\n #endif\n #define LOAD_NAMED(field, symbol, required) do { \\\n     Functions->field = (decltype(Functions->field))dlsym(Handle, symbol); \\\n-    if (required && Functions->field == nullptr) return 0; \\\n+    if (required && Functions->field == NULL) return 0; \\\n   } while (0)\n #define LOAD(name) LOAD_NAMED(name, \"swift_reflection_\" #name, 1)\n #define LOAD_OPT(name) LOAD_NAMED(name, \"swift_reflection_\" #name, 0)\n@@ -442,7 +450,7 @@ swift_reflection_interop_loadFunctions(struct SwiftReflectionInteropContext *Con\n   if (version < SWIFT_LEGACY_METADATA_MIN_VERSION)\n     return 0;\n   \n-  int IsLegacy = dlsym(Handle, \"swift_reflection_addImage\") == nullptr;\n+  int IsLegacy = dlsym(Handle, \"swift_reflection_addImage\") == NULL;\n   \n   if (IsLegacy) {\n     LOAD_NAMED(createReflectionContextLegacy, \"swift_reflection_createReflectionContext\", 1);\n@@ -464,6 +472,7 @@ swift_reflection_interop_loadFunctions(struct SwiftReflectionInteropContext *Con\n   LOAD(typeRefForMetadata);\n   LOAD(typeRefForInstance);\n   LOAD(typeRefForMangledTypeName);\n+  LOAD_OPT(copyDemangledNameForTypeRef);\n   LOAD(infoForTypeRef);\n   LOAD(childOfTypeRef);\n   LOAD(infoForMetadata);\n@@ -499,11 +508,11 @@ swift_reflection_interop_readBytesAdapter(void *reader_context,\n   void *FreeContext;\n   const void *ptr = Context->ReadBytes(Context->ReaderContext, address, size,\n                                        &FreeContext);\n-  if (ptr == nullptr)\n+  if (ptr == NULL)\n     return 0;\n   \n   memcpy(dest, ptr, size);\n-  if (Context->FreeBytes != nullptr)\n+  if (Context->FreeBytes != NULL)\n     Context->FreeBytes(Context->ReaderContext, ptr, FreeContext);\n   return 1;\n }\n@@ -536,6 +545,8 @@ swift_reflection_interop_minimalDataLayoutQueryFunction4(\n   void *ReaderContext,\n   DataLayoutQueryType type,\n   void *inBuffer, void *outBuffer) {\n+  (void)ReaderContext;\n+  (void)inBuffer;\n   switch (type) {\n   case DLQ_GetPointerSize:\n   case DLQ_GetSizeSize: {\n@@ -565,17 +576,19 @@ swift_reflection_interop_minimalDataLayoutQueryFunction8(\n   void *ReaderContext,\n   DataLayoutQueryType type,\n   void *inBuffer, void *outBuffer) {\n+  (void)ReaderContext;\n+  (void)inBuffer;\n   // Caveat: This assumes the process being examined is\n   // running in the same kind of environment as this host code.\n #if defined(__APPLE__) && __APPLE__\n-    auto applePlatform = true;\n+    int applePlatform = 1;\n #else\n-    auto applePlatform = false;\n+    int applePlatform = 0;\n #endif\n #if defined(__APPLE__) && __APPLE__ && ((defined(TARGET_OS_IOS) && TARGET_OS_IOS) || (defined(TARGET_OS_IOS) && TARGET_OS_WATCH) || (defined(TARGET_OS_TV) && TARGET_OS_TV))\n-    auto iosDerivedPlatform = true;\n+    int iosDerivedPlatform = 1;\n #else\n-    auto iosDerivedPlatform = false;\n+    int iosDerivedPlatform = 0;\n #endif\n \n   switch (type) {\n@@ -628,7 +641,7 @@ swift_reflection_interop_createReflectionContext(\n \n   return swift_reflection_interop_createReflectionContextWithDataLayout(\n     ReaderContext,\n-    nullptr,\n+    DataLayout,\n     FreeBytes,\n     ReadBytes,\n     GetStringLength,\n@@ -654,7 +667,7 @@ swift_reflection_interop_createReflectionContextWithDataLayout(\n   ContextRef->GetStringLength = GetStringLength;\n   ContextRef->GetSymbolAddress = GetSymbolAddress;\n   \n-  ContextRef->AddressToLibraryCache = CFDictionaryCreateMutable(nullptr, 0, nullptr, nullptr);\n+  ContextRef->AddressToLibraryCache = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);\n   \n   return ContextRef;\n }\n@@ -687,7 +700,7 @@ swift_reflection_interop_addLibrary(\n     } else {\n       uint8_t PointerSize;\n       int result = ContextRef->DataLayout(\n-        ContextRef->ReaderContext, DLQ_GetPointerSize, nullptr, &PointerSize);\n+        ContextRef->ReaderContext, DLQ_GetPointerSize, NULL, &PointerSize);\n       if (!result)\n         abort(); // We need the pointer size, can't proceed without it.\n \n@@ -712,14 +725,14 @@ swift_reflection_interop_destroyReflectionContext(\n   free(ContextRef->Libraries);\n   struct SwiftReflectionInteropContextLegacyImageRangeList *LegacyImageRangeList\n     = ContextRef->LegacyImageRangeList;\n-  while (LegacyImageRangeList != nullptr) {\n+  while (LegacyImageRangeList != NULL) {\n     struct SwiftReflectionInteropContextLegacyImageRangeList *Next\n       = LegacyImageRangeList->Next;\n     free(LegacyImageRangeList);\n     LegacyImageRangeList = Next;\n   }\n   struct SwiftReflectionInteropContextFreeList *FreeList = ContextRef->FreeList;\n-  while (FreeList != nullptr) {\n+  while (FreeList != NULL) {\n     ContextRef->FreeBytes(ContextRef->ReaderContext,\n                           FreeList->Pointer, FreeList->Context);\n     struct SwiftReflectionInteropContextFreeList *Next = FreeList->Next;\n@@ -771,37 +784,37 @@ swift_reflection_interop_addImageLegacy(\n                               ImageStart,\n                               sizeof(MachHeader),\n                               &FreeContext);\n-  if (Buf == nullptr)\n+  if (Buf == NULL)\n     return 0;\n   \n   MachHeader *Header = (MachHeader *)Buf;\n   \n   if (Header->magic != MH_MAGIC && Header->magic != MH_MAGIC_64) {\n-    if (ContextRef->FreeBytes != nullptr)\n+    if (ContextRef->FreeBytes != NULL)\n       ContextRef->FreeBytes(ContextRef->ReaderContext, Buf, FreeContext);\n     return 0;\n   }\n   \n   // Read the commands.\n   uint32_t Length = Header->sizeofcmds;\n-  if (ContextRef->FreeBytes != nullptr)\n+  if (ContextRef->FreeBytes != NULL)\n     ContextRef->FreeBytes(ContextRef->ReaderContext, Buf, FreeContext);\n   \n   Buf = ContextRef->ReadBytes(ContextRef->ReaderContext,\n                               ImageStart,\n                               Length,\n                               &FreeContext);\n-  if (Buf == nullptr)\n+  if (Buf == NULL)\n     return 0;\n   Header = (MachHeader *)Buf;\n   \n   // Find the TEXT segment and figure out where the end is.\n   unsigned long TextSize;\n   uint8_t *TextSegment = getsegmentdata(Header, \"__TEXT\", &TextSize);\n-  if (ContextRef->FreeBytes != nullptr)\n+  if (ContextRef->FreeBytes != NULL)\n     ContextRef->FreeBytes(ContextRef->ReaderContext, Buf, FreeContext);\n   \n-  if (TextSegment == nullptr) {\n+  if (TextSegment == NULL) {\n     return 0;\n   }\n   unsigned long TextEnd = TextSegment - (uint8_t *)Buf + TextSize;\n@@ -811,7 +824,7 @@ swift_reflection_interop_addImageLegacy(\n                               ImageStart,\n                               TextEnd,\n                               &FreeContext);\n-  if (Buf == nullptr)\n+  if (Buf == NULL)\n     return 0;\n   Header = (MachHeader *)Buf;\n \n@@ -839,7 +852,7 @@ swift_reflection_interop_addImageLegacy(\n                                                  &info.reflstr) || success;\n   \n   if (!success) {\n-    if (ContextRef->FreeBytes != nullptr)\n+    if (ContextRef->FreeBytes != NULL)\n       ContextRef->FreeBytes(ContextRef->ReaderContext, Buf, FreeContext);\n     return 0;\n   }\n@@ -863,7 +876,7 @@ swift_reflection_interop_addImageLegacy(\n   \n   // If the buffer needs to be freed, save buffer and free context to free it when the\n   //  reflection context is destroyed.\n-  if (ContextRef->FreeBytes != nullptr) {\n+  if (ContextRef->FreeBytes != NULL) {\n     struct SwiftReflectionInteropContextFreeList *FreeListNode =\n       (struct SwiftReflectionInteropContextFreeList *)malloc(sizeof(*FreeListNode));\n     FreeListNode->Next = ContextRef->FreeList;\n@@ -911,7 +924,7 @@ swift_reflection_interop_lookupMetadata(SwiftReflectionInteropContextRef Context\n   swift_metadata_interop_t Result = {};\n   struct SwiftReflectionInteropContextLibrary *Library =\n     swift_reflection_interop_libraryForAddress(ContextRef, Metadata);\n-  if (Library != nullptr) {\n+  if (Library != NULL) {\n     Result.Metadata = Metadata;\n     Result.Library = (int)LIBRARY_INDEX;\n   }\n@@ -935,7 +948,7 @@ swift_reflection_interop_typeRefForInstance(SwiftReflectionInteropContextRef Con\n   swift_typeref_interop_t Result = {};\n   struct SwiftReflectionInteropContextLibrary *Library\n     = swift_reflection_interop_libraryForObject(ContextRef, Object);\n-  if (Library != nullptr) {\n+  if (Library != NULL) {\n     swift_typeref_t Typeref = Library->Functions.typeRefForInstance(Library->Context,\n                                                                     Object);\n     Result.Typeref = Typeref;\n@@ -966,6 +979,17 @@ swift_reflection_interop_typeRefForMangledTypeName(\n   return Result;\n }\n \n+static inline char *\n+swift_reflection_interop_copyDemangledNameForTypeRef(\n+  SwiftReflectionInteropContextRef ContextRef,\n+  swift_typeref_interop_t OpaqueTypeRef) {\n+  DECLARE_LIBRARY(OpaqueTypeRef.Library);\n+  if (Library->Functions.copyDemangledNameForTypeRef)\n+    return Library->Functions.copyDemangledNameForTypeRef(Library->Context,\n+                                                          OpaqueTypeRef.Typeref);\n+  return NULL;\n+}\n+\n static inline swift_typeinfo_t\n swift_reflection_interop_infoForTypeRef(SwiftReflectionInteropContextRef ContextRef,\n                                         swift_typeref_interop_t OpaqueTypeRef) {\n@@ -1021,7 +1045,7 @@ swift_reflection_interop_infoForInstance(SwiftReflectionInteropContextRef Contex\n   struct SwiftReflectionInteropContextLibrary *Library\n     = swift_reflection_interop_libraryForObject(ContextRef, Object);\n   \n-  if (Library != nullptr) {\n+  if (Library != NULL) {\n     Result = Library->Functions.infoForInstance(Library->Context, Object);\n   } else {\n     Result.Kind = SWIFT_UNKNOWN;\n@@ -1037,7 +1061,7 @@ swift_reflection_interop_childOfInstance(SwiftReflectionInteropContextRef Contex\n   swift_childinfo_interop_t Result = {};\n   struct SwiftReflectionInteropContextLibrary *Library\n     = swift_reflection_interop_libraryForObject(ContextRef, Object);\n-  if (Library != nullptr) {\n+  if (Library != NULL) {\n     swift_childinfo_t LibResult = Library->Functions.childOfInstance(Library->Context,\n                                                                      Object, Index);\n     Result.Name = LibResult.Name;\n@@ -1115,7 +1139,7 @@ swift_reflection_interop_dumpInfoForInstance(SwiftReflectionInteropContextRef Co\n                                              uintptr_t Object) {\n   struct SwiftReflectionInteropContextLibrary *Library\n     = swift_reflection_interop_libraryForObject(ContextRef, Object);\n-  if (Library != nullptr) {\n+  if (Library != NULL) {\n     Library->Functions.dumpInfoForInstance(Library->Context, Object);\n   }\n }"
                    },
                    {
                        "filename": "include/swift/TBDGen/TBDGen.h",
                        "code": "@@ -12,9 +12,11 @@\n #ifndef SWIFT_IRGEN_TBDGEN_H\n #define SWIFT_IRGEN_TBDGEN_H\n \n+#include \"llvm/ADT/Hashing.h\"\n #include \"llvm/ADT/StringRef.h\"\n #include \"llvm/ADT/StringSet.h\"\n #include \"swift/Basic/Version.h\"\n+#include <vector>\n \n namespace llvm {\n class raw_ostream;"
                    },
                    {
                        "filename": "lib/AST/ASTContext.cpp",
                        "code": "@@ -420,9 +420,9 @@ struct ASTContext::Implementation {\n   llvm::FoldingSet<BuiltinVectorType> BuiltinVectorTypes;\n   llvm::FoldingSet<DeclName::CompoundDeclName> CompoundNames;\n   llvm::DenseMap<UUID, OpenedArchetypeType *> OpenedExistentialArchetypes;\n-\n-  /// For uniquifying `IndexSubset` allocations.\n   llvm::FoldingSet<IndexSubset> IndexSubsets;\n+  llvm::FoldingSet<AutoDiffDerivativeFunctionIdentifier>\n+      AutoDiffDerivativeFunctionIdentifiers;\n \n   /// A cache of information about whether particular nominal types\n   /// are representable in a foreign language.\n@@ -1471,6 +1471,17 @@ void ASTContext::loadObjCMethods(\n   }\n }\n \n+void ASTContext::loadDerivativeFunctionConfigurations(\n+    AbstractFunctionDecl *originalAFD, unsigned previousGeneration,\n+    llvm::SetVector<AutoDiffConfig> &results) {\n+  PrettyStackTraceDecl stackTrace(\n+      \"loading derivative function configurations for\", originalAFD);\n+  for (auto &loader : getImpl().ModuleLoaders) {\n+    loader->loadDerivativeFunctionConfigurations(originalAFD,\n+                                                 previousGeneration, results);\n+  }\n+}\n+\n void ASTContext::verifyAllLoadedModules() const {\n #ifndef NDEBUG\n   FrontendStatsTracer tracer(Stats, \"verify-all-loaded-modules\");\n@@ -4754,3 +4765,30 @@ IndexSubset::get(ASTContext &ctx, const SmallBitVector &indices) {\n   foldingSet.InsertNode(newNode, insertPos);\n   return newNode;\n }\n+\n+AutoDiffDerivativeFunctionIdentifier *AutoDiffDerivativeFunctionIdentifier::get(\n+    AutoDiffDerivativeFunctionKind kind, IndexSubset *parameterIndices,\n+    GenericSignature derivativeGenericSignature, ASTContext &C) {\n+  assert(parameterIndices);\n+  auto &foldingSet = C.getImpl().AutoDiffDerivativeFunctionIdentifiers;\n+  llvm::FoldingSetNodeID id;\n+  id.AddInteger((unsigned)kind);\n+  id.AddPointer(parameterIndices);\n+  CanGenericSignature derivativeCanGenSig;\n+  if (derivativeGenericSignature)\n+    derivativeCanGenSig = derivativeGenericSignature->getCanonicalSignature();\n+  id.AddPointer(derivativeCanGenSig.getPointer());\n+\n+  void *insertPos;\n+  auto *existing = foldingSet.FindNodeOrInsertPos(id, insertPos);\n+  if (existing)\n+    return existing;\n+\n+  void *mem = C.Allocate(sizeof(AutoDiffDerivativeFunctionIdentifier),\n+                         alignof(AutoDiffDerivativeFunctionIdentifier));\n+  auto *newNode = ::new (mem) AutoDiffDerivativeFunctionIdentifier(\n+      kind, parameterIndices, derivativeGenericSignature);\n+  foldingSet.InsertNode(newNode, insertPos);\n+\n+  return newNode;\n+}"
                    },
                    {
                        "filename": "lib/AST/ASTDemangler.cpp",
                        "code": "@@ -365,7 +365,8 @@ Type ASTBuilder::createFunctionType(\n     auto parameterFlags = ParameterTypeFlags()\n                               .withValueOwnership(ownership)\n                               .withVariadic(flags.isVariadic())\n-                              .withAutoClosure(flags.isAutoClosure());\n+                              .withAutoClosure(flags.isAutoClosure())\n+                              .withNoDerivative(flags.isNoDerivative());\n \n     funcParams.push_back(AnyFunctionType::Param(type, label, parameterFlags));\n   }\n@@ -386,16 +387,27 @@ Type ASTBuilder::createFunctionType(\n     break;\n   }\n \n+  DifferentiabilityKind diffKind;\n+  switch (flags.getDifferentiabilityKind()) {\n+  case FunctionMetadataDifferentiabilityKind::NonDifferentiable:\n+    diffKind = DifferentiabilityKind::NonDifferentiable;\n+    break;\n+  case FunctionMetadataDifferentiabilityKind::Normal:\n+    diffKind = DifferentiabilityKind::Normal;\n+    break;\n+  case FunctionMetadataDifferentiabilityKind::Linear:\n+    diffKind = DifferentiabilityKind::Linear;\n+    break;\n+  }\n+\n   auto noescape =\n     (representation == FunctionTypeRepresentation::Swift\n      || representation == FunctionTypeRepresentation::Block)\n     && !flags.isEscaping();\n \n   FunctionType::ExtInfo incompleteExtInfo(\n     FunctionTypeRepresentation::Swift,\n-    noescape, flags.throws(),\n-    DifferentiabilityKind::NonDifferentiable,\n-    /*clangFunctionType*/nullptr);\n+    noescape, flags.throws(), diffKind, /*clangFunctionType*/nullptr);\n \n   const clang::Type *clangFunctionType = nullptr;\n   if (representation == FunctionTypeRepresentation::CFunctionPointer)\n@@ -488,11 +500,23 @@ Type ASTBuilder::createImplFunctionType(\n     break;\n   }\n \n+  DifferentiabilityKind diffKind;\n+  switch (flags.getDifferentiabilityKind()) {\n+  case ImplFunctionDifferentiabilityKind::NonDifferentiable:\n+    diffKind = DifferentiabilityKind::NonDifferentiable;\n+    break;\n+  case ImplFunctionDifferentiabilityKind::Normal:\n+    diffKind = DifferentiabilityKind::Normal;\n+    break;\n+  case ImplFunctionDifferentiabilityKind::Linear:\n+    diffKind = DifferentiabilityKind::Linear;\n+    break;\n+  }\n+\n   // TODO: [store-sil-clang-function-type]\n-  auto einfo = SILFunctionType::ExtInfo(\n-      representation, flags.isPseudogeneric(), !flags.isEscaping(),\n-      DifferentiabilityKind::NonDifferentiable,\n-      /*clangFunctionType*/ nullptr);\n+  auto einfo = SILFunctionType::ExtInfo(representation, flags.isPseudogeneric(),\n+                                        !flags.isEscaping(), diffKind,\n+                                        /*clangFunctionType*/ nullptr);\n \n   llvm::SmallVector<SILParameterInfo, 8> funcParams;\n   llvm::SmallVector<SILYieldInfo, 8> funcYields;"
                    },
                    {
                        "filename": "lib/AST/ASTDumper.cpp",
                        "code": "@@ -2354,6 +2354,34 @@ class PrintExpr : public ExprVisitor<PrintExpr> {\n     printRec(E->getSubExpr());\n     PrintWithColorRAII(OS, ParenthesisColor) << ')';\n   }\n+  void visitDifferentiableFunctionExpr(DifferentiableFunctionExpr *E) {\n+    printCommon(E, \"differentiable_function\") << '\\n';\n+    printRec(E->getSubExpr());\n+    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n+  }\n+  void visitLinearFunctionExpr(LinearFunctionExpr *E) {\n+    printCommon(E, \"linear_function\") << '\\n';\n+    printRec(E->getSubExpr());\n+    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n+  }\n+  void visitDifferentiableFunctionExtractOriginalExpr(\n+      DifferentiableFunctionExtractOriginalExpr *E) {\n+    printCommon(E, \"differentiable_function_extract_original\") << '\\n';\n+    printRec(E->getSubExpr());\n+    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n+  }\n+  void visitLinearFunctionExtractOriginalExpr(\n+      LinearFunctionExtractOriginalExpr *E) {\n+    printCommon(E, \"linear_function_extract_original\") << '\\n';\n+    printRec(E->getSubExpr());\n+    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n+  }\n+  void visitLinearToDifferentiableFunctionExpr(\n+      LinearToDifferentiableFunctionExpr *E) {\n+    printCommon(E, \"linear_to_differentiable_function\") << '\\n';\n+    printRec(E->getSubExpr());\n+    PrintWithColorRAII(OS, ParenthesisColor) << ')';\n+  }\n \n   void visitInOutExpr(InOutExpr *E) {\n     printCommon(E, \"inout_expr\") << '\\n';\n@@ -2585,7 +2613,7 @@ class PrintExpr : public ExprVisitor<PrintExpr> {\n   }\n   void visitEnumIsCaseExpr(EnumIsCaseExpr *E) {\n     printCommon(E, \"enum_is_case_expr\") << ' ' <<\n-      E->getEnumElement()->getName() << \"\\n\";\n+      E->getEnumElement()->getBaseIdentifier() << \"\\n\";\n     printRec(E->getSubExpr());\n     PrintWithColorRAII(OS, ParenthesisColor) << ')';\n   }"
                    },
                    {
                        "filename": "lib/AST/ASTMangler.cpp",
                        "code": "@@ -78,12 +78,9 @@ std::string ASTMangler::mangleClosureEntity(const AbstractClosureExpr *closure,\n   return finalize();\n }\n \n-std::string ASTMangler::mangleEntity(const ValueDecl *decl, bool isCurried,\n-                                     SymbolKind SKind) {\n+std::string ASTMangler::mangleEntity(const ValueDecl *decl, SymbolKind SKind) {\n   beginMangling();\n   appendEntity(decl);\n-  if (isCurried)\n-    appendOperator(\"Tc\");\n   appendSymbolKind(SKind);\n   return finalize();\n }\n@@ -99,12 +96,9 @@ std::string ASTMangler::mangleDestructorEntity(const DestructorDecl *decl,\n \n std::string ASTMangler::mangleConstructorEntity(const ConstructorDecl *ctor,\n                                                 bool isAllocating,\n-                                                bool isCurried,\n                                                 SymbolKind SKind) {\n   beginMangling();\n   appendConstructorEntity(ctor, isAllocating);\n-  if (isCurried)\n-    appendOperator(\"Tc\");\n   appendSymbolKind(SKind);\n   return finalize();\n }\n@@ -379,6 +373,57 @@ std::string ASTMangler::mangleReabstractionThunkHelper(\n   return finalize();\n }\n \n+std::string ASTMangler::mangleAutoDiffDerivativeFunctionHelper(\n+    StringRef name, AutoDiffDerivativeFunctionKind kind,\n+    AutoDiffConfig config) {\n+  // TODO(TF-20): Make the mangling scheme robust. Support demangling.\n+  beginManglingWithoutPrefix();\n+\n+  Buffer << \"AD__\" << name << '_';\n+  switch (kind) {\n+  case AutoDiffDerivativeFunctionKind::JVP:\n+    Buffer << \"_jvp_\";\n+    break;\n+  case AutoDiffDerivativeFunctionKind::VJP:\n+    Buffer << \"_vjp_\";\n+    break;\n+  }\n+  Buffer << config.getSILAutoDiffIndices().mangle();\n+  if (config.derivativeGenericSignature) {\n+    Buffer << '_';\n+    appendGenericSignature(config.derivativeGenericSignature);\n+  }\n+\n+  auto result = Storage.str().str();\n+  Storage.clear();\n+  return result;\n+}\n+\n+std::string ASTMangler::mangleAutoDiffLinearMapHelper(\n+    StringRef name, AutoDiffLinearMapKind kind, AutoDiffConfig config) {\n+  // TODO(TF-20): Make the mangling scheme robust. Support demangling.\n+  beginManglingWithoutPrefix();\n+\n+  Buffer << \"AD__\" << name << '_';\n+  switch (kind) {\n+  case AutoDiffLinearMapKind::Differential:\n+    Buffer << \"_differential_\";\n+    break;\n+  case AutoDiffLinearMapKind::Pullback:\n+    Buffer << \"_pullback_\";\n+    break;\n+  }\n+  Buffer << config.getSILAutoDiffIndices().mangle();\n+  if (config.derivativeGenericSignature) {\n+    Buffer << '_';\n+    appendGenericSignature(config.derivativeGenericSignature);\n+  }\n+\n+  auto result = Storage.str().str();\n+  Storage.clear();\n+  return result;\n+}\n+\n std::string ASTMangler::mangleSILDifferentiabilityWitnessKey(\n     SILDifferentiabilityWitnessKey key) {\n   // TODO(TF-20): Make the mangling scheme robust. Support demangling.\n@@ -587,7 +632,6 @@ void ASTMangler::appendSymbolKind(SymbolKind SKind) {\n     case SymbolKind::DynamicThunk: return appendOperator(\"TD\");\n     case SymbolKind::SwiftAsObjCThunk: return appendOperator(\"To\");\n     case SymbolKind::ObjCAsSwiftThunk: return appendOperator(\"TO\");\n-    case SymbolKind::DirectMethodReferenceThunk: return appendOperator(\"Td\");\n   }\n }\n \n@@ -1473,6 +1517,18 @@ void ASTMangler::appendImplFunctionType(SILFunctionType *fn) {\n   if (!fn->isNoEscape())\n     OpArgs.push_back('e');\n \n+  // Differentiability kind.\n+  switch (fn->getExtInfo().getDifferentiabilityKind()) {\n+  case DifferentiabilityKind::NonDifferentiable:\n+    break;\n+  case DifferentiabilityKind::Normal:\n+    OpArgs.push_back('d');\n+    break;\n+  case DifferentiabilityKind::Linear:\n+    OpArgs.push_back('l');\n+    break;\n+  }\n+\n   // <impl-callee-convention>\n   if (fn->getExtInfo().hasContext()) {\n     OpArgs.push_back(getParamConvention(fn->getCalleeConvention()));\n@@ -2073,6 +2129,18 @@ void ASTMangler::appendFunctionType(AnyFunctionType *fn, bool isAutoClosure,\n   case AnyFunctionType::Representation::Thin:\n     return appendOperator(\"Xf\");\n   case AnyFunctionType::Representation::Swift:\n+    if (fn->getDifferentiabilityKind() == DifferentiabilityKind::Normal) {\n+      if (fn->isNoEscape())\n+        return appendOperator(\"XF\");\n+      else\n+        return appendOperator(\"XG\");\n+    }\n+    if (fn->getDifferentiabilityKind() == DifferentiabilityKind::Linear) {\n+      if (fn->isNoEscape())\n+        return appendOperator(\"XH\");\n+      else\n+        return appendOperator(\"XI\");\n+    }\n     if (isAutoClosure) {\n       if (fn->isNoEscape())\n         return appendOperator(\"XK\");\n@@ -2757,6 +2825,35 @@ void ASTMangler::appendDependentProtocolConformance(\n   }\n }\n \n+void ASTMangler::appendAnyProtocolConformance(\n+                                           CanGenericSignature genericSig,\n+                                           CanType conformingType,\n+                                           ProtocolConformanceRef conformance) {\n+  if (conformingType->isTypeParameter()) {\n+    assert(genericSig && \"Need a generic signature to resolve conformance\");\n+    auto path = genericSig->getConformanceAccessPath(conformingType,\n+                                                     conformance.getAbstract());\n+    appendDependentProtocolConformance(path);\n+  } else if (auto opaqueType = conformingType->getAs<OpaqueTypeArchetypeType>()) {\n+    GenericSignature opaqueSignature = opaqueType->getBoundSignature();\n+    GenericTypeParamType *opaqueTypeParam = opaqueSignature->getGenericParams().back();\n+    ConformanceAccessPath conformanceAccessPath =\n+        opaqueSignature->getConformanceAccessPath(opaqueTypeParam,\n+                                                  conformance.getAbstract());\n+\n+    // Append the conformance access path with the signature of the opaque type.\n+    {\n+      llvm::SaveAndRestore<CanGenericSignature> savedSignature(\n+          CurGenericSignature, opaqueSignature.getCanonicalSignature());\n+      appendDependentProtocolConformance(conformanceAccessPath);\n+    }\n+    appendType(conformingType);\n+    appendOperator(\"HO\");\n+  } else {\n+    appendConcreteProtocolConformance(conformance.getConcrete());\n+  }\n+}\n+\n void ASTMangler::appendConcreteProtocolConformance(\n                                       const ProtocolConformance *conformance) {\n   auto module = conformance->getDeclContext()->getParentModule();\n@@ -2797,30 +2894,15 @@ void ASTMangler::appendConcreteProtocolConformance(\n       CanType canType = type->getCanonicalType(CurGenericSignature);\n       auto proto =\n         conditionalReq.getSecondType()->castTo<ProtocolType>()->getDecl();\n-      if (canType->isTypeParameter()) {\n-        assert(CurGenericSignature &&\n-               \"Need a generic signature to resolve conformance\");\n-        auto conformanceAccessPath =\n-            CurGenericSignature->getConformanceAccessPath(type, proto);\n-        appendDependentProtocolConformance(conformanceAccessPath);\n-      } else if (auto opaqueType = canType->getAs<OpaqueTypeArchetypeType>()) {\n-        GenericSignature opaqueSignature = opaqueType->getBoundSignature();\n-        GenericTypeParamType *opaqueTypeParam = opaqueSignature->getGenericParams().back();\n-        ConformanceAccessPath conformanceAccessPath =\n-            opaqueSignature->getConformanceAccessPath(opaqueTypeParam, proto);\n-\n-        // Append the conformance access path with the signature of the opaque type.\n-        {\n-          llvm::SaveAndRestore<CanGenericSignature> savedSignature(\n-              CurGenericSignature, opaqueSignature.getCanonicalSignature());\n-          appendDependentProtocolConformance(conformanceAccessPath);\n-        }\n-        appendType(canType);\n-        appendOperator(\"HO\");\n+      \n+      ProtocolConformanceRef conformance;\n+      \n+      if (canType->isTypeParameter() || canType->is<OpaqueTypeArchetypeType>()){\n+        conformance = ProtocolConformanceRef(proto);\n       } else {\n-        auto conditionalConf = module->lookupConformance(canType, proto);\n-        appendConcreteProtocolConformance(conditionalConf.getConcrete());\n+        conformance = module->lookupConformance(canType, proto);\n       }\n+      appendAnyProtocolConformance(CurGenericSignature, canType, conformance);\n       appendListSeparator(firstRequirement);\n       break;\n     }"
                    },
                    {
                        "filename": "lib/AST/ASTPrinter.cpp",
                        "code": "@@ -103,6 +103,7 @@ PrintOptions PrintOptions::printSwiftInterfaceFile(bool preferTypeRepr,\n                                                    bool printFullConvention,\n                                                    bool printSPIs) {\n   PrintOptions result;\n+  result.IsForSwiftInterface = true;\n   result.PrintLongAttrsOnSeparateLines = true;\n   result.TypeDefinitions = true;\n   result.PrintIfConfig = false;\n@@ -825,7 +826,7 @@ class PrintAST : public ASTVisitor<PrintAST> {\n   void printMembers(ArrayRef<Decl *> members, bool needComma = false,\n                     bool openBracket = true, bool closeBracket = true);\n   void printGenericDeclGenericParams(GenericContext *decl);\n-  void printGenericDeclGenericRequirements(GenericContext *decl);\n+  void printDeclGenericRequirements(GenericContext *decl);\n   void printInherited(const Decl *decl);\n   void printBodyIfNecessary(const AbstractFunctionDecl *decl);\n \n@@ -2054,19 +2055,23 @@ void PrintAST::printGenericDeclGenericParams(GenericContext *decl) {\n       printGenericSignature(GenericSig, PrintParams | InnermostOnly);\n }\n \n-void PrintAST::printGenericDeclGenericRequirements(GenericContext *decl) {\n-  if (decl->isGeneric()) {\n-    if (auto genericSig = decl->getGenericSignature()) {\n-      auto baseGenericSig = decl->getParent()\n-          ->getGenericSignatureOfContext();\n-      printGenericSignature(genericSig, PrintRequirements,\n-                            [baseGenericSig](const Requirement &req) {\n-                              if (baseGenericSig)\n-                                return !baseGenericSig->isRequirementSatisfied(req);\n-                              return true;\n-                            });\n-    }\n-  }\n+void PrintAST::printDeclGenericRequirements(GenericContext *decl) {\n+  const auto genericSig = decl->getGenericSignature();\n+  if (!genericSig)\n+    return;\n+\n+  // If the declaration is itself non-generic, it might still\n+  // carry a contextual where clause.\n+  const auto parentSig = decl->getParent()->getGenericSignatureOfContext();\n+  if (parentSig && parentSig->isEqual(genericSig))\n+    return;\n+\n+  printGenericSignature(genericSig, PrintRequirements,\n+                        [parentSig](const Requirement &req) {\n+                          if (parentSig)\n+                            return !parentSig->isRequirementSatisfied(req);\n+                          return true;\n+                        });\n }\n \n void PrintAST::printInherited(const Decl *decl) {\n@@ -2177,7 +2182,7 @@ void PrintAST::printSynthesizedExtension(Type ExtendedType,\n \n     printExtendedTypeName(ExtendedType, Printer, Options);\n     printInherited(ExtDecl);\n-    printGenericDeclGenericRequirements(ExtDecl);\n+    printDeclGenericRequirements(ExtDecl);\n   }\n   if (Options.TypeDefinitions) {\n     printMembersOfDecl(ExtDecl, false,\n@@ -2378,7 +2383,7 @@ void PrintAST::visitTypeAliasDecl(TypeAliasDecl *decl) {\n     llvm::SaveAndRestore<GenericEnvironment*> setGenericEnv(Options.GenericEnv,\n                                                 decl->getGenericEnvironment());\n     printTypeLoc(TypeLoc(decl->getUnderlyingTypeRepr(), Ty));\n-    printGenericDeclGenericRequirements(decl);\n+    printDeclGenericRequirements(decl);\n   }\n }\n \n@@ -2433,7 +2438,7 @@ void PrintAST::visitEnumDecl(EnumDecl *decl) {\n         printGenericDeclGenericParams(decl);\n       });\n     printInherited(decl);\n-    printGenericDeclGenericRequirements(decl);\n+    printDeclGenericRequirements(decl);\n   }\n   if (Options.TypeDefinitions) {\n     printMembersOfDecl(decl, false, true,\n@@ -2461,7 +2466,7 @@ void PrintAST::visitStructDecl(StructDecl *decl) {\n         printGenericDeclGenericParams(decl);\n       });\n     printInherited(decl);\n-    printGenericDeclGenericRequirements(decl);\n+    printDeclGenericRequirements(decl);\n   }\n   if (Options.TypeDefinitions) {\n     printMembersOfDecl(decl, false, true,\n@@ -2490,7 +2495,7 @@ void PrintAST::visitClassDecl(ClassDecl *decl) {\n       });\n \n     printInherited(decl);\n-    printGenericDeclGenericRequirements(decl);\n+    printDeclGenericRequirements(decl);\n   }\n \n   if (Options.TypeDefinitions) {\n@@ -2871,7 +2876,7 @@ void PrintAST::visitFuncDecl(FuncDecl *decl) {\n         if (!decl->hasName()) {\n           Printer << \"<anonymous>\";\n         } else {\n-          Printer.printName(decl->getName(),\n+          Printer.printName(decl->getBaseIdentifier(),\n                             getTypeMemberPrintNameContext(decl));\n           if (decl->isOperator())\n             Printer << \" \";\n@@ -2929,7 +2934,7 @@ void PrintAST::visitFuncDecl(FuncDecl *decl) {\n           ResultTyLoc, decl->isImplicitlyUnwrappedOptional());\n       Printer.printStructurePost(PrintStructureKind::FunctionReturnType);\n     }\n-    printGenericDeclGenericRequirements(decl);\n+    printDeclGenericRequirements(decl);\n   }\n \n   printBodyIfNecessary(decl);\n@@ -2944,7 +2949,8 @@ void PrintAST::visitFuncDecl(FuncDecl *decl) {\n void PrintAST::printEnumElement(EnumElementDecl *elt) {\n   recordDeclLoc(elt,\n     [&]{\n-      Printer.printName(elt->getName(), getTypeMemberPrintNameContext(elt));\n+      Printer.printName(elt->getBaseIdentifier(),\n+                        getTypeMemberPrintNameContext(elt));\n     });\n \n   if (auto *PL = elt->getParameterList()) {\n@@ -3078,7 +3084,7 @@ void PrintAST::visitSubscriptDecl(SubscriptDecl *decl) {\n   printTypeLocForImplicitlyUnwrappedOptional(\n     elementTy, decl->isImplicitlyUnwrappedOptional());\n   Printer.printStructurePost(PrintStructureKind::FunctionReturnType);\n-  printGenericDeclGenericRequirements(decl);\n+  printDeclGenericRequirements(decl);\n   printAccessors(decl);\n }\n \n@@ -3126,7 +3132,7 @@ void PrintAST::visitConstructorDecl(ConstructorDecl *decl) {\n       printFunctionParameters(decl);\n     });\n \n-  printGenericDeclGenericRequirements(decl);\n+  printDeclGenericRequirements(decl);\n \n   printBodyIfNecessary(decl);\n }\n@@ -3585,7 +3591,8 @@ class TypePrinter : public TypeVisitor<TypePrinter> {\n   template <typename T>\n   void printModuleContext(T *Ty) {\n     FileUnit *File = cast<FileUnit>(Ty->getDecl()->getModuleScopeContext());\n-    ModuleDecl *Mod = File->getParentModule();\n+    const ModuleDecl *Mod =\n+        Options.mapModuleToUnderlying(File->getParentModule());\n \n     Identifier Name = Mod->getName();\n     if (Options.UseExportedModuleNames)"
                    },
                    {
                        "filename": "lib/AST/ASTScopeCreation.cpp",
                        "code": "@@ -1121,7 +1121,7 @@ ASTScopeImpl::expandAndBeCurrentDetectingRecursion(ScopeCreator &scopeCreator) {\n                            ExpandASTScopeRequest{this, &scopeCreator}, nullptr);\n }\n \n-llvm::Expected<ASTScopeImpl *>\n+ASTScopeImpl *\n ExpandASTScopeRequest::evaluate(Evaluator &evaluator, ASTScopeImpl *parent,\n                                 ScopeCreator *scopeCreator) const {\n   auto *insertionPoint = parent->expandAndBeCurrent(*scopeCreator);"
                    },
                    {
                        "filename": "lib/AST/ASTVerifier.cpp",
                        "code": "@@ -419,10 +419,6 @@ class Verifier : public ASTWalker {\n       // Always verify the node as a parsed node.\n       verifyParsed(node);\n \n-      // If we've bound names already, verify as a bound node.\n-      if (!SF || SF->ASTStage >= SourceFile::NameBound)\n-        verifyBound(node);\n-\n       // If we've checked types already, do some extra verification.\n       if (!SF || SF->ASTStage >= SourceFile::TypeChecked) {\n         verifyCheckedAlways(node);\n@@ -523,11 +519,6 @@ class Verifier : public ASTWalker {\n       verifyParsed(cast<typename ASTNodeBase<T>::BaseTy>(ASTNode));\n     }\n \n-    void verifyBound(Expr *E) {}\n-    void verifyBound(Stmt *S) {}\n-    void verifyBound(Pattern *P) {}\n-    void verifyBound(Decl *D) {}\n-\n     /// @{\n     /// These verification functions are always run on type checked ASTs\n     /// (even if there were errors)."
                    },
                    {
                        "filename": "lib/AST/ASTWalker.cpp",
                        "code": "@@ -267,8 +267,12 @@ class Traversal : public ASTVisitor<Traversal, Expr*, Stmt*,\n       if (doIt(Inherit))\n         return true;\n     }\n-    \n-    if (auto *ATD = dyn_cast<AssociatedTypeDecl>(TPD)) {\n+\n+    if (const auto ATD = dyn_cast<AssociatedTypeDecl>(TPD)) {\n+      if (const auto DefaultTy = ATD->getDefaultDefinitionTypeRepr())\n+        if (doIt(DefaultTy))\n+          return true;\n+\n       if (auto *WhereClause = ATD->getTrailingWhereClause()) {\n         for (auto &Req: WhereClause->getRequirements()) {\n           if (doIt(Req))"
                    },
                    {
                        "filename": "lib/AST/AccessRequests.cpp",
                        "code": "@@ -36,7 +36,7 @@ namespace swift {\n //----------------------------------------------------------------------------//\n // AccessLevel computation\n //----------------------------------------------------------------------------//\n-llvm::Expected<AccessLevel>\n+AccessLevel\n AccessLevelRequest::evaluate(Evaluator &evaluator, ValueDecl *D) const {\n   assert(!D->hasAccess());\n \n@@ -168,7 +168,7 @@ static bool isStoredWithPrivateSetter(VarDecl *VD) {\n   return true;\n }\n \n-llvm::Expected<AccessLevel>\n+AccessLevel\n SetterAccessLevelRequest::evaluate(Evaluator &evaluator,\n                                    AbstractStorageDecl *ASD) const {\n   assert(!ASD->Accessors.getInt().hasValue());\n@@ -205,7 +205,7 @@ void SetterAccessLevelRequest::cacheResult(AccessLevel value) const {\n // DefaultAccessLevel computation\n //----------------------------------------------------------------------------//\n \n-llvm::Expected<std::pair<AccessLevel, AccessLevel>>\n+std::pair<AccessLevel, AccessLevel>\n DefaultAndMaxAccessLevelRequest::evaluate(Evaluator &evaluator,\n                                           ExtensionDecl *ED) const {\n   auto &Ctx = ED->getASTContext();"
                    },
                    {
                        "filename": "lib/AST/Attr.cpp",
                        "code": "@@ -526,12 +526,9 @@ static std::string getDifferentiationParametersClauseString(\n /// Print the arguments of the given `@differentiable` attribute.\n /// - If `omitWrtClause` is true, omit printing the `wrt:` differentiation\n ///   parameters clause.\n-/// - If `omitDerivativeFunctions` is true, omit printing the JVP/VJP derivative\n-///   functions.\n static void printDifferentiableAttrArguments(\n     const DifferentiableAttr *attr, ASTPrinter &printer, PrintOptions Options,\n-    const Decl *D, bool omitWrtClause = false,\n-    bool omitDerivativeFunctions = false) {\n+    const Decl *D, bool omitWrtClause = false) {\n   assert(D);\n   // Create a temporary string for the attribute argument text.\n   std::string attrArgText;\n@@ -574,19 +571,6 @@ static void printDifferentiableAttrArguments(\n       stream << diffParamsString;\n     }\n   }\n-  // Print derivative function names, unless they are to be omitted.\n-  if (!omitDerivativeFunctions) {\n-    // Print jvp function name, if specified.\n-    if (auto jvp = attr->getJVP()) {\n-      printCommaIfNecessary();\n-      stream << \"jvp: \" << jvp->Name;\n-    }\n-    // Print vjp function name, if specified.\n-    if (auto vjp = attr->getVJP()) {\n-      printCommaIfNecessary();\n-      stream << \"vjp: \" << vjp->Name;\n-    }\n-  }\n   // Print 'where' clause, if any.\n   // First, filter out requirements satisfied by the original function's\n   // generic signature. They should not be printed.\n@@ -750,6 +734,39 @@ bool DeclAttribute::printImpl(ASTPrinter &Printer, const PrintOptions &Options,\n   case DAK_Rethrows:\n   case DAK_Infix:\n     return false;\n+  case DAK_Override: {\n+    if (!Options.IsForSwiftInterface)\n+      break;\n+    // When we are printing Swift interface, we have to skip the override keyword\n+    // if the overriden decl is invisible from the interface. Otherwise, an error\n+    // will occur while building the Swift module because the overriding decl\n+    // doesn't override anything.\n+    // We couldn't skip every `override` keywords becuase they change the\n+    // ABI if the overriden decl is also publically visible.\n+    // For public-override-internal case, having `override` doesn't have ABI\n+    // implication. Thus we can skip them.\n+    if (auto *VD = dyn_cast<ValueDecl>(D)) {\n+      if (auto *BD = VD->getOverriddenDecl()) {\n+        if (!BD->hasClangNode() &&\n+            VD->isEffectiveLinkageMoreVisibleThan(BD))\n+          return false;\n+      }\n+    }\n+    break;\n+  }\n+  case DAK_Custom: {\n+    if (!Options.IsForSwiftInterface)\n+      break;\n+    // For Swift interface, we should only print function builder attribute\n+    // on parameter decls. Printing the attribute elsewhere isn't ABI relevant.\n+    if (auto *VD = dyn_cast<ValueDecl>(D)) {\n+      if (VD->getAttachedFunctionBuilder() == this) {\n+        if (!isa<ParamDecl>(D))\n+          return false;\n+      }\n+    }\n+    break;\n+  }\n   default:\n     break;\n   }\n@@ -1583,12 +1600,9 @@ SPIAccessControlAttr::create(ASTContext &context,\n DifferentiableAttr::DifferentiableAttr(bool implicit, SourceLoc atLoc,\n                                        SourceRange baseRange, bool linear,\n                                        ArrayRef<ParsedAutoDiffParameter> params,\n-                                       Optional<DeclNameRefWithLoc> jvp,\n-                                       Optional<DeclNameRefWithLoc> vjp,\n                                        TrailingWhereClause *clause)\n   : DeclAttribute(DAK_Differentiable, atLoc, baseRange, implicit),\n-    Linear(linear), NumParsedParameters(params.size()), JVP(std::move(jvp)),\n-    VJP(std::move(vjp)), WhereClause(clause) {\n+    Linear(linear), NumParsedParameters(params.size()), WhereClause(clause) {\n   std::copy(params.begin(), params.end(),\n             getTrailingObjects<ParsedAutoDiffParameter>());\n }\n@@ -1597,12 +1611,9 @@ DifferentiableAttr::DifferentiableAttr(Decl *original, bool implicit,\n                                        SourceLoc atLoc, SourceRange baseRange,\n                                        bool linear,\n                                        IndexSubset *parameterIndices,\n-                                       Optional<DeclNameRefWithLoc> jvp,\n-                                       Optional<DeclNameRefWithLoc> vjp,\n                                        GenericSignature derivativeGenSig)\n     : DeclAttribute(DAK_Differentiable, atLoc, baseRange, implicit),\n-      OriginalDeclaration(original), Linear(linear), JVP(std::move(jvp)),\n-      VJP(std::move(vjp)) {\n+      OriginalDeclaration(original), Linear(linear) {\n   setParameterIndices(parameterIndices);\n   setDerivativeGenericSignature(derivativeGenSig);\n }\n@@ -1612,29 +1623,23 @@ DifferentiableAttr::create(ASTContext &context, bool implicit,\n                            SourceLoc atLoc, SourceRange baseRange,\n                            bool linear,\n                            ArrayRef<ParsedAutoDiffParameter> parameters,\n-                           Optional<DeclNameRefWithLoc> jvp,\n-                           Optional<DeclNameRefWithLoc> vjp,\n                            TrailingWhereClause *clause) {\n   unsigned size = totalSizeToAlloc<ParsedAutoDiffParameter>(parameters.size());\n   void *mem = context.Allocate(size, alignof(DifferentiableAttr));\n   return new (mem) DifferentiableAttr(implicit, atLoc, baseRange, linear,\n-                                      parameters, std::move(jvp),\n-                                      std::move(vjp), clause);\n+                                      parameters, clause);\n }\n \n DifferentiableAttr *\n DifferentiableAttr::create(AbstractFunctionDecl *original, bool implicit,\n                            SourceLoc atLoc, SourceRange baseRange, bool linear,\n                            IndexSubset *parameterIndices,\n-                           Optional<DeclNameRefWithLoc> jvp,\n-                           Optional<DeclNameRefWithLoc> vjp,\n                            GenericSignature derivativeGenSig) {\n   auto &ctx = original->getASTContext();\n   void *mem = ctx.Allocate(sizeof(DifferentiableAttr),\n                            alignof(DifferentiableAttr));\n   return new (mem) DifferentiableAttr(original, implicit, atLoc, baseRange,\n-                                      linear, parameterIndices, std::move(jvp),\n-                                      std::move(vjp), derivativeGenSig);\n+                                      linear, parameterIndices, derivativeGenSig);\n }\n \n void DifferentiableAttr::setOriginalDeclaration(Decl *originalDeclaration) {\n@@ -1668,18 +1673,6 @@ void DifferentiableAttr::setParameterIndices(IndexSubset *paramIndices) {\n       std::move(paramIndices));\n }\n \n-void DifferentiableAttr::setJVPFunction(FuncDecl *decl) {\n-  JVPFunction = decl;\n-  if (decl && !JVP)\n-    JVP = {decl->createNameRef(), DeclNameLoc(decl->getNameLoc())};\n-}\n-\n-void DifferentiableAttr::setVJPFunction(FuncDecl *decl) {\n-  VJPFunction = decl;\n-  if (decl && !VJP)\n-    VJP = {decl->createNameRef(), DeclNameLoc(decl->getNameLoc())};\n-}\n-\n GenericEnvironment *DifferentiableAttr::getDerivativeGenericEnvironment(\n     AbstractFunctionDecl *original) const {\n   GenericEnvironment *derivativeGenEnv = original->getGenericEnvironment();\n@@ -1689,12 +1682,10 @@ GenericEnvironment *DifferentiableAttr::getDerivativeGenericEnvironment(\n }\n \n void DifferentiableAttr::print(llvm::raw_ostream &OS, const Decl *D,\n-                               bool omitWrtClause,\n-                               bool omitDerivativeFunctions) const {\n+                               bool omitWrtClause) const {\n   StreamPrinter P(OS);\n   P << \"@\" << getAttrName();\n-  printDifferentiableAttrArguments(this, P, PrintOptions(), D, omitWrtClause,\n-                                   omitDerivativeFunctions);\n+  printDifferentiableAttrArguments(this, P, PrintOptions(), D, omitWrtClause);\n }\n \n DerivativeAttr::DerivativeAttr(bool implicit, SourceLoc atLoc,"
                    },
                    {
                        "filename": "lib/AST/AutoDiff.cpp",
                        "code": "@@ -19,6 +19,59 @@\n \n using namespace swift;\n \n+AutoDiffDerivativeFunctionKind::AutoDiffDerivativeFunctionKind(\n+    StringRef string) {\n+  Optional<innerty> result = llvm::StringSwitch<Optional<innerty>>(string)\n+                                 .Case(\"jvp\", JVP)\n+                                 .Case(\"vjp\", VJP);\n+  assert(result && \"Invalid string\");\n+  rawValue = *result;\n+}\n+\n+NormalDifferentiableFunctionTypeComponent::\n+    NormalDifferentiableFunctionTypeComponent(\n+        AutoDiffDerivativeFunctionKind kind) {\n+  switch (kind) {\n+  case AutoDiffDerivativeFunctionKind::JVP:\n+    rawValue = JVP;\n+    return;\n+  case AutoDiffDerivativeFunctionKind::VJP:\n+    rawValue = VJP;\n+    return;\n+  }\n+}\n+\n+NormalDifferentiableFunctionTypeComponent::\n+    NormalDifferentiableFunctionTypeComponent(StringRef string) {\n+  Optional<innerty> result = llvm::StringSwitch<Optional<innerty>>(string)\n+                                 .Case(\"original\", Original)\n+                                 .Case(\"jvp\", JVP)\n+                                 .Case(\"vjp\", VJP);\n+  assert(result && \"Invalid string\");\n+  rawValue = *result;\n+}\n+\n+Optional<AutoDiffDerivativeFunctionKind>\n+NormalDifferentiableFunctionTypeComponent::getAsDerivativeFunctionKind() const {\n+  switch (rawValue) {\n+  case Original:\n+    return None;\n+  case JVP:\n+    return {AutoDiffDerivativeFunctionKind::JVP};\n+  case VJP:\n+    return {AutoDiffDerivativeFunctionKind::VJP};\n+  }\n+}\n+\n+LinearDifferentiableFunctionTypeComponent::\n+    LinearDifferentiableFunctionTypeComponent(StringRef string) {\n+  Optional<innerty> result = llvm::StringSwitch<Optional<innerty>>(string)\n+                                 .Case(\"original\", Original)\n+                                 .Case(\"transpose\", Transpose);\n+  assert(result && \"Invalid string\");\n+  rawValue = *result;\n+}\n+\n DifferentiabilityWitnessFunctionKind::DifferentiabilityWitnessFunctionKind(\n     StringRef string) {\n   Optional<innerty> result = llvm::StringSwitch<Optional<innerty>>(string)\n@@ -41,6 +94,24 @@ DifferentiabilityWitnessFunctionKind::getAsDerivativeFunctionKind() const {\n   }\n }\n \n+void SILAutoDiffIndices::print(llvm::raw_ostream &s) const {\n+  s << \"(source=\" << source << \" parameters=(\";\n+  interleave(\n+      parameters->getIndices(), [&s](unsigned p) { s << p; },\n+      [&s] { s << ' '; });\n+  s << \"))\";\n+}\n+\n+void SILAutoDiffIndices::dump() const {\n+  print(llvm::errs());\n+  llvm::errs() << '\\n';\n+}\n+\n+SILAutoDiffIndices AutoDiffConfig::getSILAutoDiffIndices() const {\n+  assert(resultIndices->getNumIndices() == 1);\n+  return SILAutoDiffIndices(*resultIndices->begin(), parameterIndices);\n+}\n+\n void AutoDiffConfig::print(llvm::raw_ostream &s) const {\n   s << \"(parameters=\";\n   parameterIndices->print(s);\n@@ -138,6 +209,42 @@ void autodiff::getFunctionSemanticResultTypes(\n   }\n }\n \n+// TODO(TF-874): Simplify this helper. See TF-874 for WIP.\n+IndexSubset *\n+autodiff::getLoweredParameterIndices(IndexSubset *parameterIndices,\n+                                     AnyFunctionType *functionType) {\n+  SmallVector<AnyFunctionType *, 2> curryLevels;\n+  unwrapCurryLevels(functionType, curryLevels);\n+\n+  // Compute the lowered sizes of all AST parameter types.\n+  SmallVector<unsigned, 8> paramLoweredSizes;\n+  unsigned totalLoweredSize = 0;\n+  auto addLoweredParamInfo = [&](Type type) {\n+    unsigned paramLoweredSize = countNumFlattenedElementTypes(type);\n+    paramLoweredSizes.push_back(paramLoweredSize);\n+    totalLoweredSize += paramLoweredSize;\n+  };\n+  for (auto *curryLevel : llvm::reverse(curryLevels))\n+    for (auto &param : curryLevel->getParams())\n+      addLoweredParamInfo(param.getPlainType());\n+\n+  // Build lowered SIL parameter indices by setting the range of bits that\n+  // corresponds to each \"set\" AST parameter.\n+  llvm::SmallVector<unsigned, 8> loweredSILIndices;\n+  unsigned currentBitIndex = 0;\n+  for (unsigned i : range(parameterIndices->getCapacity())) {\n+    auto paramLoweredSize = paramLoweredSizes[i];\n+    if (parameterIndices->contains(i)) {\n+      auto indices = range(currentBitIndex, currentBitIndex + paramLoweredSize);\n+      loweredSILIndices.append(indices.begin(), indices.end());\n+    }\n+    currentBitIndex += paramLoweredSize;\n+  }\n+\n+  return IndexSubset::get(functionType->getASTContext(), totalLoweredSize,\n+                          loweredSILIndices);\n+}\n+\n GenericSignature autodiff::getConstrainedDerivativeGenericSignature(\n     SILFunctionType *originalFnTy, IndexSubset *diffParamIndices,\n     GenericSignature derivativeGenSig, LookupConformanceFn lookupConformance,\n@@ -172,6 +279,77 @@ GenericSignature autodiff::getConstrainedDerivativeGenericSignature(\n       nullptr);\n }\n \n+// Given the rest of a `Builtin.applyDerivative_{jvp|vjp}` or\n+// `Builtin.applyTranspose` operation name, attempts to parse the arity and\n+// throwing-ness from the operation name. Modifies the operation name argument\n+// in place as substrings get dropped.\n+static void parseAutoDiffBuiltinCommonConfig(\n+    StringRef &operationName, unsigned &arity, bool &throws) {\n+  // Parse '_arity'.\n+  constexpr char arityPrefix[] = \"_arity\";\n+  if (operationName.startswith(arityPrefix)) {\n+    operationName = operationName.drop_front(sizeof(arityPrefix) - 1);\n+    auto arityStr = operationName.take_while(llvm::isDigit);\n+    operationName = operationName.drop_front(arityStr.size());\n+    auto converted = llvm::to_integer(arityStr, arity);\n+    assert(converted); (void)converted;\n+    assert(arity > 0);\n+  } else {\n+    arity = 1;\n+  }\n+  // Parse '_throws'.\n+  constexpr char throwsPrefix[] = \"_throws\";\n+  if (operationName.startswith(throwsPrefix)) {\n+    operationName = operationName.drop_front(sizeof(throwsPrefix) - 1);\n+    throws = true;\n+  } else {\n+    throws = false;\n+  }\n+}\n+\n+bool autodiff::getBuiltinApplyDerivativeConfig(\n+    StringRef operationName, AutoDiffDerivativeFunctionKind &kind,\n+    unsigned &arity, bool &throws) {\n+  constexpr char prefix[] = \"applyDerivative\";\n+  if (!operationName.startswith(prefix))\n+    return false;\n+  operationName = operationName.drop_front(sizeof(prefix) - 1);\n+  // Parse 'jvp' or 'vjp'.\n+  constexpr char jvpPrefix[] = \"_jvp\";\n+  constexpr char vjpPrefix[] = \"_vjp\";\n+  if (operationName.startswith(jvpPrefix))\n+    kind = AutoDiffDerivativeFunctionKind::JVP;\n+  else if (operationName.startswith(vjpPrefix))\n+    kind = AutoDiffDerivativeFunctionKind::VJP;\n+  operationName = operationName.drop_front(sizeof(jvpPrefix) - 1);\n+  parseAutoDiffBuiltinCommonConfig(operationName, arity, throws);\n+  return operationName.empty();\n+}\n+\n+bool autodiff::getBuiltinApplyTransposeConfig(\n+    StringRef operationName, unsigned &arity, bool &throws) {\n+  constexpr char prefix[] = \"applyTranspose\";\n+  if (!operationName.startswith(prefix))\n+    return false;\n+  operationName = operationName.drop_front(sizeof(prefix) - 1);\n+  parseAutoDiffBuiltinCommonConfig(operationName, arity, throws);\n+  return operationName.empty();\n+}\n+\n+bool autodiff::getBuiltinDifferentiableOrLinearFunctionConfig(\n+    StringRef operationName, unsigned &arity, bool &throws) {\n+  constexpr char differentiablePrefix[] = \"differentiableFunction\";\n+  constexpr char linearPrefix[] = \"linearFunction\";\n+  if (operationName.startswith(differentiablePrefix))\n+    operationName = operationName.drop_front(sizeof(differentiablePrefix) - 1);\n+  else if (operationName.startswith(linearPrefix))\n+    operationName = operationName.drop_front(sizeof(linearPrefix) - 1);\n+  else\n+    return false;\n+  parseAutoDiffBuiltinCommonConfig(operationName, arity, throws);\n+  return operationName.empty();\n+}\n+\n Type TangentSpace::getType() const {\n   switch (kind) {\n   case Kind::TangentVector:"
                    },
                    {
                        "filename": "lib/AST/Availability.cpp",
                        "code": "@@ -304,6 +304,9 @@ AvailabilityContext ASTContext::getSwift52Availability() {\n AvailabilityContext ASTContext::getSwift53Availability() {\n   auto target = LangOpts.Target;\n \n+  if (target.getArchName() == \"arm64e\")\n+    return AvailabilityContext::alwaysAvailable();\n+\n   if (target.isMacOSX() ) {\n     return AvailabilityContext(\n         VersionRange::allGTE(llvm::VersionTuple(10, 99, 0)));"
                    },
                    {
                        "filename": "lib/AST/Builtins.cpp",
                        "code": "@@ -19,6 +19,7 @@\n #include \"swift/AST/FileUnit.h\"\n #include \"swift/AST/Module.h\"\n #include \"swift/AST/ParameterList.h\"\n+#include \"swift/AST/TypeCheckRequests.h\"\n #include \"swift/Basic/LLVMContext.h\"\n #include \"swift/Strings.h\"\n #include \"llvm/ADT/SmallString.h\"\n@@ -184,7 +185,9 @@ static FuncDecl *\n getBuiltinGenericFunction(Identifier Id,\n                           ArrayRef<AnyFunctionType::Param> ArgParamTypes,\n                           Type ResType,\n-                          GenericParamList *GenericParams) {\n+                          GenericParamList *GenericParams,\n+                          GenericSignature Sig,\n+                          bool Rethrows = false) {\n   assert(GenericParams && \"Missing generic parameters\");\n   auto &Context = ResType->getASTContext();\n \n@@ -213,13 +216,16 @@ getBuiltinGenericFunction(Identifier Id,\n                                StaticSpellingKind::None,\n                                /*FuncLoc=*/SourceLoc(),\n                                Name, /*NameLoc=*/SourceLoc(),\n-                               /*Throws=*/false, /*ThrowsLoc=*/SourceLoc(),\n+                               /*Throws=*/ Rethrows, /*ThrowsLoc=*/SourceLoc(),\n                                GenericParams,\n                                paramList,\n                                TypeLoc::withoutLoc(ResType), DC);\n \n   func->setImplicit();\n   func->setAccess(AccessLevel::Public);\n+  func->setGenericSignature(Sig);\n+  if (Rethrows)\n+    func->getAttrs().add(new (Context) RethrowsAttr(/*ThrowsLoc*/ SourceLoc()));\n \n   return func;\n }\n@@ -446,11 +452,21 @@ namespace {\n     GenericParamList *TheGenericParamList;\n     SmallVector<AnyFunctionType::Param, 4> InterfaceParams;\n     Type InterfaceResult;\n+    bool Rethrows = false;\n+\n+    // Accumulate params and requirements here, so that we can make the\n+    // appropriate `AbstractGenericSignatureRequest` when `build()` is called.\n+    SmallVector<GenericTypeParamType *, 2> genericParamTypes;\n+    SmallVector<Requirement, 2> addedRequirements;\n \n   public:\n     BuiltinFunctionBuilder(ASTContext &ctx, unsigned numGenericParams = 1)\n         : Context(ctx) {\n       TheGenericParamList = getGenericParams(ctx, numGenericParams);\n+      for (auto gp : TheGenericParamList->getParams()) {\n+        genericParamTypes.push_back(\n+            gp->getDeclaredInterfaceType()->castTo<GenericTypeParamType>());\n+      }\n     }\n \n     template <class G>\n@@ -466,10 +482,27 @@ namespace {\n       InterfaceResult = generator.build(*this);\n     }\n \n+    template <class G>\n+    void addConformanceRequirement(const G &generator, ProtocolDecl *proto) {\n+      Requirement req(RequirementKind::Conformance,\n+                      generator.build(*this),\n+                      proto->getDeclaredType());\n+      addedRequirements.push_back(req);\n+    }\n+\n+    void setRethrows(bool rethrows = true) {\n+      Rethrows = rethrows;\n+    }\n+\n     FuncDecl *build(Identifier name) {\n+      auto GenericSig = evaluateOrDefault(\n+        Context.evaluator,\n+        AbstractGenericSignatureRequest{\n+          nullptr, std::move(genericParamTypes), std::move(addedRequirements)},\n+        nullptr);\n       return getBuiltinGenericFunction(name, InterfaceParams,\n                                        InterfaceResult,\n-                                       TheGenericParamList);\n+                                       TheGenericParamList, GenericSig);\n     }\n \n     // Don't use these generator classes directly; call the make{...}\n@@ -942,6 +975,296 @@ static ValueDecl *getGetObjCTypeEncodingOperation(ASTContext &Context,\n   return builder.build(Id);\n }\n \n+static ValueDecl *getAutoDiffApplyDerivativeFunction(\n+    ASTContext &Context, Identifier Id, AutoDiffDerivativeFunctionKind kind,\n+    unsigned arity, bool throws) {\n+  assert(arity >= 1);\n+  // JVP:\n+  //   <...T...(arity), R> (@differentiable (...T) throws -> R, ...T)\n+  //       rethrows -> (R, (...T.TangentVector) -> R.TangentVector)\n+  // VJP:\n+  //   <...T...(arity), R> (@differentiable (...T) throws -> R, ...T)\n+  //       rethrows -> (R, (R.TangentVector) -> ...T.TangentVector)\n+  unsigned numGenericParams = 1 + arity;\n+  BuiltinFunctionBuilder builder(Context, numGenericParams);\n+  // Get the `Differentiable` protocol.\n+  auto *diffableProto = Context.getProtocol(KnownProtocolKind::Differentiable);\n+  // Create type parameters and add conformance constraints.\n+  auto fnResultGen = makeGenericParam(arity);\n+  builder.addConformanceRequirement(fnResultGen, diffableProto);\n+  SmallVector<decltype(fnResultGen), 2> fnParamGens;\n+  for (auto i : range(arity)) {\n+    auto T = makeGenericParam(i);\n+    builder.addConformanceRequirement(T, diffableProto);\n+    fnParamGens.push_back(T);\n+  }\n+  // Generator for the first argument, i.e. the `@differentiable` function.\n+  BuiltinFunctionBuilder::LambdaGenerator firstArgGen {\n+    // Generator for the function type at the argument position, i.e. the\n+    // function being differentiated.\n+    [=, &fnParamGens](BuiltinFunctionBuilder &builder) -> Type {\n+      FunctionType::ExtInfo ext;\n+      auto extInfo = FunctionType::ExtInfo()\n+          .withDifferentiabilityKind(DifferentiabilityKind::Normal)\n+          .withNoEscape().withThrows(throws);\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : fnParamGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      auto innerFunction = FunctionType::get(params,\n+                                             fnResultGen.build(builder));\n+      return innerFunction->withExtInfo(extInfo);\n+    }\n+  };\n+  // Eagerly build the type of the first arg, then use that to compute the type\n+  // of the result.\n+  auto *diffFnType =\n+      firstArgGen.build(builder)->castTo<AnyFunctionType>();\n+  diffFnType = diffFnType->getWithoutDifferentiability()->withExtInfo(\n+      diffFnType->getExtInfo().withNoEscape(false));\n+  auto *paramIndices = IndexSubset::get(\n+      Context, SmallBitVector(diffFnType->getNumParams(), true));\n+  // Generator for the resultant function type, i.e. the AD derivative function.\n+  BuiltinFunctionBuilder::LambdaGenerator resultGen{\n+      [=, &Context](BuiltinFunctionBuilder &builder) -> Type {\n+        auto derivativeFnTy = diffFnType->getAutoDiffDerivativeFunctionType(\n+            paramIndices, kind,\n+            LookUpConformanceInModule(Context.TheBuiltinModule));\n+        return derivativeFnTy->getResult();\n+      }};\n+  builder.addParameter(firstArgGen);\n+  for (auto argGen : fnParamGens)\n+    builder.addParameter(argGen);\n+  if (throws)\n+    builder.setRethrows();\n+  builder.setResult(resultGen);\n+  return builder.build(Id);\n+}\n+\n+static ValueDecl *getAutoDiffApplyTransposeFunction(\n+    ASTContext &Context, Identifier Id, unsigned arity, bool throws) {\n+  assert(arity >= 1);\n+  // <...T...(arity), R>\n+  //     (@differentiable (...T) throws -> R, ...R.TangentVector)\n+  //         rethrows -> (...T.TangentVector)\n+  unsigned numGenericParams = 1 + arity;\n+  BuiltinFunctionBuilder builder(Context, numGenericParams);\n+  auto *diffableProto = Context.getProtocol(KnownProtocolKind::Differentiable);\n+  auto *addArithProto =\n+      Context.getProtocol(KnownProtocolKind::AdditiveArithmetic);\n+  // Create type parameters and add conformance constraints.\n+  auto linearFnResultGen = makeGenericParam(arity);\n+  builder.addConformanceRequirement(linearFnResultGen, diffableProto);\n+  builder.addConformanceRequirement(linearFnResultGen, addArithProto);\n+  SmallVector<decltype(linearFnResultGen), 2> linearFnParamGens;\n+  for (auto i : range(arity)) {\n+    auto T = makeGenericParam(i);\n+    builder.addConformanceRequirement(T, diffableProto);\n+    builder.addConformanceRequirement(T, addArithProto);\n+    linearFnParamGens.push_back(T);\n+  }\n+  // Generator for the first argument, i.e. the `@differentiable(linear)`\n+  // function.\n+  BuiltinFunctionBuilder::LambdaGenerator firstArgGen {\n+    // Generator for the function type at the argument position, i.e. the\n+    // function being differentiated.\n+    [=, &linearFnParamGens](BuiltinFunctionBuilder &builder) -> Type {\n+      FunctionType::ExtInfo ext;\n+      auto extInfo = FunctionType::ExtInfo()\n+          .withDifferentiabilityKind(DifferentiabilityKind::Linear)\n+          .withNoEscape().withThrows(throws);\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : linearFnParamGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      auto innerFunction = FunctionType::get(params,\n+                                             linearFnResultGen.build(builder));\n+      return innerFunction->withExtInfo(extInfo);\n+    }\n+  };\n+  builder.addParameter(firstArgGen);\n+  builder.addParameter(linearFnResultGen);\n+  if (throws)\n+    builder.setRethrows();\n+  if (arity == 1)\n+    builder.setResult(linearFnParamGens.front());\n+  else {\n+    BuiltinFunctionBuilder::LambdaGenerator tupleResultGen {\n+      [&](BuiltinFunctionBuilder &builder) -> Type {\n+        SmallVector<TupleTypeElt, 2> tupleElts;\n+        for (auto linearFnParamGen : linearFnParamGens)\n+          tupleElts.push_back(linearFnParamGen.build(builder));\n+        return TupleType::get(tupleElts, Context);\n+      }\n+    };\n+    builder.setResult(tupleResultGen);\n+  }\n+  return builder.build(Id);\n+}\n+\n+static ValueDecl *getDifferentiableFunctionConstructor(\n+    ASTContext &Context, Identifier Id, unsigned arity, bool throws) {\n+  assert(arity >= 1);\n+  unsigned numGenericParams = 1 + arity;\n+  BuiltinFunctionBuilder builder(Context, numGenericParams);\n+  // Get the `Differentiable` and `AdditiveArithmetic` protocols.\n+  auto *diffableProto =\n+      Context.getProtocol(KnownProtocolKind::Differentiable);\n+  auto *tangentVectorDecl =\n+      diffableProto->getAssociatedType(Context.Id_TangentVector);\n+  assert(tangentVectorDecl);\n+  // Create type parameters and add conformance constraints.\n+  auto origResultGen = makeGenericParam(arity);\n+  builder.addConformanceRequirement(origResultGen, diffableProto);\n+  SmallVector<decltype(origResultGen), 2> fnArgGens;\n+  for (auto i : range(arity)) {\n+    auto T = makeGenericParam(i);\n+    builder.addConformanceRequirement(T, diffableProto);\n+    fnArgGens.push_back(T);\n+  }\n+\n+  BuiltinFunctionBuilder::LambdaGenerator origFnGen {\n+    [=, &fnArgGens](BuiltinFunctionBuilder &builder) -> Type {\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : fnArgGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      return FunctionType::get(params, origResultGen.build(builder))\n+          ->withExtInfo(\n+              FunctionType::ExtInfo(FunctionTypeRepresentation::Swift, throws));\n+    }\n+  };\n+\n+  BuiltinFunctionBuilder::LambdaGenerator jvpGen {\n+    [=, &fnArgGens, &Context](BuiltinFunctionBuilder &builder) -> Type {\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : fnArgGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      auto origResultType = origResultGen.build(builder);\n+      SmallVector<FunctionType::Param, 2> differentialParams;\n+      for (auto &param : params) {\n+        auto tanType = DependentMemberType::get(\n+            param.getPlainType(), tangentVectorDecl);\n+        differentialParams.push_back(FunctionType::Param(tanType));\n+      }\n+      auto differentialResultType = DependentMemberType::get(\n+          origResultType, tangentVectorDecl);\n+      auto differentialType =\n+          FunctionType::get({differentialParams}, differentialResultType);\n+      auto jvpResultType = TupleType::get(\n+          {TupleTypeElt(origResultType, Context.Id_value),\n+           TupleTypeElt(differentialType, Context.Id_differential)}, Context);\n+      return FunctionType::get(params, jvpResultType)\n+          ->withExtInfo(\n+              FunctionType::ExtInfo(FunctionTypeRepresentation::Swift, throws));\n+    }\n+  };\n+\n+  BuiltinFunctionBuilder::LambdaGenerator vjpGen {\n+    [=, &fnArgGens, &Context](BuiltinFunctionBuilder &builder) -> Type {\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : fnArgGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      auto origResultType = origResultGen.build(builder);\n+      SmallVector<TupleTypeElt, 2> pullbackResultTupleElts;\n+      for (auto &param : params) {\n+        auto tanType = DependentMemberType::get(\n+            param.getPlainType(), tangentVectorDecl);\n+        pullbackResultTupleElts.push_back(TupleTypeElt(tanType));\n+      }\n+      auto pullbackParam = FunctionType::Param(\n+            DependentMemberType::get(origResultType, tangentVectorDecl));\n+      auto pullbackType = FunctionType::get(\n+          {pullbackParam},\n+          pullbackResultTupleElts.size() == 1\n+              ? pullbackResultTupleElts.front().getType()\n+              : TupleType::get(pullbackResultTupleElts, Context));\n+      auto vjpResultType = TupleType::get(\n+          {TupleTypeElt(origResultType, Context.Id_value),\n+           TupleTypeElt(pullbackType, Context.Id_pullback)}, Context);\n+      return FunctionType::get(params, vjpResultType)\n+          ->withExtInfo(\n+              FunctionType::ExtInfo(FunctionTypeRepresentation::Swift, throws));\n+    }\n+  };\n+\n+  BuiltinFunctionBuilder::LambdaGenerator resultGen {\n+    [&](BuiltinFunctionBuilder &builder) -> Type {\n+      auto origFnType = origFnGen.build(builder)->castTo<FunctionType>();\n+      return origFnType->withExtInfo(\n+          origFnType->getExtInfo()\n+              .withDifferentiabilityKind(DifferentiabilityKind::Normal));\n+    }\n+  };\n+\n+  builder.addParameter(origFnGen, ValueOwnership::Owned);\n+  builder.addParameter(jvpGen, ValueOwnership::Owned);\n+  builder.addParameter(vjpGen, ValueOwnership::Owned);\n+  builder.setResult(resultGen);\n+  return builder.build(Id);\n+}\n+\n+static ValueDecl *getLinearFunctionConstructor(\n+    ASTContext &Context, Identifier Id, unsigned arity, bool throws) {\n+  assert(arity >= 1);\n+  unsigned numGenericParams = 1 + arity;\n+  BuiltinFunctionBuilder builder(Context, numGenericParams);\n+  // Get the `Differentiable` and `AdditiveArithmetic` protocols.\n+  auto *diffableProto =\n+      Context.getProtocol(KnownProtocolKind::Differentiable);\n+  auto *addArithProto =\n+      Context.getProtocol(KnownProtocolKind::AdditiveArithmetic);\n+  // Create type parameters and add conformance constraints.\n+  auto origResultGen = makeGenericParam(arity);\n+  builder.addConformanceRequirement(origResultGen, diffableProto);\n+  builder.addConformanceRequirement(origResultGen, addArithProto);\n+  SmallVector<decltype(origResultGen), 2> fnArgGens;\n+  for (auto i : range(arity)) {\n+    auto T = makeGenericParam(i);\n+    builder.addConformanceRequirement(T, diffableProto);\n+    builder.addConformanceRequirement(T, addArithProto);\n+    fnArgGens.push_back(T);\n+  }\n+\n+  BuiltinFunctionBuilder::LambdaGenerator origFnGen {\n+    [=, &fnArgGens](BuiltinFunctionBuilder &builder) -> Type {\n+      SmallVector<FunctionType::Param, 2> params;\n+      for (auto &paramGen : fnArgGens)\n+        params.push_back(FunctionType::Param(paramGen.build(builder)));\n+      return FunctionType::get(params, origResultGen.build(builder))\n+          ->withExtInfo(\n+              FunctionType::ExtInfo(FunctionTypeRepresentation::Swift, throws));\n+    }\n+  };\n+\n+  BuiltinFunctionBuilder::LambdaGenerator transposeFnGen {\n+    [=, &fnArgGens, &Context](BuiltinFunctionBuilder &builder) -> Type {\n+      auto origResultType = origResultGen.build(builder);\n+      SmallVector<TupleTypeElt, 2> resultTupleElts;\n+      for (auto &paramGen : fnArgGens)\n+        resultTupleElts.push_back(paramGen.build(builder));\n+      return FunctionType::get(\n+          {FunctionType::Param(origResultType)},\n+          resultTupleElts.size() == 1\n+              ? resultTupleElts.front().getType()\n+              : TupleType::get(resultTupleElts, Context));\n+    }\n+  };\n+\n+  BuiltinFunctionBuilder::LambdaGenerator resultGen {\n+    [&](BuiltinFunctionBuilder &builder) -> Type {\n+      auto origFnType = origFnGen.build(builder)->castTo<FunctionType>();\n+      return origFnType->withExtInfo(\n+          origFnType->getExtInfo()\n+              .withDifferentiabilityKind(DifferentiabilityKind::Linear));\n+    }\n+  };\n+\n+  builder.addParameter(origFnGen, ValueOwnership::Owned);\n+  builder.addParameter(transposeFnGen, ValueOwnership::Owned);\n+  builder.setResult(resultGen);\n+  return builder.build(Id);\n+}\n+\n+\n+\n static ValueDecl *getGlobalStringTablePointer(ASTContext &Context,\n                                               Identifier Id) {\n   // String -> Builtin.RawPointer\n@@ -1758,6 +2081,40 @@ ValueDecl *swift::getBuiltinValueDecl(ASTContext &Context, Identifier Id) {\n \n     return getAllocWithTailElemsOperation(Context, Id, NumTailTypes);\n   }\n+  if (OperationName.startswith(\"applyDerivative_\")) {\n+    AutoDiffDerivativeFunctionKind kind;\n+    unsigned arity;\n+    bool throws;\n+    if (!autodiff::getBuiltinApplyDerivativeConfig(\n+            OperationName, kind, arity, throws))\n+      return nullptr;\n+    return getAutoDiffApplyDerivativeFunction(Context, Id, kind, arity,\n+                                              throws);\n+  }\n+  if (OperationName.startswith(\"applyTranspose_\")) {\n+    unsigned arity;\n+    bool throws;\n+    if (!autodiff::getBuiltinApplyTransposeConfig(\n+            OperationName, arity, throws))\n+      return nullptr;\n+    return getAutoDiffApplyTransposeFunction(Context, Id, arity, throws);\n+  }\n+  if (OperationName.startswith(\"differentiableFunction_\")) {\n+    unsigned arity;\n+    bool throws;\n+    if (!autodiff::getBuiltinDifferentiableOrLinearFunctionConfig(\n+            OperationName, arity, throws))\n+      return nullptr;\n+    return getDifferentiableFunctionConstructor(Context, Id, arity, throws);\n+  }\n+  if (OperationName.startswith(\"linearFunction_\")) {\n+    unsigned arity;\n+    bool throws;\n+    if (!autodiff::getBuiltinDifferentiableOrLinearFunctionConfig(\n+          OperationName, arity, throws))\n+      return nullptr;\n+    return getLinearFunctionConstructor(Context, Id, arity, throws);\n+  }\n \n   auto BV = llvm::StringSwitch<BuiltinValueKind>(OperationName)\n #define BUILTIN(id, name, Attrs) .Case(name, BuiltinValueKind::id)\n@@ -2028,6 +2385,12 @@ ValueDecl *swift::getBuiltinValueDecl(ASTContext &Context, Identifier Id) {\n   case BuiltinValueKind::UnsafeGuaranteedEnd:\n     return getUnsafeGuaranteedEnd(Context, Id);\n \n+  case BuiltinValueKind::ApplyDerivative:\n+  case BuiltinValueKind::ApplyTranspose:\n+  case BuiltinValueKind::DifferentiableFunction:\n+  case BuiltinValueKind::LinearFunction:\n+    llvm_unreachable(\"Handled above\");\n+\n   case BuiltinValueKind::OnFastPath:\n     return getOnFastPath(Context, Id);\n "
                    },
                    {
                        "filename": "lib/AST/CMakeLists.txt",
                        "code": "@@ -116,25 +116,24 @@ if(NOT SWIFT_BUILD_ONLY_SYNTAXPARSERLIB)\n     clangBasic)\n endif()\n \n+target_link_libraries(swiftAST\n+  PUBLIC swiftBasic\n+  PRIVATE swiftSyntax)\n if(SWIFT_BUILD_ONLY_SYNTAXPARSERLIB)\n   # Add clangBasic as a single direct dependency to avoid bringing along some\n   # llvm libraries that we don't need.\n   if(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"WINDOWS\")\n-    set(clangBasicDep \"${LLVM_LIBRARY_OUTPUT_INTDIR}/clangBasic.lib\")\n+    target_link_libraries(swiftAST PRIVATE\n+      \"${LLVM_LIBRARY_OUTPUT_INTDIR}/clangBasic.lib\")\n   else()\n-    set(clangBasicDep \"${LLVM_LIBRARY_OUTPUT_INTDIR}/libclangBasic.a\")\n+    target_link_libraries(swiftAST PRIVATE\n+      \"${LLVM_LIBRARY_OUTPUT_INTDIR}/libclangBasic.a\")\n   endif()\n-  target_link_libraries(swiftAST PRIVATE\n-    swiftBasic\n-    swiftSyntax\n-    ${clangBasicDep})\n   target_compile_definitions(swiftAST PRIVATE\n     SWIFT_BUILD_ONLY_SYNTAXPARSERLIB=1)\n else()\n   target_link_libraries(swiftAST PRIVATE\n-    swiftBasic\n-    swiftMarkup\n-    swiftSyntax)\n+    swiftMarkup)\n endif()\n \n # intrinsics_gen is the LLVM tablegen target that generates the include files"
                    },
                    {
                        "filename": "lib/AST/Decl.cpp",
                        "code": "@@ -760,7 +760,7 @@ bool Decl::hasUnderscoredNaming() const {\n   }\n \n   if (!VD->getBaseName().isSpecial() &&\n-      VD->getBaseName().getIdentifier().str().startswith(\"_\")) {\n+      VD->getBaseIdentifier().str().startswith(\"_\")) {\n     return true;\n   }\n \n@@ -1394,7 +1394,7 @@ createExtensionGenericParams(ASTContext &ctx,\n   return toParams;\n }\n \n-llvm::Expected<GenericParamList *>\n+GenericParamList *\n GenericParamListRequest::evaluate(Evaluator &evaluator, GenericContext *value) const {\n   if (auto *ext = dyn_cast<ExtensionDecl>(value)) {\n     // Create the generic parameter list for the extension by cloning the\n@@ -1855,6 +1855,17 @@ bool Pattern::isNeverDefaultInitializable() const {\n   return result;\n }\n \n+bool PatternBindingDecl::isDefaultInitializableViaPropertyWrapper(unsigned i) const {\n+  if (auto singleVar = getSingleVar()) {\n+    if (auto wrapperInfo = singleVar->getAttachedPropertyWrapperTypeInfo(0)) {\n+      if (wrapperInfo.defaultInit)\n+        return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n bool PatternBindingDecl::isDefaultInitializable(unsigned i) const {\n   const auto entry = getPatternList()[i];\n \n@@ -1864,14 +1875,14 @@ bool PatternBindingDecl::isDefaultInitializable(unsigned i) const {\n \n   // If the outermost attached property wrapper vends an `init()`, use that\n   // for default initialization.\n+  if (isDefaultInitializableViaPropertyWrapper(i))\n+    return true;\n+\n+  // If one of the attached wrappers is missing a wrappedValue\n+  // initializer, cannot default-initialize.\n   if (auto singleVar = getSingleVar()) {\n     if (auto wrapperInfo = singleVar->getAttachedPropertyWrapperTypeInfo(0)) {\n-      if (wrapperInfo.defaultInit)\n-        return true;\n-\n-      // If one of the attached wrappers is missing an initialValue\n-      // initializer, cannot default-initialize.\n-      if (!singleVar->allAttachedPropertyWrappersHaveInitialValueInit())\n+      if (!singleVar->allAttachedPropertyWrappersHaveWrappedValueInit())\n         return false;\n     }\n   }\n@@ -2997,9 +3008,6 @@ bool ValueDecl::isRecursiveValidation() const {\n \n Type ValueDecl::getInterfaceType() const {\n   auto &ctx = getASTContext();\n-\n-  assert(ctx.areLegacySemanticQueriesEnabled());\n-\n   if (auto type =\n           evaluateOrDefault(ctx.evaluator,\n                             InterfaceTypeRequest{const_cast<ValueDecl *>(this)},\n@@ -3159,7 +3167,7 @@ bool ValueDecl::shouldHideFromEditor() const {\n \n   // '$__' names are reserved by compiler internal.\n   if (!getBaseName().isSpecial() &&\n-      getBaseName().getIdentifier().str().startswith(\"$__\"))\n+      getBaseIdentifier().str().startswith(\"$__\"))\n     return true;\n \n   return false;\n@@ -3578,8 +3586,8 @@ int TypeDecl::compare(const TypeDecl *type1, const TypeDecl *type2) {\n       return result;\n   }\n \n-  if (int result = type1->getBaseName().getIdentifier().str().compare(\n-                                  type2->getBaseName().getIdentifier().str()))\n+  if (int result = type1->getBaseIdentifier().str().compare(\n+                                  type2->getBaseIdentifier().str()))\n     return result;\n \n   // Error case: two type declarations that cannot be distinguished.\n@@ -4062,6 +4070,14 @@ ConstructorDecl *NominalTypeDecl::getMemberwiseInitializer() const {\n       ctx.evaluator, SynthesizeMemberwiseInitRequest{mutableThis}, nullptr);\n }\n \n+ConstructorDecl *NominalTypeDecl::getEffectiveMemberwiseInitializer() {\n+  auto &ctx = getASTContext();\n+  auto *mutableThis = const_cast<NominalTypeDecl *>(this);\n+  return evaluateOrDefault(ctx.evaluator,\n+                           ResolveEffectiveMemberwiseInitRequest{mutableThis},\n+                           nullptr);\n+}\n+\n bool NominalTypeDecl::hasDefaultInitializer() const {\n   // Currently only structs and classes can have default initializers.\n   if (!isa<StructDecl>(this) && !isa<ClassDecl>(this))\n@@ -4120,7 +4136,7 @@ void NominalTypeDecl::synthesizeSemanticMembersIfNeeded(DeclName member) {\n \n   if (auto actionToTake = action) {\n     (void)evaluateOrDefault(Context.evaluator,\n-        ResolveImplicitMemberRequest{this, actionToTake.getValue()}, false);\n+        ResolveImplicitMemberRequest{this, actionToTake.getValue()}, {});\n   }\n }\n \n@@ -4198,7 +4214,7 @@ synthesizeEmptyFunctionBody(AbstractFunctionDecl *afd, void *context) {\n            /*isTypeChecked=*/true };\n }\n \n-llvm::Expected<DestructorDecl *>\n+DestructorDecl *\n GetDestructorRequest::evaluate(Evaluator &evaluator, ClassDecl *CD) const {\n   auto &ctx = CD->getASTContext();\n   auto *DD = new (ctx) DestructorDecl(CD->getLoc(), CD);\n@@ -4263,8 +4279,9 @@ AncestryOptions ClassDecl::checkAncestry() const {\n                            AncestryFlags()));\n }\n         \n-llvm::Expected<AncestryFlags>\n-ClassAncestryFlagsRequest::evaluate(Evaluator &evaluator, ClassDecl *value) const {\n+AncestryFlags\n+ClassAncestryFlagsRequest::evaluate(Evaluator &evaluator,\n+                                    ClassDecl *value) const {\n   llvm::SmallPtrSet<const ClassDecl *, 8> visited;\n \n   AncestryOptions result;\n@@ -4630,26 +4647,11 @@ ProtocolDecl::ProtocolDecl(DeclContext *DC, SourceLoc ProtocolLoc,\n     setTrailingWhereClause(TrailingWhere);\n }\n \n-ArrayRef<ProtocolDecl *>\n-ProtocolDecl::getInheritedProtocolsSlow() {\n-  Bits.ProtocolDecl.InheritedProtocolsValid = true;\n-\n-  llvm::SmallVector<ProtocolDecl *, 2> result;\n-  SmallPtrSet<const ProtocolDecl *, 2> known;\n-  known.insert(this);\n-  bool anyObject = false;\n-  for (const auto found :\n-           getDirectlyInheritedNominalTypeDecls(\n-             const_cast<ProtocolDecl *>(this), anyObject)) {\n-    if (auto proto = dyn_cast<ProtocolDecl>(found.Item)) {\n-      if (known.insert(proto).second)\n-        result.push_back(proto);\n-    }\n-  }\n-\n-  auto &ctx = getASTContext();\n-  InheritedProtocols = ctx.AllocateCopy(result);\n-  return InheritedProtocols;\n+ArrayRef<ProtocolDecl *> ProtocolDecl::getInheritedProtocols() const {\n+  auto *mutThis = const_cast<ProtocolDecl *>(this);\n+  return evaluateOrDefault(getASTContext().evaluator,\n+                           InheritedProtocolsRequest{mutThis},\n+                           {});\n }\n \n llvm::TinyPtrVector<AssociatedTypeDecl *>\n@@ -5031,7 +5033,8 @@ ArrayRef<Requirement> ProtocolDecl::getCachedRequirementSignature() const {\n void ProtocolDecl::computeKnownProtocolKind() const {\n   auto module = getModuleContext();\n   if (module != module->getASTContext().getStdlibModule() &&\n-      !module->getName().is(\"Foundation\")) {\n+      !module->getName().is(\"Foundation\") &&\n+      !module->getName().is(\"_Differentiation\")) {\n     const_cast<ProtocolDecl *>(this)->Bits.ProtocolDecl.KnownProtocol = 1;\n     return;\n   }\n@@ -5046,6 +5049,41 @@ void ProtocolDecl::computeKnownProtocolKind() const {\n   const_cast<ProtocolDecl *>(this)->Bits.ProtocolDecl.KnownProtocol = value;\n }\n \n+Optional<KnownDerivableProtocolKind>\n+    ProtocolDecl::getKnownDerivableProtocolKind() const {\n+  const auto knownKind = getKnownProtocolKind();\n+  if (!knownKind)\n+      return None;\n+\n+  switch (*knownKind) {\n+  case KnownProtocolKind::RawRepresentable:\n+    return KnownDerivableProtocolKind::RawRepresentable;\n+  case KnownProtocolKind::OptionSet:\n+    return KnownDerivableProtocolKind::OptionSet;\n+  case KnownProtocolKind::CaseIterable:\n+    return KnownDerivableProtocolKind::CaseIterable;\n+  case KnownProtocolKind::Comparable:\n+    return KnownDerivableProtocolKind::Comparable;\n+  case KnownProtocolKind::Equatable:\n+    return KnownDerivableProtocolKind::Equatable;\n+  case KnownProtocolKind::Hashable:\n+    return KnownDerivableProtocolKind::Hashable;\n+  case KnownProtocolKind::BridgedNSError:\n+    return KnownDerivableProtocolKind::BridgedNSError;\n+  case KnownProtocolKind::CodingKey:\n+    return KnownDerivableProtocolKind::CodingKey;\n+  case KnownProtocolKind::Encodable:\n+    return KnownDerivableProtocolKind::Encodable;\n+  case KnownProtocolKind::Decodable:\n+    return KnownDerivableProtocolKind::Decodable;\n+  case KnownProtocolKind::AdditiveArithmetic:\n+    return KnownDerivableProtocolKind::AdditiveArithmetic;\n+  case KnownProtocolKind::Differentiable:\n+    return KnownDerivableProtocolKind::Differentiable;\n+  default: return None;\n+  }\n+}\n+\n bool ProtocolDecl::hasCircularInheritedProtocols() const {\n   auto &ctx = getASTContext();\n   auto *mutableThis = const_cast<ProtocolDecl *>(this);\n@@ -5812,13 +5850,8 @@ StaticSpellingKind AbstractStorageDecl::getCorrectStaticSpelling() const {\n }\n \n llvm::TinyPtrVector<CustomAttr *> VarDecl::getAttachedPropertyWrappers() const {\n-  auto &ctx = getASTContext();\n-  if (!ctx.areLegacySemanticQueriesEnabled()) {\n-    return { };\n-  }\n-\n   auto mutableThis = const_cast<VarDecl *>(this);\n-  return evaluateOrDefault(ctx.evaluator,\n+  return evaluateOrDefault(getASTContext().evaluator,\n                            AttachedPropertyWrappersRequest{mutableThis},\n                            { });\n }\n@@ -5830,7 +5863,7 @@ bool VarDecl::hasAttachedPropertyWrapper() const {\n \n /// Whether all of the attached property wrappers have an init(wrappedValue:)\n /// initializer.\n-bool VarDecl::allAttachedPropertyWrappersHaveInitialValueInit() const {\n+bool VarDecl::allAttachedPropertyWrappersHaveWrappedValueInit() const {\n   for (unsigned i : indices(getAttachedPropertyWrappers())) {\n     if (!getAttachedPropertyWrapperTypeInfo(i).wrappedValueInit)\n       return false;\n@@ -5935,7 +5968,26 @@ bool VarDecl::isPropertyMemberwiseInitializedWithWrappedType() const {\n \n   // If all property wrappers have a wrappedValue initializer, the property\n   // wrapper will be initialized that way.\n-  return allAttachedPropertyWrappersHaveInitialValueInit();\n+  return allAttachedPropertyWrappersHaveWrappedValueInit();\n+}\n+\n+bool VarDecl::isInnermostPropertyWrapperInitUsesEscapingAutoClosure() const {\n+  auto customAttrs = getAttachedPropertyWrappers();\n+  if (customAttrs.empty())\n+    return false;\n+\n+  unsigned innermostWrapperIndex = customAttrs.size() - 1;\n+  auto typeInfo = getAttachedPropertyWrapperTypeInfo(innermostWrapperIndex);\n+  return typeInfo.isWrappedValueInitUsingEscapingAutoClosure;\n+}\n+\n+Type VarDecl::getPropertyWrapperInitValueInterfaceType() const {\n+  Type valueInterfaceTy = getValueInterfaceType();\n+\n+  if (isInnermostPropertyWrapperInitUsesEscapingAutoClosure())\n+    return FunctionType::get({}, valueInterfaceTy);\n+\n+  return valueInterfaceTy;\n }\n \n Identifier VarDecl::getObjCPropertyName() const {\n@@ -6332,6 +6384,8 @@ Expr *swift::findOriginalPropertyWrapperInitialValue(VarDecl *var,\n         return { false, E };\n \n       if (auto call = dyn_cast<CallExpr>(E)) {\n+        ASTContext &ctx = innermostNominal->getASTContext();\n+\n         // We're looking for an implicit call.\n         if (!call->isImplicit())\n           return { true, E };\n@@ -6341,9 +6395,19 @@ Expr *swift::findOriginalPropertyWrapperInitialValue(VarDecl *var,\n         // property.\n         if (auto tuple = dyn_cast<TupleExpr>(call->getArg())) {\n           if (tuple->getNumElements() > 0) {\n-            auto elem = tuple->getElement(0);\n-            if (elem->isImplicit() && isa<CallExpr>(elem)) {\n-              return { true, E };\n+            for (unsigned i : range(tuple->getNumElements())) {\n+              if (tuple->getElementName(i) == ctx.Id_wrappedValue ||\n+                  tuple->getElementName(i) == ctx.Id_initialValue) {\n+                auto elem = tuple->getElement(i)->getSemanticsProvidingExpr();\n+\n+                // Look through autoclosures.\n+                if (auto autoclosure = dyn_cast<AutoClosureExpr>(elem))\n+                  elem = autoclosure->getSingleExpressionBody();\n+\n+                if (elem->isImplicit() && isa<CallExpr>(elem)) {\n+                  return { true, E };\n+                }\n+              }\n             }\n           }\n         }\n@@ -6356,7 +6420,6 @@ Expr *swift::findOriginalPropertyWrapperInitialValue(VarDecl *var,\n \n         // Find the implicit initialValue/wrappedValue argument.\n         if (auto tuple = dyn_cast<TupleExpr>(call->getArg())) {\n-          ASTContext &ctx = innermostNominal->getASTContext();\n           for (unsigned i : range(tuple->getNumElements())) {\n             if (tuple->getElementName(i) == ctx.Id_wrappedValue ||\n                 tuple->getElementName(i) == ctx.Id_initialValue) {\n@@ -6376,8 +6439,11 @@ Expr *swift::findOriginalPropertyWrapperInitialValue(VarDecl *var,\n   if (initArg) {\n     initArg = initArg->getSemanticsProvidingExpr();\n     if (auto autoclosure = dyn_cast<AutoClosureExpr>(initArg)) {\n-      initArg =\n-          autoclosure->getSingleExpressionBody()->getSemanticsProvidingExpr();\n+      if (!var->isInnermostPropertyWrapperInitUsesEscapingAutoClosure()) {\n+        // Remove the autoclosure part only for non-escaping autoclosures\n+        initArg =\n+            autoclosure->getSingleExpressionBody()->getSemanticsProvidingExpr();\n+      }\n     }\n   }\n   return initArg;\n@@ -6786,7 +6852,7 @@ ObjCSelector\n AbstractFunctionDecl::getObjCSelector(DeclName preferredName,\n                                       bool skipIsObjCResolution) const {\n   // FIXME: Forces computation of the Objective-C selector.\n-  if (getASTContext().areLegacySemanticQueriesEnabled() && !skipIsObjCResolution)\n+  if (!skipIsObjCResolution)\n     (void)isObjC();\n \n   // If there is an @objc attribute with a name, use that name.\n@@ -6802,7 +6868,7 @@ AbstractFunctionDecl::getObjCSelector(DeclName preferredName,\n     return destructor->getObjCSelector();\n   } else if (auto func = dyn_cast<FuncDecl>(this)) {\n     // Otherwise cast this to be able to access getName()\n-    baseNameStr = func->getName().str();\n+    baseNameStr = func->getBaseIdentifier().str();\n   } else if (isa<ConstructorDecl>(this)) {\n     baseNameStr = \"init\";\n   } else {\n@@ -7081,8 +7147,10 @@ AbstractFunctionDecl::getDerivativeFunctionConfigurations() {\n   prepareDerivativeFunctionConfigurations();\n   auto &ctx = getASTContext();\n   if (ctx.getCurrentGeneration() > DerivativeFunctionConfigGeneration) {\n-    // TODO(TF-1100): Upstream derivative function configuration serialization\n-    // logic.\n+    unsigned previousGeneration = DerivativeFunctionConfigGeneration;\n+    DerivativeFunctionConfigGeneration = ctx.getCurrentGeneration();\n+    ctx.loadDerivativeFunctionConfigurations(this, previousGeneration,\n+                                             *DerivativeFunctionConfigs);\n   }\n   return DerivativeFunctionConfigs->getArrayRef();\n }\n@@ -7308,7 +7376,8 @@ SelfAccessKind FuncDecl::getSelfAccessKind() const {\n }\n \n bool FuncDecl::isCallAsFunctionMethod() const {\n-  return getName() == getASTContext().Id_callAsFunction && isInstanceMember();\n+  return getBaseIdentifier() == getASTContext().Id_callAsFunction &&\n+         isInstanceMember();\n }\n \n ConstructorDecl::ConstructorDecl(DeclName Name, SourceLoc ConstructorLoc,\n@@ -7468,7 +7537,7 @@ LiteralExpr *EnumElementDecl::getRawValueExpr() const {\n   (void)evaluateOrDefault(\n       getASTContext().evaluator,\n       EnumRawValuesRequest{getParentEnum(), TypeResolutionStage::Interface},\n-      true);\n+      {});\n   return RawValueExpr;\n }\n \n@@ -7478,7 +7547,7 @@ LiteralExpr *EnumElementDecl::getStructuralRawValueExpr() const {\n   (void)evaluateOrDefault(\n       getASTContext().evaluator,\n       EnumRawValuesRequest{getParentEnum(), TypeResolutionStage::Structural},\n-      true);\n+      {});\n   return RawValueExpr;\n }\n \n@@ -7805,7 +7874,7 @@ PrecedenceGroupDecl *InfixOperatorDecl::getPrecedenceGroup() const {\n }\n \n bool FuncDecl::isDeferBody() const {\n-  return getName() == getASTContext().getIdentifier(\"$defer\");\n+  return getBaseIdentifier() == getASTContext().getIdentifier(\"$defer\");\n }\n \n bool FuncDecl::isPotentialIBActionTarget() const {"
                    },
                    {
                        "filename": "lib/AST/DeclContext.cpp",
                        "code": "@@ -323,7 +323,7 @@ ResilienceExpansion DeclContext::getResilienceExpansion() const {\n                            ResilienceExpansion::Minimal);\n }\n \n-llvm::Expected<ResilienceExpansion>\n+ResilienceExpansion\n swift::ResilienceExpansionRequest::evaluate(Evaluator &evaluator,\n                                             DeclContext *context) const {\n   for (const auto *dc = context->getLocalContext(); dc && dc->isLocalContext();"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -984,16 +984,15 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n     info->ChildDiagnosticInfo = childInfoPtrs;\n     \n     SmallVector<std::string, 1> educationalNotePaths;\n-    if (useEducationalNotes) {\n-      auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n-      while (associatedNotes && *associatedNotes) {\n-        SmallString<128> notePath(getDiagnosticDocumentationPath());\n-        llvm::sys::path::append(notePath, *associatedNotes);\n-        educationalNotePaths.push_back(notePath.str().str());\n-        associatedNotes++;\n-      }\n-      info->EducationalNotePaths = educationalNotePaths;\n+\n+    auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n+    while (associatedNotes && *associatedNotes) {\n+      SmallString<128> notePath(getDiagnosticDocumentationPath());\n+      llvm::sys::path::append(notePath, *associatedNotes);\n+      educationalNotePaths.push_back(notePath.str().str());\n+      associatedNotes++;\n     }\n+    info->EducationalNotePaths = educationalNotePaths;\n \n     for (auto &consumer : Consumers) {\n       consumer->handleDiagnostic(SourceMgr, *info);"
                    },
                    {
                        "filename": "lib/AST/Expr.cpp",
                        "code": "@@ -349,6 +349,11 @@ ConcreteDeclRef Expr::getReferencedDecl(bool stopAtParenExpr) const {\n   PASS_THROUGH_REFERENCE(PointerToPointer, getSubExpr);\n   PASS_THROUGH_REFERENCE(ForeignObjectConversion, getSubExpr);\n   PASS_THROUGH_REFERENCE(UnevaluatedInstance, getSubExpr);\n+  PASS_THROUGH_REFERENCE(DifferentiableFunction, getSubExpr);\n+  PASS_THROUGH_REFERENCE(LinearFunction, getSubExpr);\n+  PASS_THROUGH_REFERENCE(DifferentiableFunctionExtractOriginal, getSubExpr);\n+  PASS_THROUGH_REFERENCE(LinearFunctionExtractOriginal, getSubExpr);\n+  PASS_THROUGH_REFERENCE(LinearToDifferentiableFunction, getSubExpr);\n   PASS_THROUGH_REFERENCE(BridgeToObjC, getSubExpr);\n   PASS_THROUGH_REFERENCE(BridgeFromObjC, getSubExpr);\n   PASS_THROUGH_REFERENCE(ConditionalBridgeFromObjC, getSubExpr);\n@@ -667,6 +672,11 @@ bool Expr::canAppendPostfixExpression(bool appendingPostfixOperator) const {\n   case ExprKind::PointerToPointer:\n   case ExprKind::ForeignObjectConversion:\n   case ExprKind::UnevaluatedInstance:\n+  case ExprKind::DifferentiableFunction:\n+  case ExprKind::LinearFunction:\n+  case ExprKind::DifferentiableFunctionExtractOriginal:\n+  case ExprKind::LinearFunctionExtractOriginal:\n+  case ExprKind::LinearToDifferentiableFunction:\n   case ExprKind::EnumIsCase:\n   case ExprKind::ConditionalBridgeFromObjC:\n   case ExprKind::BridgeFromObjC:"
                    },
                    {
                        "filename": "lib/AST/FrontendSourceFileDepGraphFactory.cpp",
                        "code": "@@ -59,10 +59,6 @@ template <typename DeclT> static std::string getBaseName(const DeclT *decl) {\n   return decl->getBaseName().userFacingName().str();\n }\n \n-template <typename DeclT> static std::string getName(const DeclT *decl) {\n-  return DeclBaseName(decl->getName()).userFacingName().str();\n-}\n-\n static std::string mangleTypeAsContext(const NominalTypeDecl *NTD) {\n   Mangle::ASTMangler Mangler;\n   return !NTD ? \"\" : Mangler.mangleTypeAsContextUSR(NTD);\n@@ -188,22 +184,22 @@ std::string\n DependencyKey::computeNameForProvidedEntity<NodeKind::topLevel,\n                                             PrecedenceGroupDecl const *>(\n     const PrecedenceGroupDecl *D) {\n-  return ::getName(D);\n+  return D->getName().str().str();\n }\n template <>\n std::string DependencyKey::computeNameForProvidedEntity<\n     NodeKind::topLevel, FuncDecl const *>(const FuncDecl *D) {\n-  return ::getName(D);\n+  return getBaseName(D);\n }\n template <>\n std::string DependencyKey::computeNameForProvidedEntity<\n     NodeKind::topLevel, OperatorDecl const *>(const OperatorDecl *D) {\n-  return ::getName(D);\n+  return D->getName().str().str();\n }\n template <>\n std::string DependencyKey::computeNameForProvidedEntity<\n     NodeKind::topLevel, NominalTypeDecl const *>(const NominalTypeDecl *D) {\n-  return ::getName(D);\n+  return D->getName().str().str();\n }\n template <>\n std::string DependencyKey::computeNameForProvidedEntity<\n@@ -282,7 +278,8 @@ DependencyKey DependencyKey::createDependedUponKey(StringRef mangledHolderName,\n \n bool fine_grained_dependencies::emitReferenceDependencies(\n     DiagnosticEngine &diags, SourceFile *const SF,\n-    const DependencyTracker &depTracker, StringRef outputPath,\n+    const DependencyTracker &depTracker,\n+    StringRef outputPath,\n     const bool alsoEmitDotFile) {\n \n   // Before writing to the dependencies file path, preserve any previous file\n@@ -292,7 +289,7 @@ bool fine_grained_dependencies::emitReferenceDependencies(\n \n   SourceFileDepGraph g = FrontendSourceFileDepGraphFactory(\n                              SF, outputPath, depTracker, alsoEmitDotFile)\n-                             .construct();\n+                              .construct();\n \n   const bool hadError =\n       withOutputFile(diags, outputPath, [&](llvm::raw_pwrite_stream &out) {\n@@ -563,7 +560,7 @@ void FrontendSourceFileDepGraphFactory::addAllUsedDecls() {\n       DependencyKey::createKeyForWholeSourceFile(DeclAspect::implementation,\n                                                  swiftDeps);\n \n-  SF->getReferencedNameTracker()->enumerateAllUses(\n+  SF->getConfiguredReferencedNameTracker()->enumerateAllUses(\n       includePrivateDeps, depTracker,\n       [&](const fine_grained_dependencies::NodeKind kind, StringRef context,\n           StringRef name, const bool isCascadingUse) {"
                    },
                    {
                        "filename": "lib/AST/GenericSignatureBuilder.cpp",
                        "code": "@@ -3659,8 +3659,14 @@ ResolvedType GenericSignatureBuilder::maybeResolveEquivalenceClass(\n       // Check whether this associated type references a protocol to which\n       // the base conforms. If not, it's unresolved.\n       if (baseEquivClass->conformsTo.find(assocType->getProtocol())\n-            == baseEquivClass->conformsTo.end())\n-        return ResolvedType::forUnresolved(baseEquivClass);\n+          == baseEquivClass->conformsTo.end()) {\n+        if (!baseEquivClass->concreteType ||\n+            !lookupConformance(type->getCanonicalType(),\n+                               baseEquivClass->concreteType,\n+                               assocType->getProtocol())) {\n+          return ResolvedType::forUnresolved(baseEquivClass);\n+        }\n+      }\n \n       nestedTypeDecl = assocType;\n     } else {\n@@ -5064,6 +5070,50 @@ class GenericSignatureBuilder::InferRequirementsWalker : public TypeWalker {\n       return Action::Continue;\n     }\n \n+    // Infer requirements from `@differentiable` or `@differentiable(linear)`\n+    // function types.\n+    // For all non-`@noDerivative` parameter and result types:\n+    // - `@differentiable`: add `T: Differentiable` requirement.\n+    // - `@differentiable(linear)`: add\n+    //   `T: Differentiable`, `T == T.TangentVector` requirements.\n+    if (auto *fnTy = ty->getAs<AnyFunctionType>()) {\n+      auto &ctx = Builder.getASTContext();\n+      auto *differentiableProtocol =\n+          ctx.getProtocol(KnownProtocolKind::Differentiable);\n+      if (differentiableProtocol && fnTy->isDifferentiable()) {\n+        auto addConformanceConstraint = [&](Type type, ProtocolDecl *protocol) {\n+          Requirement req(RequirementKind::Conformance, type,\n+                          protocol->getDeclaredType());\n+          Builder.addRequirement(req, source, nullptr);\n+        };\n+        auto addSameTypeConstraint = [&](Type firstType,\n+                                         AssociatedTypeDecl *assocType) {\n+          auto *protocol = assocType->getProtocol();\n+          auto conf = Builder.lookupConformance(CanType(), firstType, protocol);\n+          auto secondType = conf.getAssociatedType(\n+              firstType, assocType->getDeclaredInterfaceType());\n+          Requirement req(RequirementKind::SameType, firstType, secondType);\n+          Builder.addRequirement(req, source, nullptr);\n+        };\n+        auto *tangentVectorAssocType =\n+            differentiableProtocol->getAssociatedType(ctx.Id_TangentVector);\n+        auto addRequirements = [&](Type type, bool isLinear) {\n+          addConformanceConstraint(type, differentiableProtocol);\n+          if (isLinear)\n+            addSameTypeConstraint(type, tangentVectorAssocType);\n+        };\n+        auto constrainParametersAndResult = [&](bool isLinear) {\n+          for (auto &param : fnTy->getParams())\n+            if (!param.isNoDerivative())\n+              addRequirements(param.getPlainType(), isLinear);\n+          addRequirements(fnTy->getResult(), isLinear);\n+        };\n+        // Add requirements.\n+        constrainParametersAndResult(fnTy->getDifferentiabilityKind() ==\n+                                     DifferentiabilityKind::Linear);\n+      }\n+    }\n+\n     if (!ty->isSpecialized())\n       return Action::Continue;\n \n@@ -7342,7 +7392,7 @@ static bool isCanonicalRequest(GenericSignature baseSignature,\n   return true;\n }\n \n-llvm::Expected<GenericSignature>\n+GenericSignature\n AbstractGenericSignatureRequest::evaluate(\n          Evaluator &evaluator,\n          GenericSignatureImpl *baseSignature,\n@@ -7400,7 +7450,7 @@ AbstractGenericSignatureRequest::evaluate(\n           canBaseSignature.getPointer(), std::move(canAddedParameters),\n           std::move(canAddedRequirements)});\n     if (!canSignatureResult || !*canSignatureResult)\n-      return canSignatureResult;\n+      return GenericSignature();\n \n     // Substitute in the original generic parameters to form a more-sugared\n     // result closer to what the original request wanted. Note that this\n@@ -7455,7 +7505,7 @@ AbstractGenericSignatureRequest::evaluate(\n       SourceLoc(), /*allowConcreteGenericParams=*/true);\n }\n \n-llvm::Expected<GenericSignature>\n+GenericSignature\n InferredGenericSignatureRequest::evaluate(\n         Evaluator &evaluator, ModuleDecl *parentModule,\n         GenericSignatureImpl *parentSig,"
                    },
                    {
                        "filename": "lib/AST/Module.cpp",
                        "code": "@@ -15,11 +15,11 @@\n //===----------------------------------------------------------------------===//\n \n #include \"swift/AST/Module.h\"\n-#include \"swift/AST/AccessScope.h\"\n #include \"swift/AST/ASTContext.h\"\n #include \"swift/AST/ASTMangler.h\"\n #include \"swift/AST/ASTPrinter.h\"\n #include \"swift/AST/ASTWalker.h\"\n+#include \"swift/AST/AccessScope.h\"\n #include \"swift/AST/Builtins.h\"\n #include \"swift/AST/ClangModuleLoader.h\"\n #include \"swift/AST/DiagnosticsSema.h\"\n@@ -31,11 +31,12 @@\n #include \"swift/AST/LinkLibrary.h\"\n #include \"swift/AST/ModuleLoader.h\"\n #include \"swift/AST/NameLookup.h\"\n-#include \"swift/AST/ReferencedNameTracker.h\"\n+#include \"swift/AST/NameLookupRequests.h\"\n #include \"swift/AST/ParseRequests.h\"\n #include \"swift/AST/PrettyStackTrace.h\"\n #include \"swift/AST/PrintOptions.h\"\n #include \"swift/AST/ProtocolConformance.h\"\n+#include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/SourceFile.h\"\n #include \"swift/AST/TypeCheckRequests.h\"\n #include \"swift/Basic/Compiler.h\"\n@@ -48,15 +49,15 @@\n #include \"clang/Basic/Module.h\"\n #include \"llvm/ADT/DenseMap.h\"\n #include \"llvm/ADT/DenseSet.h\"\n-#include \"llvm/ADT/TinyPtrVector.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n #include \"llvm/ADT/SmallPtrSet.h\"\n #include \"llvm/ADT/StringExtras.h\"\n-#include \"llvm/ADT/STLExtras.h\"\n+#include \"llvm/ADT/TinyPtrVector.h\"\n #include \"llvm/Support/MD5.h\"\n #include \"llvm/Support/MemoryBuffer.h\"\n #include \"llvm/Support/Path.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Support/SaveAndRestore.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n \n using namespace swift;\n \n@@ -135,8 +136,8 @@ SourceFile::~SourceFile() = default;\n class swift::SourceLookupCache {\n   /// A lookup map for value decls. When declarations are added they are added\n   /// under all variants of the name they can be found under.\n-  class DeclMap {\n-    llvm::DenseMap<DeclName, TinyPtrVector<ValueDecl*>> Members;\n+  class ValueDeclMap {\n+    llvm::DenseMap<DeclName, TinyPtrVector<ValueDecl *>> Members;\n \n   public:\n     void add(ValueDecl *VD) {\n@@ -155,10 +156,15 @@ class swift::SourceLookupCache {\n     }\n   };\n \n-  DeclMap TopLevelValues;\n-  DeclMap ClassMembers;\n+  ValueDeclMap TopLevelValues;\n+  ValueDeclMap ClassMembers;\n   bool MemberCachePopulated = false;\n \n+  template<typename T>\n+  using OperatorMap = llvm::DenseMap<Identifier, TinyPtrVector<T *>>;\n+  OperatorMap<OperatorDecl> Operators;\n+  OperatorMap<PrecedenceGroupDecl> PrecedenceGroups;\n+\n   template<typename Range>\n   void addToUnqualifiedLookupCache(Range decls, bool onlyOperators);\n   template<typename Range>\n@@ -174,7 +180,28 @@ class swift::SourceLookupCache {\n   \n   void lookupValue(DeclName Name, NLKind LookupKind,\n                    SmallVectorImpl<ValueDecl*> &Result);\n-  \n+\n+  /// Retrieves all the operator decls. The order of the results is not\n+  /// guaranteed to be meaningful.\n+  void getOperatorDecls(SmallVectorImpl<OperatorDecl *> &results);\n+\n+  /// Retrieves all the precedence groups. The order of the results is not\n+  /// guaranteed to be meaningful.\n+  void getPrecedenceGroups(SmallVectorImpl<PrecedenceGroupDecl *> &results);\n+\n+  /// Look up an operator declaration.\n+  ///\n+  /// \\param name The operator name (\"+\", \">>\", etc.)\n+  /// \\param fixity The fixity of the operator (infix, prefix or postfix).\n+  void lookupOperator(Identifier name, OperatorFixity fixity,\n+                      TinyPtrVector<OperatorDecl *> &results);\n+\n+  /// Look up a precedence group.\n+  ///\n+  /// \\param name The operator name (\"+\", \">>\", etc.)\n+  void lookupPrecedenceGroup(Identifier name,\n+                             TinyPtrVector<PrecedenceGroupDecl *> &results);\n+\n   void lookupVisibleDecls(AccessPathTy AccessPath,\n                           VisibleDeclConsumer &Consumer,\n                           NLKind LookupKind);\n@@ -223,6 +250,12 @@ void SourceLookupCache::addToUnqualifiedLookupCache(Range decls,\n       if (!ED->hasUnparsedMembers() || ED->maybeHasOperatorDeclarations())\n         addToUnqualifiedLookupCache(ED->getMembers(), true);\n     }\n+\n+    if (auto *OD = dyn_cast<OperatorDecl>(D))\n+      Operators[OD->getName()].push_back(OD);\n+\n+    if (auto *PG = dyn_cast<PrecedenceGroupDecl>(D))\n+      PrecedenceGroups[PG->getName()].push_back(PG);\n   }\n }\n \n@@ -299,6 +332,39 @@ void SourceLookupCache::lookupValue(DeclName Name, NLKind LookupKind,\n     Result.push_back(Elt);\n }\n \n+void SourceLookupCache::getPrecedenceGroups(\n+    SmallVectorImpl<PrecedenceGroupDecl *> &results) {\n+  for (auto &groups : PrecedenceGroups)\n+    results.append(groups.second.begin(), groups.second.end());\n+}\n+\n+void SourceLookupCache::getOperatorDecls(\n+    SmallVectorImpl<OperatorDecl *> &results) {\n+  for (auto &ops : Operators)\n+    results.append(ops.second.begin(), ops.second.end());\n+}\n+\n+void SourceLookupCache::lookupOperator(Identifier name, OperatorFixity fixity,\n+                                       TinyPtrVector<OperatorDecl *> &results) {\n+  auto ops = Operators.find(name);\n+  if (ops == Operators.end())\n+    return;\n+\n+  for (auto *op : ops->second)\n+    if (op->getFixity() == fixity)\n+      results.push_back(op);\n+}\n+\n+void SourceLookupCache::lookupPrecedenceGroup(\n+    Identifier name, TinyPtrVector<PrecedenceGroupDecl *> &results) {\n+  auto groups = PrecedenceGroups.find(name);\n+  if (groups == PrecedenceGroups.end())\n+    return;\n+\n+  for (auto *group : groups->second)\n+    results.push_back(group);\n+}\n+\n void SourceLookupCache::lookupVisibleDecls(AccessPathTy AccessPath,\n                                            VisibleDeclConsumer &Consumer,\n                                            NLKind LookupKind) {\n@@ -679,18 +745,36 @@ void SourceFile::getTopLevelDecls(SmallVectorImpl<Decl*> &Results) const {\n   Results.append(decls.begin(), decls.end());\n }\n \n+void ModuleDecl::getOperatorDecls(\n+    SmallVectorImpl<OperatorDecl *> &results) const {\n+  // For a parsed module, we can check the source cache on the module rather\n+  // than doing an O(N) search over the source files.\n+  if (isParsedModule(this)) {\n+    getSourceLookupCache().getOperatorDecls(results);\n+    return;\n+  }\n+  FORWARD(getOperatorDecls, (results));\n+}\n+\n+void SourceFile::getOperatorDecls(\n+       SmallVectorImpl<OperatorDecl*> &results) const {\n+  getCache().getOperatorDecls(results);\n+}\n+\n void ModuleDecl::getPrecedenceGroups(\n-       SmallVectorImpl<PrecedenceGroupDecl*> &Results) const {\n-  FORWARD(getPrecedenceGroups, (Results));\n+       SmallVectorImpl<PrecedenceGroupDecl*> &results) const {\n+  // For a parsed module, we can check the source cache on the module rather\n+  // than doing an O(N) search over the source files.\n+  if (isParsedModule(this)) {\n+    getSourceLookupCache().getPrecedenceGroups(results);\n+    return;\n+  }\n+  FORWARD(getPrecedenceGroups, (results));\n }\n \n void SourceFile::getPrecedenceGroups(\n-       SmallVectorImpl<PrecedenceGroupDecl*> &Results) const {\n-  for (auto pair : PrecedenceGroups) {\n-    if (pair.second.getPointer() && pair.second.getInt()) {\n-      Results.push_back(pair.second.getPointer());\n-    }\n-  }\n+       SmallVectorImpl<PrecedenceGroupDecl*> &results) const {\n+  getCache().getPrecedenceGroups(results);\n }\n \n void SourceFile::getLocalTypeDecls(SmallVectorImpl<TypeDecl*> &Results) const {\n@@ -820,7 +904,19 @@ ModuleDecl::lookupExistentialConformance(Type type, ProtocolDecl *protocol) {\n \n ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n                                                      ProtocolDecl *protocol) {\n-  ASTContext &ctx = getASTContext();\n+  return evaluateOrDefault(\n+      getASTContext().evaluator,\n+      LookupConformanceInModuleRequest{{this, type, protocol}},\n+      ProtocolConformanceRef::forInvalid());\n+}\n+\n+ProtocolConformanceRef\n+LookupConformanceInModuleRequest::evaluate(\n+    Evaluator &evaluator, LookupConformanceDescriptor desc) const {\n+  auto *mod = desc.Mod;\n+  auto type = desc.Ty;\n+  auto protocol = desc.PD;\n+  ASTContext &ctx = mod->getASTContext();\n \n   // A dynamic Self type conforms to whatever its underlying type\n   // conforms to.\n@@ -838,7 +934,7 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n     // able to be resolved by a substitution that makes the archetype\n     // concrete.\n     if (auto super = archetype->getSuperclass()) {\n-      if (auto inheritedConformance = lookupConformance(super, protocol)) {\n+      if (auto inheritedConformance = mod->lookupConformance(super, protocol)) {\n         return ProtocolConformanceRef(ctx.getInheritedConformance(\n             type, inheritedConformance.getConcrete()));\n       }\n@@ -856,7 +952,7 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n   // existential's list of conformances and the existential conforms to\n   // itself.\n   if (type->isExistentialType())\n-    return lookupExistentialConformance(type, protocol);\n+    return mod->lookupExistentialConformance(type, protocol);\n \n   // Type variables have trivial conformances.\n   if (type->isTypeVariableOrMember())\n@@ -876,7 +972,7 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n \n   // Find the (unspecialized) conformance.\n   SmallVector<ProtocolConformance *, 2> conformances;\n-  if (!nominal->lookupConformance(this, protocol, conformances))\n+  if (!nominal->lookupConformance(mod, protocol, conformances))\n     return ProtocolConformanceRef::forInvalid();\n \n   // FIXME: Ambiguity resolution.\n@@ -896,7 +992,7 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n     auto superclassTy = type->getSuperclassForDecl(conformingClass);\n \n     // Compute the conformance for the inherited type.\n-    auto inheritedConformance = lookupConformance(superclassTy, protocol);\n+    auto inheritedConformance = mod->lookupConformance(superclassTy, protocol);\n     assert(inheritedConformance &&\n            \"We already found the inherited conformance\");\n \n@@ -917,7 +1013,7 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n     if (!explicitConformanceType->isEqual(type)) {\n       // Gather the substitutions we need to map the generic conformance to\n       // the specialized conformance.\n-      auto subMap = type->getContextSubstitutionMap(this, explicitConformanceDC);\n+      auto subMap = type->getContextSubstitutionMap(mod, explicitConformanceDC);\n \n       // Create the specialized conformance entry.\n       auto result = ctx.getSpecializedConformance(type, conformance, subMap);\n@@ -930,9 +1026,6 @@ ProtocolConformanceRef ModuleDecl::lookupConformance(Type type,\n }\n \n namespace {\n-  template <typename T>\n-  using OperatorMap = SourceFile::OperatorMap<T>;\n-\n   template <typename T>\n   struct OperatorLookup {\n     // Don't fold this into the static_assert: this would trigger an MSVC bug\n@@ -943,36 +1036,47 @@ namespace {\n \n   template <>\n   struct OperatorLookup<PrefixOperatorDecl> {\n-    template <typename T>\n-    static PrefixOperatorDecl *lookup(T &container, Identifier name) {\n-      return cast_or_null<PrefixOperatorDecl>(\n-               container.lookupOperator(name, DeclKind::PrefixOperator));\n+    static PrefixOperatorDecl *lookup(Evaluator &eval,\n+                                      const OperatorLookupDescriptor &desc) {\n+      // We can return the first prefix operator. All prefix operators of the\n+      // same name are equivalent.\n+      DirectOperatorLookupRequest req{desc, OperatorFixity::Prefix};\n+      auto results = evaluateOrDefault(eval, req, {});\n+      return results.empty() ? nullptr : cast<PrefixOperatorDecl>(results[0]);\n     }\n   };\n \n   template <>\n   struct OperatorLookup<InfixOperatorDecl> {\n-    template <typename T>\n-    static InfixOperatorDecl *lookup(T &container, Identifier name) {\n-      return cast_or_null<InfixOperatorDecl>(\n-               container.lookupOperator(name, DeclKind::InfixOperator));\n+    static InfixOperatorDecl *lookup(Evaluator &eval,\n+                                     const OperatorLookupDescriptor &desc) {\n+      // Return the first result if it exists.\n+      DirectOperatorLookupRequest req{desc, OperatorFixity::Infix};\n+      auto results = evaluateOrDefault(eval, req, {});\n+      return results.empty() ? nullptr : cast<InfixOperatorDecl>(results[0]);\n     }\n   };\n \n   template <>\n   struct OperatorLookup<PostfixOperatorDecl> {\n-    template <typename T>\n-    static PostfixOperatorDecl *lookup(T &container, Identifier name) {\n-      return cast_or_null<PostfixOperatorDecl>(\n-               container.lookupOperator(name, DeclKind::PostfixOperator));\n+    static PostfixOperatorDecl *lookup(Evaluator &eval,\n+                                       const OperatorLookupDescriptor &desc) {\n+      // We can return the first postfix operator. All postfix operators of the\n+      // same name are equivalent.\n+      DirectOperatorLookupRequest req{desc, OperatorFixity::Postfix};\n+      auto results = evaluateOrDefault(eval, req, {});\n+      return results.empty() ? nullptr : cast<PostfixOperatorDecl>(results[0]);\n     }\n   };\n \n   template <>\n   struct OperatorLookup<PrecedenceGroupDecl> {\n-    template <typename T>\n-    static PrecedenceGroupDecl *lookup(T &container, Identifier name) {\n-      return container.lookupPrecedenceGroup(name);\n+    static PrecedenceGroupDecl *lookup(Evaluator &eval,\n+                                       const OperatorLookupDescriptor &desc) {\n+      // Return the first result if it exists.\n+      auto results =\n+          evaluateOrDefault(eval, DirectPrecedenceGroupLookupRequest{desc}, {});\n+      return results.empty() ? nullptr : results[0];\n     }\n   };\n } // end anonymous namespace\n@@ -1010,7 +1114,7 @@ void SourceFile::setSyntaxRoot(syntax::SourceFileSyntax &&Root) {\n template<typename OP_DECL>\n static Optional<OP_DECL *>\n lookupOperatorDeclForName(ModuleDecl *M, SourceLoc Loc, Identifier Name,\n-                          OperatorMap<OP_DECL *> SourceFile::*OP_MAP);\n+                          bool isCascading);\n \n template<typename OP_DECL>\n using ImportedOperatorsMap = llvm::SmallDenseMap<OP_DECL*, bool, 16>;\n@@ -1027,9 +1131,8 @@ checkOperatorConflicts(const SourceFile &SF, SourceLoc loc,\n       if (loc.isValid()) {\n         ASTContext &C = SF.getASTContext();\n         C.Diags.diagnose(loc, diag::ambiguous_operator_decls);\n-        C.Diags.diagnose(start->first->getLoc(),\n-                         diag::found_this_operator_decl);\n-        C.Diags.diagnose(i->first->getLoc(), diag::found_this_operator_decl);\n+        start->first->diagnose(diag::found_this_operator_decl);\n+        i->first->diagnose(diag::found_this_operator_decl);\n       }\n       return end;\n     }\n@@ -1049,21 +1152,23 @@ checkOperatorConflicts(const SourceFile &SF, SourceLoc loc,\n     ASTContext &C = SF.getASTContext();\n     C.Diags.diagnose(loc, diag::ambiguous_precedence_groups);\n     for (auto &entry : importedGroups) {\n-      C.Diags.diagnose(entry.first->getLoc(),\n-                       diag::found_this_precedence_group);\n+      entry.first->diagnose(diag::found_this_precedence_group);\n     }\n   }\n   return importedGroups.end();\n }\n \n // Returns None on error, Optional(nullptr) if no operator decl found, or\n // Optional(decl) if decl was found.\n-template<typename OP_DECL>\n+template <typename OP_DECL>\n static Optional<OP_DECL *>\n-lookupOperatorDeclForName(const FileUnit &File, SourceLoc Loc, Identifier Name,\n-                          bool includePrivate,\n-                          OperatorMap<OP_DECL *> SourceFile::*OP_MAP)\n-{\n+lookupOperatorDeclForName(const FileUnit &File, SourceLoc Loc,\n+                          Identifier Name, bool includePrivate,\n+                          bool isCascading) {\n+  auto &eval = File.getASTContext().evaluator;\n+  auto desc = OperatorLookupDescriptor::forFile(const_cast<FileUnit *>(&File),\n+                                                Name, isCascading,\n+                                                /*diagLoc*/ SourceLoc());\n   switch (File.getKind()) {\n   case FileUnitKind::Builtin:\n     // The Builtin module declares no operators.\n@@ -1073,16 +1178,15 @@ lookupOperatorDeclForName(const FileUnit &File, SourceLoc Loc, Identifier Name,\n   case FileUnitKind::SerializedAST:\n   case FileUnitKind::ClangModule:\n   case FileUnitKind::DWARFModule:\n-    return OperatorLookup<OP_DECL>::lookup(cast<LoadedFile>(File), Name);\n+    return OperatorLookup<OP_DECL>::lookup(eval, desc);\n   }\n \n   auto &SF = cast<SourceFile>(File);\n-  assert(SF.ASTStage >= SourceFile::NameBound);\n+  assert(SF.ASTStage >= SourceFile::ImportsResolved);\n \n-  // Look for an operator declaration in the current module.\n-  auto found = (SF.*OP_MAP).find(Name);\n-  if (found != (SF.*OP_MAP).end() && (includePrivate || found->second.getInt()))\n-    return found->second.getPointer();\n+  // Check if the decl exists on the file.\n+  if (auto *op = OperatorLookup<OP_DECL>::lookup(eval, desc))\n+    return op;\n \n   // Look for imported operator decls.\n   // Record whether they come from re-exported modules.\n@@ -1101,32 +1205,25 @@ lookupOperatorDeclForName(const FileUnit &File, SourceLoc Loc, Identifier Name,\n       continue;\n \n     Optional<OP_DECL *> maybeOp =\n-        lookupOperatorDeclForName(imported.module.second, Loc, Name, OP_MAP);\n+        lookupOperatorDeclForName<OP_DECL>(imported.module.second, Loc, Name,\n+                                           isCascading);\n     if (!maybeOp)\n       return None;\n     \n     if (OP_DECL *op = *maybeOp)\n       importedOperators[op] |= isExported;\n   }\n \n-  typename OperatorMap<OP_DECL *>::mapped_type result = { nullptr, true };\n-  \n+  llvm::PointerIntPair<OP_DECL *, 1, /*isPrivate*/ bool> result = {nullptr,\n+                                                                   true};\n+\n   if (!importedOperators.empty()) {\n     auto start = checkOperatorConflicts(SF, Loc, importedOperators);\n     if (start == importedOperators.end())\n       return None;\n     result = { start->first, start->second };\n   }\n \n-  if (includePrivate) {\n-    // Cache the mapping so we don't need to troll imports next time.\n-    // It's not safe to cache the non-private results because we didn't search\n-    // private imports there, but in most non-private cases the result will\n-    // be cached in the final lookup.\n-    auto &mutableOpMap = const_cast<OperatorMap<OP_DECL *> &>(SF.*OP_MAP);\n-    mutableOpMap[Name] = result;\n-  }\n-\n   if (includePrivate || result.getInt())\n     return result.getPointer();\n   return nullptr;\n@@ -1135,11 +1232,11 @@ lookupOperatorDeclForName(const FileUnit &File, SourceLoc Loc, Identifier Name,\n template<typename OP_DECL>\n static Optional<OP_DECL *>\n lookupOperatorDeclForName(ModuleDecl *M, SourceLoc Loc, Identifier Name,\n-                          OperatorMap<OP_DECL *> SourceFile::*OP_MAP)\n-{\n+                          bool isCascading) {\n   OP_DECL *result = nullptr;\n   for (const FileUnit *File : M->getFiles()) {\n-    auto next = lookupOperatorDeclForName(*File, Loc, Name, false, OP_MAP);\n+    auto next = lookupOperatorDeclForName<OP_DECL>(*File, Loc, Name, false,\n+                                                   isCascading);\n     if (!next.hasValue())\n       return next;\n \n@@ -1152,38 +1249,129 @@ lookupOperatorDeclForName(ModuleDecl *M, SourceLoc Loc, Identifier Name,\n   return result;\n }\n \n-#define LOOKUP_OPERATOR(Kind) \\\n-Kind##Decl * \\\n-ModuleDecl::lookup##Kind(Identifier name, SourceLoc loc) { \\\n-  auto result = lookupOperatorDeclForName(this, loc, name, \\\n-                                          &SourceFile::Kind##s); \\\n-  return result ? *result : nullptr; \\\n-} \\\n-Kind##Decl * \\\n-SourceFile::lookup##Kind(Identifier name, bool isCascading, SourceLoc loc) { \\\n-  auto result = lookupOperatorDeclForName(*this, loc, name, true, \\\n-                                          &SourceFile::Kind##s); \\\n-  if (!result.hasValue()) \\\n-    return nullptr; \\\n-  if (ReferencedNames) {\\\n-    if (!result.getValue() || \\\n-        result.getValue()->getDeclContext()->getModuleScopeContext() != this) {\\\n-      ReferencedNames->addTopLevelName(name, isCascading); \\\n-    } \\\n-  } \\\n-  if (!result.getValue()) { \\\n-    result = lookupOperatorDeclForName(getParentModule(), loc, name, \\\n-                                       &SourceFile::Kind##s); \\\n-  } \\\n-  return result.hasValue() ? result.getValue() : nullptr; \\\n+template <typename OperatorType>\n+OperatorType *LookupOperatorRequest<OperatorType>::evaluate(\n+    Evaluator &evaluator, OperatorLookupDescriptor desc) const {\n+  auto *file = desc.fileOrModule.get<FileUnit *>();\n+  auto result =\n+      lookupOperatorDeclForName<OperatorType>(*file, desc.diagLoc, desc.name,\n+                                              /*includePrivate*/ true,\n+                                              desc.isCascading);\n+  if (!result.hasValue())\n+    return nullptr;\n+\n+  if (!result.getValue() ||\n+      result.getValue()->getDeclContext()->getModuleScopeContext() != file) {\n+    namelookup::recordLookupOfTopLevelName(file, desc.name, desc.isCascading);\n+  }\n+  if (!result.getValue()) {\n+    result = lookupOperatorDeclForName<OperatorType>(file->getParentModule(),\n+                                                     desc.diagLoc, desc.name,\n+                                                     desc.isCascading);\n+  }\n+  return result.hasValue() ? result.getValue() : nullptr;\n }\n \n+template <typename OperatorType>\n+void LookupOperatorRequest<OperatorType>::writeDependencySink(\n+    Evaluator &evaluator, ReferencedNameTracker &reqTracker,\n+    OperatorType *o) const {\n+  auto &desc = std::get<0>(this->getStorage());\n+  auto *FU = desc.fileOrModule.template get<FileUnit *>();\n+  auto shouldRegisterDependencyEdge = [&FU](OperatorType *o) -> bool {\n+    if (!o)\n+      return true;\n+\n+    auto *topLevelContext = o->getDeclContext()->getModuleScopeContext();\n+    return topLevelContext != FU;\n+  };\n+\n+  // FIXME(Evaluator Incremental Dependencies): This is all needlessly complex.\n+  // For one, it does not take into account the fact that precedence groups can\n+  // be shadowed, and so should be registered regardless of their defining\n+  // module. Second, lookups for operators within the file define a valid named\n+  // dependency just as much as lookups outside of the current source file.\n+  if (!shouldRegisterDependencyEdge(o)) {\n+    return;\n+  }\n+\n+  reqTracker.addTopLevelName(desc.name, desc.isCascading);\n+}\n+\n+#define LOOKUP_OPERATOR(Kind)                                                  \\\n+  Kind##Decl *ModuleDecl::lookup##Kind(Identifier name, SourceLoc loc) {       \\\n+    auto result =                                                              \\\n+        lookupOperatorDeclForName<Kind##Decl>(this, loc, name,                 \\\n+                                              /*isCascading*/ false);          \\\n+    return result ? *result : nullptr;                                         \\\n+  }                                                                            \\\n+  template Kind##Decl *                                                        \\\n+  LookupOperatorRequest<Kind##Decl>::evaluate(Evaluator &e,                    \\\n+                                              OperatorLookupDescriptor) const; \\\n+  template                                                                     \\\n+  void LookupOperatorRequest<Kind##Decl>::writeDependencySink(                 \\\n+           Evaluator &, ReferencedNameTracker &, Kind##Decl *) const;          \\\n+\n LOOKUP_OPERATOR(PrefixOperator)\n LOOKUP_OPERATOR(InfixOperator)\n LOOKUP_OPERATOR(PostfixOperator)\n LOOKUP_OPERATOR(PrecedenceGroup)\n #undef LOOKUP_OPERATOR\n \n+TinyPtrVector<OperatorDecl *>\n+DirectOperatorLookupRequest::evaluate(Evaluator &evaluator,\n+                                      OperatorLookupDescriptor descriptor,\n+                                      OperatorFixity fixity) const {\n+  // For a parsed module, we can check the source cache on the module rather\n+  // than doing an O(N) search over the source files.\n+  TinyPtrVector<OperatorDecl *> results;\n+  if (auto module = descriptor.getModule()) {\n+    if (isParsedModule(module)) {\n+      module->getSourceLookupCache().lookupOperator(descriptor.name, fixity,\n+                                                    results);\n+      return results;\n+    }\n+  }\n+\n+  // Otherwise query each file.\n+  for (auto *file : descriptor.getFiles())\n+    file->lookupOperatorDirect(descriptor.name, fixity, results);\n+\n+  return results;\n+}\n+\n+void SourceFile::lookupOperatorDirect(\n+    Identifier name, OperatorFixity fixity,\n+    TinyPtrVector<OperatorDecl *> &results) const {\n+  getCache().lookupOperator(name, fixity, results);\n+}\n+\n+TinyPtrVector<PrecedenceGroupDecl *>\n+DirectPrecedenceGroupLookupRequest::evaluate(\n+    Evaluator &evaluator, OperatorLookupDescriptor descriptor) const {\n+  // For a parsed module, we can check the source cache on the module rather\n+  // than doing an O(N) search over the source files.\n+  TinyPtrVector<PrecedenceGroupDecl *> results;\n+  if (auto module = descriptor.getModule()) {\n+    if (isParsedModule(module)) {\n+      module->getSourceLookupCache().lookupPrecedenceGroup(descriptor.name,\n+                                                           results);\n+      return results;\n+    }\n+  }\n+\n+  // Otherwise query each file.\n+  for (auto *file : descriptor.getFiles())\n+    file->lookupPrecedenceGroupDirect(descriptor.name, results);\n+\n+  return results;\n+}\n+\n+void SourceFile::lookupPrecedenceGroupDirect(\n+    Identifier name, TinyPtrVector<PrecedenceGroupDecl *> &results) const {\n+  getCache().lookupPrecedenceGroup(name, results);\n+}\n+\n void ModuleDecl::getImportedModules(SmallVectorImpl<ImportedModule> &modules,\n                                     ModuleDecl::ImportFilter filter) const {\n   FORWARD(getImportedModules, (modules, filter));\n@@ -1192,14 +1380,14 @@ void ModuleDecl::getImportedModules(SmallVectorImpl<ImportedModule> &modules,\n void\n SourceFile::getImportedModules(SmallVectorImpl<ModuleDecl::ImportedModule> &modules,\n                                ModuleDecl::ImportFilter filter) const {\n-  // FIXME: Ideally we should assert that the file has been name bound before\n-  // calling this function. However unfortunately that can cause issues for\n-  // overlays which can depend on a Clang submodule for the underlying framework\n-  // they are overlaying, which causes us to attempt to load the overlay again.\n-  // We need to find a way to ensure that an overlay dependency with the same\n-  // name as the overlay always loads the underlying Clang module. We currently\n-  // handle this for a direct import from the overlay, but not when it happens\n-  // through other imports.\n+  // FIXME: Ideally we should assert that the file has had its imports resolved\n+  // before calling this function. However unfortunately that can cause issues\n+  // for overlays which can depend on a Clang submodule for the underlying\n+  // framework they are overlaying, which causes us to attempt to load the\n+  // overlay again. We need to find a way to ensure that an overlay dependency\n+  // with the same name as the overlay always loads the underlying Clang module.\n+  // We currently handle this for a direct import from the overlay, but not when\n+  // it happens through other imports.\n   assert(filter && \"no imports requested?\");\n   for (auto desc : Imports) {\n     ModuleDecl::ImportFilter requiredFilter;\n@@ -1588,6 +1776,80 @@ void ModuleDecl::getDeclaredCrossImportBystanders(\n     otherModules.push_back(std::get<0>(pair));\n }\n \n+using TransitiveOverlays =\n+    llvm::SmallDenseMap<ModuleDecl *, std::pair<Identifier, ModuleDecl *>, 1>;\n+\n+static void populateTransitiveCrossImports(ModuleDecl *base,\n+                                           TransitiveOverlays &result) {\n+  if (!result.empty() || !base->mightDeclareCrossImportOverlays())\n+    return;\n+\n+  SmallVector<Identifier, 1> bystanders;\n+  SmallVector<Identifier, 1> overlays;\n+  SmallVector<ModuleDecl *, 1> worklist;\n+  SourceLoc diagLoc; // ignored\n+\n+  worklist.push_back(base);\n+  while (!worklist.empty()) {\n+    ModuleDecl *current = worklist.back();\n+    worklist.pop_back();\n+    if (!current->mightDeclareCrossImportOverlays())\n+      continue;\n+    bystanders.clear();\n+    current->getDeclaredCrossImportBystanders(bystanders);\n+    for (Identifier bystander: bystanders) {\n+      overlays.clear();\n+      current->findDeclaredCrossImportOverlays(bystander, overlays, diagLoc);\n+      for (Identifier overlay: overlays) {\n+        if (!overlay.str().startswith(\"_\"))\n+          continue;\n+        ModuleDecl *overlayMod =\n+            base->getASTContext().getModuleByName(overlay.str());\n+        if (!overlayMod)\n+          continue;\n+        if (result.insert({overlayMod, {bystander, current}}).second)\n+          worklist.push_back(overlayMod);\n+      }\n+    }\n+  }\n+}\n+\n+bool ModuleDecl::isUnderlyingModuleOfCrossImportOverlay(\n+    const ModuleDecl *overlay) {\n+  if (!overlay->getNameStr().startswith(\"_\"))\n+    return false;\n+\n+  populateTransitiveCrossImports(this, declaredCrossImportsTransitive);\n+  return declaredCrossImportsTransitive.find(overlay) !=\n+      declaredCrossImportsTransitive.end();\n+}\n+\n+void ModuleDecl::getAllBystandersForCrossImportOverlay(\n+    ModuleDecl *overlay, SmallVectorImpl<Identifier> &bystanders) {\n+  if (!overlay->getNameStr().startswith(\"_\"))\n+    return;\n+\n+  populateTransitiveCrossImports(this, declaredCrossImportsTransitive);\n+\n+  auto end = declaredCrossImportsTransitive.end();\n+  for (auto i = declaredCrossImportsTransitive.find(overlay);\n+       i != end;\n+       i = declaredCrossImportsTransitive.find(i->second.second)) {\n+    bystanders.push_back(i->second.first);\n+  }\n+}\n+\n+void ModuleDecl::findDeclaredCrossImportOverlaysTransitive(\n+    SmallVectorImpl<ModuleDecl *> &overlayModules) {\n+  populateTransitiveCrossImports(this, declaredCrossImportsTransitive);\n+  std::transform(declaredCrossImportsTransitive.begin(),\n+                 declaredCrossImportsTransitive.end(),\n+                 std::back_inserter(overlayModules),\n+                 [](TransitiveOverlays::iterator::value_type &i) {\n+    return i.first;\n+  });\n+}\n+\n namespace {\n struct OverlayFileContents {\n   struct Module {\n@@ -1866,7 +2128,7 @@ ArrayRef<Identifier> Decl::getSPIGroups() const {\n                            ArrayRef<Identifier>());\n }\n \n-llvm::Expected<llvm::ArrayRef<Identifier>>\n+llvm::ArrayRef<Identifier>\n SPIGroupsRequest::evaluate(Evaluator &evaluator, const Decl *decl) const {\n   // Applies only to public ValueDecls and ExtensionDecls.\n   if (auto vd = dyn_cast<ValueDecl>(decl))\n@@ -1885,9 +2147,10 @@ SPIGroupsRequest::evaluate(Evaluator &evaluator, const Decl *decl) const {\n \n     // Then in the extended nominal type.\n     if (auto extension = dyn_cast<ExtensionDecl>(decl)) {\n-      auto extended = extension->getExtendedNominal();\n-      auto extSPIs = extended->getSPIGroups();\n-      if (!extSPIs.empty()) return extSPIs;\n+      if (auto extended = extension->getExtendedNominal()) {\n+        auto extSPIs = extended->getSPIGroups();\n+        if (!extSPIs.empty()) return extSPIs;\n+      }\n     }\n \n     // And finally in the parent context.\n@@ -1907,6 +2170,32 @@ bool SourceFile::shouldCrossImport() const {\n          getASTContext().LangOpts.EnableCrossImportOverlays;\n }\n \n+ModuleDecl*\n+SourceFile::getModuleShadowedBySeparatelyImportedOverlay(const ModuleDecl *overlay) {\n+  if (separatelyImportedOverlaysReversed.empty() &&\n+      !separatelyImportedOverlays.empty()) {\n+    for (auto &entry: separatelyImportedOverlays) {\n+      ModuleDecl *shadowed = entry.first;\n+      for (ModuleDecl *overlay: entry.second) {\n+        // If for some reason the same overlay shadows more than one module,\n+        // pick the one whose name is alphabetically first.\n+        ModuleDecl *old = separatelyImportedOverlaysReversed[overlay];\n+        if (!old || shadowed->getNameStr() < old->getNameStr())\n+          separatelyImportedOverlaysReversed[overlay] = shadowed;\n+      }\n+    }\n+  }\n+\n+  ModuleDecl *underlying = const_cast<ModuleDecl *>(overlay);\n+  while (underlying->getNameStr().startswith(\"_\")) {\n+    auto next = separatelyImportedOverlaysReversed.find(underlying);\n+    if (next == separatelyImportedOverlaysReversed.end())\n+      return nullptr;\n+    underlying = std::get<1>(*next);\n+  }\n+  return underlying;\n+};\n+\n void ModuleDecl::clearLookupCache() {\n   getASTContext().getImportCache().clear();\n \n@@ -2305,7 +2594,18 @@ void SourceFile::setTypeRefinementContext(TypeRefinementContext *Root) {\n \n void SourceFile::createReferencedNameTracker() {\n   assert(!ReferencedNames && \"This file already has a name tracker.\");\n+  assert(!RequestReferencedNames && \"This file already has a name tracker.\");\n   ReferencedNames.emplace(ReferencedNameTracker());\n+  RequestReferencedNames.emplace(ReferencedNameTracker());\n+}\n+\n+const ReferencedNameTracker *\n+SourceFile::getConfiguredReferencedNameTracker() const {\n+  if (getASTContext().LangOpts.EnableRequestBasedIncrementalDependencies) {\n+    return getRequestBasedReferencedNameTracker();\n+  } else {\n+    return getLegacyReferencedNameTracker();\n+  }\n }\n \n ArrayRef<OpaqueTypeDecl *> SourceFile::getOpaqueReturnTypeDecls() {"
                    },
                    {
                        "filename": "lib/AST/ModuleNameLookup.cpp",
                        "code": "@@ -243,17 +243,16 @@ void ModuleNameLookup<LookupStrategy>::lookupInModule(\n               decls.end());\n }\n \n-llvm::Expected<QualifiedLookupResult> LookupInModuleRequest::evaluate(\n+QualifiedLookupResult\n+LookupInModuleRequest::evaluate(\n     Evaluator &evaluator, const DeclContext *moduleOrFile, DeclName name,\n     NLKind lookupKind, ResolutionKind resolutionKind,\n     const DeclContext *moduleScopeContext) const {\n   assert(moduleScopeContext->isModuleScopeContext());\n \n-  auto &ctx = moduleOrFile->getASTContext();\n-  FrontendStatsTracer tracer(ctx.Stats, \"lookup-in-module\");\n-\n   QualifiedLookupResult decls;\n-  LookupByName lookup(ctx, resolutionKind, name, lookupKind);\n+  LookupByName lookup(moduleOrFile->getASTContext(), resolutionKind,\n+                      name, lookupKind);\n   lookup.lookupInModule(decls, moduleOrFile, {}, moduleScopeContext);\n   return decls;\n }"
                    },
                    {
                        "filename": "lib/AST/NameLookup.cpp",
                        "code": "@@ -707,12 +707,15 @@ void namelookup::filterForDiscriminator(SmallVectorImpl<Result> &results,\n template void namelookup::filterForDiscriminator<LookupResultEntry>(\n     SmallVectorImpl<LookupResultEntry> &results, DebuggerClient *debugClient);\n \n+// FIXME(Evaluator Incremental Dependencies): Remove this function. It is\n+// obviated by ModuleQualifiedLookupRequest and LookupInModuleRequest, which\n+// both automatically register edges into the request-based name tracker.\n void namelookup::recordLookupOfTopLevelName(DeclContext *topLevelContext,\n                                             DeclName name, bool isCascading) {\n   auto SF = dyn_cast<SourceFile>(topLevelContext);\n   if (!SF)\n     return;\n-  auto *nameTracker = SF->getReferencedNameTracker();\n+  auto *nameTracker = SF->getLegacyReferencedNameTracker();\n   if (!nameTracker)\n     return;\n   nameTracker->addTopLevelName(name.getBaseName(), isCascading);\n@@ -1242,7 +1245,7 @@ NominalTypeDecl::lookupDirect(DeclName name,\n                            DirectLookupRequest({this, name, flags}), {});\n }\n \n-llvm::Expected<TinyPtrVector<ValueDecl *>>\n+TinyPtrVector<ValueDecl *>\n DirectLookupRequest::evaluate(Evaluator &evaluator,\n                               DirectLookupDescriptor desc) const {\n   const auto &name = desc.Name;\n@@ -1371,18 +1374,14 @@ void ClassDecl::recordObjCMethod(AbstractFunctionDecl *method,\n ///\n /// This utility is used by qualified name lookup.\n static void configureLookup(const DeclContext *dc,\n-                            NLOptions &options,\n+                            NLOptions options,\n                             ReferencedNameTracker *&tracker,\n                             bool &isLookupCascading) {\n-  auto &ctx = dc->getASTContext();\n-  if (ctx.isAccessControlDisabled())\n-    options |= NL_IgnoreAccessControl;\n-\n   // Find the dependency tracker we'll need for this lookup.\n   tracker = nullptr;\n   if (auto containingSourceFile =\n           dyn_cast<SourceFile>(dc->getModuleScopeContext())) {\n-    tracker = containingSourceFile->getReferencedNameTracker();\n+    tracker = containingSourceFile->getLegacyReferencedNameTracker();\n   }\n \n   auto checkLookupCascading = [dc, options]() -> Optional<bool> {\n@@ -1439,7 +1438,8 @@ static bool isAcceptableLookupResult(const DeclContext *dc,\n   }\n \n   // Check access.\n-  if (!(options & NL_IgnoreAccessControl)) {\n+  if (!(options & NL_IgnoreAccessControl) &&\n+      !dc->getASTContext().isAccessControlDisabled()) {\n     return decl->isAccessibleFrom(dc);\n   }\n \n@@ -1573,7 +1573,7 @@ bool DeclContext::lookupQualified(ArrayRef<NominalTypeDecl *> typeDecls,\n   return !decls.empty();\n }\n \n-llvm::Expected<QualifiedLookupResult>\n+QualifiedLookupResult\n QualifiedLookupRequest::evaluate(Evaluator &eval, const DeclContext *DC,\n                                  SmallVector<NominalTypeDecl *, 4> typeDecls,\n                                  DeclNameRef member, NLOptions options) const {\n@@ -1612,19 +1612,18 @@ QualifiedLookupRequest::evaluate(Evaluator &eval, const DeclContext *DC,\n \n   // Visit all of the nominal types we know about, discovering any others\n   // we need along the way.\n-  auto &ctx = DC->getASTContext();\n   bool wantProtocolMembers = (options & NL_ProtocolMembers);\n   while (!stack.empty()) {\n     auto current = stack.back();\n     stack.pop_back();\n \n+    // FIXME(Evaluator Incremental Dependencies): Remove this. Each direct\n+    // lookup in the stack registers this edge automatically.\n     if (tracker)\n       tracker->addUsedMember({current, member.getBaseName()},isLookupCascading);\n \n     // Make sure we've resolved property wrappers, if we need them.\n-    if (ctx.areLegacySemanticQueriesEnabled()) {\n-      installPropertyWrapperMembersIfNeeded(current, member);\n-    }\n+    installPropertyWrapperMembersIfNeeded(current, member);\n \n     // Look for results within the current nominal type and its extensions.\n     bool currentIsProtocol = isa<ProtocolDecl>(current);\n@@ -1715,7 +1714,7 @@ bool DeclContext::lookupQualified(ModuleDecl *module, DeclNameRef member,\n   return !decls.empty();\n }\n \n-llvm::Expected<QualifiedLookupResult>\n+QualifiedLookupResult\n ModuleQualifiedLookupRequest::evaluate(Evaluator &eval, const DeclContext *DC,\n                                        ModuleDecl *module, DeclNameRef member,\n                                        NLOptions options) const {\n@@ -1768,7 +1767,7 @@ ModuleQualifiedLookupRequest::evaluate(Evaluator &eval, const DeclContext *DC,\n   return decls;\n }\n \n-llvm::Expected<QualifiedLookupResult>\n+QualifiedLookupResult\n AnyObjectLookupRequest::evaluate(Evaluator &evaluator, const DeclContext *dc,\n                                  DeclNameRef member, NLOptions options) const {\n   using namespace namelookup;\n@@ -2194,7 +2193,7 @@ DirectlyReferencedTypeDecls UnderlyingTypeDeclsReferencedRequest::evaluate(\n }\n \n /// Evaluate a superclass declaration request.\n-llvm::Expected<ClassDecl *>\n+ClassDecl *\n SuperclassDeclRequest::evaluate(Evaluator &evaluator,\n                                 NominalTypeDecl *subject) const {\n   auto &Ctx = subject->getASTContext();\n@@ -2241,7 +2240,24 @@ SuperclassDeclRequest::evaluate(Evaluator &evaluator,\n   return nullptr;\n }\n \n-llvm::Expected<NominalTypeDecl *>\n+ArrayRef<ProtocolDecl *>\n+InheritedProtocolsRequest::evaluate(Evaluator &evaluator,\n+                                    ProtocolDecl *PD) const {\n+  llvm::SmallVector<ProtocolDecl *, 2> result;\n+  SmallPtrSet<const ProtocolDecl *, 2> known;\n+  known.insert(PD);\n+  bool anyObject = false;\n+  for (const auto found : getDirectlyInheritedNominalTypeDecls(PD, anyObject)) {\n+    if (auto proto = dyn_cast<ProtocolDecl>(found.Item)) {\n+      if (known.insert(proto).second)\n+        result.push_back(proto);\n+    }\n+  }\n+\n+  return PD->getASTContext().AllocateCopy(result);\n+}\n+\n+NominalTypeDecl *\n ExtendedNominalRequest::evaluate(Evaluator &evaluator,\n                                  ExtensionDecl *ext) const {\n   auto typeRepr = ext->getExtendedTypeRepr();\n@@ -2278,7 +2294,7 @@ static bool declsAreAssociatedTypes(ArrayRef<TypeDecl *> decls) {\n   return true;\n }\n \n-llvm::Expected<NominalTypeDecl *>\n+NominalTypeDecl *\n CustomAttrNominalRequest::evaluate(Evaluator &evaluator,\n                                    CustomAttr *attr, DeclContext *dc) const {\n   // Find the types referenced by the custom attribute."
                    },
                    {
                        "filename": "lib/AST/NameLookupRequests.cpp",
                        "code": "@@ -12,11 +12,13 @@\n \n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/NameLookupRequests.h\"\n-#include \"swift/Subsystems.h\"\n #include \"swift/AST/ASTContext.h\"\n-#include \"swift/AST/Evaluator.h\"\n #include \"swift/AST/Decl.h\"\n+#include \"swift/AST/ProtocolConformance.h\"\n+#include \"swift/AST/Evaluator.h\"\n #include \"swift/AST/Module.h\"\n+#include \"swift/AST/SourceFile.h\"\n+#include \"swift/Subsystems.h\"\n \n using namespace swift;\n \n@@ -67,6 +69,49 @@ void SuperclassDeclRequest::cacheResult(ClassDecl *value) const {\n     protocolDecl->LazySemanticInfo.SuperclassDecl.setPointerAndInt(value, true);\n }\n \n+//----------------------------------------------------------------------------//\n+// InheritedProtocolsRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+Optional<ArrayRef<ProtocolDecl *>>\n+InheritedProtocolsRequest::getCachedResult() const {\n+  auto proto = std::get<0>(getStorage());\n+  if (!proto->areInheritedProtocolsValid())\n+    return None;\n+\n+  return proto->InheritedProtocols;\n+}\n+\n+void InheritedProtocolsRequest::cacheResult(ArrayRef<ProtocolDecl *> PDs) const {\n+  auto proto = std::get<0>(getStorage());\n+  proto->InheritedProtocols = PDs;\n+  proto->setInheritedProtocolsValid();\n+}\n+\n+evaluator::DependencySource\n+InheritedProtocolsRequest::readDependencySource(Evaluator &e) const {\n+  auto *PD = std::get<0>(getStorage());\n+  // Ignore context changes for protocols outside our module. This\n+  // prevents transitive cascading edges when e.g. our private\n+  // type conforms to Hashable which itself looks up Equatable during\n+  // qualified lookup.\n+  if (!PD->getParentSourceFile())\n+    return { nullptr, e.getActiveSourceScope() };\n+  return {\n+    e.getActiveDependencySourceOrNull(),\n+    evaluator::getScopeForAccessLevel(PD->getFormalAccess())\n+  };\n+}\n+\n+void InheritedProtocolsRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &tracker,\n+    ArrayRef<ProtocolDecl *> PDs) const {\n+  for (auto *parentProto : PDs) {\n+    tracker.addUsedMember({parentProto, Identifier()},\n+                          eval.isActiveSourceCascading());\n+  }\n+}\n+\n //----------------------------------------------------------------------------//\n // Missing designated initializers computation\n //----------------------------------------------------------------------------//\n@@ -81,7 +126,7 @@ void HasMissingDesignatedInitializersRequest::cacheResult(bool result) const {\n   classDecl->setHasMissingDesignatedInitializers(result);\n }\n \n-llvm::Expected<bool>\n+bool\n HasMissingDesignatedInitializersRequest::evaluate(Evaluator &evaluator,\n                                            ClassDecl *subject) const {\n   // Short-circuit and check for the attribute here.\n@@ -111,6 +156,7 @@ HasMissingDesignatedInitializersRequest::evaluate(Evaluator &evaluator,\n //----------------------------------------------------------------------------//\n // Extended nominal computation.\n //----------------------------------------------------------------------------//\n+\n Optional<NominalTypeDecl *> ExtendedNominalRequest::getCachedResult() const {\n   // Note: if we fail to compute any nominal declaration, it's considered\n   // a cache miss. This allows us to recompute the extended nominal types\n@@ -130,6 +176,22 @@ void ExtendedNominalRequest::cacheResult(NominalTypeDecl *value) const {\n   ext->setExtendedNominal(value);\n }\n \n+void ExtendedNominalRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &tracker,\n+    NominalTypeDecl *value) const {\n+  if (!value)\n+    return;\n+\n+  // Ensure this extension comes from a source file.\n+  auto *SF = std::get<0>(getStorage())->getParentSourceFile();\n+  if (!SF)\n+    return;\n+  if (SF != eval.getActiveDependencySourceOrNull())\n+    return;\n+  tracker.addUsedMember({value, Identifier()},\n+                        eval.isActiveSourceCascading());\n+}\n+\n //----------------------------------------------------------------------------//\n // Destructor computation.\n //----------------------------------------------------------------------------//\n@@ -148,6 +210,18 @@ void GetDestructorRequest::cacheResult(DestructorDecl *value) const {\n   classDecl->addMember(value);\n }\n \n+evaluator::DependencySource\n+GetDestructorRequest::readDependencySource(Evaluator &eval) const {\n+  // Looking up the deinitializer currently always occurs in a private\n+  // scope because it is impossible to reference 'deinit' in user code, and a\n+  // valid 'deinit' declaration cannot occur outside of the\n+  // definition of a type.\n+  return {\n+    eval.getActiveDependencySourceOrNull(),\n+    evaluator::DependencyScope::Private\n+  };\n+}\n+\n //----------------------------------------------------------------------------//\n // GenericParamListRequest computation.\n //----------------------------------------------------------------------------//\n@@ -206,6 +280,181 @@ SourceLoc swift::extractNearestSourceLoc(const DirectLookupDescriptor &desc) {\n   return extractNearestSourceLoc(desc.DC);\n }\n \n+//----------------------------------------------------------------------------//\n+// LookupOperatorRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+ArrayRef<FileUnit *> OperatorLookupDescriptor::getFiles() const {\n+  if (auto *module = getModule())\n+    return module->getFiles();\n+\n+  // Return an ArrayRef pointing to the FileUnit in the union.\n+  return llvm::makeArrayRef(*fileOrModule.getAddrOfPtr1());\n+}\n+\n+void swift::simple_display(llvm::raw_ostream &out,\n+                           const OperatorLookupDescriptor &desc) {\n+  out << \"looking up operator \";\n+  simple_display(out, desc.name);\n+  out << \" in \";\n+  simple_display(out, desc.fileOrModule);\n+}\n+\n+SourceLoc swift::extractNearestSourceLoc(const OperatorLookupDescriptor &desc) {\n+  return desc.diagLoc;\n+}\n+\n+void DirectLookupRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &tracker,\n+    TinyPtrVector<ValueDecl *> result) const {\n+  auto &desc = std::get<0>(getStorage());\n+  tracker.addUsedMember({desc.DC, desc.Name.getBaseName()},\n+                        eval.isActiveSourceCascading());\n+}\n+\n+//----------------------------------------------------------------------------//\n+// LookupConformanceInModuleRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+void swift::simple_display(llvm::raw_ostream &out,\n+                           const LookupConformanceDescriptor &desc) {\n+  out << \"looking up conformance to \";\n+  simple_display(out, desc.PD);\n+  out << \" for \";\n+  out << desc.Ty.getString();\n+  out << \" in \";\n+  simple_display(out, desc.Mod);\n+}\n+\n+void AnyObjectLookupRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &reqTracker,\n+    QualifiedLookupResult l) const {\n+  auto member = std::get<1>(getStorage());\n+  reqTracker.addDynamicLookupName(member.getBaseName(),\n+                                  eval.isActiveSourceCascading());\n+}\n+\n+SourceLoc\n+swift::extractNearestSourceLoc(const LookupConformanceDescriptor &desc) {\n+  return SourceLoc();\n+}\n+\n+//----------------------------------------------------------------------------//\n+// LookupInModuleRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+evaluator::DependencySource\n+ModuleQualifiedLookupRequest::readDependencySource(Evaluator &eval) const {\n+  auto *DC = std::get<0>(getStorage());\n+  auto options = std::get<3>(getStorage());\n+\n+  // FIXME(Evaluator Incremental Dependencies): This is an artifact of the\n+  // current scheme and should be removed. There are very few callers that are\n+  // accurately passing the right known dependencies mask.\n+  const bool knownPrivate =\n+      (options & NL_KnownDependencyMask) == NL_KnownNonCascadingDependency;\n+  const bool fromPrivateDC =\n+      DC->isCascadingContextForLookup(/*functionsAreNonCascading=*/false);\n+\n+  auto scope = evaluator::DependencyScope::Cascading;\n+  if (knownPrivate || fromPrivateDC)\n+    scope = evaluator::DependencyScope::Private;\n+  return { DC->getParentSourceFile(), scope };\n+}\n+\n+void ModuleQualifiedLookupRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &reqTracker,\n+    QualifiedLookupResult l) const {\n+  auto *DC = std::get<0>(getStorage());\n+  auto *module = std::get<1>(getStorage());\n+  auto member = std::get<2>(getStorage());\n+\n+  // Decline to record lookups outside our module.\n+  if (!DC->getParentSourceFile() ||\n+      module != DC->getModuleScopeContext()->getParentModule()) {\n+    return;\n+  }\n+  reqTracker.addTopLevelName(member.getBaseName(),\n+                            eval.isActiveSourceCascading());\n+}\n+\n+//----------------------------------------------------------------------------//\n+// LookupConformanceInModuleRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+void LookupConformanceInModuleRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &reqTracker,\n+    ProtocolConformanceRef lookupResult) const {\n+  if (lookupResult.isInvalid() || !lookupResult.isConcrete())\n+    return;\n+\n+  auto &desc = std::get<0>(getStorage());\n+  auto *Adoptee = desc.Ty->getAnyNominal();\n+  if (!Adoptee)\n+    return;\n+\n+  auto *source = eval.getActiveDependencySourceOrNull();\n+  assert(source && \"Missing dependency source?\");\n+\n+  // Decline to record conformances defined outside of the active module.\n+  auto *conformance = lookupResult.getConcrete();\n+  if (source->getParentModule() !=\n+      conformance->getDeclContext()->getParentModule())\n+    return;\n+  reqTracker.addUsedMember({Adoptee, Identifier()},\n+                           eval.isActiveSourceCascading());\n+}\n+\n+//----------------------------------------------------------------------------//\n+// UnqualifiedLookupRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+evaluator::DependencySource\n+UnqualifiedLookupRequest::readDependencySource(Evaluator &) const {\n+  auto &desc = std::get<0>(getStorage());\n+  // FIXME(Evaluator Incremental Dependencies): This maintains compatibility\n+  // with the existing scheme, but the existing scheme is totally ad-hoc. We\n+  // should remove this flag and ensure that non-cascading qualified lookups\n+  // occur in the right contexts instead.\n+  auto scope = evaluator::DependencyScope::Cascading;\n+  if (desc.Options.contains(UnqualifiedLookupFlags::KnownPrivate)) {\n+    scope = evaluator::DependencyScope::Private;\n+  }\n+  return {desc.DC->getParentSourceFile(), scope};\n+}\n+\n+void UnqualifiedLookupRequest::writeDependencySink(Evaluator &eval,\n+                                                   ReferencedNameTracker &track,\n+                                                   LookupResult res) const {\n+  auto &desc = std::get<0>(getStorage());\n+  track.addTopLevelName(desc.Name.getBaseName(),\n+                        eval.isActiveSourceCascading());\n+}\n+\n+//----------------------------------------------------------------------------//\n+// QualifiedLookupRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+evaluator::DependencySource\n+QualifiedLookupRequest::readDependencySource(Evaluator &) const {\n+  auto *dc = std::get<0>(getStorage());\n+  auto opts = std::get<3>(getStorage());\n+  // FIXME(Evaluator Incremental Dependencies): This is an artifact of the\n+  // current scheme and should be removed. There are very few callers that are\n+  // accurately passing the right known dependencies mask.\n+  const bool cascades =\n+      dc->isCascadingContextForLookup(/*functionsAreNonCascading*/ false);\n+  const bool knownPrivate =\n+      (opts & NL_KnownDependencyMask) == NL_KnownNonCascadingDependency;\n+  auto scope = evaluator::DependencyScope::Cascading;\n+  if (!cascades || knownPrivate)\n+    scope = evaluator::DependencyScope::Private;\n+  return {\n+    dyn_cast<SourceFile>(dc->getModuleScopeContext()),\n+    scope\n+  };\n+}\n+\n // Define request evaluation functions for each of the name lookup requests.\n static AbstractRequestFunction *nameLookupRequestFunctions[] = {\n #define SWIFT_REQUEST(Zone, Name, Sig, Caching, LocOptions)                    \\"
                    },
                    {
                        "filename": "lib/AST/Pattern.cpp",
                        "code": "@@ -516,8 +516,10 @@ PatternBindingDecl *ContextualPattern::getPatternBindingDecl() const {\n }\n \n bool ContextualPattern::allowsInference() const {\n-  if (auto pbd = getPatternBindingDecl())\n-    return pbd->isInitialized(index);\n+  if (auto pbd = getPatternBindingDecl()) {\n+    return pbd->isInitialized(index) ||\n+        pbd->isDefaultInitializableViaPropertyWrapper(index);\n+  }\n \n   return true;\n }"
                    },
                    {
                        "filename": "lib/AST/ProtocolConformance.cpp",
                        "code": "@@ -1327,16 +1327,14 @@ NominalTypeDecl::getSatisfiedProtocolRequirementsForMember(\n }\n \n SmallVector<ProtocolDecl *, 2>\n-DeclContext::getLocalProtocols(\n-  ConformanceLookupKind lookupKind,\n-  SmallVectorImpl<ConformanceDiagnostic> *diagnostics) const\n-{\n+DeclContext::getLocalProtocols(ConformanceLookupKind lookupKind) const {\n   SmallVector<ProtocolDecl *, 2> result;\n \n   // Dig out the nominal type.\n   NominalTypeDecl *nominal = getSelfNominalTypeDecl();\n-  if (!nominal)\n+  if (!nominal) {\n     return result;\n+  }\n \n   // Update to record all potential conformances.\n   nominal->prepareConformanceTable();\n@@ -1346,28 +1344,29 @@ DeclContext::getLocalProtocols(\n     lookupKind,\n     &result,\n     nullptr,\n-    diagnostics);\n+    nullptr);\n \n   return result;\n }\n \n SmallVector<ProtocolConformance *, 2>\n-DeclContext::getLocalConformances(\n-  ConformanceLookupKind lookupKind,\n-  SmallVectorImpl<ConformanceDiagnostic> *diagnostics) const\n-{\n+DeclContext::getLocalConformances(ConformanceLookupKind lookupKind) const {\n   SmallVector<ProtocolConformance *, 2> result;\n \n   // Dig out the nominal type.\n   NominalTypeDecl *nominal = getSelfNominalTypeDecl();\n-  if (!nominal)\n+  if (!nominal) {\n     return result;\n+  }\n \n   // Protocols only have self-conformances.\n   if (auto protocol = dyn_cast<ProtocolDecl>(nominal)) {\n-    if (protocol->requiresSelfConformanceWitnessTable())\n-      return { protocol->getASTContext().getSelfConformance(protocol) };\n-    return { };\n+    if (protocol->requiresSelfConformanceWitnessTable()) {\n+      return SmallVector<ProtocolConformance *, 2>{\n+        protocol->getASTContext().getSelfConformance(protocol)\n+      };\n+    }\n+    return SmallVector<ProtocolConformance *, 2>();\n   }\n \n   // Update to record all potential conformances.\n@@ -1378,7 +1377,35 @@ DeclContext::getLocalConformances(\n     lookupKind,\n     nullptr,\n     &result,\n-    diagnostics);\n+    nullptr);\n+\n+  return result;\n+}\n+\n+SmallVector<ConformanceDiagnostic, 4>\n+DeclContext::takeConformanceDiagnostics() const {\n+  SmallVector<ConformanceDiagnostic, 4> result;\n+\n+  // Dig out the nominal type.\n+  NominalTypeDecl *nominal = getSelfNominalTypeDecl();\n+  if (!nominal) {\n+    return { };\n+  }\n+\n+  // Protocols are not subject to the checks for supersession.\n+  if (isa<ProtocolDecl>(nominal)) {\n+    return { };\n+  }\n+\n+  // Update to record all potential conformances.\n+  nominal->prepareConformanceTable();\n+  nominal->ConformanceTable->lookupConformances(\n+    nominal,\n+    const_cast<DeclContext *>(this),\n+    ConformanceLookupKind::All,\n+    nullptr,\n+    nullptr,\n+    &result);\n \n   return result;\n }"
                    },
                    {
                        "filename": "lib/AST/SwiftNameTranslation.cpp",
                        "code": "@@ -49,7 +49,7 @@ getNameForObjC(const ValueDecl *VD, CustomNamesOnly_t customNamesOnly) {\n         return anonTypedef->getIdentifier()->getName();\n   }\n \n-  return VD->getBaseName().getIdentifier().str();\n+  return VD->getBaseIdentifier().str();\n }\n \n std::string swift::objc_translation::\n@@ -90,7 +90,7 @@ printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,\n   }\n   OS << getNameForObjC(EL->getDeclContext()->getSelfEnumDecl());\n   if (PreferredName.empty())\n-    ElemName = EL->getName().str();\n+    ElemName = EL->getBaseIdentifier().str();\n   else\n     ElemName = PreferredName.str();\n "
                    },
                    {
                        "filename": "lib/AST/Type.cpp",
                        "code": "@@ -4018,14 +4018,15 @@ TypeSubstitutionMap TypeBase::getMemberSubstitutions(\n       isa<SubscriptDecl>(member)) {\n     auto *innerDC = member->getInnermostDeclContext();\n     if (innerDC->isInnermostContextGeneric()) {\n-      auto sig = innerDC->getGenericSignatureOfContext();\n-      for (auto param : sig->getInnermostGenericParams()) {\n-        auto *genericParam = param->getCanonicalType()\n-            ->castTo<GenericTypeParamType>();\n-        substitutions[genericParam] =\n-          (genericEnv\n-           ? genericEnv->mapTypeIntoContext(param)\n-           : param);\n+      if (auto sig = innerDC->getGenericSignatureOfContext()) {\n+        for (auto param : sig->getInnermostGenericParams()) {\n+          auto *genericParam = param->getCanonicalType()\n+              ->castTo<GenericTypeParamType>();\n+          substitutions[genericParam] =\n+            (genericEnv\n+             ? genericEnv->mapTypeIntoContext(param)\n+             : param);\n+        }\n       }\n     }\n   }\n@@ -5012,6 +5013,22 @@ CanType swift::substOpaqueTypesWithUnderlyingTypes(CanType ty,\n   return ty.subst(replacer, replacer, flags)->getCanonicalType();\n }\n \n+AnyFunctionType *AnyFunctionType::getWithoutDifferentiability() const {\n+  SmallVector<Param, 8> newParams;\n+  for (auto &param : getParams()) {\n+    Param newParam(param.getPlainType(), param.getLabel(),\n+                   param.getParameterFlags().withNoDerivative(false));\n+    newParams.push_back(newParam);\n+  }\n+  auto nonDiffExtInfo = getExtInfo()\n+      .withDifferentiabilityKind(DifferentiabilityKind::NonDifferentiable);\n+  if (isa<FunctionType>(this))\n+    return FunctionType::get(newParams, getResult(), nonDiffExtInfo);\n+  assert(isa<GenericFunctionType>(this));\n+  return GenericFunctionType::get(getOptGenericSignature(), newParams,\n+                                  getResult(), nonDiffExtInfo);\n+}\n+\n Optional<TangentSpace>\n TypeBase::getAutoDiffTangentSpace(LookupConformanceFn lookupConformance) {\n   assert(lookupConformance);\n@@ -5049,7 +5066,8 @@ TypeBase::getAutoDiffTangentSpace(LookupConformanceFn lookupConformance) {\n   // `TangentVector` associated type.\n   auto *differentiableProtocol =\n       ctx.getProtocol(KnownProtocolKind::Differentiable);\n-  assert(differentiableProtocol && \"`Differentiable` protocol not found\");\n+  if (!differentiableProtocol)\n+    return cache(None);\n   auto associatedTypeLookup =\n       differentiableProtocol->lookupDirect(ctx.Id_TangentVector);\n   assert(associatedTypeLookup.size() == 1);"
                    },
                    {
                        "filename": "lib/AST/TypeCheckRequests.cpp",
                        "code": "@@ -157,6 +157,29 @@ void SuperclassTypeRequest::cacheResult(Type value) const {\n     protocolDecl->LazySemanticInfo.SuperclassType.setPointerAndInt(value, true);\n }\n \n+evaluator::DependencySource\n+SuperclassTypeRequest::readDependencySource(Evaluator &e) const {\n+  const auto access = std::get<0>(getStorage())->getFormalAccess();\n+  return {\n+    e.getActiveDependencySourceOrNull(),\n+    evaluator::getScopeForAccessLevel(access)\n+  };\n+}\n+\n+void SuperclassTypeRequest::writeDependencySink(Evaluator &eval,\n+                                                ReferencedNameTracker &tracker,\n+                                                Type value) const {\n+  if (!value)\n+    return;\n+\n+  // FIXME: This is compatible with the existing name tracking scheme, but\n+  // ignoring this name when we fail to look up a class is bogus.\n+  ClassDecl *Super = value->getClassOrBoundGenericClass();\n+  if (!Super)\n+    return;\n+  tracker.addUsedMember({Super, Identifier()}, eval.isActiveSourceCascading());\n+}\n+\n //----------------------------------------------------------------------------//\n // Enum raw type computation.\n //----------------------------------------------------------------------------//\n@@ -863,14 +886,14 @@ bool EnumRawValuesRequest::isCached() const {\n   return std::get<1>(getStorage()) == TypeResolutionStage::Interface;\n }\n \n-Optional<bool> EnumRawValuesRequest::getCachedResult() const {\n+Optional<evaluator::SideEffect> EnumRawValuesRequest::getCachedResult() const {\n   auto *ED = std::get<0>(getStorage());\n   if (ED->LazySemanticInfo.hasCheckedRawValues())\n-    return true;\n+    return std::make_tuple<>();\n   return None;\n }\n \n-void EnumRawValuesRequest::cacheResult(bool) const {\n+void EnumRawValuesRequest::cacheResult(evaluator::SideEffect) const {\n   auto *ED = std::get<0>(getStorage());\n   auto flags = ED->LazySemanticInfo.RawTypeAndFlags.getInt() |\n       EnumDecl::HasFixedRawValues |\n@@ -1017,15 +1040,16 @@ void InterfaceTypeRequest::cacheResult(Type type) const {\n }\n \n //----------------------------------------------------------------------------//\n-// LookupPrecedenceGroupRequest computation.\n+// ValidatePrecedenceGroupRequest computation.\n //----------------------------------------------------------------------------//\n \n-SourceLoc LookupPrecedenceGroupRequest::getNearestLoc() const {\n+SourceLoc ValidatePrecedenceGroupRequest::getNearestLoc() const {\n   auto &desc = std::get<0>(getStorage());\n   return desc.getLoc();\n }\n \n-void LookupPrecedenceGroupRequest::diagnoseCycle(DiagnosticEngine &diags) const {\n+void ValidatePrecedenceGroupRequest::diagnoseCycle(\n+    DiagnosticEngine &diags) const {\n   auto &desc = std::get<0>(getStorage());\n   if (auto pathDir = desc.pathDirection) {\n     diags.diagnose(desc.nameLoc, diag::precedence_group_cycle, (bool)*pathDir);\n@@ -1034,7 +1058,8 @@ void LookupPrecedenceGroupRequest::diagnoseCycle(DiagnosticEngine &diags) const\n   }\n }\n \n-void LookupPrecedenceGroupRequest::noteCycleStep(DiagnosticEngine &diag) const {\n+void ValidatePrecedenceGroupRequest::noteCycleStep(\n+    DiagnosticEngine &diag) const {\n   auto &desc = std::get<0>(getStorage());\n   diag.diagnose(desc.nameLoc,\n                  diag::circular_reference_through_precedence_group, desc.ident);\n@@ -1262,19 +1287,109 @@ void DifferentiableAttributeTypeCheckRequest::cacheResult(\n   attr->ParameterIndicesAndBit.setPointerAndInt(parameterIndices, true);\n }\n \n+//----------------------------------------------------------------------------//\n+// CheckRedeclarationRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+Optional<evaluator::SideEffect>\n+CheckRedeclarationRequest::getCachedResult() const {\n+  if (!std::get<0>(getStorage())->alreadyCheckedRedeclaration())\n+    return None;\n+  return std::make_tuple<>();\n+}\n+\n+void CheckRedeclarationRequest::cacheResult(evaluator::SideEffect) const {\n+  std::get<0>(getStorage())->setCheckedRedeclaration();\n+}\n+\n+evaluator::DependencySource\n+CheckRedeclarationRequest::readDependencySource(Evaluator &eval) const {\n+  auto *current = std::get<0>(getStorage());\n+  auto *currentDC = current->getDeclContext();\n+  return {\n+    currentDC->getParentSourceFile(),\n+    evaluator::getScopeForAccessLevel(current->getFormalAccess())\n+  };\n+}\n+\n+void CheckRedeclarationRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &tracker,\n+    evaluator::SideEffect) const {\n+  auto *current = std::get<0>(getStorage());\n+  if (!current->hasName())\n+    return;\n+\n+  DeclContext *currentDC = current->getDeclContext();\n+  SourceFile *currentFile = currentDC->getParentSourceFile();\n+  if (!currentFile || currentDC->isLocalContext())\n+    return;\n+\n+  if (currentDC->isTypeContext()) {\n+    if (auto nominal = currentDC->getSelfNominalTypeDecl()) {\n+      tracker.addUsedMember({nominal, current->getBaseName()},\n+                            eval.isActiveSourceCascading());\n+    }\n+  } else {\n+    tracker.addTopLevelName(current->getBaseName(),\n+                            eval.isActiveSourceCascading());\n+  }\n+}\n+\n+//----------------------------------------------------------------------------//\n+// LookupAllConformancesInContextRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+evaluator::DependencySource\n+LookupAllConformancesInContextRequest::readDependencySource(\n+    Evaluator &eval) const {\n+  auto *dc = std::get<0>(getStorage());\n+  AccessLevel defaultAccess;\n+  if (auto ext = dyn_cast<ExtensionDecl>(dc)) {\n+    const NominalTypeDecl *nominal = ext->getExtendedNominal();\n+    if (!nominal) {\n+      return {\n+        eval.getActiveDependencySourceOrNull(),\n+        evaluator::DependencyScope::Cascading\n+      };\n+    }\n+    defaultAccess = nominal->getFormalAccess();\n+  } else {\n+    defaultAccess = cast<NominalTypeDecl>(dc)->getFormalAccess();\n+  }\n+  return {\n+    eval.getActiveDependencySourceOrNull(),\n+    evaluator::getScopeForAccessLevel(defaultAccess)\n+  };\n+}\n+\n+void LookupAllConformancesInContextRequest::writeDependencySink(\n+    Evaluator &eval, ReferencedNameTracker &tracker,\n+    ProtocolConformanceLookupResult conformances) const {\n+  for (auto conformance : conformances) {\n+    tracker.addUsedMember({conformance->getProtocol(), Identifier()},\n+                          eval.isActiveSourceCascading());\n+  }\n+}\n+\n //----------------------------------------------------------------------------//\n // TypeCheckSourceFileRequest computation.\n //----------------------------------------------------------------------------//\n \n-Optional<bool> TypeCheckSourceFileRequest::getCachedResult() const {\n+evaluator::DependencySource\n+TypeCheckSourceFileRequest::readDependencySource(Evaluator &e) const {\n+  return {std::get<0>(getStorage()), evaluator::DependencyScope::Cascading};\n+}\n+\n+Optional<evaluator::SideEffect>\n+TypeCheckSourceFileRequest::getCachedResult() const {\n   auto *SF = std::get<0>(getStorage());\n   if (SF->ASTStage == SourceFile::TypeChecked)\n-    return true;\n+    return std::make_tuple<>();\n \n   return None;\n }\n \n-void TypeCheckSourceFileRequest::cacheResult(bool result) const {\n+void TypeCheckSourceFileRequest::cacheResult(evaluator::SideEffect) const {\n   auto *SF = std::get<0>(getStorage());\n \n   // Verify that we've checked types correctly.\n@@ -1306,3 +1421,17 @@ void TypeCheckSourceFileRequest::cacheResult(bool result) const {\n #endif\n   }\n }\n+\n+//----------------------------------------------------------------------------//\n+// TypeCheckFunctionBodyUntilRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+evaluator::DependencySource\n+TypeCheckFunctionBodyUntilRequest::readDependencySource(Evaluator &e) const {\n+  // We're going under a function body scope, unconditionally flip the scope\n+  // to private.\n+  return {\n+    std::get<0>(getStorage())->getParentSourceFile(),\n+    evaluator::DependencyScope::Private\n+  };\n+}"
                    },
                    {
                        "filename": "lib/AST/USRGeneration.cpp",
                        "code": "@@ -166,7 +166,7 @@ static bool shouldUseObjCUSR(const Decl *D) {\n   return false;\n }\n \n-llvm::Expected<std::string>\n+std::string\n swift::USRGenerationRequest::evaluate(Evaluator &evaluator,\n                                       const ValueDecl *D) const {\n   if (auto *VD = dyn_cast<VarDecl>(D))\n@@ -225,7 +225,7 @@ swift::USRGenerationRequest::evaluate(Evaluator &evaluator,\n \n     auto ClangMacroInfo = ClangN.getAsMacro();\n     bool Ignore = clang::index::generateUSRForMacro(\n-        D->getBaseName().getIdentifier().str(),\n+        D->getBaseIdentifier().str(),\n         ClangMacroInfo->getDefinitionLoc(),\n         Importer.getClangASTContext().getSourceManager(), Buffer);\n     if (!Ignore)\n@@ -254,7 +254,7 @@ swift::USRGenerationRequest::evaluate(Evaluator &evaluator,\n   return NewMangler.mangleDeclAsUSR(D, getUSRSpacePrefix());\n }\n \n-llvm::Expected<std::string>\n+std::string\n swift::MangleLocalTypeDeclRequest::evaluate(Evaluator &evaluator,\n                                             const TypeDecl *D) const {\n   if (isa<ModuleDecl>(D))"
                    },
                    {
                        "filename": "lib/AST/UnqualifiedLookup.cpp",
                        "code": "@@ -1274,7 +1274,7 @@ bool ASTScopeDeclConsumerForUnqualifiedLookup::lookInMembers(\n   return factory.isFirstResultEnough();\n }\n \n-llvm::Expected<LookupResult>\n+LookupResult\n UnqualifiedLookupRequest::evaluate(Evaluator &evaluator,\n                                    UnqualifiedLookupDescriptor desc) const {\n   SmallVector<LookupResultEntry, 4> results;\n@@ -1448,7 +1448,7 @@ bool UnqualifiedLookupFactory::shouldDiffer() const {\n     \"swift/test/TypeCoercion/overload_noncall.swift\",\n     \"swift/test/expr/capture/nested_class.swift\",\n     \"swift/test/expr/capture/order.swift\",\n-    \"swift/test/NameBinding/name-binding.swift\"\n+    \"swift/test/NameLookup/name_lookup2.swift\"\n   };\n   StringRef fileName = SF->getFilename();\n   return llvm::any_of(testsThatShouldDiffer, [&](const char *testFile) {"
                    },
                    {
                        "filename": "lib/Basic/CMakeLists.txt",
                        "code": "@@ -86,8 +86,9 @@ add_swift_host_library(swiftBasic STATIC\n target_include_directories(swiftBasic PRIVATE\n   ${UUID_INCLUDE})\n \n+target_link_libraries(swiftBasic PUBLIC\n+  swiftDemangling)\n target_link_libraries(swiftBasic PRIVATE\n-  swiftDemangling\n   ${UUID_LIBRARIES})\n \n message(STATUS \"Swift version: ${SWIFT_VERSION}\")"
                    },
                    {
                        "filename": "lib/Basic/Platform.cpp",
                        "code": "@@ -397,6 +397,9 @@ swift::getSwiftRuntimeCompatibilityVersionForTarget(\n     const llvm::Triple &Triple) {\n   unsigned Major, Minor, Micro;\n \n+  if (Triple.getArchName() == \"arm64e\")\n+    return llvm::VersionTuple(5, 3);\n+\n   if (Triple.isMacOSX()) {\n     Triple.getMacOSXVersion(Major, Minor, Micro);\n     if (Major == 10) {"
                    },
                    {
                        "filename": "lib/ClangImporter/ClangImporter.cpp",
                        "code": "@@ -2414,7 +2414,7 @@ class DarwinLegacyFilterDeclConsumer : public swift::VisibleDeclConsumer {\n     if (clangModule->Name == \"MacTypes\") {\n       if (!VD->hasName() || VD->getBaseName().isSpecial())\n         return true;\n-      return llvm::StringSwitch<bool>(VD->getBaseName().getIdentifier().str())\n+      return llvm::StringSwitch<bool>(VD->getBaseIdentifier().str())\n           .Cases(\"OSErr\", \"OSStatus\", \"OptionBits\", false)\n           .Cases(\"FourCharCode\", \"OSType\", false)\n           .Case(\"Boolean\", false)"
                    },
                    {
                        "filename": "lib/ClangImporter/ImportDecl.cpp",
                        "code": "@@ -3202,7 +3202,7 @@ namespace {\n           // context.\n           if (errorWrapper) {\n             auto enumeratorValue = cast<ValueDecl>(enumeratorDecl);\n-            auto name = enumeratorValue->getBaseName().getIdentifier();\n+            auto name = enumeratorValue->getBaseIdentifier();\n             auto alias = importEnumCaseAlias(name,\n                                              constant,\n                                              enumeratorValue,\n@@ -7731,6 +7731,17 @@ ClangImporter::Implementation::importDeclImpl(const clang::NamedDecl *ClangDecl,\n                                               bool &HadForwardDeclaration) {\n   assert(ClangDecl);\n \n+  // Private and protected C++ class members should never be used, so we skip\n+  // them entirely (instead of importing them with a corresponding Swift access\n+  // level) to remove clutter from the module interface.\n+  //\n+  // We omit protected members in addition to private members because Swift\n+  // structs can't inherit from C++ classes, so there's effectively no way to\n+  // access them.\n+  clang::AccessSpecifier access = ClangDecl->getAccess();\n+  if (access == clang::AS_protected || access == clang::AS_private)\n+    return nullptr;\n+\n   bool SkippedOverTypedef = false;\n   Decl *Result = nullptr;\n   if (auto *UnderlyingDecl = canSkipOverTypedef(*this, ClangDecl,"
                    },
                    {
                        "filename": "lib/Demangling/Demangler.cpp",
                        "code": "@@ -1773,6 +1773,11 @@ NodePointer Demangler::demangleImplFunctionType() {\n   if (nextIf('e'))\n     type->addChild(createNode(Node::Kind::ImplEscaping), *this);\n \n+  if (nextIf('d'))\n+    type->addChild(createNode(Node::Kind::ImplDifferentiable), *this);\n+  if (nextIf('l'))\n+    type->addChild(createNode(Node::Kind::ImplLinear), *this);\n+\n   const char *CAttr = nullptr;\n   switch (nextChar()) {\n     case 'y': CAttr = \"@callee_unowned\"; break;\n@@ -2791,6 +2796,14 @@ NodePointer Demangler::demangleSpecialType() {\n       return popFunctionType(Node::Kind::ObjCBlock);\n     case 'C':\n       return popFunctionType(Node::Kind::CFunctionPointer);\n+    case 'F':\n+      return popFunctionType(Node::Kind::DifferentiableFunctionType);\n+    case 'G':\n+      return popFunctionType(Node::Kind::EscapingDifferentiableFunctionType);\n+    case 'H':\n+      return popFunctionType(Node::Kind::LinearFunctionType);\n+    case 'I':\n+      return popFunctionType(Node::Kind::EscapingLinearFunctionType);\n     case 'o':\n       return createType(createWithChild(Node::Kind::Unowned,\n                                         popNode(Node::Kind::Type)));"
                    },
                    {
                        "filename": "lib/Demangling/NodePrinter.cpp",
                        "code": "@@ -351,6 +351,10 @@ class NodePrinter {\n     case Node::Kind::DependentPseudogenericSignature:\n     case Node::Kind::Destructor:\n     case Node::Kind::DidSet:\n+    case Node::Kind::DifferentiableFunctionType:\n+    case Node::Kind::EscapingDifferentiableFunctionType:\n+    case Node::Kind::LinearFunctionType:\n+    case Node::Kind::EscapingLinearFunctionType:\n     case Node::Kind::DirectMethodReferenceAttribute:\n     case Node::Kind::Directness:\n     case Node::Kind::DynamicAttribute:\n@@ -386,6 +390,8 @@ class NodePrinter {\n     case Node::Kind::Index:\n     case Node::Kind::IVarInitializer:\n     case Node::Kind::IVarDestroyer:\n+    case Node::Kind::ImplDifferentiable:\n+    case Node::Kind::ImplLinear:\n     case Node::Kind::ImplEscaping:\n     case Node::Kind::ImplConvention:\n     case Node::Kind::ImplFunctionAttribute:\n@@ -1234,6 +1240,22 @@ NodePointer NodePrinter::print(NodePointer Node, bool asPrefixContext) {\n     Printer << \"@convention(thin) \";\n     printFunctionType(nullptr, Node);\n     return nullptr;\n+  case Node::Kind::DifferentiableFunctionType:\n+    Printer << \"@differentiable \";\n+    printFunctionType(nullptr, Node);\n+    return nullptr;\n+  case Node::Kind::EscapingDifferentiableFunctionType:\n+    Printer << \"@escaping @differentiable \";\n+    printFunctionType(nullptr, Node);\n+    return nullptr;\n+  case Node::Kind::LinearFunctionType:\n+    Printer << \"@differentiable(linear) \";\n+    printFunctionType(nullptr, Node);\n+    return nullptr;\n+  case Node::Kind::EscapingLinearFunctionType:\n+    Printer << \"@escaping @differentiable(linear) \";\n+    printFunctionType(nullptr, Node);\n+    return nullptr;\n   case Node::Kind::FunctionType:\n   case Node::Kind::UncurriedFunctionType:\n     printFunctionType(nullptr, Node);\n@@ -2026,6 +2048,12 @@ NodePointer NodePrinter::print(NodePointer Node, bool asPrefixContext) {\n     return nullptr;\n   case Node::Kind::LabelList:\n     return nullptr;\n+  case Node::Kind::ImplDifferentiable:\n+    Printer << \"@differentiable\";\n+    return nullptr;\n+  case Node::Kind::ImplLinear:\n+    Printer << \"@differentiable(linear)\";\n+    return nullptr;\n   case Node::Kind::ImplEscaping:\n     Printer << \"@escaping\";\n     return nullptr;\n@@ -2527,6 +2555,14 @@ void NodePrinter::printEntityType(NodePointer Entity, NodePointer type,\n         Printer << ' ';\n       type = dependentType->getFirstChild();\n     }\n+    if (type->getKind() == Node::Kind::DifferentiableFunctionType)\n+      Printer << \"@differentiable \";\n+    else if (type->getKind() == Node::Kind::EscapingDifferentiableFunctionType)\n+      Printer << \"@escaping @differentiable \";\n+    else if (type->getKind() == Node::Kind::LinearFunctionType)\n+      Printer << \"@differentiable(linear) \";\n+    else if (type->getKind() == Node::Kind::EscapingLinearFunctionType)\n+      Printer << \"@escaping @differentiable(linear) \";\n     printFunctionType(labelList, type);\n   } else {\n     print(type);"
                    },
                    {
                        "filename": "lib/Demangling/OldRemangler.cpp",
                        "code": "@@ -1168,6 +1168,26 @@ void Remangler::mangleThinFunctionType(Node *node) {\n   mangleChildNodes(node); // argument tuple, result type\n }\n \n+void Remangler::mangleDifferentiableFunctionType(Node *node) {\n+  Buffer << \"XF\";\n+  mangleChildNodes(node); // argument tuple, result type\n+}\n+\n+void Remangler::mangleEscapingDifferentiableFunctionType(Node *node) {\n+  Buffer << \"XG\";\n+  mangleChildNodes(node); // argument tuple, result type\n+}\n+\n+void Remangler::mangleLinearFunctionType(Node *node) {\n+  Buffer << \"XH\";\n+  mangleChildNodes(node); // argument tuple, result type\n+}\n+\n+void Remangler::mangleEscapingLinearFunctionType(Node *node) {\n+  Buffer << \"XI\";\n+  mangleChildNodes(node); // argument tuple, result type\n+}\n+\n void Remangler::mangleArgumentTuple(Node *node) {\n   mangleSingleChildNode(node);\n }\n@@ -1258,6 +1278,16 @@ void Remangler::mangleImplYield(Node *node) {\n   mangleChildNodes(node); // impl convention, type\n }\n \n+void Remangler::mangleImplDifferentiable(Node *node) {\n+  // TODO(TF-750): Check if this code path actually triggers and add a test.\n+  Buffer << 'd';\n+}\n+\n+void Remangler::mangleImplLinear(Node *node) {\n+  // TODO(TF-750): Check if this code path actually triggers and add a test.\n+  Buffer << 'l';\n+}\n+\n void Remangler::mangleImplEscaping(Node *node) {\n   // The old mangler does not encode escaping.\n }"
                    },
                    {
                        "filename": "lib/Demangling/Remangler.cpp",
                        "code": "@@ -1221,6 +1221,26 @@ void Remangler::mangleFunctionType(Node *node) {\n   Buffer << 'c';\n }\n \n+void Remangler::mangleDifferentiableFunctionType(Node *node) {\n+  mangleFunctionSignature(node);\n+  Buffer << \"XF\";\n+}\n+\n+void Remangler::mangleEscapingDifferentiableFunctionType(Node *node) {\n+  mangleFunctionSignature(node);\n+  Buffer << \"XG\";\n+}\n+\n+void Remangler::mangleLinearFunctionType(Node *node) {\n+  mangleFunctionSignature(node);\n+  Buffer << \"XH\";\n+}\n+\n+void Remangler::mangleEscapingLinearFunctionType(Node *node) {\n+  mangleFunctionSignature(node);\n+  Buffer << \"XI\";\n+}\n+\n void Remangler::mangleGenericProtocolWitnessTable(Node *node) {\n   mangleSingleChildNode(node);\n   Buffer << \"WG\";\n@@ -1378,6 +1398,14 @@ void Remangler::mangleIVarDestroyer(Node *node) {\n   Buffer << \"fE\";\n }\n \n+void Remangler::mangleImplDifferentiable(Node *node) {\n+  Buffer << 'd';\n+}\n+\n+void Remangler::mangleImplLinear(Node *node) {\n+  Buffer << 'l';\n+}\n+\n void Remangler::mangleImplEscaping(Node *node) {\n   Buffer << 'e';\n }\n@@ -1459,6 +1487,12 @@ void Remangler::mangleImplFunctionType(Node *node) {\n   Buffer << PseudoGeneric;\n   for (NodePointer Child : *node) {\n     switch (Child->getKind()) {\n+      case Node::Kind::ImplDifferentiable:\n+        Buffer << 'd';\n+        break;\n+      case Node::Kind::ImplLinear:\n+        Buffer << 'l';\n+        break;\n       case Node::Kind::ImplEscaping:\n         Buffer << 'e';\n         break;"
                    },
                    {
                        "filename": "lib/Driver/Driver.cpp",
                        "code": "@@ -2107,11 +2107,21 @@ void Driver::buildActions(SmallVectorImpl<const Action *> &TopLevelActions,\n     // On ELF platforms there's no built in autolinking mechanism, so we\n     // pull the info we need from the .o files directly and pass them as an\n     // argument input file to the linker.\n+    const auto &Triple = TC.getTriple();\n     SmallVector<const Action *, 2> AutolinkExtractInputs;\n     for (const Action *A : AllLinkerInputs)\n-      if (A->getType() == file_types::TY_Object)\n+      if (A->getType() == file_types::TY_Object) {\n+        // Shared objects on ELF platforms don't have a swift1_autolink_entries\n+        // section in them because the section in the .o files is marked as\n+        // SHF_EXCLUDE.\n+        if (auto *IA = dyn_cast<InputAction>(A)) {\n+          StringRef ObjectName = IA->getInputArg().getValue();\n+          if (Triple.getObjectFormat() == llvm::Triple::ELF &&\n+              ObjectName.endswith(\".so\"))\n+            continue;\n+        }\n         AutolinkExtractInputs.push_back(A);\n-    const auto &Triple = TC.getTriple();\n+      }\n     const bool AutolinkExtractRequired =\n         (Triple.getObjectFormat() == llvm::Triple::ELF && !Triple.isPS4()) ||\n         Triple.getObjectFormat() == llvm::Triple::Wasm ||"
                    },
                    {
                        "filename": "lib/Driver/ParseableOutput.cpp",
                        "code": "@@ -141,7 +141,7 @@ class DetailedCommandBasedMessage : public CommandBasedMessage {\n     }\n     file_types::forAllTypes([&](file_types::ID Ty) {\n       for (auto Output : Cmd.getOutput().getAdditionalOutputsForType(Ty)) {\n-        Outputs.push_back(OutputPair(Ty, Output));\n+        Outputs.push_back(OutputPair(Ty, Output.str()));\n       }\n     });\n   }"
                    },
                    {
                        "filename": "lib/Driver/ToolChains.cpp",
                        "code": "@@ -249,6 +249,7 @@ static void addCommonFrontendArgs(const ToolChain &TC, const OutputInfo &OI,\n   inputArgs.AddLastArg(arguments, options::OPT_package_description_version);\n   inputArgs.AddLastArg(arguments, options::OPT_serialize_diagnostics_path);\n   inputArgs.AddLastArg(arguments, options::OPT_debug_diagnostic_names);\n+  inputArgs.AddLastArg(arguments, options::OPT_print_educational_notes);\n   inputArgs.AddLastArg(arguments, options::OPT_enable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_parser_lookup);\n@@ -403,11 +404,19 @@ ToolChain::constructInvocation(const CompileJobAction &job,\n     }\n     if (usePersistentPCH) {\n       context.Args.AddLastArg(Arguments, options::OPT_pch_output_dir);\n-      if (context.OI.CompilerMode == OutputInfo::Mode::StandardCompile) {\n+      switch (context.OI.CompilerMode) {\n+      case OutputInfo::Mode::StandardCompile:\n+      case OutputInfo::Mode::BatchModeCompile:\n         // In the 'multiple invocations for each file' mode we don't need to\n         // validate the PCH every time, it has been validated with the initial\n         // -emit-pch invocation.\n         Arguments.push_back(\"-pch-disable-validation\");\n+        break;\n+\n+      case OutputInfo::Mode::Immediate:\n+      case OutputInfo::Mode::REPL:\n+      case OutputInfo::Mode::SingleCompile:\n+        break;\n       }\n     }\n   }"
                    },
                    {
                        "filename": "lib/Frontend/ArgsToFrontendOptionsConverter.cpp",
                        "code": "@@ -67,6 +67,7 @@ bool ArgsToFrontendOptionsConverter::convert(\n     Opts.BridgingHeaderDirForPrint = A->getValue();\n   }\n   Opts.IndexSystemModules |= Args.hasArg(OPT_index_system_modules);\n+  Opts.IndexIgnoreStdlib |= Args.hasArg(OPT_index_ignore_stdlib);\n \n   Opts.EmitVerboseSIL |= Args.hasArg(OPT_emit_verbose_sil);\n   Opts.EmitSortedSIL |= Args.hasArg(OPT_emit_sorted_sil);"
                    },
                    {
                        "filename": "lib/Frontend/CMakeLists.txt",
                        "code": "@@ -16,6 +16,7 @@ add_swift_host_library(swiftFrontend STATIC\n add_dependencies(swiftFrontend\n   SwiftOptions)\n target_link_libraries(swiftFrontend PRIVATE\n+  swiftAST\n   swiftSIL\n   swiftMigrator\n   swiftOption"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -402,6 +402,10 @@ static bool ParseLangArgs(LangOptions &Opts, ArgList &Args,\n   }\n   \n   Opts.DisableParserLookup |= Args.hasArg(OPT_disable_parser_lookup);\n+  Opts.EnableRequestBasedIncrementalDependencies =\n+      Args.hasFlag(OPT_enable_request_based_incremental_dependencies,\n+                   OPT_disable_request_based_incremental_dependencies,\n+                   Opts.EnableRequestBasedIncrementalDependencies);\n   Opts.EnableASTScopeLookup =\n       Args.hasFlag(options::OPT_enable_astscope_lookup,\n                    options::OPT_disable_astscope_lookup, Opts.EnableASTScopeLookup) ||\n@@ -442,8 +446,15 @@ static bool ParseLangArgs(LangOptions &Opts, ArgList &Args,\n   if (Args.hasArg(OPT_fine_grained_dependency_include_intrafile))\n     Opts.FineGrainedDependenciesIncludeIntrafileOnes = true;\n \n-  if (Args.hasArg(OPT_enable_experimental_differentiable_programming))\n+  if (Args.hasArg(OPT_enable_experimental_additive_arithmetic_derivation))\n+    Opts.EnableExperimentalAdditiveArithmeticDerivedConformances = true;\n+\n+  if (Args.hasArg(OPT_enable_experimental_differentiable_programming)) {\n     Opts.EnableExperimentalDifferentiableProgramming = true;\n+    // Differentiable programming implies `AdditiveArithmetic` derived\n+    // conformances.\n+    Opts.EnableExperimentalAdditiveArithmeticDerivedConformances = true;\n+  }\n \n   Opts.DebuggerSupport |= Args.hasArg(OPT_debugger_support);\n   if (Opts.DebuggerSupport)\n@@ -814,7 +825,7 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.SuppressWarnings |= Args.hasArg(OPT_suppress_warnings);\n   Opts.WarningsAsErrors |= Args.hasArg(OPT_warnings_as_errors);\n   Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n-  Opts.EnableEducationalNotes |= Args.hasArg(OPT_enable_educational_notes);\n+  Opts.PrintEducationalNotes |= Args.hasArg(OPT_print_educational_notes);\n   Opts.EnableExperimentalFormatting |=\n       Args.hasArg(OPT_enable_experimental_diagnostic_formatting);\n   if (Arg *A = Args.getLastArg(OPT_diagnostic_documentation_path)) {\n@@ -1254,6 +1265,9 @@ static bool ParseIRGenArgs(IRGenOptions &Opts, ArgList &Args,\n   if (Args.hasArg(OPT_disable_debugger_shadow_copies))\n     Opts.DisableDebuggerShadowCopies = true;\n \n+  if (Args.hasArg(OPT_disable_concrete_type_metadata_mangled_name_accessors))\n+    Opts.DisableConcreteTypeMetadataMangledNameAccessors = true;\n+\n   if (Args.hasArg(OPT_use_jit))\n     Opts.UseJIT = true;\n   \n@@ -1278,6 +1292,9 @@ static bool ParseIRGenArgs(IRGenOptions &Opts, ArgList &Args,\n                                OPT_disable_type_layouts)) {\n     Opts.UseTypeLayoutValueHandling\n       = A->getOption().matches(OPT_enable_type_layouts);\n+  } else if (Opts.OptMode == OptimizationMode::NoOptimization) {\n+    // Disable type layouts at Onone except if explictly requested.\n+    Opts.UseTypeLayoutValueHandling = false;\n   }\n \n   Opts.UseSwiftCall = Args.hasArg(OPT_enable_swiftcall);"
                    },
                    {
                        "filename": "lib/Frontend/DependencyVerifier.cpp",
                        "code": "@@ -224,6 +224,7 @@ struct Obligation {\n            \"Cannot form negative obligation!\");\n   }\n \n+  Expectation::Scope getScope() const { return info.second; }\n   Expectation::Kind getKind() const { return info.first; }\n   StringRef getName() const { return name; }\n   bool getCascades() const {\n@@ -240,6 +241,22 @@ struct Obligation {\n     }\n   }\n \n+  StringRef renderAsFixit(ASTContext &Ctx) const {\n+    llvm::StringRef selector =\n+#define MATRIX_ENTRY(SELECTOR, SCOPE, KIND) \\\n+    if (getKind() == Expectation::Kind::KIND && \\\n+        getScope() == Expectation::Scope::SCOPE) { \\\n+      return SELECTOR; \\\n+    }\n+\n+    [this]() -> StringRef {\n+      EXPECTATION_MATRIX\n+      return \"\";\n+    }();\n+#undef MATRIX_ENTRY\n+    return Ctx.AllocateCopy((\"// \" + selector + \"{{\" + getName() + \"}}\").str());\n+  }\n+\n public:\n   bool isOwed() const { return state == State::Owed; }\n   FullfillmentToken fullfill() {\n@@ -410,7 +427,7 @@ bool DependencyVerifier::parseExpectations(\n \n bool DependencyVerifier::constructObligations(const SourceFile *SF,\n                                               ObligationMap &Obligations) {\n-  auto *tracker = SF->getReferencedNameTracker();\n+  auto *tracker = SF->getConfiguredReferencedNameTracker();\n   assert(tracker && \"Constructed source file without referenced name tracker!\");\n \n   auto &Ctx = SF->getASTContext();\n@@ -429,8 +446,9 @@ bool DependencyVerifier::constructObligations(const SourceFile *SF,\n           return;\n         case NodeKind::potentialMember: {\n           auto key = copyDemangledTypeName(Ctx, context);\n+          auto nameCpy = Ctx.AllocateCopy(name);\n           Obligations.insert({Obligation::Key::forPotentialMember(key),\n-                              {name, Expectation::Kind::PotentialMember,\n+                              {nameCpy, Expectation::Kind::PotentialMember,\n                                isCascadingUse ? Expectation::Scope::Cascading\n                                               : Expectation::Scope::Private}});\n         }\n@@ -439,23 +457,28 @@ bool DependencyVerifier::constructObligations(const SourceFile *SF,\n           auto demContext = copyDemangledTypeName(Ctx, context);\n           auto key = Ctx.AllocateCopy((demContext + \".\" + name).str());\n           Obligations.insert({Obligation::Key::forMember(key),\n-                              {context, Expectation::Kind::Member,\n+                              {key, Expectation::Kind::Member,\n                                isCascadingUse ? Expectation::Scope::Cascading\n                                               : Expectation::Scope::Private}});\n         }\n           break;\n-        case NodeKind::dynamicLookup:\n-          Obligations.insert({Obligation::Key::forDynamicMember(name),\n-                              {context, Expectation::Kind::DynamicMember,\n+        case NodeKind::dynamicLookup: {\n+          auto contextCpy = Ctx.AllocateCopy(context);\n+          auto key = Ctx.AllocateCopy(name);\n+          Obligations.insert({Obligation::Key::forDynamicMember(key),\n+                              {contextCpy, Expectation::Kind::DynamicMember,\n                                isCascadingUse ? Expectation::Scope::Cascading\n                                               : Expectation::Scope::Private}});\n           break;\n+        }\n         case NodeKind::topLevel:\n-        case NodeKind::sourceFileProvide:\n-          Obligations.insert({Obligation::Key::forProvides(name),\n-                              {name, Expectation::Kind::Provides,\n+        case NodeKind::sourceFileProvide: {\n+          auto key = Ctx.AllocateCopy(name);\n+          Obligations.insert({Obligation::Key::forProvides(key),\n+                              {key, Expectation::Kind::Provides,\n                                Expectation::Scope::None}});\n           break;\n+        }\n         case NodeKind::kindCount:\n           llvm_unreachable(\"Given count node?\");\n         }\n@@ -467,7 +490,7 @@ bool DependencyVerifier::constructObligations(const SourceFile *SF,\n bool DependencyVerifier::verifyObligations(\n     const SourceFile *SF, const std::vector<Expectation> &ExpectedDependencies,\n     ObligationMap &OM, llvm::StringMap<Expectation> &NegativeExpectations) {\n-  auto *tracker = SF->getReferencedNameTracker();\n+  auto *tracker = SF->getConfiguredReferencedNameTracker();\n   assert(tracker && \"Constructed source file without referenced name tracker!\");\n   auto &diags = SF->getASTContext().Diags;\n   for (auto &expectation : ExpectedDependencies) {\n@@ -564,6 +587,7 @@ bool DependencyVerifier::diagnoseUnfulfilledObligations(\n   CharSourceRange EntireRange = SM.getRangeForBuffer(*SF->getBufferID());\n   StringRef InputFile = SM.extractText(EntireRange);\n   auto &diags = SF->getASTContext().Diags;\n+  auto &Ctx = SF->getASTContext();\n   forEachOwedObligation(Obligations, [&](StringRef key, Obligation &p) {\n     // HACK: Diagnosing the end of the buffer will print a carat pointing\n     // at the file path, but not print any of the buffer's contents, which\n@@ -576,10 +600,12 @@ bool DependencyVerifier::diagnoseUnfulfilledObligations(\n     case Expectation::Kind::DynamicMember:\n     case Expectation::Kind::PotentialMember:\n       diags.diagnose(Loc, diag::unexpected_dependency, p.describeCascade(),\n-                     static_cast<uint8_t>(p.getKind()), key);\n+                     static_cast<uint8_t>(p.getKind()), key)\n+        .fixItInsert(Loc, p.renderAsFixit(Ctx));\n       break;\n     case Expectation::Kind::Provides:\n-      diags.diagnose(Loc, diag::unexpected_provided_entity, p.getName());\n+      diags.diagnose(Loc, diag::unexpected_provided_entity, p.getName())\n+        .fixItInsert(Loc, p.renderAsFixit(Ctx));\n       break;\n     }\n   });"
                    },
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -24,132 +24,79 @@\n \n using namespace swift;\n \n+namespace swift {\n+struct ExpectedFixIt {\n+  const char *StartLoc, *EndLoc; // The loc of the {{ and }}'s.\n+  unsigned StartCol;\n+  unsigned EndCol;\n+  std::string Text;\n+};\n+} // end namespace swift\n+\n namespace {\n-  struct ExpectedFixIt {\n-    const char *StartLoc, *EndLoc;   // The loc of the {{ and }}'s.\n-    unsigned StartCol;\n-    unsigned EndCol;\n-    std::string Text;\n-  };\n+struct ExpectedDiagnosticInfo {\n+  // This specifies the full range of the \"expected-foo {{}}\" specifier.\n+  const char *ExpectedStart, *ExpectedEnd = nullptr;\n \n-  struct ExpectedDiagnosticInfo {\n-    // This specifies the full range of the \"expected-foo {{}}\" specifier.\n-    const char *ExpectedStart, *ExpectedEnd = nullptr;\n+  DiagnosticKind Classification;\n \n-    llvm::SourceMgr::DiagKind Classification;\n-    \n-    // This is true if a '*' constraint is present to say that the diagnostic\n-    // may appear (or not) an uncounted number of times.\n-    bool mayAppear = false;\n-      \n-    // This is true if a '{{none}}' is present to mark that there should be no\n-    // extra fixits.\n-    bool noExtraFixitsMayAppear = false;\n+  // This is true if a '*' constraint is present to say that the diagnostic\n+  // may appear (or not) an uncounted number of times.\n+  bool mayAppear = false;\n \n-    // This is the raw input buffer for the message text, the part in the\n-    // {{...}}\n-    StringRef MessageRange;\n-    \n-    // This is the message string with escapes expanded.\n-    std::string MessageStr;\n-    unsigned LineNo = ~0U;\n-    Optional<unsigned> ColumnNo;\n+  // This is true if a '{{none}}' is present to mark that there should be no\n+  // extra fixits.\n+  bool noExtraFixitsMayAppear = false;\n \n-    std::vector<ExpectedFixIt> Fixits;\n+  // This is the raw input buffer for the message text, the part in the\n+  // {{...}}\n+  StringRef MessageRange;\n \n-    ExpectedDiagnosticInfo(const char *ExpectedStart,\n-                           llvm::SourceMgr::DiagKind Classification)\n-      : ExpectedStart(ExpectedStart), Classification(Classification) {\n-    }\n-    \n-  };\n-} // end anonymous namespace\n+  // This is the message string with escapes expanded.\n+  std::string MessageStr;\n+  unsigned LineNo = ~0U;\n+  Optional<unsigned> ColumnNo;\n+\n+  std::vector<ExpectedFixIt> Fixits;\n \n-static std::string getDiagKindString(llvm::SourceMgr::DiagKind Kind) {\n+  ExpectedDiagnosticInfo(const char *ExpectedStart,\n+                         DiagnosticKind Classification)\n+      : ExpectedStart(ExpectedStart), Classification(Classification) {}\n+};\n+\n+static std::string getDiagKindString(DiagnosticKind Kind) {\n   switch (Kind) {\n-  case llvm::SourceMgr::DK_Error: return \"error\";\n-  case llvm::SourceMgr::DK_Warning: return \"warning\";\n-  case llvm::SourceMgr::DK_Note: return \"note\";\n-  case llvm::SourceMgr::DK_Remark: return \"remark\";\n+  case DiagnosticKind::Error:\n+    return \"error\";\n+  case DiagnosticKind::Warning:\n+    return \"warning\";\n+  case DiagnosticKind::Note:\n+    return \"note\";\n+  case DiagnosticKind::Remark:\n+    return \"remark\";\n   }\n \n   llvm_unreachable(\"Unhandled DiagKind in switch.\");\n }\n \n-\n-\n-namespace {\n-  /// This class implements support for -verify mode in the compiler.  It\n-  /// buffers up diagnostics produced during compilation, then checks them\n-  /// against expected-error markers in the source file.\n-  class DiagnosticVerifier {\n-    SourceManager &SM;\n-    std::vector<llvm::SMDiagnostic> CapturedDiagnostics;\n-  public:\n-    explicit DiagnosticVerifier(SourceManager &SM) : SM(SM) {}\n-\n-    void addDiagnostic(const llvm::SMDiagnostic &Diag) {\n-      CapturedDiagnostics.push_back(Diag);\n-    }\n-\n-    /// Result of verifying a file.\n-    struct Result {\n-      /// Were there any errors? All of the following are considered errors:\n-      /// - Expected diagnostics that were not present\n-      /// - Unexpected diagnostics that were present\n-      /// - Errors in the definition of expected diagnostics\n-      bool HadError;\n-      bool HadUnexpectedDiag;\n-    };\n-\n-    /// verifyFile - After the file has been processed, check to see if we\n-    /// got all of the expected diagnostics and check to see if there were any\n-    /// unexpected ones.\n-    Result verifyFile(unsigned BufferID, bool autoApplyFixes);\n-\n-    /// diagnostics for '<unknown>:0' should be considered as unexpected.\n-    bool verifyUnknown();\n-\n-    void printRemainingDiagnostics() const;\n-\n-    /// If there are any -verify errors (e.g. differences between expectations\n-    /// and actual diagnostics produced), apply fixits to the original source\n-    /// file and drop it back in place.\n-    void autoApplyFixes(unsigned BufferID,\n-                        ArrayRef<llvm::SMDiagnostic> diagnostics);\n-    \n-  private:\n-    std::vector<llvm::SMDiagnostic>::iterator\n-    findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n-                   StringRef BufferName);\n-\n-  };\n-} // end anonymous namespace\n-\n-\n-\n-\n /// If we find the specified diagnostic in the list, return it.\n /// Otherwise return CapturedDiagnostics.end().\n-std::vector<llvm::SMDiagnostic>::iterator\n-DiagnosticVerifier::findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n-                                   StringRef BufferName) {\n+static std::vector<CapturedDiagnosticInfo>::iterator\n+findDiagnostic(std::vector<CapturedDiagnosticInfo> &CapturedDiagnostics,\n+               const ExpectedDiagnosticInfo &Expected, StringRef BufferName) {\n   for (auto I = CapturedDiagnostics.begin(), E = CapturedDiagnostics.end();\n        I != E; ++I) {\n     // Verify the file and line of the diagnostic.\n-    if (I->getLineNo() != (int)Expected.LineNo ||\n-        I->getFilename() != BufferName)\n+    if (I->Line != Expected.LineNo || I->FileName != BufferName)\n       continue;\n \n-    // If a specific column was expected, verify it. Add one to the captured\n-    // index so expected column numbers correspond to printed output.\n-    if (Expected.ColumnNo.hasValue() &&\n-        I->getColumnNo() + 1 != (int)*Expected.ColumnNo)\n+    // If a specific column was expected, verify it.\n+    if (Expected.ColumnNo.hasValue() && I->Column != *Expected.ColumnNo)\n       continue;\n \n     // Verify the classification and string.\n-    if (I->getKind() != Expected.Classification ||\n-        I->getMessage().find(Expected.MessageStr) == StringRef::npos)\n+    if (I->Classification != Expected.Classification ||\n+        I->Message.find(Expected.MessageStr) == StringRef::npos)\n       continue;\n \n     // Okay, we found a match, hurray!\n@@ -159,6 +106,105 @@ DiagnosticVerifier::findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n   return CapturedDiagnostics.end();\n }\n \n+/// If there are any -verify errors (e.g. differences between expectations\n+/// and actual diagnostics produced), apply fixits to the original source\n+/// file and drop it back in place.\n+static void autoApplyFixes(SourceManager &SM, unsigned BufferID,\n+                           ArrayRef<llvm::SMDiagnostic> diags) {\n+  // Walk the list of diagnostics, pulling out any fixits into an array of just\n+  // them.\n+  SmallVector<llvm::SMFixIt, 4> FixIts;\n+  for (auto &diag : diags)\n+    FixIts.append(diag.getFixIts().begin(), diag.getFixIts().end());\n+\n+  // If we have no fixits to apply, avoid touching the file.\n+  if (FixIts.empty())\n+    return;\n+\n+  // Sort the fixits by their start location.\n+  std::sort(FixIts.begin(), FixIts.end(),\n+            [&](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) -> bool {\n+              return lhs.getRange().Start.getPointer() <\n+                     rhs.getRange().Start.getPointer();\n+            });\n+  // Coalesce identical fix-its. This happens most often with \"expected-error 2\"\n+  // syntax.\n+  FixIts.erase(std::unique(FixIts.begin(), FixIts.end(),\n+                           [](const llvm::SMFixIt &lhs,\n+                              const llvm::SMFixIt &rhs) -> bool {\n+                             return lhs.getRange().Start ==\n+                                        rhs.getRange().Start &&\n+                                    lhs.getRange().End == rhs.getRange().End &&\n+                                    lhs.getText() == rhs.getText();\n+                           }),\n+               FixIts.end());\n+  // Filter out overlapping fix-its. This allows the compiler to apply changes\n+  // to the easy parts of the file, and leave in the tricky cases for the\n+  // developer to handle manually.\n+  FixIts.erase(swift::removeAdjacentIf(\n+                   FixIts.begin(), FixIts.end(),\n+                   [](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) {\n+                     return lhs.getRange().End.getPointer() >\n+                            rhs.getRange().Start.getPointer();\n+                   }),\n+               FixIts.end());\n+\n+  // Get the contents of the original source file.\n+  auto memBuffer = SM.getLLVMSourceMgr().getMemoryBuffer(BufferID);\n+  auto bufferRange = memBuffer->getBuffer();\n+\n+  // Apply the fixes, building up a new buffer as an std::string.\n+  const char *LastPos = bufferRange.begin();\n+  std::string Result;\n+\n+  for (auto &fix : FixIts) {\n+    // We cannot handle overlapping fixits, so assert that they don't happen.\n+    assert(LastPos <= fix.getRange().Start.getPointer() &&\n+           \"Cannot handle overlapping fixits\");\n+\n+    // Keep anything from the last spot we've checked to the start of the fixit.\n+    Result.append(LastPos, fix.getRange().Start.getPointer());\n+\n+    // Replace the content covered by the fixit with the replacement text.\n+    Result.append(fix.getText().begin(), fix.getText().end());\n+\n+    // Next character to consider is at the end of the fixit.\n+    LastPos = fix.getRange().End.getPointer();\n+  }\n+\n+  // Retain the end of the file.\n+  Result.append(LastPos, bufferRange.end());\n+\n+  std::error_code error;\n+  llvm::raw_fd_ostream outs(memBuffer->getBufferIdentifier(), error,\n+                            llvm::sys::fs::OpenFlags::F_None);\n+  if (!error)\n+    outs << Result;\n+}\n+\n+/// diagnostics for '<unknown>:0' should be considered as unexpected.\n+static bool\n+verifyUnknown(SourceManager &SM,\n+              std::vector<CapturedDiagnosticInfo> &CapturedDiagnostics) {\n+  bool HadError = false;\n+  for (unsigned i = 0, e = CapturedDiagnostics.size(); i != e; ++i) {\n+    if (CapturedDiagnostics[i].Loc.isValid())\n+      continue;\n+\n+    HadError = true;\n+    std::string Message =\n+        (\"unexpected \" +\n+         getDiagKindString(CapturedDiagnostics[i].Classification) +\n+         \" produced: \" + CapturedDiagnostics[i].Message)\n+            .str();\n+\n+    auto diag = SM.GetMessage({}, llvm::SourceMgr::DK_Error, Message, {}, {});\n+    SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), diag);\n+  }\n+  return HadError;\n+}\n+} // end anonymous namespace\n+\n static unsigned getColumnNumber(StringRef buffer, llvm::SMLoc loc) {\n   assert(loc.getPointer() >= buffer.data());\n   assert((size_t)(loc.getPointer() - buffer.data()) <= buffer.size());\n@@ -175,17 +221,18 @@ static unsigned getColumnNumber(StringRef buffer, llvm::SMLoc loc) {\n \n /// Return true if the given \\p ExpectedFixIt is in the fix-its emitted by\n /// diagnostic \\p D.\n-static bool checkForFixIt(const ExpectedFixIt &Expected,\n-                          const llvm::SMDiagnostic &D,\n-                          StringRef buffer) {\n-  for (auto &ActualFixIt : D.getFixIts()) {\n+bool DiagnosticVerifier::checkForFixIt(const ExpectedFixIt &Expected,\n+                                       const CapturedDiagnosticInfo &D,\n+                                       StringRef buffer) {\n+  for (auto &ActualFixIt : D.FixIts) {\n     if (ActualFixIt.getText() != Expected.Text)\n       continue;\n \n-    llvm::SMRange Range = ActualFixIt.getRange();\n-    if (getColumnNumber(buffer, Range.Start) != Expected.StartCol)\n+    CharSourceRange Range = ActualFixIt.getRange();\n+    if (getColumnNumber(buffer, getRawLoc(Range.getStart())) !=\n+        Expected.StartCol)\n       continue;\n-    if (getColumnNumber(buffer, Range.End) != Expected.EndCol)\n+    if (getColumnNumber(buffer, getRawLoc(Range.getEnd())) != Expected.EndCol)\n       continue;\n \n     return true;\n@@ -194,16 +241,20 @@ static bool checkForFixIt(const ExpectedFixIt &Expected,\n   return false;\n }\n \n-static std::string renderFixits(ArrayRef<llvm::SMFixIt> fixits,\n-                                StringRef InputFile) {\n+std::string\n+DiagnosticVerifier::renderFixits(ArrayRef<DiagnosticInfo::FixIt> fixits,\n+                                 StringRef InputFile) {\n   std::string Result;\n   llvm::raw_string_ostream OS(Result);\n   interleave(fixits,\n-             [&](const llvm::SMFixIt &ActualFixIt) {\n-               llvm::SMRange Range = ActualFixIt.getRange();\n+             [&](const DiagnosticInfo::FixIt &ActualFixIt) {\n+               CharSourceRange Range = ActualFixIt.getRange();\n \n-               OS << \"{{\" << getColumnNumber(InputFile, Range.Start) << '-'\n-                  << getColumnNumber(InputFile, Range.End) << '=';\n+               OS << \"{{\"\n+                  << getColumnNumber(InputFile, getRawLoc(Range.getStart()))\n+                  << '-'\n+                  << getColumnNumber(InputFile, getRawLoc(Range.getEnd()))\n+                  << '=';\n \n                for (auto C : ActualFixIt.getText()) {\n                  if (C == '\\n')\n@@ -222,8 +273,7 @@ static std::string renderFixits(ArrayRef<llvm::SMFixIt> fixits,\n /// After the file has been processed, check to see if we got all of\n /// the expected diagnostics and check to see if there were any unexpected\n /// ones.\n-DiagnosticVerifier::Result\n-DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n+DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n   using llvm::SMLoc;\n   \n   const SourceLoc BufferStartLoc = SM.getLocForBufferStart(BufferID);\n@@ -256,18 +306,18 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n     StringRef MatchStart = InputFile.substr(Match);\n     const char *DiagnosticLoc = MatchStart.data();\n \n-    llvm::SourceMgr::DiagKind ExpectedClassification;\n+    DiagnosticKind ExpectedClassification;\n     if (MatchStart.startswith(\"expected-note\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Note;\n+      ExpectedClassification = DiagnosticKind::Note;\n       MatchStart = MatchStart.substr(strlen(\"expected-note\"));\n     } else if (MatchStart.startswith(\"expected-warning\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Warning;\n+      ExpectedClassification = DiagnosticKind::Warning;\n       MatchStart = MatchStart.substr(strlen(\"expected-warning\"));\n     } else if (MatchStart.startswith(\"expected-error\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Error;\n+      ExpectedClassification = DiagnosticKind::Error;\n       MatchStart = MatchStart.substr(strlen(\"expected-error\"));\n     } else if (MatchStart.startswith(\"expected-remark\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Remark;\n+      ExpectedClassification = DiagnosticKind::Remark;\n       MatchStart = MatchStart.substr(strlen(\"expected-remark\"));\n     } else\n       continue;\n@@ -479,13 +529,14 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Make sure all the expected diagnostics appeared.\n   std::reverse(ExpectedDiagnostics.begin(), ExpectedDiagnostics.end());\n-  \n+\n   for (unsigned i = ExpectedDiagnostics.size(); i != 0; ) {\n     --i;\n     auto &expected = ExpectedDiagnostics[i];\n-    \n+\n     // Check to see if we had this expected diagnostic.\n-    auto FoundDiagnosticIter = findDiagnostic(expected, BufferName);\n+    auto FoundDiagnosticIter =\n+        findDiagnostic(CapturedDiagnostics, expected, BufferName);\n     if (FoundDiagnosticIter == CapturedDiagnostics.end()) {\n       // Diagnostic didn't exist.  If this is a 'mayAppear' diagnostic, then\n       // we're ok.  Otherwise, leave it in the list.\n@@ -505,20 +556,20 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n     }\n \n     bool matchedAllFixIts =\n-      expected.Fixits.size() == FoundDiagnostic.getFixIts().size();\n-    \n+        expected.Fixits.size() == FoundDiagnostic.FixIts.size();\n+\n     // If we have any expected fixits that didn't get matched, then they are\n     // wrong.  Replace the failed fixit with what actually happened.\n     if (IncorrectFixit) {\n-      if (FoundDiagnostic.getFixIts().empty()) {\n+      if (FoundDiagnostic.FixIts.empty()) {\n         addError(IncorrectFixit, \"expected fix-it not seen\");\n       } else {\n         // If we had an incorrect expected fixit, render it and produce a fixit\n         // of our own.\n-        auto actual = renderFixits(FoundDiagnostic.getFixIts(), InputFile);\n+        auto actual = renderFixits(FoundDiagnostic.FixIts, InputFile);\n         auto replStartLoc = SMLoc::getFromPointer(expected.Fixits[0].StartLoc);\n         auto replEndLoc = SMLoc::getFromPointer(expected.Fixits.back().EndLoc);\n-        \n+\n         llvm::SMFixIt fix(llvm::SMRange(replStartLoc, replEndLoc), actual);\n         addError(IncorrectFixit,\n                  \"expected fix-it not seen; actual fix-its: \" + actual, fix);\n@@ -528,9 +579,9 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n                !expected.mayAppear) {\n       // If there was no fixit specification, but some were produced, add a\n       // fixit to add them in.\n-      auto actual = renderFixits(FoundDiagnostic.getFixIts(), InputFile);\n+      auto actual = renderFixits(FoundDiagnostic.FixIts, InputFile);\n       auto replStartLoc = SMLoc::getFromPointer(expected.ExpectedEnd - 8); // {{none}} length\n-      auto replEndLoc = SMLoc::getFromPointer(expected.ExpectedEnd - 1);\n+      auto replEndLoc = SMLoc::getFromPointer(expected.ExpectedEnd);\n \n       llvm::SMFixIt fix(llvm::SMRange(replStartLoc, replEndLoc), actual);\n       addError(replStartLoc.getPointer(), \"expected no fix-its; actual fix-it seen: \" + actual, fix);\n@@ -551,46 +602,46 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Check to see if we have any incorrect diagnostics.  If so, diagnose them as\n   // such.\n-  for (unsigned i = ExpectedDiagnostics.size(); i != 0; ) {\n-    --i;\n-    auto &expected = ExpectedDiagnostics[i];\n-\n+  auto expectedDiagIter = ExpectedDiagnostics.begin();\n+  while (expectedDiagIter != ExpectedDiagnostics.end()) {\n     // Check to see if any found diagnostics have the right line and\n     // classification, but the wrong text.\n     auto I = CapturedDiagnostics.begin();\n     for (auto E = CapturedDiagnostics.end(); I != E; ++I) {\n       // Verify the file and line of the diagnostic.\n-      if (I->getLineNo() != (int)expected.LineNo ||\n-          I->getFilename() != BufferName ||\n-          I->getKind() != expected.Classification)\n+      if (I->Line != expectedDiagIter->LineNo || I->FileName != BufferName ||\n+          I->Classification != expectedDiagIter->Classification)\n         continue;\n       \n       // Otherwise, we found it, break out.\n       break;\n     }\n \n-    if (I == CapturedDiagnostics.end()) continue;\n+    if (I == CapturedDiagnostics.end()) {\n+      expectedDiagIter++;\n+      continue;\n+    }\n \n-    if (I->getMessage().find(expected.MessageStr) == StringRef::npos) {\n-      auto StartLoc = SMLoc::getFromPointer(expected.MessageRange.begin());\n-      auto EndLoc = SMLoc::getFromPointer(expected.MessageRange.end());\n+    if (I->Message.find(expectedDiagIter->MessageStr) == StringRef::npos) {\n+      auto StartLoc =\n+          SMLoc::getFromPointer(expectedDiagIter->MessageRange.begin());\n+      auto EndLoc = SMLoc::getFromPointer(expectedDiagIter->MessageRange.end());\n \n-      llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->getMessage());\n-      addError(expected.MessageRange.begin(), \"incorrect message found\", fixIt);\n-    } else if (I->getColumnNo() + 1 != (int)*expected.ColumnNo) {\n+      llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->Message);\n+      addError(expectedDiagIter->MessageRange.begin(),\n+               \"incorrect message found\", fixIt);\n+    } else if (I->Column != *expectedDiagIter->ColumnNo) {\n       // The difference must be only in the column\n-      addError(expected.MessageRange.begin(),\n+      addError(expectedDiagIter->MessageRange.begin(),\n                llvm::formatv(\"message found at column {0} but was expected to \"\n                              \"appear at column {1}\",\n-                             I->getColumnNo() + 1, *expected.ColumnNo));\n+                             I->Column, *expectedDiagIter->ColumnNo));\n     } else {\n       llvm_unreachable(\"unhandled difference from expected diagnostic\");\n     }\n     CapturedDiagnostics.erase(I);\n-    ExpectedDiagnostics.erase(ExpectedDiagnostics.begin()+i);\n+    expectedDiagIter = ExpectedDiagnostics.erase(expectedDiagIter);\n   }\n-  \n-  \n \n   // Diagnose expected diagnostics that didn't appear.\n   std::reverse(ExpectedDiagnostics.begin(), ExpectedDiagnostics.end());\n@@ -645,19 +696,20 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Verify that there are no diagnostics (in MemoryBuffer) left in the list.\n   bool HadUnexpectedDiag = false;\n-  for (unsigned i = CapturedDiagnostics.size(); i != 0; ) {\n-    --i;\n-    if (CapturedDiagnostics[i].getFilename() != BufferName) {\n+  auto CapturedDiagIter = CapturedDiagnostics.begin();\n+  while (CapturedDiagIter != CapturedDiagnostics.end()) {\n+    if (CapturedDiagIter->FileName != BufferName) {\n+      CapturedDiagIter++;\n       continue;\n     }\n \n     HadUnexpectedDiag = true;\n     std::string Message =\n-      \"unexpected \"+getDiagKindString(CapturedDiagnostics[i].getKind())+\n-      \" produced: \"+CapturedDiagnostics[i].getMessage().str();\n-    addError(CapturedDiagnostics[i].getLoc().getPointer(),\n-             Message);\n-    CapturedDiagnostics.erase(CapturedDiagnostics.begin() + i);\n+        (\"unexpected \" + getDiagKindString(CapturedDiagIter->Classification) +\n+         \" produced: \" + CapturedDiagIter->Message)\n+            .str();\n+    addError(getRawLoc(CapturedDiagIter->Loc).getPointer(), Message);\n+    CapturedDiagIter = CapturedDiagnostics.erase(CapturedDiagIter);\n   }\n \n   // Sort the diagnostics by their address in the memory buffer as the primary\n@@ -672,111 +724,40 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   // Emit all of the queue'd up errors.\n   for (auto Err : Errors)\n     SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), Err);\n-  \n+\n   // If auto-apply fixits is on, rewrite the original source file.\n-  if (shouldAutoApplyFixes)\n-    autoApplyFixes(BufferID, Errors);\n+  if (AutoApplyFixes)\n+    autoApplyFixes(SM, BufferID, Errors);\n \n   return Result{!Errors.empty(), HadUnexpectedDiag};\n }\n \n-bool DiagnosticVerifier::verifyUnknown() {\n-  bool HadError = false;\n-  for (unsigned i = 0, e = CapturedDiagnostics.size(); i != e; ++i) {\n-    if (CapturedDiagnostics[i].getFilename() != \"<unknown>\")\n-      continue;\n-\n-    HadError = true;\n-    std::string Message =\n-      \"unexpected \"+getDiagKindString(CapturedDiagnostics[i].getKind())+\n-      \" produced: \"+CapturedDiagnostics[i].getMessage().str();\n-\n-    auto diag = SM.GetMessage({}, llvm::SourceMgr::DK_Error, Message,\n-                              {}, {});\n-    SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), diag);\n-  }\n-  return HadError;\n-}\n-\n void DiagnosticVerifier::printRemainingDiagnostics() const {\n   for (const auto &diag : CapturedDiagnostics) {\n-    SM.getLLVMSourceMgr().PrintMessage(\n-        llvm::errs(), diag.getLoc(), diag.getKind(),\n-        \"diagnostic produced elsewhere: \" + diag.getMessage(),\n-        /*Ranges=*/ {}, diag.getFixIts());\n-  }\n-}\n-\n-/// If there are any -verify errors (e.g. differences between expectations\n-/// and actual diagnostics produced), apply fixits to the original source\n-/// file and drop it back in place.\n-void DiagnosticVerifier::autoApplyFixes(unsigned BufferID,\n-                                        ArrayRef<llvm::SMDiagnostic> diags) {\n-  // Walk the list of diagnostics, pulling out any fixits into an array of just\n-  // them.\n-  SmallVector<llvm::SMFixIt, 4> FixIts;\n-  for (auto &diag : diags)\n-    FixIts.append(diag.getFixIts().begin(), diag.getFixIts().end());\n+    // Determine what kind of diagnostic we're emitting.\n+    llvm::SourceMgr::DiagKind SMKind;\n+    switch (diag.Classification) {\n+    case DiagnosticKind::Error:\n+      SMKind = llvm::SourceMgr::DK_Error;\n+      break;\n+    case DiagnosticKind::Warning:\n+      SMKind = llvm::SourceMgr::DK_Warning;\n+      break;\n \n-  // If we have no fixits to apply, avoid touching the file.\n-  if (FixIts.empty())\n-    return;\n-  \n-  // Sort the fixits by their start location.\n-  std::sort(FixIts.begin(), FixIts.end(),\n-            [&](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) -> bool {\n-              return lhs.getRange().Start.getPointer()\n-                   < rhs.getRange().Start.getPointer();\n-            });\n-  // Coalesce identical fix-its. This happens most often with \"expected-error 2\"\n-  // syntax.\n-  FixIts.erase(std::unique(FixIts.begin(), FixIts.end(),\n-                           [](const llvm::SMFixIt &lhs,\n-                              const llvm::SMFixIt &rhs) -> bool {\n-                 return lhs.getRange().Start == rhs.getRange().Start &&\n-                        lhs.getRange().End == rhs.getRange().End &&\n-                        lhs.getText() == rhs.getText();\n-               }), FixIts.end());\n-  // Filter out overlapping fix-its. This allows the compiler to apply changes\n-  // to the easy parts of the file, and leave in the tricky cases for the\n-  // developer to handle manually.\n-  FixIts.erase(swift::removeAdjacentIf(FixIts.begin(), FixIts.end(),\n-                                       [](const llvm::SMFixIt &lhs,\n-                                          const llvm::SMFixIt &rhs) {\n-    return lhs.getRange().End.getPointer() > rhs.getRange().Start.getPointer();\n-  }), FixIts.end());\n+    case DiagnosticKind::Note:\n+      SMKind = llvm::SourceMgr::DK_Note;\n+      break;\n \n-  // Get the contents of the original source file.\n-  auto memBuffer = SM.getLLVMSourceMgr().getMemoryBuffer(BufferID);\n-  auto bufferRange = memBuffer->getBuffer();\n+    case DiagnosticKind::Remark:\n+      SMKind = llvm::SourceMgr::DK_Remark;\n+      break;\n+    }\n \n-  // Apply the fixes, building up a new buffer as an std::string.\n-  const char *LastPos = bufferRange.begin();\n-  std::string Result;\n-  \n-  for (auto &fix : FixIts) {\n-    // We cannot handle overlapping fixits, so assert that they don't happen.\n-    assert(LastPos <= fix.getRange().Start.getPointer() &&\n-           \"Cannot handle overlapping fixits\");\n-    \n-    // Keep anything from the last spot we've checked to the start of the fixit.\n-    Result.append(LastPos, fix.getRange().Start.getPointer());\n-    \n-    // Replace the content covered by the fixit with the replacement text.\n-    Result.append(fix.getText().begin(), fix.getText().end());\n-    \n-    // Next character to consider is at the end of the fixit.\n-    LastPos = fix.getRange().End.getPointer();\n+    SM.getLLVMSourceMgr().PrintMessage(\n+        llvm::errs(), getRawLoc(diag.Loc), SMKind,\n+        \"diagnostic produced by elsewhere: \" + diag.Message.str(),\n+        /*Ranges=*/{}, {});\n   }\n-  \n-  // Retain the end of the file.\n-  Result.append(LastPos, bufferRange.end());\n-\n-  std::error_code error;\n-  llvm::raw_fd_ostream outs(memBuffer->getBufferIdentifier(), error,\n-                            llvm::sys::fs::OpenFlags::F_None);\n-  if (!error)\n-    outs << Result;\n }\n \n //===----------------------------------------------------------------------===//\n@@ -786,42 +767,48 @@ void DiagnosticVerifier::autoApplyFixes(unsigned BufferID,\n /// Every time a diagnostic is generated in -verify mode, this function is\n /// called with the diagnostic.  We just buffer them up until the end of the\n /// file.\n-static void VerifyModeDiagnosticHook(const llvm::SMDiagnostic &Diag,\n-                                     void *Context) {\n-  ((DiagnosticVerifier*)Context)->addDiagnostic(Diag);\n-}\n-\n+void DiagnosticVerifier::handleDiagnostic(SourceManager &SM,\n+                                          const DiagnosticInfo &Info) {\n+  SmallVector<DiagnosticInfo::FixIt, 2> fixIts;\n+  std::copy(Info.FixIts.begin(), Info.FixIts.end(), std::back_inserter(fixIts));\n+\n+  llvm::SmallString<128> message;\n+  {\n+    llvm::raw_svector_ostream Out(message);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n+  }\n \n-void swift::enableDiagnosticVerifier(SourceManager &SM) {\n-  SM.getLLVMSourceMgr().setDiagHandler(VerifyModeDiagnosticHook,\n-                                       new DiagnosticVerifier(SM));\n+  if (Info.Loc.isValid()) {\n+    const auto lineAndColumn = SM.getLineAndColumn(Info.Loc);\n+    const auto fileName = SM.getDisplayNameForLoc(Info.Loc);\n+    CapturedDiagnostics.emplace_back(message, fileName, Info.Kind, Info.Loc,\n+                                     lineAndColumn.first, lineAndColumn.second,\n+                                     fixIts);\n+  } else {\n+    CapturedDiagnostics.emplace_back(message, StringRef(), Info.Kind, Info.Loc,\n+                                     0, 0, fixIts);\n+  }\n }\n \n-bool swift::verifyDiagnostics(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n-                              bool autoApplyFixes, bool ignoreUnknown) {\n-  auto *Verifier = (DiagnosticVerifier*)SM.getLLVMSourceMgr().getDiagContext();\n-  SM.getLLVMSourceMgr().setDiagHandler(nullptr, nullptr);\n-  \n+/// Once all diagnostics have been captured, perform verification.\n+bool DiagnosticVerifier::finishProcessing() {\n   DiagnosticVerifier::Result Result = {false, false};\n \n   for (auto &BufferID : BufferIDs) {\n-    DiagnosticVerifier::Result FileResult =\n-        Verifier->verifyFile(BufferID, autoApplyFixes);\n+    DiagnosticVerifier::Result FileResult = verifyFile(BufferID);\n     Result.HadError |= FileResult.HadError;\n     Result.HadUnexpectedDiag |= FileResult.HadUnexpectedDiag;\n   }\n-  if (!ignoreUnknown) {\n-    bool HadError = Verifier->verifyUnknown();\n+  if (!IgnoreUnknown) {\n+    bool HadError = verifyUnknown(SM, CapturedDiagnostics);\n     Result.HadError |= HadError;\n     // For <unknown>, all errors are unexpected.\n     Result.HadUnexpectedDiag |= HadError;\n   }\n \n   if (Result.HadUnexpectedDiag)\n-    Verifier->printRemainingDiagnostics();\n-\n-  delete Verifier;\n+    printRemainingDiagnostics();\n \n   return Result.HadError;\n }\n-"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -240,7 +240,6 @@ bool CompilerInstance::setUpASTContextIfNeeded() {\n   if (setUpModuleLoaders())\n     return true;\n \n-  Context->setLegacySemanticQueriesEnabled();\n   return false;\n }\n \n@@ -294,6 +293,17 @@ void CompilerInstance::setupStatsReporter() {\n   Stats = std::move(Reporter);\n }\n \n+void CompilerInstance::setupDiagnosticVerifierIfNeeded() {\n+  auto &diagOpts = Invocation.getDiagnosticOptions();\n+  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n+    DiagVerifier = std::make_unique<DiagnosticVerifier>(\n+        SourceMgr, InputSourceCodeBufferIDs,\n+        diagOpts.VerifyMode == DiagnosticOptions::VerifyAndApplyFixes,\n+        diagOpts.VerifyIgnoreUnknown);\n+    addDiagnosticConsumer(DiagVerifier.get());\n+  }\n+}\n+\n bool CompilerInstance::setup(const CompilerInvocation &Invok) {\n   Invocation = Invok;\n \n@@ -338,6 +348,7 @@ bool CompilerInstance::setup(const CompilerInvocation &Invok) {\n     return true;\n \n   setupStatsReporter();\n+  setupDiagnosticVerifierIfNeeded();\n \n   return false;\n }\n@@ -411,9 +422,6 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().PrintDiagnosticNames) {\n     Diagnostics.setPrintDiagnosticNames(true);\n   }\n-  if (Invocation.getDiagnosticOptions().EnableEducationalNotes) {\n-    Diagnostics.setUseEducationalNotes(true);\n-  }\n   Diagnostics.setDiagnosticDocumentationPath(\n       Invocation.getDiagnosticOptions().DiagnosticDocumentationPath);\n }\n@@ -756,7 +764,7 @@ shouldImplicityImportSwiftOnoneSupportModule(CompilerInvocation &Invocation) {\n }\n \n void CompilerInstance::performParseAndResolveImportsOnly() {\n-  performSemaUpTo(SourceFile::NameBound);\n+  performSemaUpTo(SourceFile::ImportsResolved);\n }\n \n void CompilerInstance::performSema() {\n@@ -930,12 +938,12 @@ void CompilerInstance::parseAndCheckTypesUpTo(\n     auto *SF = dyn_cast<SourceFile>(File);\n     if (!SF)\n       return true;\n-    return SF->ASTStage >= SourceFile::NameBound;\n+    return SF->ASTStage >= SourceFile::ImportsResolved;\n   }) && \"some files have not yet had their imports resolved\");\n   MainModule->setHasResolvedImports();\n \n   forEachFileToTypeCheck([&](SourceFile &SF) {\n-    if (limitStage == SourceFile::NameBound) {\n+    if (limitStage == SourceFile::ImportsResolved) {\n       bindExtensions(SF);\n       return;\n     }\n@@ -955,8 +963,8 @@ void CompilerInstance::parseAndCheckTypesUpTo(\n     }\n   });\n \n-  // If the limiting AST stage is name binding, we're done.\n-  if (limitStage <= SourceFile::NameBound) {\n+  // If the limiting AST stage is import resolution, we're done.\n+  if (limitStage <= SourceFile::ImportsResolved) {\n     return;\n   }\n \n@@ -971,8 +979,8 @@ void CompilerInstance::parseLibraryFile(\n       SourceFileKind::Library, implicitImports.kind, BufferID);\n   addAdditionalInitialImportsTo(NextInput, implicitImports);\n \n-  // Name binding will lazily trigger parsing of the file.\n-  performNameBinding(*NextInput);\n+  // Import resolution will lazily trigger parsing of the file.\n+  performImportResolution(*NextInput);\n }\n \n bool CompilerInstance::parsePartialModulesAndLibraryFiles(\n@@ -1001,7 +1009,7 @@ bool CompilerInstance::parsePartialModulesAndLibraryFiles(\n \n void CompilerInstance::parseAndTypeCheckMainFileUpTo(\n     SourceFile::ASTStage_t LimitStage) {\n-  assert(LimitStage >= SourceFile::NameBound);\n+  assert(LimitStage >= SourceFile::ImportsResolved);\n   FrontendStatsTracer tracer(getStatsReporter(),\n                              \"parse-and-typecheck-main-file\");\n   bool mainIsPrimary =\n@@ -1014,13 +1022,13 @@ void CompilerInstance::parseAndTypeCheckMainFileUpTo(\n   auto DidSuppressWarnings = Diags.getSuppressWarnings();\n   Diags.setSuppressWarnings(DidSuppressWarnings || !mainIsPrimary);\n \n-  // For a primary, perform type checking if needed. Otherwise, just do name\n-  // binding.\n+  // For a primary, perform type checking if needed. Otherwise, just do import\n+  // resolution.\n   if (mainIsPrimary && LimitStage >= SourceFile::TypeChecked) {\n     performTypeChecking(MainFile);\n   } else {\n     assert(!TheSILModule && \"Should perform type checking for SIL\");\n-    performNameBinding(MainFile);\n+    performImportResolution(MainFile);\n   }\n \n   // Parse the SIL decls if needed."
                    },
                    {
                        "filename": "lib/Frontend/ModuleInterfaceBuilder.cpp",
                        "code": "@@ -137,8 +137,11 @@ void ModuleInterfaceBuilder::configureSubInvocation(\n bool ModuleInterfaceBuilder::extractSwiftInterfaceVersionAndArgs(\n     swift::version::Version &Vers, StringRef &CompilerVersion,\n     llvm::StringSaver &SubArgSaver, SmallVectorImpl<const char *> &SubArgs) {\n+  llvm::vfs::FileSystem &fs = *sourceMgr.getFileSystem();\n   auto FileOrError = swift::vfs::getFileOrSTDIN(fs, interfacePath);\n   if (!FileOrError) {\n+    // Don't use this->diagnose() because it'll just try to re-open\n+    // interfacePath.\n     diags.diagnose(diagnosticLoc, diag::error_open_input_file,\n                    interfacePath, FileOrError.getError().message());\n     return true;\n@@ -149,17 +152,16 @@ bool ModuleInterfaceBuilder::extractSwiftInterfaceVersionAndArgs(\n   auto FlagRe = getSwiftInterfaceModuleFlagsRegex();\n   SmallVector<StringRef, 1> VersMatches, FlagMatches, CompMatches;\n   if (!VersRe.match(SB, &VersMatches)) {\n-    diags.diagnose(diagnosticLoc,\n-                   diag::error_extracting_version_from_module_interface);\n+    diagnose(diag::error_extracting_version_from_module_interface);\n     return true;\n   }\n   if (!FlagRe.match(SB, &FlagMatches)) {\n-    diags.diagnose(diagnosticLoc,\n-                   diag::error_extracting_flags_from_module_interface);\n+    diagnose(diag::error_extracting_flags_from_module_interface);\n     return true;\n   }\n   assert(VersMatches.size() == 2);\n   assert(FlagMatches.size() == 2);\n+  // FIXME We should diagnose this at a location that makes sense:\n   Vers = swift::version::Version(VersMatches[1], SourceLoc(), &diags);\n   llvm::cl::TokenizeGNUCommandLine(FlagMatches[1], SubArgSaver, SubArgs);\n \n@@ -178,6 +180,8 @@ bool ModuleInterfaceBuilder::extractSwiftInterfaceVersionAndArgs(\n bool ModuleInterfaceBuilder::collectDepsForSerialization(\n     CompilerInstance &SubInstance, SmallVectorImpl<FileDependency> &Deps,\n     bool IsHashBased) {\n+  llvm::vfs::FileSystem &fs = *sourceMgr.getFileSystem();\n+\n   auto &Opts = SubInstance.getASTContext().SearchPathOpts;\n   SmallString<128> SDKPath(Opts.SDKPath);\n   path::native(SDKPath);\n@@ -267,6 +271,8 @@ bool ModuleInterfaceBuilder::buildSwiftModuleInternal(\n       llvm::RestorePrettyStackState(savedInnerPrettyStackState);\n     };\n \n+    llvm::vfs::FileSystem &fs = *sourceMgr.getFileSystem();\n+    \n     // Note that we don't assume cachePath is the same as the Clang\n     // module cache path at this point.\n     if (!moduleCachePath.empty())\n@@ -296,9 +302,8 @@ bool ModuleInterfaceBuilder::buildSwiftModuleInternal(\n     // minor versions might be interesting for debugging, or special-casing a\n     // compatible field variant.\n     if (Vers.asMajorVersion() != InterfaceFormatVersion.asMajorVersion()) {\n-      diags.diagnose(diagnosticLoc,\n-                     diag::unsupported_version_of_module_interface,\n-                     interfacePath, Vers);\n+      diagnose(diag::unsupported_version_of_module_interface, interfacePath,\n+               Vers);\n       SubError = true;\n       return;\n     }\n@@ -313,8 +318,7 @@ bool ModuleInterfaceBuilder::buildSwiftModuleInternal(\n       auto DiagKind = diag::serialization_name_mismatch;\n       if (subInvocation.getLangOptions().DebuggerSupport)\n         DiagKind = diag::serialization_name_mismatch_repl;\n-      diags.diagnose(diagnosticLoc, DiagKind, subInvocation.getModuleName(),\n-                     ExpectedModuleName);\n+      diagnose(DiagKind, subInvocation.getModuleName(), ExpectedModuleName);\n       SubError = true;\n       return;\n     }\n@@ -341,9 +345,9 @@ bool ModuleInterfaceBuilder::buildSwiftModuleInternal(\n         auto builtByCompiler =\n             getSwiftInterfaceCompilerVersionForCurrentCompiler(\n                 SubInstance.getASTContext());\n-        diags.diagnose(diagnosticLoc, diag::module_interface_build_failed,\n-                       moduleName, emittedByCompiler == builtByCompiler,\n-                       emittedByCompiler, builtByCompiler);\n+        diagnose(diag::module_interface_build_failed, moduleName,\n+                 emittedByCompiler == builtByCompiler, emittedByCompiler,\n+                 builtByCompiler);\n       }\n     };\n \n@@ -439,8 +443,7 @@ bool ModuleInterfaceBuilder::buildSwiftModule(StringRef OutPath,\n     // necessary for performance. Fallback to building the module in case of any lock\n     // related errors.\n     if (RemarkRebuild) {\n-      diags.diagnose(SourceLoc(), diag::interface_file_lock_failure,\n-                     interfacePath);\n+      diagnose(diag::interface_file_lock_failure, interfacePath);\n     }\n     // Clear out any potential leftover.\n     Locked.unsafeRemoveLockFile();\n@@ -472,8 +475,7 @@ bool ModuleInterfaceBuilder::buildSwiftModule(StringRef OutPath,\n       // another process to complete the build so swift does not do it done\n       // twice. If case of timeout, build it ourselves.\n       if (RemarkRebuild) {\n-        diags.diagnose(SourceLoc(), diag::interface_file_lock_timed_out,\n-                       interfacePath);\n+        diagnose(diag::interface_file_lock_timed_out, interfacePath);\n       }\n       // Clear the lock file so that future invocations can make progress.\n       Locked.unsafeRemoveLockFile();"
                    },
                    {
                        "filename": "lib/Frontend/ModuleInterfaceBuilder.h",
                        "code": "@@ -33,7 +33,7 @@ class SearchPathOptions;\n class DependencyTracker;\n \n class ModuleInterfaceBuilder {\n-  llvm::vfs::FileSystem &fs;\n+  SourceManager &sourceMgr;\n   DiagnosticEngine &diags;\n   const StringRef interfacePath;\n   const StringRef moduleName;\n@@ -48,6 +48,19 @@ class ModuleInterfaceBuilder {\n   CompilerInvocation subInvocation;\n   SmallVector<StringRef, 3> extraDependencies;\n \n+  /// Emit a diagnostic tied to this declaration.\n+  template<typename ...ArgTypes>\n+  InFlightDiagnostic diagnose(\n+      Diag<ArgTypes...> ID,\n+      typename detail::PassArgument<ArgTypes>::type... Args) const {\n+    SourceLoc loc = diagnosticLoc;\n+    if (loc.isInvalid()) {\n+      // Diagnose this inside the interface file, if possible.\n+      loc = sourceMgr.getLocFromExternalSource(interfacePath, 1, 1);\n+    }\n+    return diags.diagnose(loc, ID, std::move(Args)...);\n+  }\n+\n   void configureSubInvocationInputsAndOutputs(StringRef OutPath);\n \n   void configureSubInvocation(const SearchPathOptions &SearchPathOpts,\n@@ -86,7 +99,7 @@ class ModuleInterfaceBuilder {\n                             bool disableInterfaceFileLock = false,\n                             SourceLoc diagnosticLoc = SourceLoc(),\n                             DependencyTracker *tracker = nullptr)\n-    : fs(*sourceMgr.getFileSystem()), diags(diags),\n+    : sourceMgr(sourceMgr), diags(diags),\n       interfacePath(interfacePath), moduleName(moduleName),\n       moduleCachePath(moduleCachePath), prebuiltCachePath(prebuiltCachePath),\n       serializeDependencyHashes(serializeDependencyHashes),"
                    },
                    {
                        "filename": "lib/Frontend/ModuleInterfaceSupport.cpp",
                        "code": "@@ -294,21 +294,26 @@ class InheritedProtocolCollector {\n     const NominalTypeDecl *nominal;\n     const IterableDeclContext *memberContext;\n \n+    auto shouldInclude = [](const ExtensionDecl *extension) {\n+      if (extension->isConstrainedExtension()) {\n+        // Conditional conformances never apply to inherited protocols, nor\n+        // can they provide unconditional conformances that might be used in\n+        // other extensions.\n+        return false;\n+      }\n+      return true;\n+    };\n     if ((nominal = dyn_cast<NominalTypeDecl>(D))) {\n       directlyInherited = nominal->getInherited();\n       memberContext = nominal;\n \n     } else if (auto *extension = dyn_cast<ExtensionDecl>(D)) {\n-      if (extension->isConstrainedExtension()) {\n-        // Conditional conformances never apply to inherited protocols, nor\n-        // can they provide unconditional conformances that might be used in\n-        // other extensions.\n+      if (!shouldInclude(extension)) {\n         return;\n       }\n       nominal = extension->getExtendedNominal();\n       directlyInherited = extension->getInherited();\n       memberContext = extension;\n-\n     } else {\n       return;\n     }\n@@ -317,6 +322,18 @@ class InheritedProtocolCollector {\n       return;\n \n     map[nominal].recordProtocols(directlyInherited, D);\n+    // Collect protocols inherited from super classes\n+    if (auto *CD = dyn_cast<ClassDecl>(D)) {\n+      for (auto *SD = CD->getSuperclassDecl(); SD;\n+           SD = SD->getSuperclassDecl()) {\n+        map[nominal].recordProtocols(SD->getInherited(), SD);\n+        for (auto *Ext: SD->getExtensions()) {\n+          if (shouldInclude(Ext)) {\n+            map[nominal].recordProtocols(Ext->getInherited(), Ext);\n+          }\n+        }\n+      }\n+    }\n \n     // Recurse to find any nested types.\n     for (const Decl *member : memberContext->getMembers())"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -883,6 +883,9 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n     DidErrorOccur = true;\n   }\n \n+  if (SuppressOutput)\n+    return;\n+\n   if (Info.IsChildNote)\n     return;\n \n@@ -898,17 +901,21 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n       currentSnippet = std::make_unique<AnnotatedSourceSnippet>(SM);\n       annotateSnippetWithInfo(SM, Info, *currentSnippet);\n     }\n-    for (auto path : Info.EducationalNotePaths) {\n-      if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n-        BufferedEducationalNotes.push_back(buffer->get()->getBuffer().str());\n+    if (PrintEducationalNotes) {\n+      for (auto path : Info.EducationalNotePaths) {\n+        if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n+          BufferedEducationalNotes.push_back(buffer->get()->getBuffer().str());\n+      }\n     }\n   } else {\n     printDiagnostic(SM, Info);\n \n-    for (auto path : Info.EducationalNotePaths) {\n-      if (auto buffer = SM.getFileSystem()->getBufferForFile(path)) {\n-        printMarkdown(buffer->get()->getBuffer(), Stream, ForceColors);\n-        Stream << \"\\n\";\n+    if (PrintEducationalNotes) {\n+      for (auto path : Info.EducationalNotePaths) {\n+        if (auto buffer = SM.getFileSystem()->getBufferForFile(path)) {\n+          printMarkdown(buffer->get()->getBuffer(), Stream, ForceColors);\n+          Stream << \"\\n\";\n+        }\n       }\n     }\n "
                    },
                    {
                        "filename": "lib/FrontendTool/FrontendTool.cpp",
                        "code": "@@ -655,10 +655,14 @@ static void countStatsOfSourceFile(UnifiedStatsReporter &Stats,\n   C.NumDecls += SF->getTopLevelDecls().size();\n   C.NumLocalTypeDecls += SF->LocalTypeDecls.size();\n   C.NumObjCMethods += SF->ObjCMethods.size();\n-  C.NumInfixOperators += SF->InfixOperators.size();\n-  C.NumPostfixOperators += SF->PostfixOperators.size();\n-  C.NumPrefixOperators += SF->PrefixOperators.size();\n-  C.NumPrecedenceGroups += SF->PrecedenceGroups.size();\n+\n+  SmallVector<OperatorDecl *, 2> operators;\n+  SF->getOperatorDecls(operators);\n+  C.NumOperators += operators.size();\n+\n+  SmallVector<PrecedenceGroupDecl *, 2> groups;\n+  SF->getPrecedenceGroups(groups);\n+  C.NumPrecedenceGroups += groups.size();\n \n   auto bufID = SF->getBufferID();\n   if (bufID.hasValue()) {\n@@ -682,7 +686,7 @@ static void countStatsPostSema(UnifiedStatsReporter &Stats,\n   }\n \n   for (auto SF : Instance.getPrimarySourceFiles()) {\n-    if (auto *R = SF->getReferencedNameTracker()) {\n+    if (auto *R = SF->getConfiguredReferencedNameTracker()) {\n       C.NumReferencedTopLevelNames += R->getTopLevelNames().size();\n       C.NumReferencedDynamicNames += R->getDynamicLookupNames().size();\n       C.NumReferencedMemberNames += R->getUsedMembers().size();\n@@ -937,16 +941,18 @@ static void emitReferenceDependenciesForAllPrimaryInputsIfNeeded(\n         Invocation.getReferenceDependenciesFilePathForPrimary(\n             SF->getFilename());\n     if (!referenceDependenciesFilePath.empty()) {\n-      if (Invocation.getLangOptions().EnableFineGrainedDependencies)\n+      auto LangOpts = Invocation.getLangOptions();\n+      if (LangOpts.EnableFineGrainedDependencies) {\n         (void)fine_grained_dependencies::emitReferenceDependencies(\n             Instance.getASTContext().Diags, SF,\n-            *Instance.getDependencyTracker(), referenceDependenciesFilePath,\n-            Invocation.getLangOptions()\n-                .EmitFineGrainedDependencySourcefileDotFiles);\n-      else\n+            *Instance.getDependencyTracker(),\n+            referenceDependenciesFilePath,\n+            LangOpts.EmitFineGrainedDependencySourcefileDotFiles);\n+      } else {\n         (void)emitReferenceDependencies(Instance.getASTContext().Diags, SF,\n                                         *Instance.getDependencyTracker(),\n                                         referenceDependenciesFilePath);\n+      }\n     }\n   }\n }\n@@ -1729,7 +1735,8 @@ static bool emitIndexDataIfNeeded(SourceFile *PrimarySourceFile,\n             PrimarySourceFile->getFilename());\n     if (index::indexAndRecord(PrimarySourceFile, PSPs.OutputFilename,\n                               opts.IndexStorePath, opts.IndexSystemModules,\n-                              isDebugCompilation, Invocation.getTargetTriple(),\n+                              opts.IndexIgnoreStdlib, isDebugCompilation,\n+                              Invocation.getTargetTriple(),\n                               *Instance.getDependencyTracker())) {\n       return true;\n     }\n@@ -1741,7 +1748,7 @@ static bool emitIndexDataIfNeeded(SourceFile *PrimarySourceFile,\n \n     if (index::indexAndRecord(Instance.getMainModule(), opts.InputsAndOutputs.copyOutputFilenames(),\n                               moduleToken, opts.IndexStorePath,\n-                              opts.IndexSystemModules,\n+                              opts.IndexSystemModules, opts.IndexIgnoreStdlib,\n                               isDebugCompilation, Invocation.getTargetTriple(),\n                               *Instance.getDependencyTracker())) {\n       return true;\n@@ -2045,15 +2052,22 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     }\n   } FinishDiagProcessingCheckRAII;\n \n-  auto finishDiagProcessing = [&](int retValue) -> int {\n+  auto finishDiagProcessing = [&](int retValue, bool verifierEnabled) -> int {\n     FinishDiagProcessingCheckRAII.CalledFinishDiagProcessing = true;\n-    bool err = Instance->getDiags().finishProcessing();\n-    return retValue ? retValue : err;\n+    PDC.setSuppressOutput(false);\n+    bool diagnosticsError = Instance->getDiags().finishProcessing();\n+    // If the verifier is enabled and did not encounter any verification errors,\n+    // return 0 even if the compile failed. This behavior isn't ideal, but large\n+    // parts of the test suite are reliant on it.\n+    if (verifierEnabled && !diagnosticsError) {\n+      return 0;\n+    }\n+    return retValue ? retValue : diagnosticsError;\n   };\n \n   if (Args.empty()) {\n     Instance->getDiags().diagnose(SourceLoc(), diag::error_no_frontend_args);\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   CompilerInvocation Invocation;\n@@ -2068,7 +2082,7 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   SmallVector<std::unique_ptr<llvm::MemoryBuffer>, 4> configurationFileBuffers;\n   if (Invocation.parseArgs(Args, Instance->getDiags(),\n                            &configurationFileBuffers, workingDirectory)) {\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // Make an array of PrettyStackTrace objects to dump the configuration files\n@@ -2110,19 +2124,19 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     Options->PrintHelp(llvm::outs(), displayName(MainExecutablePath).c_str(),\n                        \"Swift frontend\", IncludedFlagsBitmask,\n                        ExcludedFlagsBitmask, /*ShowAllAliases*/false);\n-    return finishDiagProcessing(0);\n+    return finishDiagProcessing(0, /*verifierEnabled*/ false);\n   }\n \n   if (Invocation.getFrontendOptions().PrintTargetInfo) {\n     printTargetInfo(Invocation, llvm::outs());\n-    return finishDiagProcessing(0);\n+    return finishDiagProcessing(0, /*verifierEnabled*/ false);\n   }\n \n   if (Invocation.getFrontendOptions().RequestedAction ==\n       FrontendOptions::ActionType::NoneAction) {\n     Instance->getDiags().diagnose(SourceLoc(),\n                                   diag::error_missing_frontend_action);\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // Because the serialized diagnostics consumer is initialized here,\n@@ -2145,6 +2159,9 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   if (Invocation.getDiagnosticOptions().UseColor)\n     PDC.forceColors();\n \n+  PDC.setPrintEducationalNotes(\n+      Invocation.getDiagnosticOptions().PrintEducationalNotes);\n+\n   // Temporarily stage the new diagnostic formatting style behind\n   // -enable-descriptive-diagnostics\n   if (Invocation.getDiagnosticOptions().EnableExperimentalFormatting)\n@@ -2158,9 +2175,7 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   }\n \n   const DiagnosticOptions &diagOpts = Invocation.getDiagnosticOptions();\n-  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n-    enableDiagnosticVerifier(Instance->getSourceMgr());\n-  }\n+  bool verifierEnabled = diagOpts.VerifyMode != DiagnosticOptions::NoVerify;\n \n   if (Invocation.getFrontendOptions()\n           .InputsAndOutputs.hasDependencyTrackerPath() ||\n@@ -2175,14 +2190,20 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   }\n \n   if (Instance->setup(Invocation)) {\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // The compiler instance has been configured; notify our observer.\n   if (observer) {\n     observer->configuredCompiler(*Instance);\n   }\n \n+  if (verifierEnabled) {\n+    // Suppress printed diagnostic output during the compile if the verifier is\n+    // enabled.\n+    PDC.setSuppressOutput(true);\n+  }\n+\n   int ReturnValue = 0;\n   bool HadError =\n     performCompile(*Instance, Invocation, Args, ReturnValue, observer);\n@@ -2210,23 +2231,18 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     }\n   }\n \n-  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n-    HadError = verifyDiagnostics(\n-        Instance->getSourceMgr(),\n-        Instance->getInputBufferIDs(),\n-        diagOpts.VerifyMode == DiagnosticOptions::VerifyAndApplyFixes,\n-        diagOpts.VerifyIgnoreUnknown);\n-\n+  if (verifierEnabled) {\n     DiagnosticEngine &diags = Instance->getDiags();\n     if (diags.hasFatalErrorOccurred() &&\n         !Invocation.getDiagnosticOptions().ShowDiagnosticsAfterFatalError) {\n       diags.resetHadAnyError();\n+      PDC.setSuppressOutput(false);\n       diags.diagnose(SourceLoc(), diag::verify_encountered_fatal);\n       HadError = true;\n     }\n   }\n \n-  auto r = finishDiagProcessing(HadError ? 1 : ReturnValue);\n+  auto r = finishDiagProcessing(HadError ? 1 : ReturnValue, verifierEnabled);\n   if (auto *StatsReporter = Instance->getStatsReporter())\n     StatsReporter->noteCurrentProcessExitStatus(r);\n   return r;"
                    },
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -61,7 +61,8 @@ class ReferenceDependenciesEmitter {\n   ///\n   /// \\return true on error\n   static bool emit(DiagnosticEngine &diags, SourceFile *SF,\n-                   const DependencyTracker &depTracker, StringRef outputPath);\n+                   const DependencyTracker &depTracker,\n+                   StringRef outputPath);\n \n   /// Emit the dependencies.\n   static void emit(SourceFile *SF, const DependencyTracker &depTracker,\n@@ -254,7 +255,7 @@ ProvidesEmitter::emitTopLevelNames() const {\n   for (const Decl *D : SF->getTopLevelDecls())\n     emitTopLevelDecl(D, cpd);\n   for (auto *operatorFunction : cpd.memberOperatorDecls)\n-    out << \"- \\\"\" << escape(operatorFunction->getName()) << \"\\\"\\n\";\n+    out << \"- \\\"\" << escape(operatorFunction->getBaseIdentifier()) << \"\\\"\\n\";\n   return cpd;\n }\n \n@@ -488,12 +489,12 @@ void DependsEmitter::emit(const SourceFile *SF,\n }\n \n void DependsEmitter::emit() const {\n-  const ReferencedNameTracker *const tracker = SF->getReferencedNameTracker();\n-  assert(tracker && \"Cannot emit reference dependencies without a tracker\");\n+  const auto *nameTracker = SF->getConfiguredReferencedNameTracker();\n+  assert(nameTracker && \"Cannot emit reference dependencies without a tracker\");\n \n-  emitTopLevelNames(tracker);\n+  emitTopLevelNames(nameTracker);\n \n-  auto &memberLookupTable = tracker->getUsedMembers();\n+  auto &memberLookupTable = nameTracker->getUsedMembers();\n   std::vector<MemberTableEntryTy> sortedMembers{\n     memberLookupTable.begin(), memberLookupTable.end()\n   };\n@@ -519,7 +520,7 @@ void DependsEmitter::emit() const {\n \n   emitMembers(sortedMembers);\n   emitNominalTypes(sortedMembers);\n-  emitDynamicLookup(tracker);\n+  emitDynamicLookup(nameTracker);\n   emitExternal(depTracker);\n }\n "
                    },
                    {
                        "filename": "lib/IDE/CodeCompletion.cpp",
                        "code": "@@ -767,17 +767,26 @@ void CodeCompletionResultBuilder::addChunkWithText(\n   addChunkWithTextNoCopy(Kind, copyString(*Sink.Allocator, Text));\n }\n \n-void CodeCompletionResultBuilder::setAssociatedDecl(const Decl *D) {\n+void CodeCompletionResultBuilder::setAssociatedDecl(const Decl *D,\n+                                                    SourceFile *SF) {\n   assert(Kind == CodeCompletionResult::ResultKind::Declaration);\n   AssociatedDecl = D;\n-\n   if (auto *ClangD = D->getClangDecl())\n     CurrentModule = ClangD->getImportedOwningModule();\n   // FIXME: macros\n   // FIXME: imported header module\n \n-  if (!CurrentModule)\n-    CurrentModule = D->getModuleContext();\n+  if (!CurrentModule) {\n+    ModuleDecl *MD = D->getModuleContext();\n+    // If this is an underscored cross-import overlay, map it to its underlying\n+    // module instead.\n+    if (SF) {\n+      auto *Underlying = SF->getModuleShadowedBySeparatelyImportedOverlay(MD);\n+      if (Underlying)\n+        MD = Underlying;\n+    }\n+    CurrentModule = MD;\n+  }\n \n   if (D->getAttrs().getDeprecated(D->getASTContext()))\n     setNotRecommended(CodeCompletionResult::Deprecated);\n@@ -1549,6 +1558,15 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     Builder.addDeclDocCommentWords(llvm::makeArrayRef(Pairs));\n   }\n \n+  /// Sets the given declaration \\p D as the associated declaration of the\n+  /// completion result being built in \\p Builder.\n+  void setAssociatedDecl(const Decl *D, CodeCompletionResultBuilder &Builder) {\n+    SourceFile *SF = nullptr;\n+    if (CurrDeclContext)\n+      SF = CurrDeclContext->getParentSourceFile();\n+    Builder.setAssociatedDecl(D, SF);\n+  }\n+\n   bool shouldUseFunctionReference(AbstractFunctionDecl *D) {\n     if (PreferFunctionReferencesToCalls)\n       return true;\n@@ -1638,8 +1656,6 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Importer(static_cast<ClangImporter *>(CurrDeclContext->getASTContext().\n           getClangModuleLoader())),\n         CompletionContext(CompletionContext) {\n-    Ctx.setLegacySemanticQueriesEnabled();\n-\n     // Determine if we are doing code completion inside a static method.\n     if (CurrDeclContext) {\n       CurrentMethod = CurrDeclContext->getInnermostMethodContext();\n@@ -1726,7 +1742,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n                                           SemanticContextKind::None,\n                                           expectedTypeContext);\n       auto MD = ModuleDecl::create(Ctx.getIdentifier(Pair.first), Ctx);\n-      Builder.setAssociatedDecl(MD);\n+      setAssociatedDecl(MD, Builder);\n       Builder.addTextChunk(MD->getNameStr());\n       Builder.addTypeAnnotation(\"Module\");\n       if (Pair.second)\n@@ -1740,7 +1756,6 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     ImportFilter |= ModuleDecl::ImportFilterKind::Public;\n     ImportFilter |= ModuleDecl::ImportFilterKind::Private;\n     ImportFilter |= ModuleDecl::ImportFilterKind::ImplementationOnly;\n-    // FIXME: ImportFilterKind::ShadowedBySeparateOverlay?\n \n     SmallVector<ModuleDecl::ImportedModule, 16> Imported;\n     SmallVector<ModuleDecl::ImportedModule, 16> FurtherImported;\n@@ -1755,21 +1770,27 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n       MD->getImportedModules(FurtherImported,\n                              ModuleDecl::ImportFilterKind::Public);\n       Imported.append(FurtherImported.begin(), FurtherImported.end());\n-      for (auto SubMod : FurtherImported) {\n-        Imported.push_back(SubMod);\n-      }\n     }\n   }\n \n   void addModuleName(\n       const ModuleDecl *MD,\n       Optional<CodeCompletionResult::NotRecommendedReason> R = None) {\n+\n+    // Don't add underscored cross-import overlay modules.\n+    if (CurrDeclContext && MD->getNameStr().startswith(\"_\")) {\n+      if (auto SF = CurrDeclContext->getParentSourceFile()) {\n+        if (SF->getModuleShadowedBySeparatelyImportedOverlay(MD))\n+          return;\n+      }\n+    }\n+\n     CodeCompletionResultBuilder Builder(\n         Sink,\n         CodeCompletionResult::ResultKind::Declaration,\n         SemanticContextKind::None,\n         expectedTypeContext);\n-    Builder.setAssociatedDecl(MD);\n+    setAssociatedDecl(MD, Builder);\n     Builder.addTextChunk(MD->getNameStr());\n     Builder.addTypeAnnotation(\"Module\");\n     if (R)\n@@ -1826,7 +1847,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         return SemanticContextKind::ExpressionSpecific;\n       return SemanticContextKind::CurrentNominal;\n \n-    case DeclVisibilityKind::MemberOfProtocolImplementedByCurrentNominal:\n+    case DeclVisibilityKind::MemberOfProtocolConformedToByCurrentNominal:\n     case DeclVisibilityKind::MemberOfSuper:\n       return SemanticContextKind::Super;\n \n@@ -1870,6 +1891,9 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n             D, dynamicLookupInfo.getKeyPathDynamicMember().originalVisibility,\n             {});\n       }\n+\n+    case DeclVisibilityKind::MemberOfProtocolDerivedByCurrentNominal:\n+      llvm_unreachable(\"should not see this kind\");\n     }\n     llvm_unreachable(\"unhandled kind\");\n   }\n@@ -2156,14 +2180,14 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         VD->shouldHideFromEditor())\n       return;\n \n-    Identifier Name = VD->getName();\n+    const Identifier Name = VD->getName();\n     assert(!Name.empty() && \"name should not be empty\");\n \n     CommandWordsPairs Pairs;\n     CodeCompletionResultBuilder Builder(\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(VD, Reason, dynamicLookupInfo), expectedTypeContext);\n-    Builder.setAssociatedDecl(VD);\n+    setAssociatedDecl(VD, Builder);\n     addLeadingDot(Builder);\n     addValueBaseName(Builder, Name);\n     setClangDeclKeywords(VD, Pairs, Builder);\n@@ -2413,7 +2437,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         SemanticContext ? *SemanticContext : getSemanticContextKind(SD),\n         expectedTypeContext);\n-    Builder.setAssociatedDecl(SD);\n+    setAssociatedDecl(SD, Builder);\n     setClangDeclKeywords(SD, Pairs, Builder);\n     if (!HaveLParen)\n       Builder.addLeftBracket();\n@@ -2452,7 +2476,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n           SemanticContext ? *SemanticContext : getSemanticContextKind(AFD),\n           expectedTypeContext);\n       if (AFD) {\n-        Builder.setAssociatedDecl(AFD);\n+        setAssociatedDecl(AFD, Builder);\n         setClangDeclKeywords(AFD, Pairs, Builder);\n       }\n \n@@ -2523,16 +2547,22 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n   }\n \n   bool isImplicitlyCurriedInstanceMethod(const AbstractFunctionDecl *FD) {\n+    if (FD->isStatic())\n+      return false;\n+\n     switch (Kind) {\n     case LookupKind::ValueExpr:\n-      return ExprType->is<AnyMetatypeType>() && !FD->isStatic();\n+      return ExprType->is<AnyMetatypeType>();\n     case LookupKind::ValueInDeclContext:\n-      if (InsideStaticMethod &&\n-          FD->getDeclContext() == CurrentMethod->getDeclContext() &&\n-          !FD->isStatic())\n-        return true;\n-      if (auto Init = dyn_cast<Initializer>(CurrDeclContext))\n-        return FD->getDeclContext() == Init->getParent() && !FD->isStatic();\n+      if (InsideStaticMethod)\n+        return FD->getDeclContext() == CurrentMethod->getDeclContext();\n+      if (auto Init = dyn_cast<Initializer>(CurrDeclContext)) {\n+        if (auto PatInit = dyn_cast<PatternBindingInitializer>(Init)) {\n+          if (PatInit->getInitializedLazyVar())\n+            return false;\n+        }\n+        return FD->getDeclContext() == Init->getInnermostTypeContext();\n+      }\n       return false;\n     case LookupKind::EnumElement:\n     case LookupKind::Type:\n@@ -2549,11 +2579,11 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n \n   void addMethodCall(const FuncDecl *FD, DeclVisibilityKind Reason,\n                      DynamicLookupInfo dynamicLookupInfo) {\n-    if (FD->getName().empty())\n+    if (FD->getBaseIdentifier().empty())\n       return;\n     foundFunction(FD);\n \n-    Identifier Name = FD->getName();\n+    const Identifier Name = FD->getBaseIdentifier();\n     assert(!Name.empty() && \"name should not be empty\");\n \n     Type FunctionType = getTypeOfMember(FD, dynamicLookupInfo);\n@@ -2583,7 +2613,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n           getSemanticContext(FD, Reason, dynamicLookupInfo),\n           expectedTypeContext);\n       setClangDeclKeywords(FD, Pairs, Builder);\n-      Builder.setAssociatedDecl(FD);\n+      setAssociatedDecl(FD, Builder);\n       addLeadingDot(Builder);\n       addValueBaseName(Builder, Name);\n       if (IsDynamicLookup)\n@@ -2696,7 +2726,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n           getSemanticContext(CD, Reason, dynamicLookupInfo),\n           expectedTypeContext);\n       setClangDeclKeywords(CD, Pairs, Builder);\n-      Builder.setAssociatedDecl(CD);\n+      setAssociatedDecl(CD, Builder);\n       if (needInit) {\n         assert(addName.empty());\n         addLeadingDot(Builder);\n@@ -2787,7 +2817,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     CodeCompletionResultBuilder Builder(\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(SD, Reason, dynamicLookupInfo), expectedTypeContext);\n-    Builder.setAssociatedDecl(SD);\n+    setAssociatedDecl(SD, Builder);\n     setClangDeclKeywords(SD, Pairs, Builder);\n \n     // '\\TyName#^TOKEN^#' requires leading dot.\n@@ -2822,7 +2852,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(NTD, Reason, dynamicLookupInfo),\n         expectedTypeContext);\n-    Builder.setAssociatedDecl(NTD);\n+    setAssociatedDecl(NTD, Builder);\n     setClangDeclKeywords(NTD, Pairs, Builder);\n     addLeadingDot(Builder);\n     Builder.addTextChunk(NTD->getName().str());\n@@ -2838,7 +2868,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(TAD, Reason, dynamicLookupInfo),\n         expectedTypeContext);\n-    Builder.setAssociatedDecl(TAD);\n+    setAssociatedDecl(TAD, Builder);\n     setClangDeclKeywords(TAD, Pairs, Builder);\n     addLeadingDot(Builder);\n     Builder.addTextChunk(TAD->getName().str());\n@@ -2868,7 +2898,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(GP, Reason, dynamicLookupInfo), expectedTypeContext);\n     setClangDeclKeywords(GP, Pairs, Builder);\n-    Builder.setAssociatedDecl(GP);\n+    setAssociatedDecl(GP, Builder);\n     addLeadingDot(Builder);\n     Builder.addTextChunk(GP->getName().str());\n     addTypeAnnotation(Builder, GP->getDeclaredInterfaceType());\n@@ -2882,7 +2912,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         getSemanticContext(AT, Reason, dynamicLookupInfo), expectedTypeContext);\n     setClangDeclKeywords(AT, Pairs, Builder);\n-    Builder.setAssociatedDecl(AT);\n+    setAssociatedDecl(AT, Builder);\n     addLeadingDot(Builder);\n     Builder.addTextChunk(AT->getName().str());\n     if (Type T = getAssociatedTypeType(AT))\n@@ -2897,7 +2927,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n       semanticContext, {});\n \n     builder.addTextChunk(PGD->getName().str());\n-    builder.setAssociatedDecl(PGD);\n+    setAssociatedDecl(PGD, builder);\n   };\n \n   void addEnumElementRef(const EnumElementDecl *EED, DeclVisibilityKind Reason,\n@@ -2914,10 +2944,10 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         HasTypeContext ? SemanticContextKind::ExpressionSpecific\n                        : getSemanticContext(EED, Reason, dynamicLookupInfo),\n         expectedTypeContext);\n-    Builder.setAssociatedDecl(EED);\n+    setAssociatedDecl(EED, Builder);\n     setClangDeclKeywords(EED, Pairs, Builder);\n     addLeadingDot(Builder);\n-    addValueBaseName(Builder, EED->getName());\n+    addValueBaseName(Builder, EED->getBaseIdentifier());\n \n     // Enum element is of function type; (Self.type) -> Self or\n     // (Self.Type) -> (Args...) -> Self.\n@@ -2996,7 +3026,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n         getSemanticContext(AFD, Reason, dynamicLookupInfo),\n         expectedTypeContext);\n     setClangDeclKeywords(AFD, Pairs, Builder);\n-    Builder.setAssociatedDecl(AFD);\n+    setAssociatedDecl(AFD, Builder);\n \n     // Base name\n     addLeadingDot(Builder);\n@@ -3025,6 +3055,10 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n   // Implement swift::VisibleDeclConsumer.\n   void foundDecl(ValueDecl *D, DeclVisibilityKind Reason,\n                  DynamicLookupInfo dynamicLookupInfo) override {\n+    assert(Reason !=\n+             DeclVisibilityKind::MemberOfProtocolDerivedByCurrentNominal &&\n+           \"Including derived requirement in non-override lookup\");\n+\n     if (D->shouldHideFromEditor())\n       return;\n \n@@ -3123,7 +3157,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n \n         // SE-0253: Callable values of user-defined nominal types.\n         if (FD->isCallAsFunctionMethod() && !HaveDot &&\n-            !ExprType->is<AnyMetatypeType>()) {\n+            (!ExprType || !ExprType->is<AnyMetatypeType>())) {\n           Type funcType = getTypeOfMember(FD, dynamicLookupInfo)\n                               ->castTo<AnyFunctionType>()\n                               ->getResult();\n@@ -3301,7 +3335,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     if (isIUO) {\n       if (Type Unwrapped = ExprType->getOptionalObjectType()) {\n         lookupVisibleMemberDecls(*this, Unwrapped, CurrDeclContext,\n-                                 IncludeInstanceMembers);\n+                                 IncludeInstanceMembers,\n+                                 /*includeDerivedRequirements*/false);\n         return true;\n       }\n       assert(IsUnwrappedOptional && \"IUOs should be optional if not bound/forced\");\n@@ -3321,7 +3356,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n           CodeCompletionResult::MaxNumBytesToErase) {\n         if (!tryTupleExprCompletions(Unwrapped)) {\n           lookupVisibleMemberDecls(*this, Unwrapped, CurrDeclContext,\n-                                   IncludeInstanceMembers);\n+                                   IncludeInstanceMembers,\n+                                   /*includeDerivedRequirements*/false);\n         }\n       }\n       return true;\n@@ -3391,59 +3427,14 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     tryUnwrappedCompletions(ExprType, isIUO);\n \n     lookupVisibleMemberDecls(*this, ExprType, CurrDeclContext,\n-                             IncludeInstanceMembers);\n+                             IncludeInstanceMembers,\n+                             /*includeDerivedRequirements*/false);\n   }\n \n-  template <typename T>\n-  void collectOperatorsFromMap(SourceFile::OperatorMap<T> &map,\n-                               bool includePrivate,\n-                               std::vector<OperatorDecl *> &results) {\n-    for (auto &pair : map) {\n-      if (pair.second.getPointer() &&\n-          (pair.second.getInt() || includePrivate)) {\n-        results.push_back(pair.second.getPointer());\n-      }\n-    }\n-  }\n-\n-  void collectOperatorsFrom(SourceFile *SF,\n-                            std::vector<OperatorDecl *> &results) {\n-    bool includePrivate = CurrDeclContext->getParentSourceFile() == SF;\n-    collectOperatorsFromMap(SF->PrefixOperators, includePrivate, results);\n-    collectOperatorsFromMap(SF->PostfixOperators, includePrivate, results);\n-    collectOperatorsFromMap(SF->InfixOperators, includePrivate, results);\n-  }\n-\n-  void collectOperatorsFrom(LoadedFile *F,\n-                            std::vector<OperatorDecl *> &results) {\n-    SmallVector<Decl *, 64> topLevelDecls;\n-    F->getTopLevelDecls(topLevelDecls);\n-    for (auto D : topLevelDecls) {\n-      if (auto op = dyn_cast<OperatorDecl>(D))\n-        results.push_back(op);\n-    }\n-  }\n-\n-  std::vector<OperatorDecl *> collectOperators() {\n-    std::vector<OperatorDecl *> results;\n+  void collectOperators(SmallVectorImpl<OperatorDecl *> &results) {\n     assert(CurrDeclContext);\n-    for (auto import : namelookup::getAllImports(CurrDeclContext)) {\n-      for (auto fileUnit : import.second->getFiles()) {\n-        switch (fileUnit->getKind()) {\n-        case FileUnitKind::Builtin:\n-        case FileUnitKind::ClangModule:\n-        case FileUnitKind::DWARFModule:\n-          continue;\n-        case FileUnitKind::Source:\n-          collectOperatorsFrom(cast<SourceFile>(fileUnit), results);\n-          break;\n-        case FileUnitKind::SerializedAST:\n-          collectOperatorsFrom(cast<LoadedFile>(fileUnit), results);\n-          break;\n-        }\n-      }\n-    }\n-    return results;\n+    for (auto import : namelookup::getAllImports(CurrDeclContext))\n+      import.second->getOperatorDecls(results);\n   }\n \n   void addPostfixBang(Type resultType) {\n@@ -3469,7 +3460,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     // FIXME: handle variable amounts of space.\n     if (HaveLeadingSpace)\n       builder.setNumBytesToErase(1);\n-    builder.setAssociatedDecl(op);\n+    setAssociatedDecl(op, builder);\n     builder.addTextChunk(op->getName().str());\n     assert(resultType);\n     addTypeAnnotation(builder, resultType);\n@@ -3515,7 +3506,7 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     CodeCompletionResultBuilder builder(\n         Sink, CodeCompletionResult::ResultKind::Declaration, semanticContext,\n         {});\n-    builder.setAssociatedDecl(op);\n+    setAssociatedDecl(op, builder);\n \n     if (HaveLeadingSpace)\n       builder.addAnnotatedWhitespace(\" \");\n@@ -3591,7 +3582,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n \n     Expr *foldedExpr = typeCheckLeadingSequence(LHS, leadingSequence);\n \n-    std::vector<OperatorDecl *> operators = collectOperators();\n+    SmallVector<OperatorDecl *, 16> operators;\n+    collectOperators(operators);\n     // FIXME: this always chooses the first operator with the given name.\n     llvm::DenseSet<Identifier> seenPostfixOperators;\n     llvm::DenseSet<Identifier> seenInfixOperators;\n@@ -3911,7 +3903,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     llvm::SaveAndRestore<Type> SaveType(ExprType, baseType);\n     llvm::SaveAndRestore<bool> SaveUnresolved(IsUnresolvedMember, true);\n     lookupVisibleMemberDecls(consumer, baseType, CurrDeclContext,\n-                             /*includeInstanceMembers=*/false);\n+                             /*includeInstanceMembers=*/false,\n+                             /*includeDerivedRequirements*/false);\n   }\n \n   void getUnresolvedMemberCompletions(ArrayRef<Type> Types) {\n@@ -3972,7 +3965,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     NeedLeadingDot = !HaveDot;\n     lookupVisibleMemberDecls(*this, MetatypeType::get(BaseType),\n                              CurrDeclContext,\n-                             IncludeInstanceMembers);\n+                             IncludeInstanceMembers,\n+                             /*includeDerivedRequirements*/false);\n     if (BaseType->isAnyExistentialType()) {\n       addKeyword(\"Protocol\", MetatypeType::get(BaseType));\n       addKeyword(\"Type\", ExistentialMetatypeType::get(BaseType));\n@@ -4005,7 +3999,8 @@ class CompletionLookup final : public swift::VisibleDeclConsumer {\n     this->BaseType = selfTy;\n     NeedLeadingDot = false;\n     lookupVisibleMemberDecls(*this, MetatypeType::get(selfTy),\n-                             CurrDeclContext, IncludeInstanceMembers);\n+                             CurrDeclContext, IncludeInstanceMembers,\n+                             /*includeDerivedRequirements*/false);\n   }\n \n   static bool canUseAttributeOnDecl(DeclAttrKind DAK, bool IsInSil,\n@@ -4179,15 +4174,22 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n   bool hasOverridabilityModifier = false;\n   bool hasStaticOrClass = false;\n \n+  /// Sets the given declaration \\p D as the associated declaration of the\n+  /// completion result being built in \\p Builder.\n+  void setAssociatedDecl(const Decl *D, CodeCompletionResultBuilder &Builder) {\n+    SourceFile *SF = nullptr;\n+    if (CurrDeclContext)\n+      SF = CurrDeclContext->getParentSourceFile();\n+    Builder.setAssociatedDecl(D, SF);\n+  }\n+\n public:\n   CompletionOverrideLookup(CodeCompletionResultSink &Sink, ASTContext &Ctx,\n                            const DeclContext *CurrDeclContext,\n                            SmallVectorImpl<StringRef> &ParsedKeywords,\n                            SourceLoc introducerLoc)\n       : Sink(Sink), Ctx(Ctx), CurrDeclContext(CurrDeclContext),\n         ParsedKeywords(ParsedKeywords), introducerLoc(introducerLoc) {\n-    Ctx.setLegacySemanticQueriesEnabled();\n-\n     hasFuncIntroducer = isKeywordSpecified(\"func\");\n     hasVarIntroducer = isKeywordSpecified(\"var\") ||\n                        isKeywordSpecified(\"let\");\n@@ -4264,7 +4266,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n   Type getOpaqueResultType(const ValueDecl *VD, DeclVisibilityKind Reason,\n                            DynamicLookupInfo dynamicLookupInfo) {\n     if (Reason !=\n-        DeclVisibilityKind::MemberOfProtocolImplementedByCurrentNominal)\n+        DeclVisibilityKind::MemberOfProtocolConformedToByCurrentNominal)\n       return nullptr;\n \n     auto currTy = CurrDeclContext->getDeclaredTypeInContext();\n@@ -4407,7 +4409,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n         SemanticContextKind::Super, {});\n     Builder.setExpectedTypeRelation(\n         CodeCompletionResult::ExpectedTypeRelation::NotApplicable);\n-    Builder.setAssociatedDecl(FD);\n+    setAssociatedDecl(FD, Builder);\n     addValueOverride(FD, Reason, dynamicLookupInfo, Builder, hasFuncIntroducer);\n     Builder.addBraceStmtWithCursor();\n   }\n@@ -4425,7 +4427,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n     CodeCompletionResultBuilder Builder(\n         Sink, CodeCompletionResult::ResultKind::Declaration,\n         SemanticContextKind::Super, {});\n-    Builder.setAssociatedDecl(VD);\n+    setAssociatedDecl(VD, Builder);\n     addValueOverride(VD, Reason, dynamicLookupInfo, Builder, hasVarIntroducer);\n   }\n \n@@ -4436,7 +4438,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n         SemanticContextKind::Super, {});\n     Builder.setExpectedTypeRelation(\n         CodeCompletionResult::ExpectedTypeRelation::NotApplicable);\n-    Builder.setAssociatedDecl(SD);\n+    setAssociatedDecl(SD, Builder);\n     addValueOverride(SD, Reason, dynamicLookupInfo, Builder, false);\n     Builder.addBraceStmtWithCursor();\n   }\n@@ -4448,7 +4450,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n       SemanticContextKind::Super, {});\n     Builder.setExpectedTypeRelation(\n         CodeCompletionResult::ExpectedTypeRelation::NotApplicable);\n-    Builder.setAssociatedDecl(ATD);\n+    setAssociatedDecl(ATD, Builder);\n     if (!hasTypealiasIntroducer && !hasAccessModifier)\n       addAccessControl(ATD, Builder);\n     if (!hasTypealiasIntroducer)\n@@ -4466,7 +4468,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n         SemanticContextKind::Super, {});\n     Builder.setExpectedTypeRelation(\n         CodeCompletionResult::ExpectedTypeRelation::NotApplicable);\n-    Builder.setAssociatedDecl(CD);\n+    setAssociatedDecl(CD, Builder);\n \n     if (!hasAccessModifier)\n       addAccessControl(CD, Builder);\n@@ -4480,12 +4482,18 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n     bool needRequired = false;\n     auto C = CurrDeclContext->getSelfClassDecl();\n     if (C && !isKeywordSpecified(\"required\")) {\n-      if (Reason ==\n-            DeclVisibilityKind::MemberOfProtocolImplementedByCurrentNominal &&\n-          !C->isFinal())\n-        needRequired = true;\n-      else if (Reason == DeclVisibilityKind::MemberOfSuper && CD->isRequired())\n-        needRequired = true;\n+      switch (Reason) {\n+      case DeclVisibilityKind::MemberOfProtocolConformedToByCurrentNominal:\n+      case DeclVisibilityKind::MemberOfProtocolDerivedByCurrentNominal:\n+        if (!C->isFinal())\n+          needRequired = true;\n+        break;\n+      case DeclVisibilityKind::MemberOfSuper:\n+        if (CD->isRequired())\n+          needRequired = true;\n+        break;\n+      default: break;\n+      }\n     }\n \n     llvm::SmallString<256> DeclStr;\n@@ -4605,7 +4613,7 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n           continue;\n         addTypeAlias(\n             ATD,\n-            DeclVisibilityKind::MemberOfProtocolImplementedByCurrentNominal,\n+            DeclVisibilityKind::MemberOfProtocolConformedToByCurrentNominal,\n             {});\n       }\n     }\n@@ -4623,7 +4631,8 @@ class CompletionOverrideLookup : public swift::VisibleDeclConsumer {\n       // Look for overridable static members too.\n       Type Meta = MetatypeType::get(CurrTy);\n       lookupVisibleMemberDecls(*this, Meta, CurrDeclContext,\n-                               /*includeInstanceMembers=*/true);\n+                               /*includeInstanceMembers=*/true,\n+                               /*includeDerivedRequirements*/true);\n       addDesignatedInitializers(NTD);\n       addAssociatedTypes(NTD);\n     }\n@@ -5732,7 +5741,6 @@ void CodeCompletionCallbacksImpl::doneParsing() {\n       ImportFilter |= ModuleDecl::ImportFilterKind::Public;\n       ImportFilter |= ModuleDecl::ImportFilterKind::Private;\n       ImportFilter |= ModuleDecl::ImportFilterKind::ImplementationOnly;\n-      // FIXME: ImportFilterKind::ShadowedBySeparateOverlay?\n       SmallVector<ModuleDecl::ImportedModule, 4> Imports;\n       auto *SF = CurDeclContext->getParentSourceFile();\n       SF->getImportedModules(Imports, ImportFilter);"
                    },
                    {
                        "filename": "lib/IDE/CodeCompletionResultBuilder.h",
                        "code": "@@ -114,7 +114,7 @@ class CodeCompletionResultBuilder {\n     NumBytesToErase = N;\n   }\n \n-  void setAssociatedDecl(const Decl *D);\n+  void setAssociatedDecl(const Decl *D, SourceFile *SF);\n \n   void setLiteralKind(CodeCompletionLiteralKind kind) { LiteralKind = kind; }\n   void setKeywordKind(CodeCompletionKeywordKind kind) { KeywordKind = kind; }"
                    },
                    {
                        "filename": "lib/IDE/CompletionInstance.cpp",
                        "code": "@@ -326,7 +326,7 @@ bool CompletionInstance::performCachedOperaitonIfPossible(\n \n     // Re-process the whole file (parsing will be lazily triggered). Still\n     // re-use imported modules.\n-    performNameBinding(*newSF);\n+    performImportResolution(*newSF);\n     bindExtensions(*newSF);\n \n #ifndef NDEBUG"
                    },
                    {
                        "filename": "lib/IDE/ConformingMethodList.cpp",
                        "code": "@@ -164,7 +164,8 @@ void ConformingMethodListCallbacks::getMatchingMethods(\n   } LocalConsumer(CurDeclContext, T, expectedTypes, result);\n \n   lookupVisibleMemberDecls(LocalConsumer, MetatypeType::get(T), CurDeclContext,\n-                           /*includeInstanceMembers=*/false);\n+                           /*includeInstanceMembers=*/false,\n+                           /*includeDerivedRequirements*/false);\n }\n \n } // anonymous namespace."
                    },
                    {
                        "filename": "lib/IDE/ExprContextAnalysis.cpp",
                        "code": "@@ -138,15 +138,35 @@ class ExprFinder : public ASTWalker {\n     return SM.rangeContains(Node->getSourceRange(), TargetRange);\n   }\n \n+  bool shouldIgnore(Expr *E) {\n+    // E.g. instanceOfDerived.methodInBaseReturningSelf().#^HERE^#'\n+    // When calling a method in a base class returning 'Self', the call\n+    // expression itself has the type of the base class. That is wrapped with\n+    // CovariantReturnConversionExpr which downcasts it to the derived class.\n+    if (isa<CovariantReturnConversionExpr>(E))\n+      return false;\n+\n+    // E.g. TypeName(#^HERE^#\n+    // In this case, we want the type expression instead of a reference to the\n+    // initializer.\n+    if (isa<ConstructorRefCallExpr>(E))\n+      return true;\n+\n+    // Ignore other implicit expression.\n+    if (E->isImplicit())\n+      return true;\n+\n+    return false;\n+  }\n+\n public:\n   ExprFinder(SourceManager &SM, SourceRange TargetRange)\n       : SM(SM), TargetRange(TargetRange) {}\n \n   Expr *get() const { return FoundExpr; }\n \n   std::pair<bool, Expr *> walkToExprPre(Expr *E) override {\n-    if (TargetRange == E->getSourceRange() && !E->isImplicit() &&\n-        !isa<ConstructorRefCallExpr>(E)) {\n+    if (TargetRange == E->getSourceRange() && !shouldIgnore(E)) {\n       assert(!FoundExpr && \"non-nullptr for found expr\");\n       FoundExpr = E;\n       return {false, nullptr};"
                    },
                    {
                        "filename": "lib/IDE/IDERequests.cpp",
                        "code": "@@ -303,7 +303,7 @@ bool CursorInfoResolver::rangeContainsLoc(CharSourceRange Range) const {\n   return Range.contains(LocToResolve);\n }\n \n-llvm::Expected<ide::ResolvedCursorInfo>\n+ide::ResolvedCursorInfo\n CursorInfoRequest::evaluate(Evaluator &eval, CursorInfoOwner CI) const {\n   if (!CI.isValid())\n     return ResolvedCursorInfo();\n@@ -1066,7 +1066,7 @@ RangeInfoOwner::RangeInfoOwner(SourceFile *File, unsigned Offset,\n   EndLoc = SM.getLocForOffset(BufferId, Offset + Length);\n }\n \n-llvm::Expected<ide::ResolvedRangeInfo>\n+ide::ResolvedRangeInfo\n RangeInfoRequest::evaluate(Evaluator &eval, RangeInfoOwner CI) const {\n   if (!CI.isValid())\n     return ResolvedRangeInfo();\n@@ -1092,7 +1092,7 @@ static Type getContextFreeInterfaceType(ValueDecl *VD) {\n   return VD->getInterfaceType();\n }\n \n-llvm::Expected<ArrayRef<ValueDecl*>>\n+ArrayRef<ValueDecl *>\n ProvideDefaultImplForRequest::evaluate(Evaluator &eval, ValueDecl* VD) const {\n   // Skip decls that don't have valid names.\n   if (!VD->getFullName())\n@@ -1126,7 +1126,7 @@ ProvideDefaultImplForRequest::evaluate(Evaluator &eval, ValueDecl* VD) const {\n //----------------------------------------------------------------------------//\n // CollectOverriddenDeclsRequest\n //----------------------------------------------------------------------------//\n-llvm::Expected<ArrayRef<ValueDecl*>>\n+ArrayRef<ValueDecl *>\n CollectOverriddenDeclsRequest::evaluate(Evaluator &evaluator,\n                                         OverridenDeclsOwner Owner) const {\n   std::vector<ValueDecl*> results;\n@@ -1155,7 +1155,7 @@ CollectOverriddenDeclsRequest::evaluate(Evaluator &evaluator,\n //----------------------------------------------------------------------------//\n // ResolveProtocolNameRequest\n //----------------------------------------------------------------------------//\n-llvm::Expected<ProtocolDecl*>\n+ProtocolDecl *\n ResolveProtocolNameRequest::evaluate(Evaluator &evaluator,\n                                      ProtocolNameOwner Input) const {\n   auto &ctx = Input.DC->getASTContext();"
                    },
                    {
                        "filename": "lib/IDE/ModuleInterfacePrinting.cpp",
                        "code": "@@ -238,6 +238,295 @@ swift::ide::findGroupNameForUSR(ModuleDecl *M, StringRef USR) {\n   return None;\n }\n \n+/// Prints a single decl using the \\p Printer and \\p Options provided.\n+///\n+/// \\returns Whether the given decl was printed.\n+static bool printModuleInterfaceDecl(Decl *D,\n+                                     ASTPrinter &Printer,\n+                                     PrintOptions &Options,\n+                                     bool PrintSynthesizedExtensions) {\n+  if (!Options.shouldPrint(D)) {\n+    Printer.callAvoidPrintDeclPost(D);\n+    return false;\n+  }\n+  if (auto Ext = dyn_cast<ExtensionDecl>(D)) {\n+    // Clang extensions (categories) are always printed in source order.\n+    // Swift extensions are printed with their associated type unless it's\n+    // a cross-module extension.\n+    if (!extensionHasClangNode(Ext)) {\n+      auto ExtendedNominal = Ext->getExtendedNominal();\n+      if (Ext->getModuleContext() == ExtendedNominal->getModuleContext())\n+        return false;\n+    }\n+  }\n+  std::unique_ptr<SynthesizedExtensionAnalyzer> pAnalyzer;\n+  if (auto NTD = dyn_cast<NominalTypeDecl>(D)) {\n+    if (PrintSynthesizedExtensions) {\n+      pAnalyzer.reset(new SynthesizedExtensionAnalyzer(NTD, Options));\n+      Options.BracketOptions = {\n+        NTD, true, true,\n+        !pAnalyzer->hasMergeGroup(\n+          SynthesizedExtensionAnalyzer::MergeGroupKind::MergeableWithTypeDef\n+        )\n+      };\n+    }\n+  }\n+  if (D->print(Printer, Options)) {\n+    if (Options.BracketOptions.shouldCloseNominal(D))\n+      Printer << \"\\n\";\n+    Options.BracketOptions = BracketOptions();\n+    if (auto NTD = dyn_cast<NominalTypeDecl>(D)) {\n+      std::queue<NominalTypeDecl *> SubDecls{{NTD}};\n+\n+      while (!SubDecls.empty()) {\n+        auto NTD = SubDecls.front();\n+        SubDecls.pop();\n+\n+        // Add sub-types of NTD.\n+        for (auto Sub : NTD->getMembers())\n+          if (auto N = dyn_cast<NominalTypeDecl>(Sub))\n+            SubDecls.push(N);\n+\n+        // Print Ext and add sub-types of Ext.\n+        for (auto Ext : NTD->getExtensions()) {\n+          if (!PrintSynthesizedExtensions) {\n+            if (!Options.shouldPrint(Ext)) {\n+              Printer.callAvoidPrintDeclPost(Ext);\n+              continue;\n+            }\n+            if (extensionHasClangNode(Ext))\n+              continue; // will be printed in its source location, see above.\n+            Printer << \"\\n\";\n+            Ext->print(Printer, Options);\n+            Printer << \"\\n\";\n+          }\n+          for (auto Sub : Ext->getMembers())\n+            if (auto N = dyn_cast<NominalTypeDecl>(Sub))\n+              SubDecls.push(N);\n+        }\n+        if (!PrintSynthesizedExtensions)\n+          continue;\n+\n+        bool IsTopLevelDecl = D == NTD;\n+\n+        // If printed Decl is the top-level, merge the constraint-free extensions\n+        // into the main body.\n+        if (IsTopLevelDecl) {\n+          // Print the part that should be merged with the type decl.\n+          pAnalyzer->forEachExtensionMergeGroup(\n+            SynthesizedExtensionAnalyzer::MergeGroupKind::MergeableWithTypeDef,\n+            [&](ArrayRef<ExtensionInfo> Decls) {\n+              for (auto ET : Decls) {\n+                Options.BracketOptions = {\n+                  ET.Ext, false, Decls.back().Ext == ET.Ext, true\n+                };\n+                if (ET.IsSynthesized)\n+                  Options.initForSynthesizedExtension(NTD);\n+                ET.Ext->print(Printer, Options);\n+                if (ET.IsSynthesized)\n+                  Options.clearSynthesizedExtension();\n+                if (Options.BracketOptions.shouldCloseExtension(ET.Ext))\n+                  Printer << \"\\n\";\n+              }\n+            });\n+        }\n+\n+        // If the printed Decl is not the top-level one, reset analyzer.\n+        if (!IsTopLevelDecl)\n+          pAnalyzer.reset(new SynthesizedExtensionAnalyzer(NTD, Options));\n+\n+        // Print the rest as synthesized extensions.\n+        pAnalyzer->forEachExtensionMergeGroup(\n+          // For top-level decls, only constraint extensions need to be\n+          // printed, since the rest are merged into the main body.\n+          IsTopLevelDecl\n+          ? SynthesizedExtensionAnalyzer::MergeGroupKind::UnmergeableWithTypeDef\n+          : SynthesizedExtensionAnalyzer::MergeGroupKind::All,\n+          [&](ArrayRef<ExtensionInfo> Decls) {\n+            // Whether we've started the extension merge group in printing.\n+            bool Opened = false;\n+            for (auto ET : Decls) {\n+              Options.BracketOptions = {\n+                ET.Ext, !Opened, Decls.back().Ext == ET.Ext, true\n+              };\n+              if (Options.BracketOptions.shouldOpenExtension(ET.Ext))\n+                Printer << \"\\n\";\n+              if (ET.IsSynthesized) {\n+                if (ET.EnablingExt)\n+                  Options.initForSynthesizedExtension(ET.EnablingExt);\n+                else\n+                  Options.initForSynthesizedExtension(NTD);\n+              }\n+              // Set opened if we actually printed this extension.\n+              Opened |= ET.Ext->print(Printer, Options);\n+              if (ET.IsSynthesized)\n+                Options.clearSynthesizedExtension();\n+              if (Options.BracketOptions.shouldCloseExtension(ET.Ext))\n+                Printer << \"\\n\";\n+            }\n+          });\n+        Options.BracketOptions = BracketOptions();\n+      }\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+/// Sorts import declarations for display.\n+static bool compareImports(ImportDecl *LHS, ImportDecl *RHS) {\n+  auto LHSPath = LHS->getFullAccessPath();\n+  auto RHSPath = RHS->getFullAccessPath();\n+  for (unsigned i: range(std::min(LHSPath.size(), RHSPath.size()))) {\n+    if (int Ret = LHSPath[i].Item.str().compare(RHSPath[i].Item.str()))\n+      return Ret < 0;\n+  }\n+  return false;\n+};\n+\n+/// Sorts Swift declarations for display.\n+static bool compareSwiftDecls(Decl *LHS, Decl *RHS) {\n+  auto *LHSValue = dyn_cast<ValueDecl>(LHS);\n+  auto *RHSValue = dyn_cast<ValueDecl>(RHS);\n+\n+  if (LHSValue && RHSValue) {\n+    auto LHSName = LHSValue->getBaseName();\n+    auto RHSName = RHSValue->getBaseName();\n+    if (int Ret = LHSName.compare(RHSName))\n+      return Ret < 0;\n+    // FIXME: not sufficient to establish a total order for overloaded decls.\n+  }\n+  return LHS->getKind() < RHS->getKind();\n+};\n+\n+static std::pair<ArrayRef<Decl*>, ArrayRef<Decl*>>\n+getDeclsFromOverlay(ModuleDecl *Overlay, ModuleDecl *Underlying,\n+                    SmallVectorImpl<Decl *> &Decls, AccessLevel AccessFilter) {\n+  Overlay->getDisplayDecls(Decls);\n+\n+  // Collector the imports of the underlying module so we can filter them out.\n+  SmallPtrSet<ModuleDecl *, 8> PrevImported;\n+  SmallVector<Decl*, 1> UnderlyingDecls;\n+  Underlying->getDisplayDecls(UnderlyingDecls);\n+  for (auto *D: UnderlyingDecls) {\n+    if (auto *ID = dyn_cast<ImportDecl>(D))\n+      PrevImported.insert(ID->getModule());\n+  }\n+\n+  // Filter out inaccessible decls and any imports of, or shared with the\n+  // underlying module.\n+  auto NewEnd = std::partition(Decls.begin(), Decls.end(), [&](Decl *D) {\n+    if (auto *ID = dyn_cast<ImportDecl>(D)) {\n+      // Ignore imports of the underlying module, or any cross-import\n+      // that would map back to it.\n+      if (ID->getModule() == Underlying ||\n+          Underlying->isUnderlyingModuleOfCrossImportOverlay(ID->getModule()))\n+        return false;\n+      // Ignore an imports of modules also imported by the underlying module.\n+      if (PrevImported.find(ID->getModule()) != PrevImported.end())\n+        return false;\n+    }\n+    if (auto *VD = dyn_cast<ValueDecl>(D)) {\n+      if (AccessFilter > AccessLevel::Private &&\n+          VD->getFormalAccess() < AccessFilter)\n+        return false;\n+    }\n+    return true;\n+  });\n+  if (NewEnd != Decls.end())\n+    Decls.erase(NewEnd, Decls.end());\n+\n+  // Separate out the import declarations and sort\n+  MutableArrayRef<Decl*> Imports, Remainder;\n+  auto ImportsEnd = std::partition(Decls.begin(), Decls.end(), [](Decl *D) {\n+    return isa<ImportDecl>(D);\n+  });\n+  if (ImportsEnd != Decls.begin()) {\n+    Imports = {Decls.begin(), ImportsEnd};\n+    Remainder = {ImportsEnd, Decls.end()};\n+    std::sort(Imports.begin(), Imports.end(), [](Decl *LHS, Decl *RHS) {\n+      return compareImports(cast<ImportDecl>(LHS), cast<ImportDecl>(RHS));\n+    });\n+  } else {\n+    Remainder = Decls;\n+  }\n+  std::sort(Remainder.begin(), Remainder.end(), compareSwiftDecls);\n+  return {Imports, Remainder};\n+}\n+\n+static void printCrossImportOverlays(ModuleDecl *Underlying, ASTContext &Ctx,\n+                                     ASTPrinter &Printer,\n+                                     PrintOptions Options,\n+                                     bool PrintSynthesizedExtensions) {\n+  // If we end up printing decls from any cross-import overlay modules, make\n+  // sure we map any qualifying module references to the underlying module.\n+  Options.mapModuleToUnderlying = [&](const ModuleDecl *M) {\n+    if (Underlying->isUnderlyingModuleOfCrossImportOverlay(M))\n+      return const_cast<const ModuleDecl*>(Underlying);\n+    return M;\n+  };\n+\n+  SmallVector<Decl *, 1> OverlayDecls;\n+  SmallVector<Identifier, 1> Bystanders;\n+\n+  auto PrintDecl = [&](Decl *D) {\n+    return printModuleInterfaceDecl(D, Printer, Options,\n+                                    PrintSynthesizedExtensions);\n+  };\n+\n+  SmallVector<ModuleDecl *, 1> OverlayModules;\n+  Underlying->findDeclaredCrossImportOverlaysTransitive(OverlayModules);\n+  std::sort(OverlayModules.begin(), OverlayModules.end(),\n+            [](ModuleDecl *LHS, ModuleDecl *RHS) {\n+    return LHS->getNameStr() < RHS->getNameStr();\n+  });\n+\n+  for (auto *Overlay: OverlayModules) {\n+    OverlayDecls.clear();\n+    auto DeclLists = getDeclsFromOverlay(Overlay, Underlying, OverlayDecls,\n+                                         Options.AccessFilter);\n+\n+    // Ignore overlays without any decls\n+    if (OverlayDecls.empty())\n+      continue;\n+\n+    Bystanders.clear();\n+    Underlying->getAllBystandersForCrossImportOverlay(Overlay, Bystanders);\n+    assert(!Bystanders.empty() && \"Overlay with no bystanders?\");\n+    std::sort(Bystanders.begin(), Bystanders.end(),\n+              [](Identifier LHS, Identifier RHS) {\n+      return LHS.str() < RHS.str();\n+    });\n+\n+    std::string BystanderList;\n+    for (size_t I: range(Bystanders.size())) {\n+      if (I == Bystanders.size() - 1) {\n+        if (I != 0)\n+          BystanderList += \" and \";\n+      } else if (I != 0) {\n+        BystanderList += \", \";\n+      }\n+      BystanderList += Bystanders[I].str();\n+    }\n+\n+    Printer << \"\\n// MARK: - \" << BystanderList << \" Additions\\n\\n\";\n+    for (auto *Import : DeclLists.first)\n+      PrintDecl(Import);\n+    Printer << \"\\n\";\n+\n+    std::string PerDeclComment = \"// Available when \" + BystanderList;\n+    PerDeclComment += Bystanders.size() == 1 ? \" is\" : \" are\";\n+    PerDeclComment += \" imported with \" + Underlying->getNameStr().str();\n+\n+    for (auto *D : DeclLists.second) {\n+      // FIXME: only print this comment if the decl is actually printed.\n+      Printer << PerDeclComment << \"\\n\";\n+      if (PrintDecl(D))\n+        Printer << \"\\n\";\n+    }\n+  }\n+}\n+\n void swift::ide::printSubmoduleInterface(\n        ModuleDecl *M,\n        ArrayRef<StringRef> FullModuleName,\n@@ -246,18 +535,17 @@ void swift::ide::printSubmoduleInterface(\n        ASTPrinter &Printer,\n        const PrintOptions &Options,\n        const bool PrintSynthesizedExtensions) {\n+  auto &SwiftContext = M->getASTContext();\n+  auto &Importer =\n+      static_cast<ClangImporter &>(*SwiftContext.getClangModuleLoader());\n+\n   auto AdjustedOptions = Options;\n   adjustPrintOptions(AdjustedOptions);\n \n   SmallVector<Decl *, 1> Decls;\n   M->getDisplayDecls(Decls);\n \n-  auto &SwiftContext = M->getASTContext();\n-  auto &Importer =\n-      static_cast<ClangImporter &>(*SwiftContext.getClangModuleLoader());\n-\n   const clang::Module *InterestingClangModule = nullptr;\n-\n   SmallVector<ImportDecl *, 1> ImportDecls;\n   llvm::DenseSet<const clang::Module *> ClangModulesForImports;\n   SmallVector<Decl *, 1> SwiftDecls;\n@@ -429,9 +717,8 @@ void swift::ide::printSubmoduleInterface(\n     ImportDecls.push_back(createImportDecl(M->getASTContext(), M, SM, {}));\n   }\n \n+  // Sort imported clang declarations in source order *within a submodule*.\n   auto &ClangSourceManager = Importer.getClangASTContext().getSourceManager();\n-\n-  // Sort imported declarations in source order *within a submodule*.\n   for (auto &P : ClangDecls) {\n     std::stable_sort(P.second.begin(), P.second.end(),\n                      [&](std::pair<Decl *, clang::SourceLocation> LHS,\n@@ -442,176 +729,22 @@ void swift::ide::printSubmoduleInterface(\n   }\n \n   // Sort Swift declarations so that we print them in a consistent order.\n-  std::sort(ImportDecls.begin(), ImportDecls.end(),\n-            [](ImportDecl *LHS, ImportDecl *RHS) -> bool {\n-    auto LHSPath = LHS->getFullAccessPath();\n-    auto RHSPath = RHS->getFullAccessPath();\n-    for (unsigned i = 0, e = std::min(LHSPath.size(), RHSPath.size()); i != e;\n-         i++) {\n-      if (int Ret = LHSPath[i].Item.str().compare(RHSPath[i].Item.str()))\n-        return Ret < 0;\n-    }\n-    return false;\n-  });\n+  std::sort(ImportDecls.begin(), ImportDecls.end(), compareImports);\n \n   // If the group name is specified, we sort them according to their source order,\n   // which is the order preserved by getTopLevelDecls.\n-  if (GroupNames.empty()) {\n-    std::stable_sort(SwiftDecls.begin(), SwiftDecls.end(),\n-      [&](Decl *LHS, Decl *RHS) -> bool {\n-        auto *LHSValue = dyn_cast<ValueDecl>(LHS);\n-        auto *RHSValue = dyn_cast<ValueDecl>(RHS);\n-\n-        if (LHSValue && RHSValue) {\n-          auto LHSName = LHSValue->getBaseName();\n-          auto RHSName = RHSValue->getBaseName();\n-          if (int Ret = LHSName.compare(RHSName))\n-            return Ret < 0;\n-          // FIXME: this is not sufficient to establish a total order for overloaded\n-          // decls.\n-          return LHS->getKind() < RHS->getKind();\n-        }\n-\n-        return LHS->getKind() < RHS->getKind();\n-      });\n-  }\n+  if (GroupNames.empty())\n+    std::stable_sort(SwiftDecls.begin(), SwiftDecls.end(), compareSwiftDecls);\n \n   ASTPrinter *PrinterToUse = &Printer;\n \n   ClangCommentPrinter RegularCommentPrinter(Printer, Importer);\n   if (Options.PrintRegularClangComments)\n     PrinterToUse = &RegularCommentPrinter;\n \n-  auto PrintDecl = [&](Decl *D) -> bool {\n-    ASTPrinter &Printer = *PrinterToUse;\n-    if (!AdjustedOptions.shouldPrint(D)) {\n-      Printer.callAvoidPrintDeclPost(D);\n-      return false;\n-    }\n-    if (auto Ext = dyn_cast<ExtensionDecl>(D)) {\n-      // Clang extensions (categories) are always printed in source order.\n-      // Swift extensions are printed with their associated type unless it's\n-      // a cross-module extension.\n-      if (!extensionHasClangNode(Ext)) {\n-        auto ExtendedNominal = Ext->getExtendedNominal();\n-        if (Ext->getModuleContext() == ExtendedNominal->getModuleContext())\n-          return false;\n-      }\n-    }\n-    std::unique_ptr<SynthesizedExtensionAnalyzer> pAnalyzer;\n-    if (auto NTD = dyn_cast<NominalTypeDecl>(D)) {\n-      if (PrintSynthesizedExtensions) {\n-        pAnalyzer.reset(new SynthesizedExtensionAnalyzer(NTD, AdjustedOptions));\n-        AdjustedOptions.BracketOptions = {NTD, true, true,\n-          !pAnalyzer->hasMergeGroup(SynthesizedExtensionAnalyzer::\n-                                    MergeGroupKind::MergeableWithTypeDef)};\n-      }\n-    }\n-    if (D->print(Printer, AdjustedOptions)) {\n-      if (AdjustedOptions.BracketOptions.shouldCloseNominal(D))\n-        Printer << \"\\n\";\n-      AdjustedOptions.BracketOptions = BracketOptions();\n-      if (auto NTD = dyn_cast<NominalTypeDecl>(D)) {\n-        std::queue<NominalTypeDecl *> SubDecls{{NTD}};\n-\n-        while (!SubDecls.empty()) {\n-          auto NTD = SubDecls.front();\n-          SubDecls.pop();\n-\n-          // Add sub-types of NTD.\n-          for (auto Sub : NTD->getMembers())\n-            if (auto N = dyn_cast<NominalTypeDecl>(Sub))\n-              SubDecls.push(N);\n-\n-          // Print Ext and add sub-types of Ext.\n-          for (auto Ext : NTD->getExtensions()) {\n-            if (!PrintSynthesizedExtensions) {\n-              if (!AdjustedOptions.shouldPrint(Ext)) {\n-                Printer.callAvoidPrintDeclPost(Ext);\n-                continue;\n-              }\n-              if (extensionHasClangNode(Ext))\n-                continue; // will be printed in its source location, see above.\n-              Printer << \"\\n\";\n-              Ext->print(Printer, AdjustedOptions);\n-              Printer << \"\\n\";\n-            }\n-            for (auto Sub : Ext->getMembers())\n-              if (auto N = dyn_cast<NominalTypeDecl>(Sub))\n-                SubDecls.push(N);\n-          }\n-          if (!PrintSynthesizedExtensions)\n-            continue;\n-\n-          bool IsTopLevelDecl = D == NTD;\n-\n-          // If printed Decl is the top-level, merge the constraint-free extensions\n-          // into the main body.\n-          if (IsTopLevelDecl) {\n-          // Print the part that should be merged with the type decl.\n-          pAnalyzer->forEachExtensionMergeGroup(\n-              SynthesizedExtensionAnalyzer::MergeGroupKind::\n-                  MergeableWithTypeDef,\n-              [&](ArrayRef<ExtensionInfo> Decls) {\n-                for (auto ET : Decls) {\n-                  AdjustedOptions.BracketOptions = {\n-                      ET.Ext, false, Decls.back().Ext == ET.Ext, true};\n-                  if (ET.IsSynthesized)\n-                    AdjustedOptions.initForSynthesizedExtension(NTD);\n-                  ET.Ext->print(Printer, AdjustedOptions);\n-                  if (ET.IsSynthesized)\n-                    AdjustedOptions.clearSynthesizedExtension();\n-                  if (AdjustedOptions.BracketOptions.shouldCloseExtension(\n-                          ET.Ext))\n-                    Printer << \"\\n\";\n-                }\n-              });\n-          }\n-\n-          // If the printed Decl is not the top-level one, reset analyzer.\n-          if (!IsTopLevelDecl)\n-            pAnalyzer.reset(new SynthesizedExtensionAnalyzer(NTD, AdjustedOptions));\n-\n-          // Print the rest as synthesized extensions.\n-          pAnalyzer->forEachExtensionMergeGroup(\n-              // For top-level decls, only constraint extensions need to be\n-              // printed, since the rest are merged into the main body.\n-              IsTopLevelDecl ? SynthesizedExtensionAnalyzer::MergeGroupKind::\n-                                   UnmergeableWithTypeDef\n-                             :\n-                             // For sub-decls, all extensions should be printed.\n-                  SynthesizedExtensionAnalyzer::MergeGroupKind::All,\n-              [&](ArrayRef<ExtensionInfo> Decls) {\n-                // Whether we've started the extension merge group in printing.\n-                bool Opened = false;\n-                for (auto ET : Decls) {\n-                  AdjustedOptions.BracketOptions = { ET.Ext, !Opened,\n-                    Decls.back().Ext == ET.Ext, true};\n-                  if (AdjustedOptions.BracketOptions.shouldOpenExtension(\n-                          ET.Ext))\n-                    Printer << \"\\n\";\n-                  if (ET.IsSynthesized) {\n-                    if (ET.EnablingExt)\n-                      AdjustedOptions.initForSynthesizedExtension(\n-                          ET.EnablingExt);\n-                    else\n-                      AdjustedOptions.initForSynthesizedExtension(NTD);\n-                  }\n-                  // Set opened if we actually printed this extension.\n-                  Opened |= ET.Ext->print(Printer, AdjustedOptions);\n-                  if (ET.IsSynthesized)\n-                    AdjustedOptions.clearSynthesizedExtension();\n-                  if (AdjustedOptions.BracketOptions.shouldCloseExtension(\n-                          ET.Ext))\n-                    Printer << \"\\n\";\n-                }\n-              });\n-          AdjustedOptions.BracketOptions = BracketOptions();\n-        }\n-      }\n-      return true;\n-    }\n-    return false;\n+  auto PrintDecl = [&](Decl *D) {\n+    return printModuleInterfaceDecl(D, *PrinterToUse, AdjustedOptions,\n+                                    PrintSynthesizedExtensions);\n   };\n \n   // Imports from the stdlib are internal details that don't need to be exposed.\n@@ -646,6 +779,14 @@ void swift::ide::printSubmoduleInterface(\n       if (PrintDecl(D))\n         Printer << \"\\n\";\n     }\n+\n+    // If we're printing the entire target module (not specific sub-groups),\n+    // also print the decls from any underscored Swift cross-import overlays it\n+    // is the underlying module of, transitively.\n+    if (GroupNames.empty()) {\n+      printCrossImportOverlays(M, SwiftContext, *PrinterToUse, AdjustedOptions,\n+                               PrintSynthesizedExtensions);\n+    }\n   }\n }\n "
                    },
                    {
                        "filename": "lib/IDE/Refactoring.cpp",
                        "code": "@@ -2278,7 +2278,7 @@ isApplicable(ResolvedRangeInfo Info, DiagnosticEngine &Diag) {\n     }\n \n     bool checkName(FuncDecl *FD) {\n-      auto Name = FD->getName().str();\n+      const auto Name = FD->getBaseIdentifier().str();\n       return Name == \"~=\"\n       || Name == \"==\"\n       || Name == \"__derived_enum_equals\"\n@@ -2391,7 +2391,8 @@ bool RefactoringActionConvertToSwitchStmt::performChange() {\n     bool isFunctionNameAllowed(BinaryExpr *E) {\n       auto FunctionBody = dyn_cast<DotSyntaxCallExpr>(E->getFn())->getFn();\n       auto FunctionDeclaration = dyn_cast<DeclRefExpr>(FunctionBody)->getDecl();\n-      auto FunctionName = dyn_cast<FuncDecl>(FunctionDeclaration)->getName().str();\n+      const auto FunctionName = dyn_cast<FuncDecl>(FunctionDeclaration)\n+          ->getBaseIdentifier().str();\n       return FunctionName == \"~=\"\n       || FunctionName == \"==\"\n       || FunctionName == \"__derived_enum_equals\""
                    },
                    {
                        "filename": "lib/IDE/SyntaxModel.cpp",
                        "code": "@@ -1047,7 +1047,7 @@ bool ModelASTWalker::walkToDeclPre(Decl *D) {\n       // as members of the enum case decl. Walk them manually here so that they\n       // end up as child nodes of enum case.\n       for (auto *EnumElemD : EnumCaseD->getElements()) {\n-        if (EnumElemD->getName().empty())\n+        if (EnumElemD->getBaseIdentifier().empty())\n           continue;\n         SyntaxStructureNode SN;\n         setDecl(SN, EnumElemD);\n@@ -1060,7 +1060,8 @@ bool ModelASTWalker::walkToDeclPre(Decl *D) {\n           SN.NameRange = charSourceRangeFromSourceRange(SM, NameRange);\n         } else {\n           SN.NameRange = CharSourceRange(EnumElemD->getNameLoc(),\n-                                         EnumElemD->getName().getLength());\n+                                         EnumElemD->getBaseIdentifier()\n+                                           .getLength());\n         }\n \n         if (auto *E = EnumElemD->getRawValueUnchecked()) {"
                    },
                    {
                        "filename": "lib/IDE/TypeContextInfo.cpp",
                        "code": "@@ -167,7 +167,8 @@ void ContextInfoCallbacks::getImplicitMembers(\n   } LocalConsumer(CurDeclContext, T, Result);\n \n   lookupVisibleMemberDecls(LocalConsumer, MetatypeType::get(T), CurDeclContext,\n-                           /*includeInstanceMembers=*/false);\n+                           /*includeInstanceMembers=*/false,\n+                           /*includeDerivedRequirements*/false);\n }\n \n void PrintingTypeContextInfoConsumer::handleResults("
                    },
                    {
                        "filename": "lib/IRGen/CMakeLists.txt",
                        "code": "@@ -16,6 +16,7 @@ add_swift_host_library(swiftIRGen STATIC\n   GenControl.cpp\n   GenCoverage.cpp\n   GenDecl.cpp\n+  GenDiffFunc.cpp\n   GenDiffWitness.cpp\n   GenEnum.cpp\n   GenExistential.cpp"
                    },
                    {
                        "filename": "lib/IRGen/GenClass.cpp",
                        "code": "@@ -1113,8 +1113,7 @@ namespace {\n     void visitConformances(DeclContext *dc) {\n       llvm::SmallSetVector<ProtocolDecl *, 2> protocols;\n       for (auto conformance : dc->getLocalConformances(\n-                                ConformanceLookupKind::OnlyExplicit,\n-                                nullptr)) {\n+                                ConformanceLookupKind::OnlyExplicit)) {\n         ProtocolDecl *proto = conformance->getProtocol();\n         getObjCProtocols(proto, protocols);\n       }\n@@ -1521,33 +1520,27 @@ namespace {\n     }\n \n     void buildMethod(ConstantArrayBuilder &descriptors,\n-                     MethodDescriptor descriptor,\n-                     llvm::StringSet<> &uniqueSelectors) {\n+                     MethodDescriptor descriptor) {\n       switch (descriptor.getKind()) {\n       case MethodDescriptor::Kind::Method:\n-        return buildMethod(descriptors, descriptor.getMethod(),\n-                           uniqueSelectors);\n+        return buildMethod(descriptors, descriptor.getMethod());\n       case MethodDescriptor::Kind::IVarInitializer:\n         emitObjCIVarInitDestroyDescriptor(IGM, descriptors, getClass(),\n-                                          descriptor.getImpl(), false,\n-                                          uniqueSelectors);\n+                                          descriptor.getImpl(), false);\n         return;\n       case MethodDescriptor::Kind::IVarDestroyer:\n         emitObjCIVarInitDestroyDescriptor(IGM, descriptors, getClass(),\n-                                          descriptor.getImpl(), true,\n-                                          uniqueSelectors);\n+                                          descriptor.getImpl(), true);\n         return;\n       }\n       llvm_unreachable(\"bad method descriptor kind\");\n     }\n \n     void buildMethod(ConstantArrayBuilder &descriptors,\n-                     AbstractFunctionDecl *method,\n-                     llvm::StringSet<> &uniqueSelectors) {\n+                     AbstractFunctionDecl *method) {\n       auto accessor = dyn_cast<AccessorDecl>(method);\n       if (!accessor)\n-        return emitObjCMethodDescriptor(IGM, descriptors, method,\n-                                        uniqueSelectors);\n+        return emitObjCMethodDescriptor(IGM, descriptors, method);\n \n       switch (accessor->getAccessorKind()) {\n       case AccessorKind::Get:\n@@ -1616,9 +1609,7 @@ namespace {\n         namePrefix = \"_PROTOCOL_INSTANCE_METHODS_OPT_\";\n         break;\n       }\n-      llvm::StringSet<> uniqueSelectors;\n-      llvm::Constant *methodListPtr =\n-          buildMethodList(methods, namePrefix, uniqueSelectors);\n+      llvm::Constant *methodListPtr = buildMethodList(methods, namePrefix);\n       builder.add(methodListPtr);\n     }\n \n@@ -1661,12 +1652,11 @@ namespace {\n     ///\n     /// This method does not return a value of a predictable type.\n     llvm::Constant *buildMethodList(ArrayRef<MethodDescriptor> methods,\n-                                    StringRef name,\n-                                    llvm::StringSet<> &uniqueSelectors) {\n+                                    StringRef name) {\n       return buildOptionalList(methods, 3 * IGM.getPointerSize(), name,\n                                [&](ConstantArrayBuilder &descriptors,\n                                    MethodDescriptor descriptor) {\n-        buildMethod(descriptors, descriptor, uniqueSelectors);\n+        buildMethod(descriptors, descriptor);\n       });\n     }\n "
                    },
                    {
                        "filename": "lib/IRGen/GenDecl.cpp",
                        "code": "@@ -889,7 +889,7 @@ IRGenModule::getConstantReferenceForProtocolDescriptor(ProtocolDecl *proto) {\n \n void IRGenModule::addLazyConformances(DeclContext *dc) {\n   for (const ProtocolConformance *conf :\n-         dc->getLocalConformances(ConformanceLookupKind::All, nullptr)) {\n+         dc->getLocalConformances(ConformanceLookupKind::All)) {\n     IRGen.addLazyWitnessTable(conf);\n   }\n }"
                    },
                    {
                        "filename": "lib/IRGen/GenDiffFunc.cpp",
                        "code": "@@ -0,0 +1,350 @@\n+//===- GenDiffFunc.cpp - Swift IR Generation For @differentiable Functions ===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2019 - 2020 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file implements IR generation for `@differentiable` function types in\n+// Swift.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"swift/AST/Decl.h\"\n+#include \"swift/AST/Pattern.h\"\n+#include \"swift/AST/Types.h\"\n+#include \"swift/SIL/SILModule.h\"\n+#include \"swift/SIL/SILType.h\"\n+#include \"llvm/IR/DerivedTypes.h\"\n+\n+#include \"Explosion.h\"\n+#include \"GenHeap.h\"\n+#include \"GenRecord.h\"\n+#include \"GenType.h\"\n+#include \"IRGenFunction.h\"\n+#include \"IRGenModule.h\"\n+#include \"IndirectTypeInfo.h\"\n+#include \"NonFixedTypeInfo.h\"\n+\n+#pragma clang diagnostic ignored \"-Winconsistent-missing-override\"\n+\n+using namespace swift;\n+using namespace irgen;\n+\n+//----------------------------------------------------------------------------//\n+// `@differentiable` (non-linear) function type info\n+//----------------------------------------------------------------------------//\n+\n+namespace {\n+class DifferentiableFuncFieldInfo final\n+    : public RecordField<DifferentiableFuncFieldInfo> {\n+public:\n+  DifferentiableFuncFieldInfo(\n+      NormalDifferentiableFunctionTypeComponent component, const TypeInfo &type,\n+      IndexSubset *parameterIndices)\n+      : RecordField(type), component(component),\n+        parameterIndices(parameterIndices) {}\n+\n+  /// The field index.\n+  const NormalDifferentiableFunctionTypeComponent component;\n+\n+  /// The parameter indices.\n+  IndexSubset *parameterIndices;\n+\n+  std::string getFieldName() const {\n+    switch (component) {\n+    case NormalDifferentiableFunctionTypeComponent::Original:\n+      return \"original\";\n+    case NormalDifferentiableFunctionTypeComponent::JVP:\n+      return \"jvp\";\n+    case NormalDifferentiableFunctionTypeComponent::VJP:\n+      return \"vjp\";\n+    }\n+  }\n+\n+  SILType getType(IRGenModule &IGM, SILType t) const {\n+    auto fnTy = t.castTo<SILFunctionType>();\n+    auto origFnTy = fnTy->getWithoutDifferentiability();\n+    if (component == NormalDifferentiableFunctionTypeComponent::Original)\n+      return SILType::getPrimitiveObjectType(origFnTy);\n+    auto kind = *component.getAsDerivativeFunctionKind();\n+    auto assocTy = origFnTy->getAutoDiffDerivativeFunctionType(\n+        parameterIndices, /*resultIndex*/ 0, kind, IGM.getSILTypes(),\n+        LookUpConformanceInModule(IGM.getSwiftModule()));\n+    return SILType::getPrimitiveObjectType(assocTy);\n+  }\n+};\n+\n+class DifferentiableFuncTypeInfo final\n+    : public RecordTypeInfo<DifferentiableFuncTypeInfo, LoadableTypeInfo,\n+                            DifferentiableFuncFieldInfo> {\n+  using super = RecordTypeInfo<DifferentiableFuncTypeInfo, LoadableTypeInfo,\n+                               DifferentiableFuncFieldInfo>;\n+\n+public:\n+  DifferentiableFuncTypeInfo(ArrayRef<DifferentiableFuncFieldInfo> fields,\n+                             unsigned explosionSize, llvm::Type *ty, Size size,\n+                             SpareBitVector &&spareBits, Alignment align,\n+                             IsPOD_t isPOD, IsFixedSize_t alwaysFixedSize)\n+      : super(fields, explosionSize, ty, size, std::move(spareBits), align,\n+              isPOD, alwaysFixedSize) {}\n+\n+  Address projectFieldAddress(IRGenFunction &IGF, Address addr, SILType T,\n+                              const DifferentiableFuncFieldInfo &field) const {\n+    return field.projectAddress(IGF, addr, getNonFixedOffsets(IGF, T));\n+  }\n+\n+  void initializeFromParams(IRGenFunction &IGF, Explosion &params, Address src,\n+                            SILType T, bool isOutlined) const override {\n+    llvm_unreachable(\"unexploded @differentiable function as argument?\");\n+  }\n+\n+  void addToAggLowering(IRGenModule &IGM, SwiftAggLowering &lowering,\n+                        Size offset) const override {\n+    for (auto &field : getFields()) {\n+      auto fieldOffset = offset + field.getFixedByteOffset();\n+      cast<LoadableTypeInfo>(field.getTypeInfo())\n+          .addToAggLowering(IGM, lowering, fieldOffset);\n+    }\n+  }\n+\n+  TypeLayoutEntry *buildTypeLayoutEntry(IRGenModule &IGM,\n+                                        SILType T) const override {\n+    return IGM.typeLayoutCache.getOrCreateScalarEntry(*this, T);\n+  }\n+\n+  llvm::NoneType getNonFixedOffsets(IRGenFunction &IGF) const { return None; }\n+  llvm::NoneType getNonFixedOffsets(IRGenFunction &IGF, SILType T) const {\n+    return None;\n+  }\n+};\n+\n+class DifferentiableFuncTypeBuilder\n+    : public RecordTypeBuilder<DifferentiableFuncTypeBuilder,\n+                               DifferentiableFuncFieldInfo,\n+                               NormalDifferentiableFunctionTypeComponent> {\n+\n+  SILFunctionType *originalType;\n+  IndexSubset *parameterIndices;\n+\n+public:\n+  DifferentiableFuncTypeBuilder(IRGenModule &IGM, SILFunctionType *fnTy)\n+      : RecordTypeBuilder(IGM),\n+        originalType(fnTy->getWithoutDifferentiability()),\n+        parameterIndices(fnTy->getDifferentiabilityParameterIndices()) {\n+    assert(fnTy->getDifferentiabilityKind() == DifferentiabilityKind::Normal);\n+  }\n+\n+  TypeInfo *createFixed(ArrayRef<DifferentiableFuncFieldInfo> fields,\n+                        StructLayout &&layout) {\n+    llvm_unreachable(\"@differentiable functions are always loadable\");\n+  }\n+\n+  DifferentiableFuncTypeInfo *\n+  createLoadable(ArrayRef<DifferentiableFuncFieldInfo> fields,\n+                 StructLayout &&layout, unsigned explosionSize) {\n+    return DifferentiableFuncTypeInfo::create(\n+        fields, explosionSize, layout.getType(), layout.getSize(),\n+        std::move(layout.getSpareBits()), layout.getAlignment(), layout.isPOD(),\n+        layout.isAlwaysFixedSize());\n+  }\n+\n+  TypeInfo *createNonFixed(ArrayRef<DifferentiableFuncFieldInfo> fields,\n+                           FieldsAreABIAccessible_t fieldsAccessible,\n+                           StructLayout &&layout) {\n+    llvm_unreachable(\"@differentiable functions are always loadable\");\n+  }\n+\n+  DifferentiableFuncFieldInfo\n+  getFieldInfo(unsigned index,\n+               NormalDifferentiableFunctionTypeComponent component,\n+               const TypeInfo &fieldTI) {\n+    return DifferentiableFuncFieldInfo(component, fieldTI, parameterIndices);\n+  }\n+\n+  SILType getType(NormalDifferentiableFunctionTypeComponent component) {\n+    if (component == NormalDifferentiableFunctionTypeComponent::Original)\n+      return SILType::getPrimitiveObjectType(originalType->getCanonicalType());\n+    auto kind = *component.getAsDerivativeFunctionKind();\n+    auto assocTy = originalType->getAutoDiffDerivativeFunctionType(\n+        parameterIndices, /*resultIndex*/ 0, kind, IGM.getSILTypes(),\n+        LookUpConformanceInModule(IGM.getSwiftModule()));\n+    return SILType::getPrimitiveObjectType(assocTy);\n+  }\n+\n+  StructLayout performLayout(ArrayRef<const TypeInfo *> fieldTypes) {\n+    return StructLayout(IGM, /*decl=*/nullptr, LayoutKind::NonHeapObject,\n+                        LayoutStrategy::Universal, fieldTypes);\n+  }\n+};\n+} // end anonymous namespace\n+\n+//----------------------------------------------------------------------------//\n+// `@differentiable(linear)` function type info\n+//----------------------------------------------------------------------------//\n+\n+namespace {\n+class LinearFuncFieldInfo final : public RecordField<LinearFuncFieldInfo> {\n+public:\n+  LinearFuncFieldInfo(LinearDifferentiableFunctionTypeComponent component,\n+                      const TypeInfo &type, IndexSubset *parameterIndices)\n+      : RecordField(type), component(component),\n+        parameterIndices(parameterIndices) {}\n+\n+  /// The field index.\n+  const LinearDifferentiableFunctionTypeComponent component;\n+\n+  /// The parameter indices.\n+  IndexSubset *parameterIndices;\n+\n+  std::string getFieldName() const {\n+    switch (component) {\n+    case LinearDifferentiableFunctionTypeComponent::Original:\n+      return \"original\";\n+    case LinearDifferentiableFunctionTypeComponent::Transpose:\n+      return \"transpose\";\n+    }\n+  }\n+\n+  SILType getType(IRGenModule &IGM, SILType t) const {\n+    auto fnTy = t.castTo<SILFunctionType>();\n+    auto origFnTy = fnTy->getWithoutDifferentiability();\n+    switch (component) {\n+    case LinearDifferentiableFunctionTypeComponent::Original:\n+      return SILType::getPrimitiveObjectType(origFnTy);\n+    case LinearDifferentiableFunctionTypeComponent::Transpose:\n+      auto transposeTy = origFnTy->getAutoDiffTransposeFunctionType(\n+          parameterIndices, IGM.getSILTypes(),\n+          LookUpConformanceInModule(IGM.getSwiftModule()));\n+      return SILType::getPrimitiveObjectType(transposeTy);\n+    }\n+  }\n+};\n+\n+class LinearFuncTypeInfo final\n+    : public RecordTypeInfo<LinearFuncTypeInfo, LoadableTypeInfo,\n+                            LinearFuncFieldInfo> {\n+  using super =\n+      RecordTypeInfo<LinearFuncTypeInfo, LoadableTypeInfo, LinearFuncFieldInfo>;\n+\n+public:\n+  LinearFuncTypeInfo(ArrayRef<LinearFuncFieldInfo> fields,\n+                     unsigned explosionSize, llvm::Type *ty, Size size,\n+                     SpareBitVector &&spareBits, Alignment align, IsPOD_t isPOD,\n+                     IsFixedSize_t alwaysFixedSize)\n+      : super(fields, explosionSize, ty, size, std::move(spareBits), align,\n+              isPOD, alwaysFixedSize) {}\n+\n+  Address projectFieldAddress(IRGenFunction &IGF, Address addr, SILType T,\n+                              const LinearFuncFieldInfo &field) const {\n+    return field.projectAddress(IGF, addr, getNonFixedOffsets(IGF, T));\n+  }\n+\n+  void initializeFromParams(IRGenFunction &IGF, Explosion &params, Address src,\n+                            SILType T, bool isOutlined) const override {\n+    llvm_unreachable(\"unexploded @differentiable function as argument?\");\n+  }\n+\n+  void addToAggLowering(IRGenModule &IGM, SwiftAggLowering &lowering,\n+                        Size offset) const override {\n+    for (auto &field : getFields()) {\n+      auto fieldOffset = offset + field.getFixedByteOffset();\n+      cast<LoadableTypeInfo>(field.getTypeInfo())\n+          .addToAggLowering(IGM, lowering, fieldOffset);\n+    }\n+  }\n+\n+  TypeLayoutEntry *buildTypeLayoutEntry(IRGenModule &IGM,\n+                                        SILType T) const override {\n+    return IGM.typeLayoutCache.getOrCreateScalarEntry(*this, T);\n+  }\n+\n+  llvm::NoneType getNonFixedOffsets(IRGenFunction &IGF) const { return None; }\n+  llvm::NoneType getNonFixedOffsets(IRGenFunction &IGF, SILType T) const {\n+    return None;\n+  }\n+};\n+\n+class LinearFuncTypeBuilder\n+    : public RecordTypeBuilder<LinearFuncTypeBuilder, LinearFuncFieldInfo,\n+                               LinearDifferentiableFunctionTypeComponent> {\n+\n+  SILFunctionType *originalType;\n+  IndexSubset *parameterIndices;\n+\n+public:\n+  LinearFuncTypeBuilder(IRGenModule &IGM, SILFunctionType *fnTy)\n+      : RecordTypeBuilder(IGM),\n+        originalType(fnTy->getWithoutDifferentiability()),\n+        parameterIndices(fnTy->getDifferentiabilityParameterIndices()) {\n+    assert(fnTy->getDifferentiabilityKind() == DifferentiabilityKind::Linear);\n+  }\n+\n+  TypeInfo *createFixed(ArrayRef<LinearFuncFieldInfo> fields,\n+                        StructLayout &&layout) {\n+    llvm_unreachable(\"@differentiable functions are always loadable\");\n+  }\n+\n+  LinearFuncTypeInfo *createLoadable(ArrayRef<LinearFuncFieldInfo> fields,\n+                                     StructLayout &&layout,\n+                                     unsigned explosionSize) {\n+    return LinearFuncTypeInfo::create(\n+        fields, explosionSize, layout.getType(), layout.getSize(),\n+        std::move(layout.getSpareBits()), layout.getAlignment(), layout.isPOD(),\n+        layout.isAlwaysFixedSize());\n+  }\n+\n+  TypeInfo *createNonFixed(ArrayRef<LinearFuncFieldInfo> fields,\n+                           FieldsAreABIAccessible_t fieldsAccessible,\n+                           StructLayout &&layout) {\n+    llvm_unreachable(\"@differentiable functions are always loadable\");\n+  }\n+\n+  LinearFuncFieldInfo\n+  getFieldInfo(unsigned index, LinearDifferentiableFunctionTypeComponent field,\n+               const TypeInfo &fieldTI) {\n+    return LinearFuncFieldInfo(field, fieldTI, parameterIndices);\n+  }\n+\n+  SILType getType(LinearDifferentiableFunctionTypeComponent component) {\n+    switch (component) {\n+    case LinearDifferentiableFunctionTypeComponent::Original:\n+      return SILType::getPrimitiveObjectType(originalType->getCanonicalType());\n+    case LinearDifferentiableFunctionTypeComponent::Transpose:\n+      auto transposeTy = originalType->getAutoDiffTransposeFunctionType(\n+          parameterIndices, IGM.getSILTypes(),\n+          LookUpConformanceInModule(IGM.getSwiftModule()));\n+      return SILType::getPrimitiveObjectType(transposeTy);\n+    }\n+  }\n+\n+  StructLayout performLayout(ArrayRef<const TypeInfo *> fieldTypes) {\n+    return StructLayout(IGM, /*decl=*/nullptr, LayoutKind::NonHeapObject,\n+                        LayoutStrategy::Universal, fieldTypes);\n+  }\n+};\n+} // end anonymous namespace\n+\n+//----------------------------------------------------------------------------//\n+// Type converter entry points\n+//----------------------------------------------------------------------------//\n+\n+const TypeInfo *\n+TypeConverter::convertNormalDifferentiableFunctionType(SILFunctionType *type) {\n+  DifferentiableFuncTypeBuilder builder(IGM, type);\n+  return builder.layout({NormalDifferentiableFunctionTypeComponent::Original,\n+                         NormalDifferentiableFunctionTypeComponent::JVP,\n+                         NormalDifferentiableFunctionTypeComponent::VJP});\n+}\n+\n+const TypeInfo *\n+TypeConverter::convertLinearDifferentiableFunctionType(SILFunctionType *type) {\n+  LinearFuncTypeBuilder builder(IGM, type);\n+  return builder.layout({LinearDifferentiableFunctionTypeComponent::Original,\n+                         LinearDifferentiableFunctionTypeComponent::Transpose});\n+}"
                    },
                    {
                        "filename": "lib/IRGen/GenDiffWitness.cpp",
                        "code": "@@ -39,15 +39,28 @@ void IRGenModule::emitSILDifferentiabilityWitness(\n   ConstantInitBuilder builder(*this);\n   auto diffWitnessContents = builder.beginStruct();\n \n+  // TODO(TF-1211): Uncomment assertions after upstreaming differentiation\n+  // transform.\n+  // The mandatory differentiation transform canonicalizes differentiability\n+  // witnesses and ensures that JVPs/VJPs are populated.\n+  /*\n   assert(dw->getJVP() &&\n          \"Differentiability witness definition should have JVP\");\n   assert(dw->getVJP() &&\n          \"Differentiability witness definition should have VJP\");\n-\n   diffWitnessContents.addBitCast(\n       getAddrOfSILFunction(dw->getJVP(), NotForDefinition), Int8PtrTy);\n   diffWitnessContents.addBitCast(\n       getAddrOfSILFunction(dw->getVJP(), NotForDefinition), Int8PtrTy);\n+  */\n+  llvm::Constant *jvpValue = llvm::UndefValue::get(Int8PtrTy);\n+  llvm::Constant *vjpValue = llvm::UndefValue::get(Int8PtrTy);\n+  if (auto *jvpFn = dw->getJVP())\n+    jvpValue = getAddrOfSILFunction(dw->getJVP(), NotForDefinition);\n+  if (auto *vjpFn = dw->getJVP())\n+    vjpValue = getAddrOfSILFunction(dw->getVJP(), NotForDefinition);\n+  diffWitnessContents.addBitCast(jvpValue, Int8PtrTy);\n+  diffWitnessContents.addBitCast(vjpValue, Int8PtrTy);\n \n   getAddrOfDifferentiabilityWitness(\n       dw, diffWitnessContents.finishAndCreateFuture());"
                    },
                    {
                        "filename": "lib/IRGen/GenEnum.cpp",
                        "code": "@@ -6917,7 +6917,7 @@ const TypeInfo *TypeConverter::convertEnumType(TypeBase *key, CanType type,\n       auto bitPattern = strategy->getBitPatternForNoPayloadElement(elt.decl);\n       assert(bitPattern.size() == fixedTI->getFixedSize().getValueInBits());\n       LLVM_DEBUG(llvm::dbgs() << \"  no-payload case \"\n-                              << elt.decl->getName().str()\n+                              << elt.decl->getBaseIdentifier().str()\n                               << \":\\t\";\n             displayBitMask(bitPattern));\n "
                    },
                    {
                        "filename": "lib/IRGen/GenFunc.cpp",
                        "code": "@@ -498,6 +498,16 @@ Address irgen::projectBlockStorageCapture(IRGenFunction &IGF,\n }\n \n const TypeInfo *TypeConverter::convertFunctionType(SILFunctionType *T) {\n+  // Handle `@differentiable` and `@differentiable(linear)` functions.\n+  switch (T->getDifferentiabilityKind()) {\n+  case DifferentiabilityKind::Normal:\n+    return convertNormalDifferentiableFunctionType(T);\n+  case DifferentiabilityKind::Linear:\n+    return convertLinearDifferentiableFunctionType(T);\n+  case DifferentiabilityKind::NonDifferentiable:\n+    break;\n+  }\n+\n   switch (T->getRepresentation()) {\n   case SILFunctionType::Representation::Block:\n     return new BlockTypeInfo(CanSILFunctionType(T),"
                    },
                    {
                        "filename": "lib/IRGen/GenKeyPath.cpp",
                        "code": "@@ -992,8 +992,7 @@ emitKeyPathComponent(IRGenModule &IGM,\n         auto methodProto = cast<ProtocolDecl>(dc);\n         auto &protoInfo = IGM.getProtocolInfo(methodProto,\n                                               ProtocolInfoKind::Full);\n-        auto index = protoInfo.getFunctionIndex(\n-                             cast<AbstractFunctionDecl>(declRef.getDecl()));\n+        auto index = protoInfo.getFunctionIndex(declRef);\n         idValue = llvm::ConstantInt::get(IGM.SizeTy, -index.getValue());\n         idResolution = KeyPathComponentHeader::Resolved;\n       }"
                    },
                    {
                        "filename": "lib/IRGen/GenMeta.cpp",
                        "code": "@@ -1741,7 +1741,12 @@ namespace {\n         auto underlyingConformance = conformance\n           .subst(O->getUnderlyingInterfaceType(),\n                  *O->getUnderlyingTypeSubstitutions());\n-        \n+\n+        // Skip protocols without Witness tables, e.g. @objc protocols.\n+        if (!Lowering::TypeConverter::protocolRequiresWitnessTable(\n+                underlyingConformance.getRequirement()))\n+          continue;\n+\n         auto witnessTableRef = IGM.emitWitnessTableRefString(\n                                           underlyingType, underlyingConformance,\n                                           contextSig,\n@@ -4634,6 +4639,7 @@ SpecialProtocol irgen::getSpecialProtocolID(ProtocolDecl *P) {\n   case KnownProtocolKind::Encodable:\n   case KnownProtocolKind::Decodable:\n   case KnownProtocolKind::StringInterpolationProtocol:\n+  case KnownProtocolKind::AdditiveArithmetic:\n   case KnownProtocolKind::Differentiable:\n     return SpecialProtocol::None;\n   }"
                    },
                    {
                        "filename": "lib/IRGen/GenObjC.cpp",
                        "code": "@@ -1100,41 +1100,9 @@ static llvm::Constant *getObjCEncodingForTypes(IRGenModule &IGM,\n   return IGM.getAddrOfGlobalString(encodingString);\n }\n \n-static llvm::Constant *\n-getObjectEncodingFromClangNode(IRGenModule &IGM, Decl *d,\n-                               bool useExtendedEncoding) {\n-  // Use the clang node's encoding if there is a clang node.\n-  if (d->getClangNode()) {\n-    auto clangDecl = d->getClangNode().castAsDecl();\n-    auto &clangASTContext = IGM.getClangASTContext();\n-    std::string typeStr;\n-    if (auto objcMethodDecl = dyn_cast<clang::ObjCMethodDecl>(clangDecl)) {\n-      typeStr = clangASTContext.getObjCEncodingForMethodDecl(\n-          objcMethodDecl, useExtendedEncoding /*extended*/);\n-    }\n-    if (auto objcPropertyDecl = dyn_cast<clang::ObjCPropertyDecl>(clangDecl)) {\n-      typeStr = clangASTContext.getObjCEncodingForPropertyDecl(objcPropertyDecl,\n-                                                               nullptr);\n-    }\n-    if (!typeStr.empty()) {\n-      return IGM.getAddrOfGlobalString(typeStr.c_str());\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-static llvm::Constant *getObjCEncodingForMethod(IRGenModule &IGM,\n-                                                CanSILFunctionType fnType,\n-                                                bool useExtendedEncoding,\n-                                                Decl *optionalDecl) {\n-  // Use the decl's ClangNode to get the encoding if possible.\n-  if (optionalDecl) {\n-    if (auto *enc = getObjectEncodingFromClangNode(IGM, optionalDecl,\n-                                                   useExtendedEncoding)) {\n-      return enc;\n-    }\n-  }\n-\n+static llvm::Constant *getObjCEncodingForMethodType(IRGenModule &IGM,\n+                                                    CanSILFunctionType fnType,\n+                                                    bool useExtendedEncoding) {\n   // Get the inputs without 'self'.\n   auto inputs = fnType->getParameters().drop_back();\n \n@@ -1160,13 +1128,11 @@ irgen::emitObjCMethodDescriptorParts(IRGenModule &IGM,\n   /// The first element is the selector.\n   descriptor.selectorRef = IGM.getAddrOfObjCMethodName(selector.str());\n   \n-  /// The second element is the method signature. A method signature is made\n-  /// of the return type @encoding and every parameter type @encoding, glued\n-  /// with numbers that used to represent stack offsets for each of these\n-  /// elements.\n+  /// The second element is the method signature. A method signature is made of\n+  /// the return type @encoding and every parameter type @encoding, glued with\n+  /// numbers that used to represent stack offsets for each of these elements.\n   CanSILFunctionType methodType = getObjCMethodType(IGM, method);\n-  descriptor.typeEncoding =\n-      getObjCEncodingForMethod(IGM, methodType, /*extended*/ false, method);\n+  descriptor.typeEncoding = getObjCEncodingForMethodType(IGM, methodType, /*extended*/false);\n   \n   /// The third element is the method implementation pointer.\n   if (!concrete) {\n@@ -1225,13 +1191,10 @@ irgen::emitObjCGetterDescriptorParts(IRGenModule &IGM,\n   Selector getterSel(subscript, Selector::ForGetter);\n   ObjCMethodDescriptor descriptor{};\n   descriptor.selectorRef = IGM.getAddrOfObjCMethodName(getterSel.str());\n-\n-  auto methodTy =\n-      getObjCMethodType(IGM, subscript->getOpaqueAccessor(AccessorKind::Get));\n-  descriptor.typeEncoding =\n-      getObjCEncodingForMethod(IGM, methodTy,\n-                               /*extended*/ false, subscript);\n-\n+  auto methodTy = getObjCMethodType(IGM,\n+                              subscript->getOpaqueAccessor(AccessorKind::Get));\n+  descriptor.typeEncoding = getObjCEncodingForMethodType(IGM, methodTy,\n+                                                         /*extended*/false);\n   descriptor.silFunction = nullptr;\n   descriptor.impl = getObjCGetterPointer(IGM, subscript,\n                                          descriptor.silFunction);\n@@ -1303,9 +1266,8 @@ irgen::emitObjCSetterDescriptorParts(IRGenModule &IGM,\n   descriptor.selectorRef = IGM.getAddrOfObjCMethodName(setterSel.str());\n   auto methodTy = getObjCMethodType(IGM,\n                               subscript->getOpaqueAccessor(AccessorKind::Set));\n-  descriptor.typeEncoding =\n-      getObjCEncodingForMethod(IGM, methodTy,\n-                               /*extended*/ false, subscript);\n+  descriptor.typeEncoding = getObjCEncodingForMethodType(IGM, methodTy,\n+                                                         /*extended*/false);\n   descriptor.silFunction = nullptr;\n   descriptor.impl = getObjCSetterPointer(IGM, subscript,\n                                          descriptor.silFunction);\n@@ -1361,34 +1323,23 @@ static void emitObjCDescriptor(IRGenModule &IGM,\n /// };\n void irgen::emitObjCMethodDescriptor(IRGenModule &IGM,\n                                      ConstantArrayBuilder &descriptors,\n-                                     AbstractFunctionDecl *method,\n-                                     llvm::StringSet<> &uniqueSelectors) {\n-  // Don't emit a selector twice.\n-  Selector selector(method);\n-  if (!uniqueSelectors.insert(selector.str()).second)\n-    return;\n-\n+                                     AbstractFunctionDecl *method) {\n   ObjCMethodDescriptor descriptor(\n     emitObjCMethodDescriptorParts(IGM, method, /*concrete*/ true));\n   emitObjCDescriptor(IGM, descriptors, descriptor);\n }\n \n-void irgen::emitObjCIVarInitDestroyDescriptor(\n-    IRGenModule &IGM, ConstantArrayBuilder &descriptors, ClassDecl *cd,\n-    llvm::Function *objcImpl, bool isDestroyer,\n-    llvm::StringSet<> &uniqueSelectors) {\n+void irgen::emitObjCIVarInitDestroyDescriptor(IRGenModule &IGM,\n+                                              ConstantArrayBuilder &descriptors,\n+                                              ClassDecl *cd,\n+                                              llvm::Function *objcImpl,\n+                                              bool isDestroyer) {\n   /// The first element is the selector.\n   SILDeclRef declRef = SILDeclRef(cd, \n                                   isDestroyer? SILDeclRef::Kind::IVarDestroyer\n                                              : SILDeclRef::Kind::IVarInitializer,\n-                                  1, \n                                   /*foreign*/ true);\n   Selector selector(declRef);\n-\n-  // Don't emit a selector twice.\n-  if (!uniqueSelectors.insert(selector.str()).second)\n-    return;\n-\n   ObjCMethodDescriptor descriptor{};\n   descriptor.selectorRef = IGM.getAddrOfObjCMethodName(selector.str());\n   \n@@ -1407,12 +1358,11 @@ void irgen::emitObjCIVarInitDestroyDescriptor(\n   buildMethodDescriptor(IGM, descriptors, descriptor);\n }\n \n-\n llvm::Constant *\n irgen::getMethodTypeExtendedEncoding(IRGenModule &IGM,\n                                      AbstractFunctionDecl *method) {\n   CanSILFunctionType methodType = getObjCMethodType(IGM, method);\n-  return getObjCEncodingForMethod(IGM, methodType, true /*Extended*/, method);\n+  return getObjCEncodingForMethodType(IGM, methodType, true/*Extended*/);\n }\n \n llvm::Constant *"
                    },
                    {
                        "filename": "lib/IRGen/GenObjC.h",
                        "code": "@@ -155,17 +155,15 @@ namespace irgen {\n   /// constructor, or destructor implementation.\n   void emitObjCMethodDescriptor(IRGenModule &IGM,\n                                 ConstantArrayBuilder &descriptors,\n-                                AbstractFunctionDecl *method,\n-                                llvm::StringSet<> &uniqueSelectors);\n+                                AbstractFunctionDecl *method);\n \n   /// Build an Objective-C method descriptor for the ivar initializer\n   /// or destroyer of a class (-.cxx_construct or -.cxx_destruct).\n   void emitObjCIVarInitDestroyDescriptor(IRGenModule &IGM,\n                                          ConstantArrayBuilder &descriptors,\n                                          ClassDecl *cd,\n                                          llvm::Function *impl,\n-                                         bool isDestroyer,\n-                                         llvm::StringSet<> &uniqueSelectors);\n+                                         bool isDestroyer);\n \n   /// Get the type encoding for an ObjC property.\n   void getObjCEncodingForPropertyType(IRGenModule &IGM, VarDecl *property,"
                    },
                    {
                        "filename": "lib/IRGen/GenProto.cpp",
                        "code": "@@ -792,20 +792,19 @@ namespace {\n     }\n \n     void addMethod(SILDeclRef func) {\n-      auto decl = cast<AbstractFunctionDecl>(func.getDecl());\n       // If this assert needs to be changed, be sure to also change\n       // ProtocolDescriptorBuilder::getRequirementInfo.\n-      assert((isa<ConstructorDecl>(decl)\n-                ? (func.kind == SILDeclRef::Kind::Allocator)\n-                : (func.kind == SILDeclRef::Kind::Func))\n-             && \"unexpected kind for protocol witness declaration ref\");\n-      Entries.push_back(WitnessTableEntry::forFunction(decl));\n+      assert((isa<ConstructorDecl>(func.getDecl())\n+                  ? (func.kind == SILDeclRef::Kind::Allocator)\n+                  : (func.kind == SILDeclRef::Kind::Func)) &&\n+             \"unexpected kind for protocol witness declaration ref\");\n+      Entries.push_back(WitnessTableEntry::forFunction(func));\n     }\n \n     void addPlaceholder(MissingMemberDecl *placeholder) {\n       for (auto i : range(placeholder->getNumberOfVTableEntries())) {\n         (void)i;\n-        Entries.push_back(WitnessTableEntry());\n+        Entries.push_back(WitnessTableEntry::forPlaceholder());\n       }\n     }\n \n@@ -1318,8 +1317,7 @@ class AccessorConformanceInfo : public ConformanceInfo {\n              && \"sil witness table does not match protocol\");\n       assert(entry.getMethodWitness().Requirement == requirement\n              && \"sil witness table does not match protocol\");\n-      auto piIndex =\n-        PI.getFunctionIndex(cast<AbstractFunctionDecl>(requirement.getDecl()));\n+      auto piIndex = PI.getFunctionIndex(requirement);\n       assert((size_t)piIndex.getValue() ==\n               Table.size() - WitnessTableFirstRequirementOffset &&\n              \"offset doesn't match ProtocolInfo layout\");\n@@ -2739,12 +2737,8 @@ static void addAbstractConditionalRequirements(\n     SpecializedProtocolConformance *specializedConformance,\n     llvm::SetVector<GenericRequirement> &requirements) {\n   auto subMap = specializedConformance->getSubstitutionMap();\n-  auto condRequirements =\n-      specializedConformance->getConditionalRequirementsIfAvailable();\n-  if (!condRequirements)\n-    return;\n-\n-  for (auto req : *condRequirements) {\n+  auto condRequirements = specializedConformance->getConditionalRequirements();\n+  for (auto req : condRequirements) {\n     if (req.getKind() != RequirementKind::Conformance)\n       continue;\n     auto *proto =\n@@ -3277,7 +3271,7 @@ FunctionPointer irgen::emitWitnessMethodValue(IRGenFunction &IGF,\n \n   // Find the witness we're interested in.\n   auto &fnProtoInfo = IGF.IGM.getProtocolInfo(proto, ProtocolInfoKind::Full);\n-  auto index = fnProtoInfo.getFunctionIndex(fn);\n+  auto index = fnProtoInfo.getFunctionIndex(member);\n   llvm::Value *slot;\n   llvm::Value *witnessFnPtr =\n     emitInvariantLoadOfOpaqueWitness(IGF, wtable,"
                    },
                    {
                        "filename": "lib/IRGen/GenReflection.cpp",
                        "code": "@@ -693,7 +693,7 @@ class FieldTypeMetadataBuilder : public ReflectionMetadataBuilder {\n     }\n \n     if (IGM.IRGen.Opts.EnableReflectionNames) {\n-      auto name = value->getBaseName().getIdentifier().str();\n+      auto name = value->getBaseIdentifier().str();\n       auto fieldName = IGM.getAddrOfFieldName(name);\n       B.addRelativeAddress(fieldName);\n     } else {\n@@ -827,13 +827,13 @@ static bool\n deploymentTargetHasRemoteMirrorZeroSizedTypeDescriptorBug(IRGenModule &IGM) {\n   auto target = IGM.Context.LangOpts.Target;\n   \n-  if (target.isMacOSX() && target.isMacOSXVersionLT(10, 16, 0)) {\n+  if (target.isMacOSX() && target.isMacOSXVersionLT(10, 15, 4)) {\n     return true;\n   }\n-  if (target.isiOS() && target.isOSVersionLT(14)) { // includes tvOS\n+  if (target.isiOS() && target.isOSVersionLT(13, 4)) { // includes tvOS\n     return true;\n   }\n-  if (target.isWatchOS() && target.isOSVersionLT(7)) {\n+  if (target.isWatchOS() && target.isOSVersionLT(6, 2)) {\n     return true;\n   }\n   "
                    },
                    {
                        "filename": "lib/IRGen/GenType.h",
                        "code": "@@ -145,6 +145,8 @@ class TypeConverter {\n   const TypeInfo *convertEnumType(TypeBase *key, CanType type, EnumDecl *D);\n   const TypeInfo *convertStructType(TypeBase *key, CanType type, StructDecl *D);\n   const TypeInfo *convertFunctionType(SILFunctionType *T);\n+  const TypeInfo *convertNormalDifferentiableFunctionType(SILFunctionType *T);\n+  const TypeInfo *convertLinearDifferentiableFunctionType(SILFunctionType *T);\n   const TypeInfo *convertBlockStorageType(SILBlockStorageType *T);\n   const TypeInfo *convertBoxType(SILBoxType *T);\n   const TypeInfo *convertArchetypeType(ArchetypeType *T);"
                    },
                    {
                        "filename": "lib/IRGen/GenValueWitness.cpp",
                        "code": "@@ -431,6 +431,33 @@ static void getArgAsLocalSelfTypeMetadata(IRGenFunction &IGF,\n   getArgAsLocalSelfTypeMetadata(IGF, arg, abstractType);\n }\n \n+static const TypeLayoutEntry *\n+conditionallyGetTypeLayoutEntry(IRGenModule &IGM, SILType concreteType) {\n+  if (!IGM.getOptions().UseTypeLayoutValueHandling)\n+    return nullptr;\n+\n+  auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n+\n+  // Don't use type layout based generation for layouts that contain a resilient\n+  // field but no archetype. We don't expect a speadup by using type layout\n+  // based ir generation.\n+  if ((typeLayoutEntry.containsResilientField() &&\n+       !typeLayoutEntry.containsArchetypeField()) ||\n+      typeLayoutEntry.containsDependentResilientField())\n+    return nullptr;\n+\n+  return &typeLayoutEntry;\n+}\n+\n+static const EnumTypeLayoutEntry *\n+conditionallyGetEnumTypeLayoutEntry(IRGenModule &IGM, SILType concreteType) {\n+  auto *entry = conditionallyGetTypeLayoutEntry(IGM, concreteType);\n+  if (!entry)\n+    return nullptr;\n+\n+  return entry->getAsEnum();\n+}\n+\n /// Build a specific value-witness function.\n static void buildValueWitnessFunction(IRGenModule &IGM,\n                                       llvm::Function *fn,\n@@ -452,9 +479,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     Address src = getArgAs(IGF, argv, type, \"src\");\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n \n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.assignWithCopy(IGF, dest, src);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->assignWithCopy(IGF, dest, src);\n     } else {\n       type.assignWithCopy(IGF, dest, src, concreteType, true);\n     }\n@@ -467,9 +494,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     Address dest = getArgAs(IGF, argv, type, \"dest\");\n     Address src = getArgAs(IGF, argv, type, \"src\");\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.assignWithTake(IGF, dest, src);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->assignWithTake(IGF, dest, src);\n     } else {\n       type.assignWithTake(IGF, dest, src, concreteType, true);\n     }\n@@ -481,9 +508,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n   case ValueWitness::Destroy: {\n     Address object = getArgAs(IGF, argv, type, \"object\");\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.destroy(IGF, object);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->destroy(IGF, object);\n     } else {\n       type.destroy(IGF, object, concreteType, true);\n     }\n@@ -497,9 +524,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n \n     llvm::Value *objectPtr = nullptr;\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      objectPtr = typeLayoutEntry.initBufferWithCopyOfBuffer(IGF, dest, src);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      objectPtr = typeLayoutEntry->initBufferWithCopyOfBuffer(IGF, dest, src);\n     } else {\n       Address result = emitInitializeBufferWithCopyOfBuffer(\n           IGF, dest, src, concreteType, type, packing);\n@@ -514,9 +541,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     Address dest = getArgAs(IGF, argv, type, \"dest\");\n     Address src = getArgAs(IGF, argv, type, \"src\");\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.initWithCopy(IGF, dest, src);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->initWithCopy(IGF, dest, src);\n     } else {\n       type.initializeWithCopy(IGF, dest, src, concreteType, true);\n     }\n@@ -530,9 +557,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     Address src = getArgAs(IGF, argv, type, \"src\");\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n \n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.initWithTake(IGF, dest, src);\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->initWithTake(IGF, dest, src);\n     } else {\n       type.initializeWithTake(IGF, dest, src, concreteType, true);\n     }\n@@ -552,9 +579,8 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     auto enumAddr = type.getAddressForPointer(value);\n \n     llvm::Value *result;\n-    auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-    const auto *enumTypeLayoutEntry = typeLayoutEntry.getAsEnum();\n-    if (enumTypeLayoutEntry && IGM.getOptions().UseTypeLayoutValueHandling) {\n+    if (auto *enumTypeLayoutEntry =\n+            conditionallyGetEnumTypeLayoutEntry(IGM, concreteType)) {\n       result = enumTypeLayoutEntry->getEnumTag(IGF, enumAddr);\n     } else {\n       result = strategy.emitGetEnumTag(IGF, concreteType, enumAddr);\n@@ -570,9 +596,8 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n \n     if (!strategy.getElementsWithPayload().empty()) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      const auto *enumTypeLayoutEntry = typeLayoutEntry.getAsEnum();\n-      if (enumTypeLayoutEntry && IGM.getOptions().UseTypeLayoutValueHandling) {\n+      if (auto *enumTypeLayoutEntry =\n+              conditionallyGetEnumTypeLayoutEntry(IGM, concreteType)) {\n         enumTypeLayoutEntry->destructiveProjectEnumData(\n             IGF, Address(value, type.getBestKnownAlignment()));\n       } else {\n@@ -596,9 +621,8 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     llvm::Value *tag = getArg(argv, \"tag\");\n \n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-    const auto *enumTypeLayoutEntry = typeLayoutEntry.getAsEnum();\n-    if (enumTypeLayoutEntry && IGM.getOptions().UseTypeLayoutValueHandling) {\n+    if (auto *enumTypeLayoutEntry =\n+            conditionallyGetEnumTypeLayoutEntry(IGM, concreteType)) {\n       enumTypeLayoutEntry->destructiveInjectEnumTag(\n           IGF, tag, Address(value, type.getBestKnownAlignment()));\n     } else {\n@@ -618,9 +642,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     llvm::Value *numEmptyCases = getArg(argv, \"numEmptyCases\");\n \n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      auto *idx = typeLayoutEntry.getEnumTagSinglePayload(\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      auto *idx = typeLayoutEntry->getEnumTagSinglePayload(\n           IGF, numEmptyCases, Address(value, type.getBestKnownAlignment()));\n       IGF.Builder.CreateRet(idx);\n     } else {\n@@ -642,9 +666,9 @@ static void buildValueWitnessFunction(IRGenModule &IGM,\n     llvm::Value *numEmptyCases = getArg(argv, \"numEmptyCases\");\n \n     getArgAsLocalSelfTypeMetadata(IGF, argv, abstractType);\n-    if (IGM.getOptions().UseTypeLayoutValueHandling) {\n-      auto &typeLayoutEntry = IGM.getTypeLayoutEntry(concreteType);\n-      typeLayoutEntry.storeEnumTagSinglePayload(\n+    if (auto *typeLayoutEntry =\n+            conditionallyGetTypeLayoutEntry(IGM, concreteType)) {\n+      typeLayoutEntry->storeEnumTagSinglePayload(\n           IGF, whichCase, numEmptyCases,\n           Address(value, type.getBestKnownAlignment()));\n     } else {"
                    },
                    {
                        "filename": "lib/IRGen/IRGen.cpp",
                        "code": "@@ -1366,7 +1366,7 @@ std::unique_ptr<llvm::Module> swift::performIRGeneration(\n       M->getASTContext().evaluator(IRGenWholeModuleRequest{desc}));\n }\n \n-llvm::Expected<std::unique_ptr<llvm::Module>>\n+std::unique_ptr<llvm::Module>\n IRGenWholeModuleRequest::evaluate(Evaluator &evaluator,\n                                   IRGenDescriptor desc) const {\n   auto *M = desc.Ctx.get<ModuleDecl *>();\n@@ -1401,7 +1401,7 @@ performIRGeneration(const IRGenOptions &Opts, SourceFile &SF,\n       SF.getASTContext().evaluator(IRGenSourceFileRequest{desc}));\n }\n \n-llvm::Expected<std::unique_ptr<llvm::Module>>\n+std::unique_ptr<llvm::Module>\n IRGenSourceFileRequest::evaluate(Evaluator &evaluator,\n                                  IRGenDescriptor desc) const {\n   auto *SF = desc.Ctx.get<SourceFile *>();"
                    },
                    {
                        "filename": "lib/IRGen/IRGenDebugInfo.cpp",
                        "code": "@@ -489,7 +489,7 @@ class IRGenDebugInfoImpl : public IRGenDebugInfo {\n       }\n \n     if (FD.hasName())\n-      return FD.getName().str();\n+      return FD.getBaseIdentifier().str();\n \n     return StringRef();\n   }\n@@ -947,8 +947,8 @@ class IRGenDebugInfoImpl : public IRGenDebugInfo {\n                                   Alignment(1), true, false);\n       }\n       unsigned Offset = 0;\n-      auto MTy = createMemberType(ElemDbgTy, ElemDecl->getName().str(), Offset,\n-                                  Scope, File, Flags);\n+      auto MTy = createMemberType(ElemDbgTy, ElemDecl->getBaseIdentifier().str(),\n+                                  Offset, Scope, File, Flags);\n       Elements.push_back(MTy);\n     }\n     return DBuilder.getOrCreateArray(Elements);"
                    },
                    {
                        "filename": "lib/IRGen/IRGenMangler.cpp",
                        "code": "@@ -308,15 +308,7 @@ std::string IRGenMangler::mangleSymbolNameForMangledConformanceAccessorString(\n   if (genericSig)\n     appendGenericSignature(genericSig);\n \n-  if (type)\n-    appendType(type);\n-\n-  if (conformance.isConcrete())\n-    appendConcreteProtocolConformance(conformance.getConcrete());\n-  else if (conformance.isAbstract())\n-    appendProtocolName(conformance.getAbstract());\n-  else\n-    assert(conformance.isInvalid() && \"Unknown protocol conformance\");\n+  appendAnyProtocolConformance(genericSig, type, conformance);\n   return finalize();\n }\n "
                    },
                    {
                        "filename": "lib/IRGen/IRGenRequests.cpp",
                        "code": "@@ -48,6 +48,15 @@ SourceLoc swift::extractNearestSourceLoc(const IRGenDescriptor &desc) {\n   return SourceLoc();\n }\n \n+evaluator::DependencySource\n+IRGenSourceFileRequest::readDependencySource(Evaluator &e) const {\n+  auto &desc = std::get<0>(getStorage());\n+  return {\n+    desc.Ctx.dyn_cast<SourceFile *>(),\n+    evaluator::DependencyScope::Cascading\n+  };\n+}\n+\n // Define request evaluation functions for each of the IRGen requests.\n static AbstractRequestFunction *irGenRequestFunctions[] = {\n #define SWIFT_REQUEST(Zone, Name, Sig, Caching, LocOptions)                    \\"
                    },
                    {
                        "filename": "lib/IRGen/IRGenSIL.cpp",
                        "code": "@@ -1044,6 +1044,11 @@ class IRGenSILFunction :\n   \n   void visitKeyPathInst(KeyPathInst *I);\n \n+  void visitDifferentiableFunctionInst(DifferentiableFunctionInst *i);\n+  void visitLinearFunctionInst(LinearFunctionInst *i);\n+  void\n+  visitDifferentiableFunctionExtractInst(DifferentiableFunctionExtractInst *i);\n+  void visitLinearFunctionExtractInst(LinearFunctionExtractInst *i);\n   void visitDifferentiabilityWitnessFunctionInst(\n       DifferentiabilityWitnessFunctionInst *i);\n \n@@ -1814,6 +1819,89 @@ void IRGenSILFunction::visitSILBasicBlock(SILBasicBlock *BB) {\n   assert(Builder.hasPostTerminatorIP() && \"SIL bb did not terminate block?!\");\n }\n \n+void IRGenSILFunction::visitDifferentiableFunctionInst(\n+    DifferentiableFunctionInst *i) {\n+  auto origFnExp = getLoweredExplosion(i->getOriginalFunction());\n+  Explosion e;\n+  e.add(origFnExp.claimAll());\n+  // TODO(TF-1211): Uncomment assertions after upstreaming differentiation\n+  // transform.\n+  // The mandatory differentiation transform canonicalizes\n+  // `differentiable_function` instructions and ensures that derivative operands\n+  // are populated.\n+  /*\n+  assert(i->hasDerivativeFunctions());\n+  for (auto &derivFnOperand : i->getDerivativeFunctionArray())\n+    e.add(getLoweredExplosion(derivFnOperand.get()).claimAll());\n+  setLoweredExplosion(i, e);\n+  */\n+  // Note: code below is a temporary measure until TF-1211. Derivative function\n+  // operands should always exist after the differentiation transform.\n+  auto getDerivativeExplosion = [&](AutoDiffDerivativeFunctionKind kind) {\n+    // If the derivative value exists, get its explosion.\n+    if (i->hasDerivativeFunctions())\n+      return getLoweredExplosion(i->getDerivativeFunction(kind));\n+    // Otherwise, create an undef explosion.\n+    auto origFnType =\n+        i->getOriginalFunction()->getType().castTo<SILFunctionType>();\n+    auto derivativeFnType = origFnType->getAutoDiffDerivativeFunctionType(\n+        i->getParameterIndices(), /*resultIndex*/ 0, kind, i->getModule().Types,\n+        LookUpConformanceInModule(i->getModule().getSwiftModule()));\n+    auto *undef = SILUndef::get(\n+        SILType::getPrimitiveObjectType(derivativeFnType), *i->getFunction());\n+    return getLoweredExplosion(undef);\n+  };\n+  auto jvpExp = getDerivativeExplosion(AutoDiffDerivativeFunctionKind::JVP);\n+  e.add(jvpExp.claimAll());\n+  auto vjpExp = getDerivativeExplosion(AutoDiffDerivativeFunctionKind::VJP);\n+  e.add(vjpExp.claimAll());\n+  setLoweredExplosion(i, e);\n+}\n+\n+void IRGenSILFunction::\n+visitLinearFunctionInst(LinearFunctionInst *i) {\n+  auto origExp = getLoweredExplosion(i->getOriginalFunction());\n+  Explosion e;\n+  e.add(origExp.claimAll());\n+  assert(i->hasTransposeFunction());\n+  e.add(getLoweredExplosion(i->getTransposeFunction()).claimAll());\n+  setLoweredExplosion(i, e);\n+}\n+\n+void IRGenSILFunction::visitDifferentiableFunctionExtractInst(\n+    DifferentiableFunctionExtractInst *i) {\n+  unsigned structFieldOffset = i->getExtractee().rawValue;\n+  unsigned fieldSize = 1;\n+  auto fnRepr = i->getOperand()->getType().getFunctionRepresentation();\n+  if (fnRepr == SILFunctionTypeRepresentation::Thick) {\n+    structFieldOffset *= 2;\n+    fieldSize = 2;\n+  }\n+  auto diffFnExp = getLoweredExplosion(i->getOperand());\n+  assert(diffFnExp.size() == fieldSize * 3);\n+  Explosion e;\n+  e.add(diffFnExp.getRange(structFieldOffset, structFieldOffset + fieldSize));\n+  (void)diffFnExp.claimAll();\n+  setLoweredExplosion(i, e);\n+}\n+\n+void IRGenSILFunction::\n+visitLinearFunctionExtractInst(LinearFunctionExtractInst *i) {\n+  unsigned structFieldOffset = i->getExtractee().rawValue;\n+  unsigned fieldSize = 1;\n+  auto fnRepr = i->getFunctionOperand()->getType().getFunctionRepresentation();\n+  if (fnRepr == SILFunctionTypeRepresentation::Thick) {\n+    structFieldOffset *= 2;\n+    fieldSize = 2;\n+  }\n+  auto diffFnExp = getLoweredExplosion(i->getFunctionOperand());\n+  assert(diffFnExp.size() == fieldSize * 2);\n+  Explosion e;\n+  e.add(diffFnExp.getRange(structFieldOffset, structFieldOffset + fieldSize));\n+  (void)diffFnExp.claimAll();\n+  setLoweredExplosion(i, e);\n+}\n+\n void IRGenSILFunction::visitDifferentiabilityWitnessFunctionInst(\n     DifferentiabilityWitnessFunctionInst *i) {\n   llvm::Value *diffWitness =\n@@ -2262,11 +2350,33 @@ void IRGenSILFunction::visitTryApplyInst(swift::TryApplyInst *i) {\n }\n \n void IRGenSILFunction::visitFullApplySite(FullApplySite site) {\n-  const LoweredValue &calleeLV = getLoweredValue(site.getCallee());\n-  \n   auto origCalleeType = site.getOrigCalleeType();\n   auto substCalleeType = site.getSubstCalleeType();\n-  \n+  if (site.getOrigCalleeType()->isDifferentiable()) {\n+    origCalleeType = origCalleeType->getWithoutDifferentiability();\n+    substCalleeType = substCalleeType->getWithoutDifferentiability();\n+  }\n+\n+  // If the callee is a differentiable function, we extract the original\n+  // function because we want to call the original function.\n+  Optional<LoweredValue> diffCalleeOrigFnLV;\n+  if (site.getOrigCalleeType()->isDifferentiable()) {\n+    auto diffFnExplosion = getLoweredExplosion(site.getCallee());\n+    Explosion origFnExplosion;\n+    unsigned fieldSize = 1;\n+    if (origCalleeType->getRepresentation() ==\n+        SILFunctionTypeRepresentation::Thick) {\n+      fieldSize = 2;\n+    }\n+    origFnExplosion.add(diffFnExplosion.getRange(0, 0 + fieldSize));\n+    (void)diffFnExplosion.claimAll();\n+    diffCalleeOrigFnLV = LoweredValue(origFnExplosion);\n+  }\n+\n+  const LoweredValue &calleeLV =\n+      diffCalleeOrigFnLV ? *diffCalleeOrigFnLV :\n+                            getLoweredValue(site.getCallee());\n+\n   auto args = site.getArguments();\n   SILFunctionConventions origConv(origCalleeType, getSILModule());\n   assert(origConv.getNumSILArguments() == args.size());\n@@ -4454,11 +4564,15 @@ void IRGenSILFunction::visitConvertEscapeToNoEscapeInst(\n     swift::ConvertEscapeToNoEscapeInst *i) {\n   // This instruction makes the context trivial.\n   Explosion in = getLoweredExplosion(i->getOperand());\n-  llvm::Value *fn = in.claimNext();\n-  llvm::Value *ctx = in.claimNext();\n   Explosion out;\n-  out.add(fn);\n-  out.add(Builder.CreateBitCast(ctx, IGM.OpaquePtrTy));\n+  // Differentiable functions contain multiple pairs of fn and ctx pointer.\n+  for (unsigned index : range(in.size() / 2)) {\n+    (void)index;\n+    llvm::Value *fn = in.claimNext();\n+    llvm::Value *ctx = in.claimNext();\n+    out.add(fn);\n+    out.add(Builder.CreateBitCast(ctx, IGM.OpaquePtrTy));\n+  }\n   setLoweredExplosion(i, out);\n }\n "
                    },
                    {
                        "filename": "lib/IRGen/Linking.cpp",
                        "code": "@@ -352,10 +352,9 @@ std::string LinkEntity::mangleAsString() const {\n     assert(isa<AbstractFunctionDecl>(getDecl()));\n     std::string Result;\n     if (auto *Constructor = dyn_cast<ConstructorDecl>(getDecl())) {\n-      Result = mangler.mangleConstructorEntity(Constructor, isAllocator(),\n-                                               /*isCurried=*/false);\n+      Result = mangler.mangleConstructorEntity(Constructor, isAllocator());\n     } else  {\n-      Result = mangler.mangleEntity(getDecl(), /*isCurried=*/false);\n+      Result = mangler.mangleEntity(getDecl());\n     }\n     Result.append(\"TI\");\n     return Result;\n@@ -379,10 +378,9 @@ std::string LinkEntity::mangleAsString() const {\n     std::string Result;\n     if (auto *Constructor = dyn_cast<ConstructorDecl>(getDecl())) {\n       Result =\n-          mangler.mangleConstructorEntity(Constructor, isAllocator(),\n-                                          /*isCurried=*/false);\n+          mangler.mangleConstructorEntity(Constructor, isAllocator());\n     } else  {\n-      Result = mangler.mangleEntity(getDecl(), /*isCurried=*/false);\n+      Result = mangler.mangleEntity(getDecl());\n     }\n     Result.append(\"TX\");\n     return Result;\n@@ -393,10 +391,9 @@ std::string LinkEntity::mangleAsString() const {\n     std::string Result;\n     if (auto *Constructor = dyn_cast<ConstructorDecl>(getDecl())) {\n       Result =\n-          mangler.mangleConstructorEntity(Constructor, isAllocator(),\n-                                          /*isCurried=*/false);\n+          mangler.mangleConstructorEntity(Constructor, isAllocator());\n     } else  {\n-      Result = mangler.mangleEntity(getDecl(), /*isCurried=*/false);\n+      Result = mangler.mangleEntity(getDecl());\n     }\n     Result.append(\"Tx\");\n     return Result;"
                    },
                    {
                        "filename": "lib/IRGen/MetadataRequest.cpp",
                        "code": "@@ -1231,12 +1231,30 @@ namespace {\n         break;\n       }\n \n+      FunctionMetadataDifferentiabilityKind metadataDifferentiabilityKind;\n+      switch (type->getDifferentiabilityKind()) {\n+      case DifferentiabilityKind::NonDifferentiable:\n+        metadataDifferentiabilityKind =\n+            FunctionMetadataDifferentiabilityKind::NonDifferentiable;\n+        break;\n+      case DifferentiabilityKind::Normal:\n+        metadataDifferentiabilityKind =\n+            FunctionMetadataDifferentiabilityKind::Normal;\n+        break;\n+      case DifferentiabilityKind::Linear:\n+        metadataDifferentiabilityKind =\n+            FunctionMetadataDifferentiabilityKind::Linear;\n+        break;\n+      }\n+\n       auto flagsVal = FunctionTypeFlags()\n                           .withNumParameters(numParams)\n                           .withConvention(metadataConvention)\n                           .withThrows(type->throws())\n                           .withParameterFlags(hasFlags)\n-                          .withEscaping(isEscaping);\n+                          .withEscaping(isEscaping)\n+                          .withDifferentiabilityKind(\n+                              metadataDifferentiabilityKind);\n \n       auto flags = llvm::ConstantInt::get(IGF.IGM.SizeTy,\n                                           flagsVal.getIntValue());\n@@ -2202,6 +2220,10 @@ irgen::getGenericTypeMetadataAccessFunction(IRGenModule &IGM,\n }\n \n static bool shouldAccessByMangledName(IRGenModule &IGM, CanType type) {\n+  // Never access by mangled name if we've been asked not to.\n+  if (IGM.getOptions().DisableConcreteTypeMetadataMangledNameAccessors)\n+    return false;\n+  \n   // A nongeneric nominal type with nontrivial metadata has an accessor\n   // already we can just call.\n   if (auto nom = dyn_cast<NominalType>(type)) {\n@@ -2213,17 +2235,19 @@ static bool shouldAccessByMangledName(IRGenModule &IGM, CanType type) {\n   }\n   \n   // The Swift 5.1 runtime fails to demangle associated types of opaque types.\n-  auto hasNestedOpaqueArchetype = type.findIf([](CanType sub) -> bool {\n-    if (auto archetype = dyn_cast<NestedArchetypeType>(sub)) {\n-      if (isa<OpaqueTypeArchetypeType>(archetype->getRoot())) {\n-        return true;\n+  if (!IGM.getAvailabilityContext().isContainedIn(IGM.Context.getSwift52Availability())) {\n+    auto hasNestedOpaqueArchetype = type.findIf([](CanType sub) -> bool {\n+      if (auto archetype = dyn_cast<NestedArchetypeType>(sub)) {\n+        if (isa<OpaqueTypeArchetypeType>(archetype->getRoot())) {\n+          return true;\n+        }\n       }\n-    }\n-    return false;\n-  });\n-  \n-  if (hasNestedOpaqueArchetype)\n-    return false;\n+      return false;\n+    });\n+    \n+    if (hasNestedOpaqueArchetype)\n+      return false;\n+  }\n   \n   return true;\n "
                    },
                    {
                        "filename": "lib/IRGen/ProtocolInfo.h",
                        "code": "@@ -39,28 +39,59 @@ namespace irgen {\n /// ProtocolTypeInfo stores one of these for each requirement\n /// introduced by the protocol.\n class WitnessTableEntry {\n-public:\n-  llvm::PointerUnion<Decl *, TypeBase *> MemberOrAssociatedType;\n-  ProtocolDecl *Protocol;\n-\n-  WitnessTableEntry(llvm::PointerUnion<Decl *, TypeBase *> member,\n-                    ProtocolDecl *protocol)\n-    : MemberOrAssociatedType(member), Protocol(protocol) {}\n+  enum WitnessKind {\n+    PlaceholderKind,\n+    OutOfLineBaseKind,\n+    MethodKind,\n+    AssociatedTypeKind,\n+    AssociatedConformanceKind\n+  };\n+\n+  struct OutOfLineBaseWitness {\n+    ProtocolDecl *Protocol;\n+  };\n+\n+  struct MethodWitness {\n+    SILDeclRef Witness;\n+  };\n+\n+  struct AssociatedTypeWitness {\n+    AssociatedTypeDecl *Association;\n+  };\n+\n+  struct AssociatedConformanceWitness {\n+    TypeBase *AssociatedType;\n+    ProtocolDecl *Protocol;\n+  };\n+\n+  WitnessKind Kind;\n+  union {\n+    OutOfLineBaseWitness OutOfLineBaseEntry;\n+    MethodWitness MethodEntry;\n+    AssociatedTypeWitness AssociatedTypeEntry;\n+    AssociatedConformanceWitness AssociatedConformanceEntry;\n+  };\n+\n+  WitnessTableEntry(WitnessKind Kind) : Kind(Kind) {}\n \n public:\n-  WitnessTableEntry() = default;\n+  static WitnessTableEntry forPlaceholder() {\n+    return WitnessTableEntry(WitnessKind::PlaceholderKind);\n+  }\n \n   static WitnessTableEntry forOutOfLineBase(ProtocolDecl *proto) {\n     assert(proto != nullptr);\n-    return WitnessTableEntry({}, proto);\n+    WitnessTableEntry entry(WitnessKind::OutOfLineBaseKind);\n+    entry.OutOfLineBaseEntry = {proto};\n+    return entry;\n   }\n \n   /// Is this a base-protocol entry?\n-  bool isBase() const { return MemberOrAssociatedType.isNull(); }\n+  bool isBase() const { return Kind == WitnessKind::OutOfLineBaseKind; }\n \n   bool matchesBase(ProtocolDecl *proto) const {\n     assert(proto != nullptr);\n-    return MemberOrAssociatedType.isNull() && Protocol == proto;\n+    return isBase() && OutOfLineBaseEntry.Protocol == proto;\n   }\n \n   /// Given that this is a base-protocol entry, is the table\n@@ -72,84 +103,97 @@ class WitnessTableEntry {\n \n   ProtocolDecl *getBase() const {\n     assert(isBase());\n-    return Protocol;\n+    return OutOfLineBaseEntry.Protocol;\n   }\n \n-  static WitnessTableEntry forFunction(AbstractFunctionDecl *func) {\n-    assert(func != nullptr);\n-    return WitnessTableEntry(func, nullptr);\n-  }\n-  \n-  bool isFunction() const {\n-    auto decl = MemberOrAssociatedType.dyn_cast<Decl*>();\n-    return Protocol == nullptr && decl && isa<AbstractFunctionDecl>(decl);\n+  static WitnessTableEntry forFunction(SILDeclRef declRef) {\n+    assert(!declRef.isNull());\n+    WitnessTableEntry entry(WitnessKind::MethodKind);\n+    entry.MethodEntry = {declRef};\n+    return entry;\n   }\n \n-  bool matchesFunction(AbstractFunctionDecl *func) const {\n-    assert(func != nullptr);\n-    if (auto decl = MemberOrAssociatedType.dyn_cast<Decl*>())\n-      return decl == func && Protocol == nullptr;\n-    return false;\n+  bool isFunction() const { return Kind == WitnessKind::MethodKind; }\n+\n+  bool matchesFunction(SILDeclRef declRef) const {\n+    return isFunction() && MethodEntry.Witness == declRef;\n   }\n \n-  AbstractFunctionDecl *getFunction() const {\n+  SILDeclRef getFunction() const {\n     assert(isFunction());\n-    auto decl = MemberOrAssociatedType.get<Decl*>();\n-    return static_cast<AbstractFunctionDecl*>(decl);\n+    return MethodEntry.Witness;\n   }\n \n   static WitnessTableEntry forAssociatedType(AssociatedType ty) {\n-    return WitnessTableEntry(ty.getAssociation(), nullptr);\n+    WitnessTableEntry entry(WitnessKind::AssociatedTypeKind);\n+    entry.AssociatedTypeEntry = {ty.getAssociation()};\n+    return entry;\n   }\n   \n   bool isAssociatedType() const {\n-    if (auto decl = MemberOrAssociatedType.dyn_cast<Decl*>())\n-      return Protocol == nullptr && isa<AssociatedTypeDecl>(decl);\n-    return false;\n+    return Kind == WitnessKind::AssociatedTypeKind;\n   }\n \n   bool matchesAssociatedType(AssociatedType assocType) const {\n-    if (auto decl = MemberOrAssociatedType.dyn_cast<Decl*>())\n-      return decl == assocType.getAssociation() && Protocol == nullptr;\n-    return false;\n+    return isAssociatedType() &&\n+           AssociatedTypeEntry.Association == assocType.getAssociation();\n   }\n \n   AssociatedTypeDecl *getAssociatedType() const {\n     assert(isAssociatedType());\n-    auto decl = MemberOrAssociatedType.get<Decl*>();\n-    return static_cast<AssociatedTypeDecl*>(decl);\n+    return AssociatedTypeEntry.Association;\n   }\n \n-  static WitnessTableEntry forAssociatedConformance(AssociatedConformance conf){\n-    return WitnessTableEntry(conf.getAssociation().getPointer(),\n-                             conf.getAssociatedRequirement());\n+  static WitnessTableEntry\n+  forAssociatedConformance(AssociatedConformance conf) {\n+    WitnessTableEntry entry(WitnessKind::AssociatedConformanceKind);\n+    entry.AssociatedConformanceEntry = {conf.getAssociation().getPointer(),\n+                                        conf.getAssociatedRequirement()};\n+    return entry;\n   }\n \n   bool isAssociatedConformance() const {\n-    return Protocol != nullptr && !MemberOrAssociatedType.isNull();\n+    return Kind == WitnessKind::AssociatedConformanceKind;\n   }\n \n   bool matchesAssociatedConformance(const AssociatedConformance &conf) const {\n-    if (auto type = MemberOrAssociatedType.dyn_cast<TypeBase*>())\n-      return type == conf.getAssociation().getPointer() &&\n-             Protocol == conf.getAssociatedRequirement();\n-    return false;\n+    return isAssociatedConformance() &&\n+           AssociatedConformanceEntry.AssociatedType ==\n+               conf.getAssociation().getPointer() &&\n+           AssociatedConformanceEntry.Protocol ==\n+               conf.getAssociatedRequirement();\n   }\n \n   CanType getAssociatedConformancePath() const {\n     assert(isAssociatedConformance());\n-    auto type = MemberOrAssociatedType.get<TypeBase*>();\n-    return CanType(type);\n+    return CanType(AssociatedConformanceEntry.AssociatedType);\n   }\n \n   ProtocolDecl *getAssociatedConformanceRequirement() const {\n     assert(isAssociatedConformance());\n-    return Protocol;\n+    return AssociatedConformanceEntry.Protocol;\n   }\n \n   friend bool operator==(WitnessTableEntry left, WitnessTableEntry right) {\n-    return left.MemberOrAssociatedType == right.MemberOrAssociatedType &&\n-           left.Protocol == right.Protocol;\n+    if (left.Kind != right.Kind)\n+      return false;\n+    switch (left.Kind) {\n+    case WitnessKind::PlaceholderKind:\n+      return true;\n+    case WitnessKind::OutOfLineBaseKind:\n+      return left.OutOfLineBaseEntry.Protocol ==\n+             right.OutOfLineBaseEntry.Protocol;\n+    case WitnessKind::MethodKind:\n+      return left.MethodEntry.Witness == right.MethodEntry.Witness;\n+    case WitnessKind::AssociatedTypeKind:\n+      return left.AssociatedTypeEntry.Association ==\n+             right.AssociatedTypeEntry.Association;\n+    case WitnessKind::AssociatedConformanceKind:\n+      return left.AssociatedConformanceEntry.AssociatedType ==\n+                 right.AssociatedConformanceEntry.AssociatedType &&\n+             left.AssociatedConformanceEntry.Protocol ==\n+                 right.AssociatedConformanceEntry.Protocol;\n+    }\n   }\n };\n \n@@ -236,10 +280,10 @@ class ProtocolInfo final :\n \n   /// Return the witness index for the witness function for the given\n   /// function requirement.\n-  WitnessIndex getFunctionIndex(AbstractFunctionDecl *function) const {\n+  WitnessIndex getFunctionIndex(SILDeclRef declRef) const {\n     assert(getKind() >= ProtocolInfoKind::Full);\n     for (auto &witness : getWitnessEntries()) {\n-      if (witness.matchesFunction(function))\n+      if (witness.matchesFunction(declRef))\n         return getNonBaseWitnessIndex(&witness);\n     }\n     llvm_unreachable(\"didn't find entry for function\");"
                    },
                    {
                        "filename": "lib/IRGen/TypeLayout.cpp",
                        "code": "@@ -25,6 +25,18 @@ using namespace irgen;\n \n TypeLayoutEntry::~TypeLayoutEntry() {}\n \n+void TypeLayoutEntry::computeProperties() {\n+  // does not add anything.\n+}\n+\n+void TypeLayoutEntry::gatherProperties(TypeLayoutEntry *fromEntry) {\n+  hasArchetypeField |= fromEntry->hasArchetypeField;\n+  hasResilientField |= fromEntry->hasResilientField;\n+  hasDependentResilientField |= fromEntry->hasDependentResilientField;\n+\n+  assert(!(!hasResilientField && hasDependentResilientField));\n+}\n+\n const EnumTypeLayoutEntry *TypeLayoutEntry::getAsEnum() const {\n   if (getKind() == TypeLayoutEntryKind::Enum) {\n     return static_cast<const EnumTypeLayoutEntry *>(this);\n@@ -99,8 +111,16 @@ void TypeLayoutEntry::initWithTake(IRGenFunction &IGF, Address dest,\n   // Nothing to copy.\n }\n \n-bool TypeLayoutEntry::containsEnum() const {\n-  return false;\n+bool TypeLayoutEntry::containsResilientField() const {\n+  return hasResilientField;\n+}\n+\n+bool TypeLayoutEntry::containsArchetypeField() const {\n+  return hasArchetypeField;\n+}\n+\n+bool TypeLayoutEntry::containsDependentResilientField() const {\n+  return hasDependentResilientField;\n }\n \n llvm::Value *TypeLayoutEntry::getEnumTagSinglePayload(\n@@ -571,6 +591,10 @@ llvm::Value *TypeLayoutEntry::initBufferWithCopyOfBuffer(IRGenFunction &IGF,\n   return pointerToObject;\n }\n \n+void ScalarTypeLayoutEntry::computeProperties() {\n+  // does not add anything.\n+}\n+\n void ScalarTypeLayoutEntry::Profile(llvm::FoldingSetNodeID &id) const {\n   ScalarTypeLayoutEntry::Profile(id, typeInfo);\n }\n@@ -608,10 +632,6 @@ llvm::Value *ScalarTypeLayoutEntry::isBitwiseTakable(IRGenFunction &IGF) const {\n                                     ResilienceExpansion::Maximal));\n }\n \n-bool ScalarTypeLayoutEntry::containsEnum() const {\n-  return false;\n-}\n-\n void ScalarTypeLayoutEntry::destroy(IRGenFunction &IGF, Address addr) const {\n   auto alignment = cast<FixedTypeInfo>(typeInfo).getFixedAlignment();\n   auto addressType = typeInfo.getStorageType()->getPointerTo();\n@@ -709,6 +729,12 @@ LLVM_DUMP_METHOD void ScalarTypeLayoutEntry::dump() const {\n }\n #endif\n \n+void AlignedGroupEntry::computeProperties() {\n+  for (auto *entry : entries) {\n+    gatherProperties(entry);\n+  }\n+}\n+\n void AlignedGroupEntry::Profile(llvm::FoldingSetNodeID &id) const {\n   AlignedGroupEntry::Profile(id, entries, minimumAlignment, isFixedSize);\n }\n@@ -763,14 +789,6 @@ llvm::Value *AlignedGroupEntry::size(IRGenFunction &IGF) const {\n   return currentSize;\n }\n \n-bool AlignedGroupEntry::containsEnum() const {\n-  for (auto *entry : entries) {\n-    if (entry->containsEnum())\n-      return true;\n-  }\n-  return false;\n-}\n-\n llvm::Value *AlignedGroupEntry::extraInhabitantCount(IRGenFunction &IGF) const {\n   llvm::Value *currentMaxXICount = IGF.IGM.getInt32(0);\n   auto &Builder = IGF.Builder;\n@@ -1001,6 +1019,8 @@ LLVM_DUMP_METHOD void AlignedGroupEntry::dump() const {\n }\n #endif\n \n+void ArchetypeLayoutEntry::computeProperties() { hasArchetypeField = true; }\n+\n void ArchetypeLayoutEntry::Profile(llvm::FoldingSetNodeID &id) const {\n   ArchetypeLayoutEntry::Profile(id, archetype);\n }\n@@ -1030,10 +1050,6 @@ ArchetypeLayoutEntry::isBitwiseTakable(IRGenFunction &IGF) const {\n   return emitLoadOfIsBitwiseTakable(IGF, archetype);\n }\n \n-bool ArchetypeLayoutEntry::containsEnum() const {\n-  return false;\n-}\n-\n void ArchetypeLayoutEntry::destroy(IRGenFunction &IGF, Address addr) const {\n   emitDestroyCall(IGF, archetype, addr);\n }\n@@ -1139,10 +1155,10 @@ llvm::Value *EnumTypeLayoutEntry::isBitwiseTakable(IRGenFunction &IGF) const {\n   return isBitwiseTakable;\n }\n \n-bool EnumTypeLayoutEntry::containsEnum() const {\n-  if (cases.size() == 1)\n-    return false;\n-  return false;\n+void EnumTypeLayoutEntry::computeProperties() {\n+  for (auto c: cases) {\n+    gatherProperties(c);\n+  }\n }\n \n llvm::Value *EnumTypeLayoutEntry::size(IRGenFunction &IGF) const {\n@@ -2006,8 +2022,10 @@ ResilientTypeLayoutEntry::isBitwiseTakable(IRGenFunction &IGF) const {\n   return emitLoadOfIsBitwiseTakable(IGF, ty);\n }\n \n-bool ResilientTypeLayoutEntry::containsEnum() const {\n-  return false;\n+void ResilientTypeLayoutEntry::computeProperties() {\n+  hasResilientField = true;\n+  if (ty.getASTType()->hasArchetype())\n+    hasDependentResilientField = true;\n }\n \n void ResilientTypeLayoutEntry::destroy(IRGenFunction &IGF, Address addr) const {\n@@ -2076,6 +2094,7 @@ TypeLayoutCache::getOrCreateScalarEntry(const TypeInfo &ti,\n   auto mem = bumpAllocator.Allocate(bytes, alignof(ScalarTypeLayoutEntry));\n   auto newEntry = new (mem) ScalarTypeLayoutEntry(ti, representative);\n   scalarEntries.InsertNode(newEntry, insertPos);\n+  newEntry->computeProperties();\n   return newEntry;\n }\n \n@@ -2091,6 +2110,7 @@ TypeLayoutCache::getOrCreateArchetypeEntry(SILType archetype) {\n   auto mem = bumpAllocator.Allocate(bytes, alignof(ArchetypeLayoutEntry));\n   auto newEntry = new (mem) ArchetypeLayoutEntry(archetype);\n   archetypeEntries.InsertNode(newEntry, insertPos);\n+  newEntry->computeProperties();\n   return newEntry;\n }\n \n@@ -2108,6 +2128,7 @@ AlignedGroupEntry *TypeLayoutCache::getOrCreateAlignedGroupEntry(\n   auto newEntry =\n       new (mem) AlignedGroupEntry(entries, minimumAlignment, isFixedSize);\n   alignedGroupEntries.InsertNode(newEntry, insertPos);\n+  newEntry->computeProperties();\n   return newEntry;\n }\n \n@@ -2127,6 +2148,7 @@ EnumTypeLayoutEntry *TypeLayoutCache::getOrCreateEnumEntry(\n   auto mem = bumpAllocator.Allocate(bytes, alignof(EnumTypeLayoutEntry));\n   auto newEntry = new (mem) EnumTypeLayoutEntry(numEmptyCases, nonEmptyCases);\n   enumEntries.InsertNode(newEntry, insertPos);\n+  newEntry->computeProperties();\n   return newEntry;\n }\n \n@@ -2142,6 +2164,7 @@ TypeLayoutCache::getOrCreateResilientEntry(SILType ty) {\n   auto mem = bumpAllocator.Allocate(bytes, alignof(ResilientTypeLayoutEntry));\n   auto newEntry = new (mem) ResilientTypeLayoutEntry(ty);\n   resilientEntries.InsertNode(newEntry, insertPos);\n+  newEntry->computeProperties();\n   return newEntry;\n }\n "
                    },
                    {
                        "filename": "lib/IRGen/TypeLayout.h",
                        "code": "@@ -22,7 +22,7 @@ namespace irgen {\n \n class EnumTypeLayoutEntry;\n \n-enum class TypeLayoutEntryKind {\n+enum class TypeLayoutEntryKind : uint8_t {\n   Empty,\n   Scalar,\n   Archetype,\n@@ -34,11 +34,27 @@ enum class TypeLayoutEntryKind {\n class TypeLayoutEntry {\n public:\n   TypeLayoutEntryKind kind;\n-  TypeLayoutEntry() : kind(TypeLayoutEntryKind::Empty) {}\n-  TypeLayoutEntry(TypeLayoutEntryKind kind) : kind(kind) {}\n+  uint8_t hasArchetypeField : 1;\n+  uint8_t hasResilientField : 1;\n+  uint8_t hasDependentResilientField : 1;\n+\n+  TypeLayoutEntry()\n+      : kind(TypeLayoutEntryKind::Empty), hasArchetypeField(false),\n+        hasResilientField(false), hasDependentResilientField(false) {}\n+\n+  TypeLayoutEntry(TypeLayoutEntryKind kind)\n+      : kind(kind), hasArchetypeField(false), hasResilientField(false),\n+        hasDependentResilientField(false) {}\n \n   virtual ~TypeLayoutEntry();\n \n+  virtual void computeProperties();\n+\n+  bool containsResilientField() const;\n+  bool containsArchetypeField() const;\n+  bool containsDependentResilientField() const;\n+\n+\n   bool isEmpty() const { return kind == TypeLayoutEntryKind::Empty; }\n \n   TypeLayoutEntryKind getKind() const { return kind; }\n@@ -78,9 +94,6 @@ class TypeLayoutEntry {\n                                          llvm::Value *numEmptyCases,\n                                          Address enumAddr) const;\n \n-\n-  virtual bool containsEnum() const;\n-\n   const EnumTypeLayoutEntry *getAsEnum() const;\n \n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n@@ -101,6 +114,8 @@ class TypeLayoutEntry {\n       Address addr,\n       llvm::function_ref<void(Address addr, llvm::Value *tag)>\n           storeExtraInhabitantIndexFun) const;\n+\n+  void gatherProperties(TypeLayoutEntry *fromEntry);\n };\n \n class ScalarTypeLayoutEntry : public TypeLayoutEntry,\n@@ -114,6 +129,8 @@ class ScalarTypeLayoutEntry : public TypeLayoutEntry,\n \n   ~ScalarTypeLayoutEntry();\n \n+  void computeProperties() override;\n+\n   // Support for FoldingSet.\n   void Profile(llvm::FoldingSetNodeID &id) const;\n   static void Profile(llvm::FoldingSetNodeID &ID, const TypeInfo &ti);\n@@ -143,8 +160,6 @@ class ScalarTypeLayoutEntry : public TypeLayoutEntry,\n                                  llvm::Value *numEmptyCases,\n                                  Address enumAddr) const override;\n \n-  bool containsEnum() const override;\n-\n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n   void dump() const override;\n #endif\n@@ -161,6 +176,8 @@ class ArchetypeLayoutEntry : public TypeLayoutEntry,\n \n   ~ArchetypeLayoutEntry();\n \n+  void computeProperties() override;\n+\n   // Support for FoldingSet.\n   void Profile(llvm::FoldingSetNodeID &id) const;\n   static void Profile(llvm::FoldingSetNodeID &ID, SILType archetype);\n@@ -190,8 +207,6 @@ class ArchetypeLayoutEntry : public TypeLayoutEntry,\n                                  llvm::Value *numEmptyCases,\n                                  Address enumAddr) const override;\n \n-  bool containsEnum() const override;\n-\n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n   void dump() const override;\n #endif\n@@ -207,6 +222,8 @@ class ResilientTypeLayoutEntry : public TypeLayoutEntry,\n \n   ~ResilientTypeLayoutEntry();\n \n+  void computeProperties() override;\n+\n   // Support for FoldingSet.\n   void Profile(llvm::FoldingSetNodeID &id) const;\n   static void Profile(llvm::FoldingSetNodeID &ID, SILType ty);\n@@ -236,8 +253,6 @@ class ResilientTypeLayoutEntry : public TypeLayoutEntry,\n                                  llvm::Value *numEmptyCases,\n                                  Address enumAddr) const override;\n \n-  bool containsEnum() const override;\n-\n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n   void dump() const override;\n #endif\n@@ -256,6 +271,8 @@ class AlignedGroupEntry : public TypeLayoutEntry, public llvm::FoldingSetNode {\n \n   ~AlignedGroupEntry();\n \n+  void computeProperties() override;\n+\n   // Support for FoldingSet.\n   void Profile(llvm::FoldingSetNodeID &id) const;\n   static void Profile(llvm::FoldingSetNodeID &ID,\n@@ -287,8 +304,6 @@ class AlignedGroupEntry : public TypeLayoutEntry, public llvm::FoldingSetNode {\n                                  llvm::Value *numEmptyCases,\n                                  Address enumAddr) const override;\n \n-  bool containsEnum() const override;\n-\n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n   void dump() const override;\n #endif\n@@ -321,6 +336,8 @@ class EnumTypeLayoutEntry : public TypeLayoutEntry,\n \n   ~EnumTypeLayoutEntry();\n \n+  void computeProperties() override;\n+\n   // Support for FoldingSet.\n   void Profile(llvm::FoldingSetNodeID &id) const;\n   static void Profile(llvm::FoldingSetNodeID &ID, unsigned numEmptyCases,\n@@ -358,8 +375,6 @@ class EnumTypeLayoutEntry : public TypeLayoutEntry,\n   void destructiveInjectEnumTag(IRGenFunction &IGF, llvm::Value *tag,\n                                 Address enumAddr) const;\n \n-  bool containsEnum() const override;\n-\n   bool isMultiPayloadEnum() const;\n \n #if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)"
                    },
                    {
                        "filename": "lib/Index/Index.cpp",
                        "code": "@@ -129,7 +129,6 @@ class SourceFileOrModule {\n     ImportFilter |= ModuleDecl::ImportFilterKind::Public;\n     ImportFilter |= ModuleDecl::ImportFilterKind::Private;\n     ImportFilter |= ModuleDecl::ImportFilterKind::ImplementationOnly;\n-    // FIXME: ImportFilterKind::ShadowedBySeparateOverlay?\n \n     if (auto *SF = SFOrMod.dyn_cast<SourceFile *>()) {\n       SF->getImportedModules(Modules, ImportFilter);\n@@ -147,6 +146,7 @@ struct IndexedWitness {\n class IndexSwiftASTWalker : public SourceEntityWalker {\n   IndexDataConsumer &IdxConsumer;\n   SourceManager &SrcMgr;\n+  SourceFile *InitialFile; ///< The SoureFile we started walking from, if any.\n   unsigned BufferID;\n   bool enableWarnings;\n \n@@ -282,8 +282,9 @@ class IndexSwiftASTWalker : public SourceEntityWalker {\n \n public:\n   IndexSwiftASTWalker(IndexDataConsumer &IdxConsumer, ASTContext &Ctx,\n-                      unsigned BufferID = -1)\n-      : IdxConsumer(IdxConsumer), SrcMgr(Ctx.SourceMgr), BufferID(BufferID),\n+                      SourceFile *SF = nullptr)\n+      : IdxConsumer(IdxConsumer), SrcMgr(Ctx.SourceMgr), InitialFile(SF),\n+        BufferID(SF ? SF->getBufferID().getValueOr(-1) : -1),\n         enableWarnings(IdxConsumer.enableWarnings()) {}\n \n   ~IndexSwiftASTWalker() override {\n@@ -755,7 +756,18 @@ bool IndexSwiftASTWalker::visitImports(\n       continue;\n     bool IsClangModule = *IsClangModuleOpt;\n \n-    if (!IdxConsumer.startDependency(Mod->getName().str(), Path, IsClangModule,\n+    StringRef ModuleName = Mod->getNameStr();\n+\n+    // If this module is an underscored cross-import overlay, use the name\n+    // of the underlying module instead.\n+    if (InitialFile) {\n+      ModuleDecl *Underlying =\n+        InitialFile->getModuleShadowedBySeparatelyImportedOverlay(Mod);\n+      if (Underlying)\n+        ModuleName = Underlying->getNameStr();\n+    }\n+\n+    if (!IdxConsumer.startDependency(ModuleName, Path, IsClangModule,\n                                      Mod->isSystemModule()))\n       return false;\n     if (!IsClangModule)\n@@ -1584,16 +1596,15 @@ void IndexSwiftASTWalker::collectRecursiveModuleImports(\n \n void index::indexDeclContext(DeclContext *DC, IndexDataConsumer &consumer) {\n   assert(DC);\n-  unsigned bufferId = DC->getParentSourceFile()->getBufferID().getValue();\n-  IndexSwiftASTWalker walker(consumer, DC->getASTContext(), bufferId);\n+  SourceFile *SF = DC->getParentSourceFile();\n+  IndexSwiftASTWalker walker(consumer, DC->getASTContext(), SF);\n   walker.visitDeclContext(DC);\n   consumer.finish();\n }\n \n void index::indexSourceFile(SourceFile *SF, IndexDataConsumer &consumer) {\n   assert(SF);\n-  unsigned bufferID = SF->getBufferID().getValue();\n-  IndexSwiftASTWalker walker(consumer, SF->getASTContext(), bufferID);\n+  IndexSwiftASTWalker walker(consumer, SF->getASTContext(), SF);\n   walker.visitModule(*SF->getParentModule());\n   consumer.finish();\n }"
                    },
                    {
                        "filename": "lib/Index/IndexRecord.cpp",
                        "code": "@@ -372,23 +372,40 @@ getModuleInfoFromOpaqueModule(clang::index::writer::OpaqueModule mod,\n   return info;\n }\n \n+/// Gets the module name of the given module, or its underlying module if it's a\n+/// cross import overlay implicitly imported in \\p initialFile.\n+static StringRef getUnderlyingModuleName(ModuleDecl *module,\n+                                         SourceFile *initialFile) {\n+  if (initialFile) {\n+    ModuleDecl *underlying =\n+      initialFile->getModuleShadowedBySeparatelyImportedOverlay(module);\n+    if (underlying)\n+      module = underlying;\n+  }\n+  return module->getNameStr();\n+}\n+\n static bool\n emitDataForSwiftSerializedModule(ModuleDecl *module,\n                                  StringRef indexStorePath,\n                                  bool indexSystemModules,\n+                                 bool skipStdlib,\n                                  StringRef targetTriple,\n                                  const clang::CompilerInstance &clangCI,\n                                  DiagnosticEngine &diags,\n-                                 IndexUnitWriter &parentUnitWriter);\n+                                 IndexUnitWriter &parentUnitWriter,\n+                                 SourceFile *initialFile);\n \n static void addModuleDependencies(ArrayRef<ModuleDecl::ImportedModule> imports,\n                                   StringRef indexStorePath,\n                                   bool indexSystemModules,\n+                                  bool skipStdlib,\n                                   StringRef targetTriple,\n                                   const clang::CompilerInstance &clangCI,\n                                   DiagnosticEngine &diags,\n                                   IndexUnitWriter &unitWriter,\n-                                  StringScratchSpace &moduleNameScratch) {\n+                                  StringScratchSpace &moduleNameScratch,\n+                                  SourceFile *initialFile = nullptr) {\n   auto &fileMgr = clangCI.getFileManager();\n \n   for (auto &import : imports) {\n@@ -408,13 +425,13 @@ static void addModuleDependencies(ArrayRef<ModuleDecl::ImportedModule> imports,\n       case FileUnitKind::ClangModule: {\n         auto *LFU = cast<LoadedFile>(FU);\n         if (auto F = fileMgr.getFile(LFU->getFilename())) {\n-          std::string moduleName = mod->getNameStr().str();\n+          StringRef moduleName = mod->getNameStr();\n           bool withoutUnitName = true;\n           if (FU->getKind() == FileUnitKind::ClangModule) {\n             withoutUnitName = false;\n             auto clangModUnit = cast<ClangModuleUnit>(LFU);\n             if (auto clangMod = clangModUnit->getUnderlyingClangModule()) {\n-              moduleName = clangMod->getTopLevelModuleName().str();\n+              moduleName = clangMod->getTopLevelModuleName();\n               // FIXME: clang's -Rremarks do not seem to go through Swift's\n               // diagnostic emitter.\n               clang::index::emitIndexDataForModuleFile(clangMod,\n@@ -426,13 +443,18 @@ static void addModuleDependencies(ArrayRef<ModuleDecl::ImportedModule> imports,\n             // We don't officially support binary swift modules, so normally\n             // the index data for user modules would get generated while\n             // building them.\n-            if (mod->isSystemModule() && indexSystemModules) {\n+            if (mod->isSystemModule() && indexSystemModules &&\n+                (!skipStdlib || !mod->isStdlibModule())) {\n               emitDataForSwiftSerializedModule(mod, indexStorePath,\n-                                               indexSystemModules,\n+                                               indexSystemModules, skipStdlib,\n                                                targetTriple, clangCI, diags,\n-                                               unitWriter);\n+                                               unitWriter, initialFile);\n               withoutUnitName = false;\n             }\n+\n+            // If this is a cross-import overlay, make sure we use the name of\n+            // the underlying module instead.\n+            moduleName = getUnderlyingModuleName(mod, initialFile);\n           }\n           clang::index::writer::OpaqueModule opaqMod =\n               moduleNameScratch.createString(moduleName);\n@@ -451,12 +473,16 @@ static bool\n emitDataForSwiftSerializedModule(ModuleDecl *module,\n                                  StringRef indexStorePath,\n                                  bool indexSystemModules,\n+                                 bool skipStdlib,\n                                  StringRef targetTriple,\n                                  const clang::CompilerInstance &clangCI,\n                                  DiagnosticEngine &diags,\n-                                 IndexUnitWriter &parentUnitWriter) {\n+                                 IndexUnitWriter &parentUnitWriter,\n+                                 SourceFile *initialFile) {\n   StringRef filename = module->getModuleFilename();\n-  std::string moduleName = module->getNameStr().str();\n+  // If this is a cross-import overlay, make sure we use the name of the\n+  // underlying module instead.\n+  std::string moduleName = getUnderlyingModuleName(module, initialFile).str();\n \n   std::string error;\n   auto isUptodateOpt = parentUnitWriter.isUnitUpToDateForOutputFile(/*FilePath=*/filename,\n@@ -528,7 +554,7 @@ emitDataForSwiftSerializedModule(ModuleDecl *module,\n                                 indexStorePath.str(), &diags, outRecordFile);\n       if (failed)\n         return false;\n-      records.emplace_back(outRecordFile, moduleName.str());\n+      records.emplace_back(outRecordFile, moduleName.str().str());\n       return true;\n     });\n     indexModule(module, groupIndexConsumer);\n@@ -565,12 +591,12 @@ emitDataForSwiftSerializedModule(ModuleDecl *module,\n   ModuleDecl::ImportFilter importFilter;\n   importFilter |= ModuleDecl::ImportFilterKind::Public;\n   importFilter |= ModuleDecl::ImportFilterKind::Private;\n-  // FIXME: ImportFilterKind::ShadowedBySeparateOverlay?\n   SmallVector<ModuleDecl::ImportedModule, 8> imports;\n   module->getImportedModules(imports, importFilter);\n   StringScratchSpace moduleNameScratch;\n-  addModuleDependencies(imports, indexStorePath, indexSystemModules,\n-                        targetTriple, clangCI, diags, unitWriter, moduleNameScratch);\n+  addModuleDependencies(imports, indexStorePath, indexSystemModules, skipStdlib,\n+                        targetTriple, clangCI, diags, unitWriter,\n+                        moduleNameScratch, initialFile);\n \n   if (unitWriter.write(error)) {\n     diags.diagnose(SourceLoc(), diag::error_write_index_unit, error);\n@@ -583,7 +609,8 @@ emitDataForSwiftSerializedModule(ModuleDecl *module,\n static bool\n recordSourceFileUnit(SourceFile *primarySourceFile, StringRef indexUnitToken,\n                      StringRef indexStorePath, bool indexSystemModules,\n-                     bool isDebugCompilation, StringRef targetTriple,\n+                     bool skipStdlib, bool isDebugCompilation,\n+                     StringRef targetTriple,\n                      ArrayRef<const clang::FileEntry *> fileDependencies,\n                      const clang::CompilerInstance &clangCI,\n                      DiagnosticEngine &diags) {\n@@ -606,12 +633,13 @@ recordSourceFileUnit(SourceFile *primarySourceFile, StringRef indexUnitToken,\n   importFilter |= ModuleDecl::ImportFilterKind::Public;\n   importFilter |= ModuleDecl::ImportFilterKind::Private;\n   importFilter |= ModuleDecl::ImportFilterKind::ImplementationOnly;\n-  // FIXME: ImportFilterKind::ShadowedBySeparateOverlay?\n+\n   SmallVector<ModuleDecl::ImportedModule, 8> imports;\n   primarySourceFile->getImportedModules(imports, importFilter);\n   StringScratchSpace moduleNameScratch;\n-  addModuleDependencies(imports, indexStorePath, indexSystemModules,\n-                        targetTriple, clangCI, diags, unitWriter, moduleNameScratch);\n+  addModuleDependencies(imports, indexStorePath, indexSystemModules, skipStdlib,\n+                        targetTriple, clangCI, diags, unitWriter,\n+                        moduleNameScratch, primarySourceFile);\n \n   // File dependencies.\n   for (auto *F : fileDependencies)\n@@ -662,6 +690,7 @@ bool index::indexAndRecord(SourceFile *primarySourceFile,\n                            StringRef indexUnitToken,\n                            StringRef indexStorePath,\n                            bool indexSystemModules,\n+                           bool skipStdlib,\n                            bool isDebugCompilation,\n                            StringRef targetTriple,\n                            const DependencyTracker &dependencyTracker) {\n@@ -689,7 +718,7 @@ bool index::indexAndRecord(SourceFile *primarySourceFile,\n #endif\n \n   return recordSourceFileUnit(primarySourceFile, indexUnitToken,\n-                              indexStorePath, indexSystemModules,\n+                              indexStorePath, indexSystemModules, skipStdlib,\n                               isDebugCompilation, targetTriple,\n                               fileDependencies.getArrayRef(),\n                               clangCI, diags);\n@@ -700,6 +729,7 @@ bool index::indexAndRecord(ModuleDecl *module,\n                            StringRef moduleUnitToken,\n                            StringRef indexStorePath,\n                            bool indexSystemModules,\n+                           bool skipStdlib,\n                            bool isDebugCompilation,\n                            StringRef targetTriple,\n                            const DependencyTracker &dependencyTracker) {\n@@ -735,7 +765,7 @@ bool index::indexAndRecord(ModuleDecl *module,\n         return true;\n       }\n       if (recordSourceFileUnit(SF, indexUnitTokens[unitIndex],\n-                               indexStorePath, indexSystemModules,\n+                               indexStorePath, indexSystemModules, skipStdlib,\n                                isDebugCompilation, targetTriple,\n                                fileDependencies.getArrayRef(),\n                                clangCI, diags))"
                    },
                    {
                        "filename": "lib/Index/IndexSymbol.cpp",
                        "code": "@@ -75,7 +75,7 @@ static bool isUnitTest(const ValueDecl *D) {\n     return false;\n \n   // 6. ...and starts with \"test\".\n-  if (FD->getName().str().startswith(\"test\"))\n+  if (FD->getBaseIdentifier().str().startswith(\"test\"))\n     return true;\n \n   return false;"
                    },
                    {
                        "filename": "lib/LLVMPasses/CMakeLists.txt",
                        "code": "@@ -9,4 +9,5 @@ add_swift_host_library(swiftLLVMPasses STATIC\n   LLVM_LINK_COMPONENTS\n   analysis\n   )\n-\n+target_link_libraries(swiftLLVMPasses PRIVATE\n+  swiftDemangling)"
                    },
                    {
                        "filename": "lib/Migrator/APIDiffMigratorPass.cpp",
                        "code": "@@ -386,7 +386,7 @@ struct APIDiffMigratorPass : public ASTMigratorPass, public SourceEntityWalker {\n     for (auto *D: TopDecls) {\n       if (auto *FD = dyn_cast<FuncDecl>(D)) {\n         InsertedFunctions.insert(\n-            std::string(FD->getBaseName().getIdentifier()));\n+            std::string(FD->getBaseIdentifier()));\n       }\n     }\n "
                    },
                    {
                        "filename": "lib/Migrator/overlay4.json",
                        "code": "@@ -1342,5 +1342,5 @@\n     \"RightUsr\": \"\",\n     \"RightComment\": \"firstIndex\",\n     \"ModuleName\": \"Swift\"\n-  },\n+  }\n ]"
                    },
                    {
                        "filename": "lib/Migrator/overlay42.json",
                        "code": "@@ -20,5 +20,5 @@\n     \"RightUsr\": \"\",\n     \"RightComment\": \"firstIndex\",\n     \"ModuleName\": \"Swift\"\n-  },\n+  }\n ]"
                    },
                    {
                        "filename": "lib/Parse/ParseDecl.cpp",
                        "code": "@@ -644,7 +644,7 @@ bool Parser::parseSpecializeAttributeArguments(\n           return false;\n         }\n         if (ParamLabel == \"exported\") {\n-          Exported = isTrue ? true : false;\n+          Exported = isTrue;\n         }\n       }\n       if (ParamLabel == \"kind\") {\n@@ -816,28 +816,21 @@ Parser::parseImplementsAttribute(SourceLoc AtLoc, SourceLoc Loc) {\n /// \\verbatim\n ///   differentiable-attribute-arguments:\n ///     '(' (differentiability-params-clause ',')?\n-///         (differentiable-attr-func-specifier ',')?\n-///         differentiable-attr-func-specifier?\n ///         where-clause?\n ///     ')'\n-///   differentiable-attr-func-specifier:\n-///     ('jvp' | 'vjp') ':' decl-name\n /// \\endverbatim\n ParserResult<DifferentiableAttr>\n Parser::parseDifferentiableAttribute(SourceLoc atLoc, SourceLoc loc) {\n   StringRef AttrName = \"differentiable\";\n   SourceLoc lParenLoc = loc, rParenLoc = loc;\n   bool linear = false;\n   SmallVector<ParsedAutoDiffParameter, 8> parameters;\n-  Optional<DeclNameRefWithLoc> jvpSpec;\n-  Optional<DeclNameRefWithLoc> vjpSpec;\n   TrailingWhereClause *whereClause = nullptr;\n \n   // Parse '('.\n   if (consumeIf(tok::l_paren, lParenLoc)) {\n     // Parse @differentiable attribute arguments.\n-    if (parseDifferentiableAttributeArguments(linear, parameters, jvpSpec,\n-                                              vjpSpec, whereClause))\n+    if (parseDifferentiableAttributeArguments(linear, parameters, whereClause))\n       return makeParserError();\n     // Parse ')'.\n     if (!consumeIf(tok::r_paren, rParenLoc)) {\n@@ -849,7 +842,7 @@ Parser::parseDifferentiableAttribute(SourceLoc atLoc, SourceLoc loc) {\n \n   return ParserResult<DifferentiableAttr>(DifferentiableAttr::create(\n       Context, /*implicit*/ false, atLoc, SourceRange(loc, rParenLoc), linear,\n-      parameters, jvpSpec, vjpSpec, whereClause));\n+      parameters, whereClause));\n }\n \n // Attribute parsing error helper.\n@@ -963,8 +956,7 @@ bool Parser::parseDifferentiabilityParametersClause(\n \n bool Parser::parseDifferentiableAttributeArguments(\n     bool &linear, SmallVectorImpl<ParsedAutoDiffParameter> &parameters,\n-    Optional<DeclNameRefWithLoc> &jvpSpec,\n-    Optional<DeclNameRefWithLoc> &vjpSpec, TrailingWhereClause *&whereClause) {\n+    TrailingWhereClause *&whereClause) {\n   StringRef AttrName = \"differentiable\";\n \n   // Parse trailing comma, if it exists, and check for errors.\n@@ -975,9 +967,8 @@ bool Parser::parseDifferentiableAttributeArguments(\n       diagnose(Tok, diag::unexpected_separator, \",\");\n       return true;\n     }\n-    // Check that token after comma is 'wrt' or a function specifier label.\n-    if (isIdentifier(Tok, \"wrt\") || isIdentifier(Tok, \"jvp\") ||\n-        isIdentifier(Tok, \"vjp\")) {\n+    // Check that token after comma is 'wrt'.\n+    if (isIdentifier(Tok, \"wrt\")) {\n       return false;\n     }\n     diagnose(Tok, diag::attr_differentiable_expected_label);\n@@ -1021,66 +1012,6 @@ bool Parser::parseDifferentiableAttributeArguments(\n       return errorAndSkipUntilConsumeRightParen(*this, AttrName);\n   }\n \n-  // Function that parses a label and a function specifier, e.g. 'vjp: foo(_:)'.\n-  // Return true on error.\n-  auto parseFuncSpec = [&](StringRef label, DeclNameRefWithLoc &result,\n-                           bool &terminateParsingArgs) -> bool {\n-    // Parse label.\n-    if (parseSpecificIdentifier(label, diag::attr_missing_label, label,\n-                                AttrName) ||\n-        parseToken(tok::colon, diag::expected_colon_after_label, label))\n-      return true;\n-    // Parse the name of the function.\n-    SyntaxParsingContext FuncDeclNameContext(\n-         SyntaxContext, SyntaxKind::FunctionDeclName);\n-    Diagnostic funcDiag(diag::attr_differentiable_expected_function_name.ID,\n-                        { label });\n-    result.Name = parseDeclNameRef(result.Loc, funcDiag,\n-        DeclNameFlag::AllowZeroArgCompoundNames | DeclNameFlag::AllowOperators);\n-    // Emit warning for deprecated `jvp:` and `vjp:` arguments.\n-    // TODO(TF-1001): Remove deprecated `jvp:` and `vjp:` arguments.\n-    if (result.Loc.isValid()) {\n-      diagnose(result.Loc.getStartLoc(),\n-               diag::attr_differentiable_jvp_vjp_deprecated_warning)\n-          .highlight(result.Loc.getSourceRange());\n-    }\n-    // If no trailing comma or 'where' clause, terminate parsing arguments.\n-    if (Tok.isNot(tok::comma, tok::kw_where))\n-      terminateParsingArgs = true;\n-    return !result.Name;\n-  };\n-\n-  // Store whether to terminate parsing arguments.\n-  bool terminateParsingArgs = false;\n-\n-  // Parse 'jvp: <func_name>' (optional).\n-  if (isIdentifier(Tok, \"jvp\")) {\n-    SyntaxParsingContext JvpContext(\n-        SyntaxContext, SyntaxKind::DifferentiableAttributeFuncSpecifier);\n-    jvpSpec = DeclNameRefWithLoc();\n-    if (parseFuncSpec(\"jvp\", *jvpSpec, terminateParsingArgs))\n-      return errorAndSkipUntilConsumeRightParen(*this, AttrName);\n-    if (terminateParsingArgs)\n-      return false;\n-    if (consumeIfTrailingComma())\n-      return errorAndSkipUntilConsumeRightParen(*this, AttrName);\n-  }\n-\n-  // Parse 'vjp: <func_name>' (optional).\n-  if (isIdentifier(Tok, \"vjp\")) {\n-    SyntaxParsingContext VjpContext(\n-        SyntaxContext, SyntaxKind::DifferentiableAttributeFuncSpecifier);\n-    vjpSpec = DeclNameRefWithLoc();\n-    if (parseFuncSpec(\"vjp\", *vjpSpec, terminateParsingArgs))\n-      return errorAndSkipUntilConsumeRightParen(*this, AttrName);\n-    if (terminateParsingArgs)\n-      return false;\n-    // Note: intentionally parse trailing comma here, even though it's the last\n-    // function specifier. `consumeIfTrailingComma` will emit an error.\n-    if (consumeIfTrailingComma())\n-      return errorAndSkipUntilConsumeRightParen(*this, AttrName);\n-  }\n-\n   // If parser has not advanced and token is not 'where' or ')', emit error.\n   if (Tok.getLoc() == startingLoc && Tok.isNot(tok::kw_where, tok::r_paren)) {\n     diagnose(Tok, diag::attr_differentiable_expected_label);\n@@ -3588,7 +3519,7 @@ void Parser::setLocalDiscriminator(ValueDecl *D) {\n     if (!getScopeInfo().isInactiveConfigBlock())\n       SF.LocalTypeDecls.insert(TD);\n \n-  Identifier name = D->getBaseName().getIdentifier();\n+  const Identifier name = D->getBaseIdentifier();\n   unsigned discriminator = CurLocalContext->claimNextNamedDiscriminator(name);\n   D->setLocalDiscriminator(discriminator);\n }"
                    },
                    {
                        "filename": "lib/Parse/ParseExpr.cpp",
                        "code": "@@ -46,8 +46,8 @@ ParserResult<Expr> Parser::parseExprImpl(Diag<> Message,\n   SyntaxParsingContext ExprParsingContext(SyntaxContext, SyntaxContextKind::Expr);\n \n   // If we are parsing a refutable pattern, check to see if this is the start\n-  // of a let/var/is pattern.  If so, parse it to an UnresolvedPatternExpr and\n-  // name binding will perform final validation.\n+  // of a let/var/is pattern.  If so, parse it as an UnresolvedPatternExpr and\n+  // let pattern type checking determine its final form.\n   //\n   // Only do this if we're parsing a pattern, to improve QoI on malformed\n   // expressions followed by (e.g.) let/var decls.\n@@ -2264,7 +2264,10 @@ Expr *Parser::parseExprIdentifier() {\n   }\n   \n   ValueDecl *D = nullptr;\n-  if (!InPoundIfEnvironment) {\n+  // When doing incremental re-parsing for SwiftSyntax this check may emit bogus\n+  // diagnostic. Also really the syntactic parser should not be doing name\n+  // lookups, so disable this check when parsing for SwiftSyntax.\n+  if (!InPoundIfEnvironment && !Context.LangOpts.ParseForSyntaxTreeOnly) {\n     D = lookupInScope(name);\n     // FIXME: We want this to work: \"var x = { x() }\", but for now it's better\n     // to disallow it than to crash.\n@@ -2835,6 +2838,15 @@ ParserResult<Expr> Parser::parseExprClosure() {\n   ParserStatus Status;\n   Status |= parseBraceItems(bodyElements, BraceItemListKind::Brace);\n \n+  if (SourceMgr.rangeContainsCodeCompletionLoc({leftBrace, PreviousLoc})) {\n+    // Ignore 'CodeCompletionDelayedDeclState' inside closures.\n+    // Completions inside functions body inside closures at top level should\n+    // be considered top-level completions.\n+    if (State->hasCodeCompletionDelayedDeclState())\n+      (void)State->takeCodeCompletionDelayedDeclState();\n+    Status.setHasCodeCompletion();\n+  }\n+\n   // Parse the closing '}'.\n   SourceLoc rightBrace;\n   bool missingRBrace = parseMatchingToken(tok::r_brace, rightBrace,"
                    },
                    {
                        "filename": "lib/Parse/ParseGeneric.cpp",
                        "code": "@@ -418,12 +418,10 @@ parseFreestandingGenericWhereClause(GenericContext *genCtx,\n \n     genericParams->addTrailingWhereClause(Context, WhereLoc, Requirements);\n \n-  // A where clause that references only outer generic parameters?\n-  } else if (flags.contains(PD_HasContainerType)) {\n+  } else {\n+    // A where clause against outer generic parameters.\n     genCtx->setTrailingWhereClause(\n         TrailingWhereClause::create(Context, WhereLoc, Requirements));\n-  } else {\n-    diagnose(WhereLoc, diag::where_toplevel_nongeneric);\n   }\n \n   return ParserStatus();"
                    },
                    {
                        "filename": "lib/Parse/ParseRequests.cpp",
                        "code": "@@ -167,6 +167,11 @@ ArrayRef<Decl *> ParseSourceFileRequest::evaluate(Evaluator &evaluator,\n   return ctx.AllocateCopy(decls);\n }\n \n+evaluator::DependencySource\n+ParseSourceFileRequest::readDependencySource(Evaluator &e) const {\n+  return {std::get<0>(getStorage()), evaluator::DependencyScope::Cascading};\n+}\n+\n Optional<ArrayRef<Decl *>> ParseSourceFileRequest::getCachedResult() const {\n   auto *SF = std::get<0>(getStorage());\n   return SF->getCachedTopLevelDecls();\n@@ -181,6 +186,19 @@ void ParseSourceFileRequest::cacheResult(ArrayRef<Decl *> decls) const {\n   verify(*SF);\n }\n \n+//----------------------------------------------------------------------------//\n+// CodeCompletionSecondPassRequest computation.\n+//----------------------------------------------------------------------------//\n+\n+\n+void swift::simple_display(llvm::raw_ostream &out,\n+                           const CodeCompletionCallbacksFactory *factory) { }\n+\n+evaluator::DependencySource\n+CodeCompletionSecondPassRequest::readDependencySource(Evaluator &e) const {\n+  return {std::get<0>(getStorage()), e.getActiveSourceScope()};\n+}\n+\n // Define request evaluation functions for each of the type checker requests.\n static AbstractRequestFunction *parseRequestFunctions[] = {\n #define SWIFT_REQUEST(Zone, Name, Sig, Caching, LocOptions)                    \\"
                    },
                    {
                        "filename": "lib/Parse/Parser.cpp",
                        "code": "@@ -114,25 +114,31 @@ void SILParserTUStateBase::anchor() { }\n \n void swift::performCodeCompletionSecondPass(\n     SourceFile &SF, CodeCompletionCallbacksFactory &Factory) {\n+  return (void)evaluateOrDefault(SF.getASTContext().evaluator,\n+                                 CodeCompletionSecondPassRequest{&SF, &Factory},\n+                                 false);\n+}\n+\n+bool CodeCompletionSecondPassRequest::evaluate(\n+    Evaluator &evaluator, SourceFile *SF,\n+    CodeCompletionCallbacksFactory *Factory) const {\n   // If we didn't find the code completion token, bail.\n-  auto *parserState = SF.getDelayedParserState();\n+  auto *parserState = SF->getDelayedParserState();\n   if (!parserState->hasCodeCompletionDelayedDeclState())\n-    return;\n+    return true;\n \n   auto state = parserState->takeCodeCompletionDelayedDeclState();\n-  auto &Ctx = SF.getASTContext();\n-\n-  FrontendStatsTracer tracer(Ctx.Stats,\n-                             \"CodeCompletionSecondPass\");\n+  auto &Ctx = SF->getASTContext();\n \n   auto BufferID = Ctx.SourceMgr.getCodeCompletionBufferID();\n-  Parser TheParser(BufferID, SF, nullptr, parserState, nullptr);\n+  Parser TheParser(BufferID, *SF, nullptr, parserState, nullptr);\n \n   std::unique_ptr<CodeCompletionCallbacks> CodeCompletion(\n-      Factory.createCodeCompletionCallbacks(TheParser));\n+      Factory->createCodeCompletionCallbacks(TheParser));\n   TheParser.setCodeCompletionCallbacks(CodeCompletion.get());\n \n   TheParser.performCodeCompletionSecondPassImpl(*state);\n+  return true;\n }\n \n void Parser::performCodeCompletionSecondPassImpl("
                    },
                    {
                        "filename": "lib/ParseSIL/CMakeLists.txt",
                        "code": "@@ -1,6 +1,7 @@\n add_swift_host_library(swiftParseSIL STATIC\n   ParseSIL.cpp)\n target_link_libraries(swiftParseSIL PRIVATE\n+  swiftDemangling\n   swiftSema\n   swiftSIL)\n "
                    },
                    {
                        "filename": "lib/ParseSIL/ParseSIL.cpp",
                        "code": "@@ -1093,7 +1093,6 @@ static bool parseDeclSILOptional(bool *isTransparent,\n bool SILParser::performTypeLocChecking(TypeLoc &T, bool IsSILType,\n                                        GenericEnvironment *GenericEnv,\n                                        DeclContext *DC) {\n-  // Do some type checking / name binding for the parsed type.\n   if (GenericEnv == nullptr)\n     GenericEnv = ContextGenericEnv;\n \n@@ -1340,9 +1339,8 @@ static Optional<AccessorKind> getAccessorKind(StringRef ident) {\n }\n \n ///  sil-decl-ref ::= '#' sil-identifier ('.' sil-identifier)* sil-decl-subref?\n-///  sil-decl-subref ::= '!' sil-decl-subref-part ('.' sil-decl-uncurry-level)?\n-///                      ('.' sil-decl-lang)?\n-///  sil-decl-subref ::= '!' sil-decl-uncurry-level ('.' sil-decl-lang)?\n+///  sil-decl-subref ::= '!' sil-decl-subref-part ('.' sil-decl-lang)?\n+///                      ('.' sil-decl-autodiff)?\n ///  sil-decl-subref ::= '!' sil-decl-lang\n ///  sil-decl-subref-part ::= 'getter'\n ///  sil-decl-subref-part ::= 'setter'\n@@ -1351,33 +1349,34 @@ static Optional<AccessorKind> getAccessorKind(StringRef ident) {\n ///  sil-decl-subref-part ::= 'enumelt'\n ///  sil-decl-subref-part ::= 'destroyer'\n ///  sil-decl-subref-part ::= 'globalaccessor'\n-///  sil-decl-uncurry-level ::= [0-9]+\n ///  sil-decl-lang ::= 'foreign'\n+///  sil-decl-autodiff ::= sil-decl-autodiff-kind '.' sil-decl-autodiff-indices\n+///  sil-decl-autodiff-kind ::= 'jvp'\n+///  sil-decl-autodiff-kind ::= 'vjp'\n+///  sil-decl-autodiff-indices ::= [SU]+\n bool SILParser::parseSILDeclRef(SILDeclRef &Result,\n                                 SmallVectorImpl<ValueDecl *> &values) {\n   ValueDecl *VD;\n   if (parseSILDottedPath(VD, values))\n     return true;\n \n-  // Initialize Kind, uncurryLevel and IsObjC.\n+  // Initialize SILDeclRef components.\n   SILDeclRef::Kind Kind = SILDeclRef::Kind::Func;\n-  unsigned uncurryLevel = 0;\n   bool IsObjC = false;\n+  AutoDiffDerivativeFunctionIdentifier *DerivativeId = nullptr;\n \n   if (!P.consumeIf(tok::sil_exclamation)) {\n     // Construct SILDeclRef.\n-    Result = SILDeclRef(VD, Kind, /*isCurried=*/false, IsObjC);\n-    if (uncurryLevel < Result.getParameterListCount() - 1)\n-      Result = Result.asCurried();\n+    Result = SILDeclRef(VD, Kind, IsObjC, DerivativeId);\n     return false;\n   }\n \n-  // Handle sil-constant-kind-and-uncurry-level.\n-  // ParseState indicates the value we just handled.\n-  // 1 means we just handled Kind, 2 means we just handled uncurryLevel.\n-  // We accept func|getter|setter|...|foreign or an integer when ParseState is\n-  // 0; accept foreign or an integer when ParseState is 1; accept foreign when\n-  // ParseState is 2.\n+  // Handle SILDeclRef components. ParseState tracks the last parsed component.\n+  //\n+  // When ParseState is 0, accept kind (`func|getter|setter|...`) and set\n+  // ParseState to 1.\n+  //\n+  // Always accept `foreign` and derivative function identifier.\n   unsigned ParseState = 0;\n   Identifier Id;\n   do {\n@@ -1446,21 +1445,47 @@ bool SILParser::parseSILDeclRef(SILDeclRef &Result,\n       } else if (Id.str() == \"foreign\") {\n         IsObjC = true;\n         break;\n-      } else\n+      } else if (Id.str() == \"jvp\" || Id.str() == \"vjp\") {\n+        IndexSubset *parameterIndices = nullptr;\n+        GenericSignature derivativeGenSig;\n+        // Parse derivative function kind.\n+        AutoDiffDerivativeFunctionKind derivativeKind(Id.str());\n+        if (!P.consumeIf(tok::period)) {\n+          P.diagnose(P.Tok, diag::expected_tok_in_sil_instr, \".\");\n+          return true;\n+        }\n+        // Parse parameter indices.\n+        parameterIndices =\n+            IndexSubset::getFromString(SILMod.getASTContext(), P.Tok.getText());\n+        if (!parameterIndices) {\n+          P.diagnose(P.Tok, diag::invalid_index_subset);\n+          return true;\n+        }\n+        P.consumeToken();\n+        // Parse derivative generic signature (optional).\n+        if (P.Tok.is(tok::oper_binary_unspaced) && P.Tok.getText() == \".<\") {\n+          P.consumeStartingCharacterOfCurrentToken(tok::period);\n+          // Create a new scope to avoid type redefinition errors.\n+          Scope genericsScope(&P, ScopeKind::Generics);\n+          auto *genericParams = P.maybeParseGenericParams().getPtrOrNull();\n+          assert(genericParams);\n+          auto *derivativeGenEnv = handleSILGenericParams(genericParams, &P.SF);\n+          derivativeGenSig = derivativeGenEnv->getGenericSignature();\n+        }\n+        DerivativeId = AutoDiffDerivativeFunctionIdentifier::get(\n+            derivativeKind, parameterIndices, derivativeGenSig,\n+            SILMod.getASTContext());\n         break;\n-    } else if (ParseState < 2 && P.Tok.is(tok::integer_literal)) {\n-      parseIntegerLiteral(P.Tok.getText(), 0, uncurryLevel);\n-      P.consumeToken(tok::integer_literal);\n-      ParseState = 2;\n+      } else {\n+        break;\n+      }\n     } else\n       break;\n \n   } while (P.consumeIf(tok::period));\n \n   // Construct SILDeclRef.\n-  Result = SILDeclRef(VD, Kind, /*isCurried=*/false, IsObjC);\n-  if (uncurryLevel < Result.getParameterListCount() - 1)\n-    Result = Result.asCurried();\n+  Result = SILDeclRef(VD, Kind, IsObjC, DerivativeId);\n   return false;\n }\n \n@@ -4996,6 +5021,144 @@ bool SILParser::parseSpecificSILInstruction(SILBuilder &B,\n                                                  blockType, subMap);\n       break;\n     }\n+    case SILInstructionKind::DifferentiableFunctionInst: {\n+      // e.g. differentiable_function [parameters 0 1 2] %0 : $T\n+      //\n+      // e.g. differentiable_function [parameters 0 1 2] %0 : $T with_derivative\n+      //      {%1 : $T, %2 : $T}\n+      //       ^~ jvp   ^~ vjp\n+      // Parse `[parameters <integer_literal>...]`.\n+      SmallVector<unsigned, 8> parameterIndices;\n+      if (parseIndexList(P, \"parameters\", parameterIndices,\n+                         diag::sil_autodiff_expected_parameter_index))\n+        return true;\n+      // Parse the original function value.\n+      SILValue original;\n+      SourceLoc originalOperandLoc;\n+      if (parseTypedValueRef(original, originalOperandLoc, B))\n+        return true;\n+      auto fnType = original->getType().getAs<SILFunctionType>();\n+      if (!fnType) {\n+        P.diagnose(originalOperandLoc,\n+                   diag::sil_inst_autodiff_expected_function_type_operand);\n+        return true;\n+      }\n+      Optional<std::pair<SILValue, SILValue>> derivativeFunctions = None;\n+      // Parse an optional operand list\n+      //   `with_derivative { <operand> , <operand> }`.\n+      if (P.Tok.is(tok::identifier) && P.Tok.getText() == \"with_derivative\") {\n+        P.consumeToken(tok::identifier);\n+        // Parse derivative function values as an operand list.\n+        // FIXME(rxwei): Change this to *not* require a type signature once\n+        // we can infer derivative function types.\n+        derivativeFunctions = std::make_pair(SILValue(), SILValue());\n+        if (P.parseToken(\n+                tok::l_brace,\n+                diag::sil_inst_autodiff_operand_list_expected_lbrace) ||\n+            parseTypedValueRef(derivativeFunctions->first, B) ||\n+            P.parseToken(tok::comma,\n+                         diag::sil_inst_autodiff_operand_list_expected_comma) ||\n+            parseTypedValueRef(derivativeFunctions->second, B) ||\n+            P.parseToken(tok::r_brace,\n+                         diag::sil_inst_autodiff_operand_list_expected_rbrace))\n+          return true;\n+      }\n+      if (parseSILDebugLocation(InstLoc, B))\n+        return true;\n+      auto *parameterIndicesSubset = IndexSubset::get(\n+          P.Context, fnType->getNumParameters(), parameterIndices);\n+      ResultVal = B.createDifferentiableFunction(\n+          InstLoc, parameterIndicesSubset, original, derivativeFunctions);\n+      break;\n+    }\n+    case SILInstructionKind::LinearFunctionInst: {\n+      // e.g. linear_function [parameters 0 1 2] %0 : $T\n+      // e.g. linear_function [parameters 0 1 2] %0 : $T with_transpose %1 : $T\n+      // Parse `[parameters <integer_literal>...]`.\n+      SmallVector<unsigned, 8> parameterIndices;\n+      if (parseIndexList(P, \"parameters\", parameterIndices,\n+                         diag::sil_autodiff_expected_parameter_index))\n+        return true;\n+      // Parse the original function value.\n+      SILValue original;\n+      SourceLoc originalOperandLoc;\n+      if (parseTypedValueRef(original, originalOperandLoc, B))\n+        return true;\n+      auto fnType = original->getType().getAs<SILFunctionType>();\n+      if (!fnType) {\n+        P.diagnose(originalOperandLoc,\n+                   diag::sil_inst_autodiff_expected_function_type_operand);\n+        return true;\n+      }\n+      // Parse an optional transpose function.\n+      Optional<SILValue> transpose = None;\n+      if (P.Tok.is(tok::identifier) && P.Tok.getText() == \"with_transpose\") {\n+        P.consumeToken(tok::identifier);\n+        transpose = SILValue();\n+        if (parseTypedValueRef(*transpose, B))\n+          return true;\n+      }\n+      if (parseSILDebugLocation(InstLoc, B))\n+        return true;\n+      auto *parameterIndicesSubset = IndexSubset::get(\n+          P.Context, fnType->getNumParameters(), parameterIndices);\n+      ResultVal = B.createLinearFunction(\n+          InstLoc, parameterIndicesSubset, original, transpose);\n+      break;\n+    }\n+    case SILInstructionKind::DifferentiableFunctionExtractInst: {\n+      // Parse the rest of the instruction: an extractee, a differentiable\n+      // function operand, an optional explicit extractee type, and a debug\n+      // location.\n+      NormalDifferentiableFunctionTypeComponent extractee;\n+      StringRef extracteeNames[3] = {\"original\", \"jvp\", \"vjp\"};\n+      SILValue functionOperand;\n+      SourceLoc lastLoc;\n+      if (P.parseToken(\n+              tok::l_square,\n+              diag::sil_inst_autodiff_expected_differentiable_extractee_kind) ||\n+          parseSILIdentifierSwitch(\n+              extractee, extracteeNames,\n+              diag::sil_inst_autodiff_expected_differentiable_extractee_kind) ||\n+          P.parseToken(tok::r_square, diag::sil_autodiff_expected_rsquare,\n+                       \"extractee kind\"))\n+        return true;\n+      if (parseTypedValueRef(functionOperand, B))\n+        return true;\n+      // Parse an optional explicit extractee type.\n+      Optional<SILType> extracteeType = None;\n+      if (P.consumeIf(tok::kw_as)) {\n+        extracteeType = SILType();\n+        if (parseSILType(*extracteeType))\n+          return true;\n+      }\n+      if (parseSILDebugLocation(InstLoc, B))\n+        return true;\n+      ResultVal = B.createDifferentiableFunctionExtract(\n+          InstLoc, extractee, functionOperand, extracteeType);\n+      break;\n+    }\n+    case SILInstructionKind::LinearFunctionExtractInst: {\n+      // Parse the rest of the instruction: an extractee, a linear function\n+      // operand, and a debug location.\n+      LinearDifferentiableFunctionTypeComponent extractee;\n+      StringRef extracteeNames[2] = {\"original\", \"transpose\"};\n+      SILValue functionOperand;\n+      SourceLoc lastLoc;\n+      if (P.parseToken(tok::l_square,\n+              diag::sil_inst_autodiff_expected_linear_extractee_kind) ||\n+          parseSILIdentifierSwitch(extractee, extracteeNames,\n+              diag::sil_inst_autodiff_expected_linear_extractee_kind) ||\n+          P.parseToken(tok::r_square, diag::sil_autodiff_expected_rsquare,\n+                       \"extractee kind\"))\n+        return true;\n+      if (parseTypedValueRef(functionOperand, B) ||\n+          parseSILDebugLocation(InstLoc, B))\n+        return true;\n+      ResultVal = B.createLinearFunctionExtract(\n+          InstLoc, extractee, functionOperand);\n+      break;\n+    }\n     case SILInstructionKind::DifferentiabilityWitnessFunctionInst: {\n       // e.g. differentiability_witness_function\n       //      [jvp] [parameters 0 1] [results 0] <T where T: Differentiable>"
                    },
                    {
                        "filename": "lib/PrintAsObjC/DeclAndTypePrinter.cpp",
                        "code": "@@ -395,7 +395,7 @@ class DeclAndTypePrinter::Implementation\n       // name.\n       os << \"  \";\n       if (printSwiftEnumElemNameInObjC(Elt, os)) {\n-        os << \" SWIFT_COMPILE_NAME(\\\"\" << Elt->getName() << \"\\\")\";\n+        os << \" SWIFT_COMPILE_NAME(\\\"\" << Elt->getBaseIdentifier() << \"\\\")\";\n       }\n \n       // Print the raw values, even the ones that we synthesize."
                    },
                    {
                        "filename": "lib/PrintAsObjC/ModuleContentsWriter.cpp",
                        "code": "@@ -443,7 +443,7 @@ class ModuleWriter {\n       bool hasDomainCase = std::any_of(ED->getAllElements().begin(),\n                                        ED->getAllElements().end(),\n                                        [](const EnumElementDecl *elem) {\n-        return elem->getName().str() == \"Domain\";\n+        return elem->getBaseIdentifier().str() == \"Domain\";\n       });\n       if (!hasDomainCase) {\n         os << \"static NSString * _Nonnull const \" << getNameForObjC(ED)"
                    },
                    {
                        "filename": "lib/PrintAsObjC/PrintAsObjC.cpp",
                        "code": "@@ -319,24 +319,6 @@ static void writeImports(raw_ostream &out,\n \n   // Track printed names to handle overlay modules.\n   llvm::SmallPtrSet<Identifier, 8> seenImports;\n-  llvm::SmallString<256> allPaths;\n-  llvm::SmallSetVector<StringRef, 8> headerImports;\n-  auto insertHeaderPath = [&](clang::Module::Header header,\n-                              const clang::Module *module) {\n-    auto startIdx = allPaths.size();\n-    if (module->IsFramework) {\n-      SmallString<64> Buffer(header.NameAsWritten);\n-      llvm::sys::path::replace_path_prefix(Buffer, \"Headers/\", StringRef());\n-      llvm::sys::path::replace_path_prefix(Buffer, \"PrivateHeaders/\", StringRef());\n-      // For framworks, the header import should start from the framework name.\n-      allPaths.append(module->getTopLevelModuleName());\n-      llvm::sys::path::append(allPaths, Buffer.str());\n-    } else {\n-      // Otherwise, import the header directly.\n-      allPaths.append(header.NameAsWritten);\n-    }\n-    headerImports.insert(allPaths.str().substr(startIdx));\n-  };\n   bool includeUnderlying = false;\n   for (auto import : sortedImports) {\n     if (auto *swiftModule = import.dyn_cast<ModuleDecl *>()) {\n@@ -345,43 +327,17 @@ static void writeImports(raw_ostream &out,\n         includeUnderlying = true;\n         continue;\n       }\n-      if (seenImports.insert(Name).second) {\n+      if (seenImports.insert(Name).second)\n         out << \"@import \" << Name.str() << \";\\n\";\n-        if (auto *clangM = swiftModule->findUnderlyingClangModule()) {\n-          if (auto umbrella = clangM->getUmbrellaHeader()) {\n-            // If an umbrella header is available, use that.\n-            insertHeaderPath(umbrella, clangM);\n-          } else {\n-            // Collect all headers included in the module.\n-            for (auto headers: clangM->Headers) {\n-              for (auto header: headers) {\n-                insertHeaderPath(header, clangM);\n-              }\n-            }\n-          }\n-        }\n-      }\n     } else {\n       const auto *clangModule = import.get<const clang::Module *>();\n       assert(clangModule->isSubModule() &&\n              \"top-level modules should use a normal swift::ModuleDecl\");\n       out << \"@import \";\n       ModuleDecl::ReverseFullNameIterator(clangModule).printForward(out);\n       out << \";\\n\";\n-      // Collect all headers included in the submodule\n-      for (auto headers: clangModule->Headers) {\n-         for (auto header: headers) {\n-           insertHeaderPath(header, clangModule);\n-         }\n-       }\n     }\n   }\n-  out << \"#else\\n\";\n-\n-  // We cannot use module import, so use header includes instead.\n-  for (auto header: headerImports) {\n-    out << \"#import <\" << header << \">\\n\";\n-  }\n \n   out << \"#endif\\n\\n\";\n "
                    },
                    {
                        "filename": "lib/RemoteAST/CMakeLists.txt",
                        "code": "@@ -15,6 +15,8 @@ add_swift_host_library(swiftRemoteAST STATIC\n   RemoteAST.cpp\n   InProcessMemoryReader.cpp\n   ${REMOTE_LIB_HEADERS})\n+target_link_libraries(swiftRemoteAST PUBLIC\n+  swiftDemangling)\n target_link_libraries(swiftRemoteAST PRIVATE\n   swiftIRGen\n   swiftSema)"
                    },
                    {
                        "filename": "lib/SIL/CMakeLists.txt",
                        "code": "@@ -1,56 +1,34 @@\n+\n+set(SIL_SOURCES)\n+\n+function(_list_transform newvar)\n+  set(sources ${ARGN})\n+  set(dir ${CMAKE_CURRENT_SOURCE_DIR})\n+  set(tmp)\n+  foreach (s ${sources})\n+    list(APPEND tmp \"${dir}/${s}\")\n+  endforeach()\n+  set(${newvar} \"${tmp}\" PARENT_SCOPE)\n+endfunction()\n+\n+macro(sil_register_sources)\n+  precondition(new_transformed_sources\n+    NEGATE\n+    MESSAGE \"Expected this to be empty since we clear after each run\")\n+  _list_transform(new_transformed_sources ${ARGN})\n+  list_union(\"${SIL_SOURCES}\" \"${new_transformed_sources}\" out)\n+  set(SIL_SOURCES \"${out}\" PARENT_SCOPE)\n+  set(new_transformed_sources)\n+endmacro()\n+\n+add_subdirectory(IR)\n+add_subdirectory(Utils)\n+add_subdirectory(Verifier)\n+\n add_swift_host_library(swiftSIL STATIC\n-  AbstractionPattern.cpp\n-  BasicBlockUtils.cpp\n-  Bridging.cpp\n-  DebugUtils.cpp\n-  Dominance.cpp\n-  DynamicCasts.cpp\n-  InstructionUtils.cpp\n-  MemAccessUtils.cpp\n-  Linker.cpp\n-  LinearLifetimeChecker.cpp\n-  LoopInfo.cpp\n-  MemoryLifetime.cpp\n-  Notifications.cpp\n-  OperandOwnership.cpp\n-  OptimizationRemark.cpp\n-  OwnershipUtils.cpp\n-  PrettyStackTrace.cpp\n-  Projection.cpp\n-  SIL.cpp\n-  SILArgument.cpp\n-  SILBasicBlock.cpp\n-  SILBuilder.cpp\n-  SILConstants.cpp\n-  SILCoverageMap.cpp\n-  SILDebugScope.cpp\n-  SILDeclRef.cpp\n-  SILDefaultWitnessTable.cpp\n-  SILDifferentiabilityWitness.cpp\n-  SILFunction.cpp\n-  SILFunctionType.cpp\n-  SILGlobalVariable.cpp\n-  SILInstruction.cpp\n-  SILInstructions.cpp\n-  SILInstructionWorklist.cpp\n-  SILLocation.cpp\n-  SILModule.cpp\n-  SILFunctionBuilder.cpp\n-  SILOpenedArchetypesTracker.cpp\n-  SILPrinter.cpp\n-  SILProfiler.cpp\n-  SILRemarkStreamer.cpp\n-  SILSuccessor.cpp\n-  SILType.cpp\n-  SILUndef.cpp\n-  SILValue.cpp\n-  SILVerifier.cpp\n-  SILOwnershipVerifier.cpp\n-  SILVTable.cpp\n-  SILWitnessTable.cpp\n-  TypeLowering.cpp\n-  ValueOwnership.cpp\n-  ValueUtils.cpp)\n+  ${SIL_SOURCES})\n+target_link_libraries(swiftSIL PUBLIC\n+  swiftDemangling)\n target_link_libraries(swiftSIL PRIVATE\n   swiftSema\n   swiftSerialization)"
                    },
                    {
                        "filename": "lib/SIL/IR/AbstractionPattern.cpp",
                        "code": "@@ -183,6 +183,8 @@ AbstractionPattern::getOptional(AbstractionPattern object) {\n   case Kind::CXXMethodType:\n   case Kind::CurriedCXXMethodType:\n   case Kind::PartialCurriedCXXMethodType:\n+  case Kind::OpaqueFunction:\n+  case Kind::OpaqueDerivativeFunction:\n     llvm_unreachable(\"cannot add optionality to non-type abstraction\");\n   case Kind::Opaque:\n     return AbstractionPattern::getOpaque();\n@@ -289,6 +291,8 @@ bool AbstractionPattern::matchesTuple(CanTupleType substType) {\n   case Kind::CXXMethodType:\n   case Kind::CurriedCXXMethodType:\n   case Kind::PartialCurriedCXXMethodType:\n+  case Kind::OpaqueFunction:\n+  case Kind::OpaqueDerivativeFunction:\n     return false;\n   case Kind::Opaque:\n     return true;\n@@ -359,6 +363,8 @@ AbstractionPattern::getTupleElementType(unsigned index) const {\n   case Kind::CXXMethodType:\n   case Kind::CurriedCXXMethodType:\n   case Kind::PartialCurriedCXXMethodType:\n+  case Kind::OpaqueFunction:\n+  case Kind::OpaqueDerivativeFunction:\n     llvm_unreachable(\"function types are not tuples\");\n   case Kind::Opaque:\n     return *this;\n@@ -486,6 +492,12 @@ AbstractionPattern AbstractionPattern::getFunctionResultType() const {\n     return AbstractionPattern(getGenericSignatureForFunctionComponent(),\n                               getResultType(getType()),\n                               getObjCMethod()->getReturnType().getTypePtr());\n+  case Kind::OpaqueFunction:\n+    return getOpaque();\n+  case Kind::OpaqueDerivativeFunction:\n+    static SmallVector<AbstractionPattern, 2> elements{getOpaque(),\n+                                                       getOpaqueFunction()};\n+    return getTuple(elements);\n   }\n   llvm_unreachable(\"bad kind\");\n }\n@@ -615,6 +627,10 @@ AbstractionPattern::getFunctionParamType(unsigned index) const {\n                               params[index].getParameterType(),\n                           getClangFunctionParameterType(getClangType(), index));\n   }\n+  case Kind::OpaqueFunction:\n+    return getOpaque();\n+  case Kind::OpaqueDerivativeFunction:\n+    return getOpaque();\n   default:\n     llvm_unreachable(\"does not have function parameters\");\n   }\n@@ -644,6 +660,8 @@ AbstractionPattern AbstractionPattern::getOptionalObjectType() const {\n   case Kind::CurriedCXXMethodType:\n   case Kind::PartialCurriedCXXMethodType:\n   case Kind::Tuple:\n+  case Kind::OpaqueFunction:\n+  case Kind::OpaqueDerivativeFunction:\n     llvm_unreachable(\"pattern for function or tuple cannot be for optional\");\n \n   case Kind::Opaque:\n@@ -685,6 +703,8 @@ AbstractionPattern AbstractionPattern::getReferenceStorageReferentType() const {\n   case Kind::CurriedCXXMethodType:\n   case Kind::PartialCurriedCXXMethodType:\n   case Kind::Tuple:\n+  case Kind::OpaqueFunction:\n+  case Kind::OpaqueDerivativeFunction:\n     return *this;\n   case Kind::Type:\n     return AbstractionPattern(getGenericSignature(),\n@@ -714,6 +734,12 @@ void AbstractionPattern::print(raw_ostream &out) const {\n   case Kind::Opaque:\n     out << \"AP::Opaque\";\n     return;\n+  case Kind::OpaqueFunction:\n+    out << \"AP::OpaqueFunction\";\n+    return;\n+  case Kind::OpaqueDerivativeFunction:\n+    out << \"AP::OpaqueDerivativeFunction\";\n+    return;\n   case Kind::Type:\n   case Kind::Discard:\n     out << (getKind() == Kind::Type\n@@ -877,6 +903,12 @@ const {\n   case Kind::Tuple:\n     llvm_unreachable(\"should not have a tuple pattern matching a struct/enum \"\n                      \"type\");\n+  case Kind::OpaqueFunction:\n+    llvm_unreachable(\"should not have an opaque function pattern matching a \"\n+                     \"struct/enum type\");\n+  case Kind::OpaqueDerivativeFunction:\n+    llvm_unreachable(\"should not have an opaque derivative function pattern \"\n+                     \"matching a struct/enum type\");\n   case Kind::PartialCurriedObjCMethodType:\n   case Kind::CurriedObjCMethodType:\n   case Kind::PartialCurriedCFunctionAsMethodType:\n@@ -896,3 +928,27 @@ const {\n     return AbstractionPattern(getGenericSignature(), memberTy);\n   }\n }\n+\n+AbstractionPattern AbstractionPattern::getAutoDiffDerivativeFunctionType(\n+    IndexSubset *parameterIndices, AutoDiffDerivativeFunctionKind kind,\n+    LookupConformanceFn lookupConformance,\n+    GenericSignature derivativeGenericSignature, bool makeSelfParamFirst) {\n+  switch (getKind()) {\n+  case Kind::Type: {\n+    auto fnTy = dyn_cast<AnyFunctionType>(getType());\n+    if (!fnTy)\n+      return getOpaqueDerivativeFunction();\n+    auto derivativeFnTy = fnTy->getAutoDiffDerivativeFunctionType(\n+        parameterIndices, kind, lookupConformance, derivativeGenericSignature,\n+        makeSelfParamFirst);\n+    assert(derivativeFnTy);\n+    return AbstractionPattern(\n+        getGenericSignature(),\n+        derivativeFnTy->getCanonicalType(getGenericSignature()));\n+  }\n+  case Kind::Opaque:\n+    return getOpaqueDerivativeFunction();\n+  default:\n+    llvm_unreachable(\"called on unsupported abstraction pattern kind\");\n+  }\n+}"
                    },
                    {
                        "filename": "lib/SIL/IR/CMakeLists.txt",
                        "code": "@@ -0,0 +1,35 @@\n+sil_register_sources(\n+  AbstractionPattern.cpp\n+  Bridging.cpp\n+  Linker.cpp\n+  Notifications.cpp\n+  OperandOwnership.cpp\n+  SIL.cpp\n+  SILArgument.cpp\n+  SILBasicBlock.cpp\n+  SILBuilder.cpp\n+  SILConstants.cpp\n+  SILCoverageMap.cpp\n+  SILDebugScope.cpp\n+  SILDeclRef.cpp\n+  SILDefaultWitnessTable.cpp\n+  SILDifferentiabilityWitness.cpp\n+  SILFunction.cpp\n+  SILFunctionBuilder.cpp\n+  SILFunctionType.cpp\n+  SILGlobalVariable.cpp\n+  SILInstruction.cpp\n+  SILInstructions.cpp\n+  SILLocation.cpp\n+  SILModule.cpp\n+  SILPrinter.cpp\n+  SILProfiler.cpp\n+  SILSuccessor.cpp\n+  SILType.cpp\n+  SILUndef.cpp\n+  SILVTable.cpp\n+  SILValue.cpp\n+  SILWitnessTable.cpp\n+  TypeLowering.cpp\n+  ValueOwnership.cpp\n+)"
                    },
                    {
                        "filename": "lib/SIL/IR/OperandOwnership.cpp",
                        "code": "@@ -11,15 +11,13 @@\n //===----------------------------------------------------------------------===//\n \n #include \"swift/SIL/ApplySite.h\"\n-#include \"swift/SIL/LinearLifetimeChecker.h\"\n #include \"swift/SIL/OwnershipUtils.h\"\n #include \"swift/SIL/SILBuiltinVisitor.h\"\n #include \"swift/SIL/SILInstruction.h\"\n #include \"swift/SIL/SILValue.h\"\n #include \"swift/SIL/SILVisitor.h\"\n \n using namespace swift;\n-using namespace swift::ownership;\n \n //===----------------------------------------------------------------------===//\n //                      OperandOwnershipKindClassifier\n@@ -37,7 +35,6 @@ class OperandOwnershipKindClassifier\n   LLVM_ATTRIBUTE_UNUSED SILModule &mod;\n \n   const Operand &op;\n-  ErrorBehaviorKind errorBehavior;\n   bool checkingSubObject;\n \n public:\n@@ -48,10 +45,10 @@ class OperandOwnershipKindClassifier\n   /// should be the subobject and Value should be the parent object. An example\n   /// of where one would want to do this is in the case of value projections\n   /// like struct_extract.\n-  OperandOwnershipKindClassifier(SILModule &mod, const Operand &op,\n-                                 ErrorBehaviorKind errorBehavior,\n-                                 bool checkingSubObject)\n-      : mod(mod), op(op), errorBehavior(errorBehavior),\n+  OperandOwnershipKindClassifier(\n+      SILModule &mod, const Operand &op,\n+      bool checkingSubObject)\n+      : mod(mod), op(op),\n         checkingSubObject(checkingSubObject) {}\n \n   bool isCheckingSubObject() const { return checkingSubObject; }\n@@ -348,6 +345,8 @@ FORWARD_ANY_OWNERSHIP_INST(UncheckedEnumData)\n FORWARD_ANY_OWNERSHIP_INST(DestructureStruct)\n FORWARD_ANY_OWNERSHIP_INST(DestructureTuple)\n FORWARD_ANY_OWNERSHIP_INST(InitExistentialRef)\n+FORWARD_ANY_OWNERSHIP_INST(DifferentiableFunction)\n+FORWARD_ANY_OWNERSHIP_INST(LinearFunction)\n #undef FORWARD_ANY_OWNERSHIP_INST\n \n // An instruction that forwards a constant ownership or trivial ownership.\n@@ -366,6 +365,10 @@ FORWARD_ANY_OWNERSHIP_INST(InitExistentialRef)\n   }\n FORWARD_CONSTANT_OR_NONE_OWNERSHIP_INST(Guaranteed, MustBeLive, TupleExtract)\n FORWARD_CONSTANT_OR_NONE_OWNERSHIP_INST(Guaranteed, MustBeLive, StructExtract)\n+FORWARD_CONSTANT_OR_NONE_OWNERSHIP_INST(Guaranteed, MustBeLive,\n+                                        DifferentiableFunctionExtract)\n+FORWARD_CONSTANT_OR_NONE_OWNERSHIP_INST(Guaranteed, MustBeLive,\n+                                        LinearFunctionExtract)\n FORWARD_CONSTANT_OR_NONE_OWNERSHIP_INST(Owned, MustBeInvalidated,\n                                         MarkUninitialized)\n #undef CONSTANT_OR_NONE_OWNERSHIP_INST\n@@ -1042,8 +1045,8 @@ OperandOwnershipKindClassifier::visitBuiltinInst(BuiltinInst *bi) {\n \n OperandOwnershipKindMap\n Operand::getOwnershipKindMap(bool isForwardingSubValue) const {\n-  OperandOwnershipKindClassifier classifier(getUser()->getModule(), *this,\n-                                            ErrorBehaviorKind::ReturnFalse,\n-                                            isForwardingSubValue);\n+  OperandOwnershipKindClassifier classifier(\n+      getUser()->getModule(), *this,\n+      isForwardingSubValue);\n   return classifier.visit(const_cast<SILInstruction *>(getUser()));\n }"
                    },
                    {
                        "filename": "lib/SIL/IR/SILDebugScope.cpp",
                        "code": "@@ -55,3 +55,10 @@ SILFunction *SILDebugScope::getParentFunction() const {\n     return ParentScope->getParentFunction();\n   return Parent.get<SILFunction *>();\n }\n+\n+/// Determine whether an instruction may not have a SILDebugScope.\n+bool swift::maybeScopeless(SILInstruction &I) {\n+  if (I.getFunction()->isBare())\n+    return true;\n+  return !isa<DebugValueInst>(I) && !isa<DebugValueAddrInst>(I);\n+}"
                    },
                    {
                        "filename": "lib/SIL/IR/SILDeclRef.cpp",
                        "code": "@@ -113,17 +113,13 @@ bool swift::requiresForeignEntryPoint(ValueDecl *vd) {\n   return false;\n }\n \n-SILDeclRef::SILDeclRef(ValueDecl *vd, SILDeclRef::Kind kind,\n-                       bool isCurried, bool isForeign)\n-  : loc(vd), kind(kind),\n-    isCurried(isCurried), isForeign(isForeign),\n-    isDirectReference(0), defaultArgIndex(0)\n-{}\n-\n-SILDeclRef::SILDeclRef(SILDeclRef::Loc baseLoc,\n-                       bool isCurried, bool asForeign) \n-  : isCurried(isCurried), isDirectReference(0), defaultArgIndex(0)\n-{\n+SILDeclRef::SILDeclRef(ValueDecl *vd, SILDeclRef::Kind kind, bool isForeign,\n+                       AutoDiffDerivativeFunctionIdentifier *derivativeId)\n+    : loc(vd), kind(kind), isForeign(isForeign), defaultArgIndex(0),\n+      derivativeFunctionIdentifier(derivativeId) {}\n+\n+SILDeclRef::SILDeclRef(SILDeclRef::Loc baseLoc, bool asForeign)\n+    : defaultArgIndex(0), derivativeFunctionIdentifier(nullptr) {\n   if (auto *vd = baseLoc.dyn_cast<ValueDecl*>()) {\n     if (auto *fd = dyn_cast<FuncDecl>(vd)) {\n       // Map FuncDecls directly to Func SILDeclRefs.\n@@ -174,7 +170,7 @@ Optional<AnyFunctionRef> SILDeclRef::getAnyFunctionRef() const {\n }\n \n bool SILDeclRef::isThunk() const {\n-  return isCurried || isForeignToNativeThunk() || isNativeToForeignThunk();\n+  return isForeignToNativeThunk() || isNativeToForeignThunk();\n }\n \n bool SILDeclRef::isClangImported() const {\n@@ -247,22 +243,6 @@ SILLinkage SILDeclRef::getLinkage(ForDefinition_t forDefinition) const {\n     moduleContext = moduleContext->getParent();\n   }\n \n-  // Enum constructors and curry thunks either have private or shared\n-  // linkage, dependings are essentially the same as thunks, they are\n-  // emitted by need and have shared linkage.\n-  if (isEnumElement() || isCurried) {\n-    switch (d->getEffectiveAccess()) {\n-    case AccessLevel::Private:\n-    case AccessLevel::FilePrivate:\n-      return maybeAddExternal(SILLinkage::Private);\n-\n-    case AccessLevel::Internal:\n-    case AccessLevel::Public:\n-    case AccessLevel::Open:\n-      return SILLinkage::Shared;\n-    }\n-  }\n-\n   // Calling convention thunks have shared linkage.\n   if (isForeignToNativeThunk())\n     return SILLinkage::Shared;\n@@ -313,15 +293,8 @@ SILLinkage SILDeclRef::getLinkage(ForDefinition_t forDefinition) const {\n     limit = Limit::NeverPublic;\n   }\n \n-  // The property wrapper backing initializer is never public for resilient\n-  // properties.\n-  if (kind == SILDeclRef::Kind::PropertyWrapperBackingInitializer) {\n-    if (cast<VarDecl>(d)->isResilient())\n-      limit = Limit::NeverPublic;\n-  }\n-\n   // Stored property initializers get the linkage of their containing type.\n-  if (isStoredPropertyInitializer()) {\n+  if (isStoredPropertyInitializer() || isPropertyWrapperBackingInitializer()) {\n     // Three cases:\n     //\n     // 1) Type is formally @_fixed_layout/@frozen. Root initializers can be\n@@ -361,7 +334,7 @@ SILLinkage SILDeclRef::getLinkage(ForDefinition_t forDefinition) const {\n       limit = Limit::OnDemand;\n     }\n   }\n-  \n+\n   auto effectiveAccess = d->getEffectiveAccess();\n   \n   // Private setter implementations for an internal storage declaration should\n@@ -503,7 +476,7 @@ IsSerialized_t SILDeclRef::isSerialized() const {\n \n   // Stored property initializers are inlinable if the type is explicitly\n   // marked as @frozen.\n-  if (isStoredPropertyInitializer()) {\n+  if (isStoredPropertyInitializer() || isPropertyWrapperBackingInitializer()) {\n     auto *nominal = cast<NominalTypeDecl>(d->getDeclContext());\n     auto scope =\n       nominal->getFormalAccessScope(/*useDC=*/nullptr,\n@@ -539,18 +512,6 @@ IsSerialized_t SILDeclRef::isSerialized() const {\n         fn->hasForcedStaticDispatch())\n       return IsSerialized;\n \n-  // Enum element constructors are serializable if the enum is\n-  // @usableFromInline or public.\n-  if (isEnumElement())\n-    return IsSerializable;\n-\n-  // Currying thunks are serialized if referenced from an inlinable\n-  // context -- Sema's semantic checks ensure the serialization of\n-  // such a thunk is valid, since it must in turn reference a public\n-  // symbol, or dispatch via class_method or witness_method.\n-  if (isCurried)\n-    return IsSerializable;\n-\n   if (isForeignToNativeThunk())\n     return IsSerializable;\n \n@@ -684,11 +645,25 @@ std::string SILDeclRef::mangle(ManglingKind MKind) const {\n   using namespace Mangle;\n   ASTMangler mangler;\n \n+  if (derivativeFunctionIdentifier) {\n+    std::string originalMangled = asAutoDiffOriginalFunction().mangle(MKind);\n+    auto *silParameterIndices = autodiff::getLoweredParameterIndices(\n+        derivativeFunctionIdentifier->getParameterIndices(),\n+        getDecl()->getInterfaceType()->castTo<AnyFunctionType>());\n+    auto &ctx = getDecl()->getASTContext();\n+    auto *resultIndices = IndexSubset::get(ctx, 1, {0});\n+    AutoDiffConfig silConfig(\n+        silParameterIndices, resultIndices,\n+        derivativeFunctionIdentifier->getDerivativeGenericSignature());\n+    auto derivativeFnKind = derivativeFunctionIdentifier->getKind();\n+    return mangler.mangleAutoDiffDerivativeFunctionHelper(\n+        originalMangled, derivativeFnKind, silConfig);\n+  }\n+\n   // As a special case, Clang functions and globals don't get mangled at all.\n   if (hasDecl()) {\n     if (auto clangDecl = getDecl()->getClangDecl()) {\n-      if (!isForeignToNativeThunk() && !isNativeToForeignThunk()\n-          && !isCurried) {\n+      if (!isForeignToNativeThunk() && !isNativeToForeignThunk()) {\n         if (auto namedClangDecl = dyn_cast<clang::DeclaratorDecl>(clangDecl)) {\n           if (auto asmLabel = namedClangDecl->getAttr<clang::AsmLabelAttr>()) {\n             std::string s(1, '\\01');\n@@ -712,8 +687,6 @@ std::string SILDeclRef::mangle(ManglingKind MKind) const {\n     case SILDeclRef::ManglingKind::Default:\n       if (isForeign) {\n         SKind = ASTMangler::SymbolKind::SwiftAsObjCThunk;\n-      } else if (isDirectReference) {\n-        SKind = ASTMangler::SymbolKind::DirectMethodReferenceThunk;\n       } else if (isForeignToNativeThunk()) {\n         SKind = ASTMangler::SymbolKind::ObjCAsSwiftThunk;\n       }\n@@ -733,8 +706,7 @@ std::string SILDeclRef::mangle(ManglingKind MKind) const {\n     // point.\n     if (auto NameA = getDecl()->getAttrs().getAttribute<SILGenNameAttr>())\n       if (!NameA->Name.empty() &&\n-          !isForeignToNativeThunk() && !isNativeToForeignThunk()\n-          && !isCurried) {\n+          !isForeignToNativeThunk() && !isNativeToForeignThunk()) {\n         return NameA->Name.str();\n       }\n       \n@@ -748,67 +720,92 @@ std::string SILDeclRef::mangle(ManglingKind MKind) const {\n     LLVM_FALLTHROUGH;\n \n   case SILDeclRef::Kind::EnumElement:\n-    return mangler.mangleEntity(getDecl(), isCurried, SKind);\n+    return mangler.mangleEntity(getDecl(), SKind);\n \n   case SILDeclRef::Kind::Deallocator:\n-    assert(!isCurried);\n     return mangler.mangleDestructorEntity(cast<DestructorDecl>(getDecl()),\n                                           /*isDeallocating*/ true,\n                                           SKind);\n \n   case SILDeclRef::Kind::Destroyer:\n-    assert(!isCurried);\n     return mangler.mangleDestructorEntity(cast<DestructorDecl>(getDecl()),\n                                           /*isDeallocating*/ false,\n                                           SKind);\n \n   case SILDeclRef::Kind::Allocator:\n     return mangler.mangleConstructorEntity(cast<ConstructorDecl>(getDecl()),\n                                            /*allocating*/ true,\n-                                           isCurried,\n                                            SKind);\n \n   case SILDeclRef::Kind::Initializer:\n     return mangler.mangleConstructorEntity(cast<ConstructorDecl>(getDecl()),\n                                            /*allocating*/ false,\n-                                           isCurried,\n                                            SKind);\n \n   case SILDeclRef::Kind::IVarInitializer:\n   case SILDeclRef::Kind::IVarDestroyer:\n-    assert(!isCurried);\n     return mangler.mangleIVarInitDestroyEntity(cast<ClassDecl>(getDecl()),\n                                   kind == SILDeclRef::Kind::IVarDestroyer,\n                                   SKind);\n \n   case SILDeclRef::Kind::GlobalAccessor:\n-    assert(!isCurried);\n     return mangler.mangleAccessorEntity(AccessorKind::MutableAddress,\n                                         cast<AbstractStorageDecl>(getDecl()),\n                                         /*isStatic*/ false,\n                                         SKind);\n \n   case SILDeclRef::Kind::DefaultArgGenerator:\n-    assert(!isCurried);\n     return mangler.mangleDefaultArgumentEntity(\n                                         cast<DeclContext>(getDecl()),\n                                         defaultArgIndex,\n                                         SKind);\n \n   case SILDeclRef::Kind::StoredPropertyInitializer:\n-    assert(!isCurried);\n     return mangler.mangleInitializerEntity(cast<VarDecl>(getDecl()), SKind);\n \n   case SILDeclRef::Kind::PropertyWrapperBackingInitializer:\n-    assert(!isCurried);\n     return mangler.mangleBackingInitializerEntity(cast<VarDecl>(getDecl()),\n                                                   SKind);\n   }\n \n   llvm_unreachable(\"bad entity kind!\");\n }\n \n+// Returns true if the given JVP/VJP SILDeclRef requires a new vtable entry.\n+// FIXME(TF-1213): Also consider derived declaration `@derivative` attributes.\n+static bool derivativeFunctionRequiresNewVTableEntry(SILDeclRef declRef) {\n+  assert(declRef.derivativeFunctionIdentifier &&\n+         \"Expected a derivative function SILDeclRef\");\n+  auto overridden = declRef.getOverridden();\n+  if (!overridden)\n+    return false;\n+  // Get the derived `@differentiable` attribute.\n+  auto *derivedDiffAttr = *llvm::find_if(\n+      declRef.getDecl()->getAttrs().getAttributes<DifferentiableAttr>(),\n+      [&](const DifferentiableAttr *derivedDiffAttr) {\n+        return derivedDiffAttr->getParameterIndices() ==\n+               declRef.derivativeFunctionIdentifier->getParameterIndices();\n+      });\n+  assert(derivedDiffAttr && \"Expected `@differentiable` attribute\");\n+  // Otherwise, if the base `@differentiable` attribute specifies a derivative\n+  // function, then the derivative is inherited and no new vtable entry is\n+  // needed. Return false.\n+  auto baseDiffAttrs =\n+      overridden.getDecl()->getAttrs().getAttributes<DifferentiableAttr>();\n+  for (auto *baseDiffAttr : baseDiffAttrs) {\n+    if (baseDiffAttr->getParameterIndices() ==\n+        declRef.derivativeFunctionIdentifier->getParameterIndices())\n+      return false;\n+  }\n+  // Otherwise, if there is no base `@differentiable` attribute exists, then a\n+  // new vtable entry is needed. Return true.\n+  return true;\n+}\n+\n bool SILDeclRef::requiresNewVTableEntry() const {\n+  if (derivativeFunctionIdentifier)\n+    if (derivativeFunctionRequiresNewVTableEntry(*this))\n+      return true;\n   if (cast<AbstractFunctionDecl>(getDecl())->needsNewVTableEntry())\n     return true;\n   return false;\n@@ -828,8 +825,7 @@ SILDeclRef SILDeclRef::getOverridden() const {\n   auto overridden = getDecl()->getOverriddenDecl();\n   if (!overridden)\n     return SILDeclRef();\n-\n-  return SILDeclRef(overridden, kind, isCurried);\n+  return withDecl(overridden);\n }\n \n SILDeclRef SILDeclRef::getNextOverriddenVTableEntry() const {\n@@ -881,6 +877,26 @@ SILDeclRef SILDeclRef::getNextOverriddenVTableEntry() const {\n     if (isa<ExtensionDecl>(overridden.getDecl()->getDeclContext()))\n       return SILDeclRef();\n \n+    // JVPs/VJPs are overridden only if the base declaration has a\n+    // `@differentiable` attribute with the same parameter indices.\n+    if (derivativeFunctionIdentifier) {\n+      auto overriddenAttrs =\n+          overridden.getDecl()->getAttrs().getAttributes<DifferentiableAttr>();\n+      for (const auto *attr : overriddenAttrs) {\n+        if (attr->getParameterIndices() !=\n+            derivativeFunctionIdentifier->getParameterIndices())\n+          continue;\n+        auto *overriddenDerivativeId = overridden.derivativeFunctionIdentifier;\n+        overridden.derivativeFunctionIdentifier =\n+            AutoDiffDerivativeFunctionIdentifier::get(\n+                overriddenDerivativeId->getKind(),\n+                overriddenDerivativeId->getParameterIndices(),\n+                attr->getDerivativeGenericSignature(),\n+                getDecl()->getASTContext());\n+        return overridden;\n+      }\n+      return SILDeclRef();\n+    }\n     return overridden;\n   }\n   return SILDeclRef();\n@@ -889,7 +905,7 @@ SILDeclRef SILDeclRef::getNextOverriddenVTableEntry() const {\n SILDeclRef SILDeclRef::getOverriddenWitnessTableEntry() const {\n   auto bestOverridden =\n     getOverriddenWitnessTableEntry(cast<AbstractFunctionDecl>(getDecl()));\n-  return SILDeclRef(bestOverridden, kind, isCurried);\n+  return withDecl(bestOverridden);\n }\n \n AbstractFunctionDecl *SILDeclRef::getOverriddenWitnessTableEntry(\n@@ -1056,7 +1072,7 @@ SubclassScope SILDeclRef::getSubclassScope() const {\n }\n \n unsigned SILDeclRef::getParameterListCount() const {\n-  if (isCurried || !hasDecl() || kind == Kind::DefaultArgGenerator)\n+  if (!hasDecl() || kind == Kind::DefaultArgGenerator)\n     return 1;\n \n   auto *vd = getDecl();\n@@ -1095,8 +1111,7 @@ bool SILDeclRef::canBeDynamicReplacement() const {\n bool SILDeclRef::isDynamicallyReplaceable() const {\n   if (kind == SILDeclRef::Kind::DefaultArgGenerator)\n     return false;\n-  if (isStoredPropertyInitializer() ||\n-      kind == SILDeclRef::Kind::PropertyWrapperBackingInitializer)\n+  if (isStoredPropertyInitializer() || isPropertyWrapperBackingInitializer())\n     return false;\n \n   // Class allocators are not dynamic replaceable."
                    },
                    {
                        "filename": "lib/SIL/IR/SILFunctionBuilder.cpp",
                        "code": "@@ -66,6 +66,25 @@ void SILFunctionBuilder::addFunctionAttributes(\n   if (Attrs.hasAttribute<SILGenNameAttr>() || Attrs.hasAttribute<CDeclAttr>())\n     F->setHasCReferences(true);\n \n+  // Validate `@differentiable` attributes by calling `getParameterIndices`.\n+  // This is important for:\n+  // - Skipping invalid `@differentiable` attributes in non-primary files.\n+  // - Preventing duplicate SIL differentiability witness creation for\n+  //   `@differentiable` attributes on `AbstractStorageDecl` declarations.\n+  //   Such `@differentiable` attributes are deleted and recreated on the getter\n+  //   `AccessorDecl` of the `AbstractStorageDecl`.\n+  for (auto *A : Attrs.getAttributes<DifferentiableAttr>())\n+    (void)A->getParameterIndices();\n+\n+  // Propagate `@noDerivative` as `[_semantics \"autodiff.nonvarying\"]`.\n+  //\n+  // `@noDerivative` implies non-varying semantics for differentiable activity\n+  // analysis. SIL values produced from references to `@noDerivative`\n+  // declarations will not be marked as varying; these values do not need a\n+  // derivative.\n+  if (Attrs.hasAttribute<NoDerivativeAttr>())\n+    F->addSemanticsAttr(\"autodiff.nonvarying\");\n+\n   // Propagate @_dynamicReplacement(for:).\n   if (constant.isNull())\n     return;"
                    }
                ]
            },
            {
                "date": "2019-11-17T03:04:31Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/465bab002fa6e836bc438ab3504e3405720e5a9d",
                "changes": [
                    {
                        "filename": "include/swift/Frontend/DiagnosticVerifier.h",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -18,30 +18,87 @@\n #ifndef SWIFT_FRONTEND_DIAGNOSTIC_VERIFIER_H\n #define SWIFT_FRONTEND_DIAGNOSTIC_VERIFIER_H\n \n+#include \"swift/AST/DiagnosticConsumer.h\"\n #include \"swift/Basic/LLVM.h\"\n \n namespace swift {\n-  class DependencyTracker;\n-  class FileUnit;\n-  class SourceManager;\n-  class SourceFile;\n-\n-  /// Set up the specified source manager so that diagnostics are captured\n-  /// instead of being printed.\n-  void enableDiagnosticVerifier(SourceManager &SM);\n-\n-  /// Verify that captured diagnostics meet with the expectations of the source\n-  /// files corresponding to the specified \\p BufferIDs and tear down our\n-  /// support for capturing and verifying diagnostics.\n-  ///\n-  /// This returns true if there are any mismatches found.\n-  bool verifyDiagnostics(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n-                         bool autoApplyFixes, bool ignoreUnknown);\n-\n-  bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n-                          ArrayRef<FileUnit *> SFs);\n-  bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n-                          ArrayRef<SourceFile *> SFs);\n+class DependencyTracker;\n+class FileUnit;\n+class SourceManager;\n+class SourceFile;\n+\n+// MARK: - DependencyVerifier\n+bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n+                        ArrayRef<FileUnit *> SFs);\n+bool verifyDependencies(SourceManager &SM, const DependencyTracker &DT,\n+                        ArrayRef<SourceFile *> SFs);\n+\n+// MARK: - DiagnosticVerifier\n+struct ExpectedFixIt;\n+\n+struct CapturedDiagnosticInfo {\n+  llvm::SmallString<128> Message;\n+  llvm::SmallString<32> FileName;\n+  DiagnosticKind Classification;\n+  SourceLoc Loc;\n+  unsigned Line;\n+  unsigned Column;\n+  SmallVector<DiagnosticInfo::FixIt, 2> FixIts;\n+\n+  CapturedDiagnosticInfo(llvm::SmallString<128> Message,\n+                         llvm::SmallString<32> FileName,\n+                         DiagnosticKind Classification, SourceLoc Loc,\n+                         unsigned Line, unsigned Column,\n+                         SmallVector<DiagnosticInfo::FixIt, 2> FixIts)\n+      : Message(Message), FileName(FileName), Classification(Classification),\n+        Loc(Loc), Line(Line), Column(Column), FixIts(FixIts) {}\n+};\n+/// This class implements support for -verify mode in the compiler.  It\n+/// buffers up diagnostics produced during compilation, then checks them\n+/// against expected-error markers in the source file.\n+class DiagnosticVerifier : public DiagnosticConsumer {\n+  SourceManager &SM;\n+  std::vector<CapturedDiagnosticInfo> CapturedDiagnostics;\n+  ArrayRef<unsigned> BufferIDs;\n+  bool AutoApplyFixes;\n+  bool IgnoreUnknown;\n+\n+public:\n+  explicit DiagnosticVerifier(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n+                              bool AutoApplyFixes, bool IgnoreUnknown)\n+      : SM(SM), BufferIDs(BufferIDs), AutoApplyFixes(AutoApplyFixes),\n+        IgnoreUnknown(IgnoreUnknown) {}\n+\n+  virtual void handleDiagnostic(SourceManager &SM,\n+                                const DiagnosticInfo &Info) override;\n+\n+  virtual bool finishProcessing() override;\n+\n+private:\n+  /// Result of verifying a file.\n+  struct Result {\n+    /// Were there any errors? All of the following are considered errors:\n+    /// - Expected diagnostics that were not present\n+    /// - Unexpected diagnostics that were present\n+    /// - Errors in the definition of expected diagnostics\n+    bool HadError;\n+    bool HadUnexpectedDiag;\n+  };\n+\n+  /// verifyFile - After the file has been processed, check to see if we\n+  /// got all of the expected diagnostics and check to see if there were any\n+  /// unexpected ones.\n+  Result verifyFile(unsigned BufferID);\n+\n+  bool checkForFixIt(const ExpectedFixIt &Expected,\n+                     const CapturedDiagnosticInfo &D, StringRef buffer);\n+\n+  // Render the verifier syntax for a given set of fix-its.\n+  std::string renderFixits(ArrayRef<DiagnosticInfo::FixIt> fixits,\n+                           StringRef InputFile);\n+\n+  void printRemainingDiagnostics() const;\n+};\n }\n \n #endif"
                    },
                    {
                        "filename": "include/swift/Frontend/Frontend.h",
                        "code": "@@ -31,6 +31,7 @@\n #include \"swift/Basic/SourceManager.h\"\n #include \"swift/ClangImporter/ClangImporter.h\"\n #include \"swift/ClangImporter/ClangImporterOptions.h\"\n+#include \"swift/Frontend/DiagnosticVerifier.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n #include \"swift/Frontend/ModuleInterfaceSupport.h\"\n #include \"swift/Migrator/MigratorOptions.h\"\n@@ -405,6 +406,7 @@ class CompilerInstance {\n   std::unique_ptr<ASTContext> Context;\n   std::unique_ptr<Lowering::TypeConverter> TheSILTypes;\n   std::unique_ptr<SILModule> TheSILModule;\n+  std::unique_ptr<DiagnosticVerifier> DiagVerifier;\n \n   /// Null if no tracker.\n   std::unique_ptr<DependencyTracker> DepTracker;\n@@ -585,6 +587,7 @@ class CompilerInstance {\n   bool setUpInputs();\n   bool setUpASTContextIfNeeded();\n   void setupStatsReporter();\n+  void setupDiagnosticVerifierIfNeeded();\n   Optional<unsigned> setUpCodeCompletionBuffer();\n \n   /// Set up all state in the CompilerInstance to process the given input file."
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -40,6 +40,7 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   // Educational notes which are buffered until the consumer is finished\n   // constructing a snippet.\n   SmallVector<std::string, 1> BufferedEducationalNotes;\n+  bool SuppressOutput = false;\n \n public:\n   PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs());\n@@ -65,6 +66,10 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n     return DidErrorOccur;\n   }\n \n+  void setSuppressOutput(bool suppressOutput) {\n+    SuppressOutput = suppressOutput;\n+  }\n+\n private:\n   void printDiagnostic(SourceManager &SM, const DiagnosticInfo &Info);\n };"
                    },
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -24,132 +24,79 @@\n \n using namespace swift;\n \n+namespace swift {\n+struct ExpectedFixIt {\n+  const char *StartLoc, *EndLoc; // The loc of the {{ and }}'s.\n+  unsigned StartCol;\n+  unsigned EndCol;\n+  std::string Text;\n+};\n+} // end namespace swift\n+\n namespace {\n-  struct ExpectedFixIt {\n-    const char *StartLoc, *EndLoc;   // The loc of the {{ and }}'s.\n-    unsigned StartCol;\n-    unsigned EndCol;\n-    std::string Text;\n-  };\n+struct ExpectedDiagnosticInfo {\n+  // This specifies the full range of the \"expected-foo {{}}\" specifier.\n+  const char *ExpectedStart, *ExpectedEnd = nullptr;\n \n-  struct ExpectedDiagnosticInfo {\n-    // This specifies the full range of the \"expected-foo {{}}\" specifier.\n-    const char *ExpectedStart, *ExpectedEnd = nullptr;\n+  DiagnosticKind Classification;\n \n-    llvm::SourceMgr::DiagKind Classification;\n-    \n-    // This is true if a '*' constraint is present to say that the diagnostic\n-    // may appear (or not) an uncounted number of times.\n-    bool mayAppear = false;\n-      \n-    // This is true if a '{{none}}' is present to mark that there should be no\n-    // extra fixits.\n-    bool noExtraFixitsMayAppear = false;\n+  // This is true if a '*' constraint is present to say that the diagnostic\n+  // may appear (or not) an uncounted number of times.\n+  bool mayAppear = false;\n \n-    // This is the raw input buffer for the message text, the part in the\n-    // {{...}}\n-    StringRef MessageRange;\n-    \n-    // This is the message string with escapes expanded.\n-    std::string MessageStr;\n-    unsigned LineNo = ~0U;\n-    Optional<unsigned> ColumnNo;\n+  // This is true if a '{{none}}' is present to mark that there should be no\n+  // extra fixits.\n+  bool noExtraFixitsMayAppear = false;\n \n-    std::vector<ExpectedFixIt> Fixits;\n+  // This is the raw input buffer for the message text, the part in the\n+  // {{...}}\n+  StringRef MessageRange;\n \n-    ExpectedDiagnosticInfo(const char *ExpectedStart,\n-                           llvm::SourceMgr::DiagKind Classification)\n-      : ExpectedStart(ExpectedStart), Classification(Classification) {\n-    }\n-    \n-  };\n-} // end anonymous namespace\n+  // This is the message string with escapes expanded.\n+  std::string MessageStr;\n+  unsigned LineNo = ~0U;\n+  Optional<unsigned> ColumnNo;\n+\n+  std::vector<ExpectedFixIt> Fixits;\n \n-static std::string getDiagKindString(llvm::SourceMgr::DiagKind Kind) {\n+  ExpectedDiagnosticInfo(const char *ExpectedStart,\n+                         DiagnosticKind Classification)\n+      : ExpectedStart(ExpectedStart), Classification(Classification) {}\n+};\n+\n+static std::string getDiagKindString(DiagnosticKind Kind) {\n   switch (Kind) {\n-  case llvm::SourceMgr::DK_Error: return \"error\";\n-  case llvm::SourceMgr::DK_Warning: return \"warning\";\n-  case llvm::SourceMgr::DK_Note: return \"note\";\n-  case llvm::SourceMgr::DK_Remark: return \"remark\";\n+  case DiagnosticKind::Error:\n+    return \"error\";\n+  case DiagnosticKind::Warning:\n+    return \"warning\";\n+  case DiagnosticKind::Note:\n+    return \"note\";\n+  case DiagnosticKind::Remark:\n+    return \"remark\";\n   }\n \n   llvm_unreachable(\"Unhandled DiagKind in switch.\");\n }\n \n-\n-\n-namespace {\n-  /// This class implements support for -verify mode in the compiler.  It\n-  /// buffers up diagnostics produced during compilation, then checks them\n-  /// against expected-error markers in the source file.\n-  class DiagnosticVerifier {\n-    SourceManager &SM;\n-    std::vector<llvm::SMDiagnostic> CapturedDiagnostics;\n-  public:\n-    explicit DiagnosticVerifier(SourceManager &SM) : SM(SM) {}\n-\n-    void addDiagnostic(const llvm::SMDiagnostic &Diag) {\n-      CapturedDiagnostics.push_back(Diag);\n-    }\n-\n-    /// Result of verifying a file.\n-    struct Result {\n-      /// Were there any errors? All of the following are considered errors:\n-      /// - Expected diagnostics that were not present\n-      /// - Unexpected diagnostics that were present\n-      /// - Errors in the definition of expected diagnostics\n-      bool HadError;\n-      bool HadUnexpectedDiag;\n-    };\n-\n-    /// verifyFile - After the file has been processed, check to see if we\n-    /// got all of the expected diagnostics and check to see if there were any\n-    /// unexpected ones.\n-    Result verifyFile(unsigned BufferID, bool autoApplyFixes);\n-\n-    /// diagnostics for '<unknown>:0' should be considered as unexpected.\n-    bool verifyUnknown();\n-\n-    void printRemainingDiagnostics() const;\n-\n-    /// If there are any -verify errors (e.g. differences between expectations\n-    /// and actual diagnostics produced), apply fixits to the original source\n-    /// file and drop it back in place.\n-    void autoApplyFixes(unsigned BufferID,\n-                        ArrayRef<llvm::SMDiagnostic> diagnostics);\n-    \n-  private:\n-    std::vector<llvm::SMDiagnostic>::iterator\n-    findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n-                   StringRef BufferName);\n-\n-  };\n-} // end anonymous namespace\n-\n-\n-\n-\n /// If we find the specified diagnostic in the list, return it.\n /// Otherwise return CapturedDiagnostics.end().\n-std::vector<llvm::SMDiagnostic>::iterator\n-DiagnosticVerifier::findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n-                                   StringRef BufferName) {\n+static std::vector<CapturedDiagnosticInfo>::iterator\n+findDiagnostic(std::vector<CapturedDiagnosticInfo> &CapturedDiagnostics,\n+               const ExpectedDiagnosticInfo &Expected, StringRef BufferName) {\n   for (auto I = CapturedDiagnostics.begin(), E = CapturedDiagnostics.end();\n        I != E; ++I) {\n     // Verify the file and line of the diagnostic.\n-    if (I->getLineNo() != (int)Expected.LineNo ||\n-        I->getFilename() != BufferName)\n+    if (I->Line != Expected.LineNo || I->FileName != BufferName)\n       continue;\n \n-    // If a specific column was expected, verify it. Add one to the captured\n-    // index so expected column numbers correspond to printed output.\n-    if (Expected.ColumnNo.hasValue() &&\n-        I->getColumnNo() + 1 != (int)*Expected.ColumnNo)\n+    // If a specific column was expected, verify it.\n+    if (Expected.ColumnNo.hasValue() && I->Column != *Expected.ColumnNo)\n       continue;\n \n     // Verify the classification and string.\n-    if (I->getKind() != Expected.Classification ||\n-        I->getMessage().find(Expected.MessageStr) == StringRef::npos)\n+    if (I->Classification != Expected.Classification ||\n+        I->Message.find(Expected.MessageStr) == StringRef::npos)\n       continue;\n \n     // Okay, we found a match, hurray!\n@@ -159,6 +106,105 @@ DiagnosticVerifier::findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n   return CapturedDiagnostics.end();\n }\n \n+/// If there are any -verify errors (e.g. differences between expectations\n+/// and actual diagnostics produced), apply fixits to the original source\n+/// file and drop it back in place.\n+static void autoApplyFixes(SourceManager &SM, unsigned BufferID,\n+                           ArrayRef<llvm::SMDiagnostic> diags) {\n+  // Walk the list of diagnostics, pulling out any fixits into an array of just\n+  // them.\n+  SmallVector<llvm::SMFixIt, 4> FixIts;\n+  for (auto &diag : diags)\n+    FixIts.append(diag.getFixIts().begin(), diag.getFixIts().end());\n+\n+  // If we have no fixits to apply, avoid touching the file.\n+  if (FixIts.empty())\n+    return;\n+\n+  // Sort the fixits by their start location.\n+  std::sort(FixIts.begin(), FixIts.end(),\n+            [&](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) -> bool {\n+              return lhs.getRange().Start.getPointer() <\n+                     rhs.getRange().Start.getPointer();\n+            });\n+  // Coalesce identical fix-its. This happens most often with \"expected-error 2\"\n+  // syntax.\n+  FixIts.erase(std::unique(FixIts.begin(), FixIts.end(),\n+                           [](const llvm::SMFixIt &lhs,\n+                              const llvm::SMFixIt &rhs) -> bool {\n+                             return lhs.getRange().Start ==\n+                                        rhs.getRange().Start &&\n+                                    lhs.getRange().End == rhs.getRange().End &&\n+                                    lhs.getText() == rhs.getText();\n+                           }),\n+               FixIts.end());\n+  // Filter out overlapping fix-its. This allows the compiler to apply changes\n+  // to the easy parts of the file, and leave in the tricky cases for the\n+  // developer to handle manually.\n+  FixIts.erase(swift::removeAdjacentIf(\n+                   FixIts.begin(), FixIts.end(),\n+                   [](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) {\n+                     return lhs.getRange().End.getPointer() >\n+                            rhs.getRange().Start.getPointer();\n+                   }),\n+               FixIts.end());\n+\n+  // Get the contents of the original source file.\n+  auto memBuffer = SM.getLLVMSourceMgr().getMemoryBuffer(BufferID);\n+  auto bufferRange = memBuffer->getBuffer();\n+\n+  // Apply the fixes, building up a new buffer as an std::string.\n+  const char *LastPos = bufferRange.begin();\n+  std::string Result;\n+\n+  for (auto &fix : FixIts) {\n+    // We cannot handle overlapping fixits, so assert that they don't happen.\n+    assert(LastPos <= fix.getRange().Start.getPointer() &&\n+           \"Cannot handle overlapping fixits\");\n+\n+    // Keep anything from the last spot we've checked to the start of the fixit.\n+    Result.append(LastPos, fix.getRange().Start.getPointer());\n+\n+    // Replace the content covered by the fixit with the replacement text.\n+    Result.append(fix.getText().begin(), fix.getText().end());\n+\n+    // Next character to consider is at the end of the fixit.\n+    LastPos = fix.getRange().End.getPointer();\n+  }\n+\n+  // Retain the end of the file.\n+  Result.append(LastPos, bufferRange.end());\n+\n+  std::error_code error;\n+  llvm::raw_fd_ostream outs(memBuffer->getBufferIdentifier(), error,\n+                            llvm::sys::fs::OpenFlags::F_None);\n+  if (!error)\n+    outs << Result;\n+}\n+\n+/// diagnostics for '<unknown>:0' should be considered as unexpected.\n+static bool\n+verifyUnknown(SourceManager &SM,\n+              std::vector<CapturedDiagnosticInfo> &CapturedDiagnostics) {\n+  bool HadError = false;\n+  for (unsigned i = 0, e = CapturedDiagnostics.size(); i != e; ++i) {\n+    if (CapturedDiagnostics[i].Loc.isValid())\n+      continue;\n+\n+    HadError = true;\n+    std::string Message =\n+        (\"unexpected \" +\n+         getDiagKindString(CapturedDiagnostics[i].Classification) +\n+         \" produced: \" + CapturedDiagnostics[i].Message)\n+            .str();\n+\n+    auto diag = SM.GetMessage({}, llvm::SourceMgr::DK_Error, Message, {}, {});\n+    SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), diag);\n+  }\n+  return HadError;\n+}\n+} // end anonymous namespace\n+\n static unsigned getColumnNumber(StringRef buffer, llvm::SMLoc loc) {\n   assert(loc.getPointer() >= buffer.data());\n   assert((size_t)(loc.getPointer() - buffer.data()) <= buffer.size());\n@@ -175,17 +221,18 @@ static unsigned getColumnNumber(StringRef buffer, llvm::SMLoc loc) {\n \n /// Return true if the given \\p ExpectedFixIt is in the fix-its emitted by\n /// diagnostic \\p D.\n-static bool checkForFixIt(const ExpectedFixIt &Expected,\n-                          const llvm::SMDiagnostic &D,\n-                          StringRef buffer) {\n-  for (auto &ActualFixIt : D.getFixIts()) {\n+bool DiagnosticVerifier::checkForFixIt(const ExpectedFixIt &Expected,\n+                                       const CapturedDiagnosticInfo &D,\n+                                       StringRef buffer) {\n+  for (auto &ActualFixIt : D.FixIts) {\n     if (ActualFixIt.getText() != Expected.Text)\n       continue;\n \n-    llvm::SMRange Range = ActualFixIt.getRange();\n-    if (getColumnNumber(buffer, Range.Start) != Expected.StartCol)\n+    CharSourceRange Range = ActualFixIt.getRange();\n+    if (getColumnNumber(buffer, getRawLoc(Range.getStart())) !=\n+        Expected.StartCol)\n       continue;\n-    if (getColumnNumber(buffer, Range.End) != Expected.EndCol)\n+    if (getColumnNumber(buffer, getRawLoc(Range.getEnd())) != Expected.EndCol)\n       continue;\n \n     return true;\n@@ -194,16 +241,20 @@ static bool checkForFixIt(const ExpectedFixIt &Expected,\n   return false;\n }\n \n-static std::string renderFixits(ArrayRef<llvm::SMFixIt> fixits,\n-                                StringRef InputFile) {\n+std::string\n+DiagnosticVerifier::renderFixits(ArrayRef<DiagnosticInfo::FixIt> fixits,\n+                                 StringRef InputFile) {\n   std::string Result;\n   llvm::raw_string_ostream OS(Result);\n   interleave(fixits,\n-             [&](const llvm::SMFixIt &ActualFixIt) {\n-               llvm::SMRange Range = ActualFixIt.getRange();\n+             [&](const DiagnosticInfo::FixIt &ActualFixIt) {\n+               CharSourceRange Range = ActualFixIt.getRange();\n \n-               OS << \"{{\" << getColumnNumber(InputFile, Range.Start) << '-'\n-                  << getColumnNumber(InputFile, Range.End) << '=';\n+               OS << \"{{\"\n+                  << getColumnNumber(InputFile, getRawLoc(Range.getStart()))\n+                  << '-'\n+                  << getColumnNumber(InputFile, getRawLoc(Range.getEnd()))\n+                  << '=';\n \n                for (auto C : ActualFixIt.getText()) {\n                  if (C == '\\n')\n@@ -222,8 +273,7 @@ static std::string renderFixits(ArrayRef<llvm::SMFixIt> fixits,\n /// After the file has been processed, check to see if we got all of\n /// the expected diagnostics and check to see if there were any unexpected\n /// ones.\n-DiagnosticVerifier::Result\n-DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n+DiagnosticVerifier::Result DiagnosticVerifier::verifyFile(unsigned BufferID) {\n   using llvm::SMLoc;\n   \n   const SourceLoc BufferStartLoc = SM.getLocForBufferStart(BufferID);\n@@ -256,18 +306,18 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n     StringRef MatchStart = InputFile.substr(Match);\n     const char *DiagnosticLoc = MatchStart.data();\n \n-    llvm::SourceMgr::DiagKind ExpectedClassification;\n+    DiagnosticKind ExpectedClassification;\n     if (MatchStart.startswith(\"expected-note\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Note;\n+      ExpectedClassification = DiagnosticKind::Note;\n       MatchStart = MatchStart.substr(strlen(\"expected-note\"));\n     } else if (MatchStart.startswith(\"expected-warning\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Warning;\n+      ExpectedClassification = DiagnosticKind::Warning;\n       MatchStart = MatchStart.substr(strlen(\"expected-warning\"));\n     } else if (MatchStart.startswith(\"expected-error\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Error;\n+      ExpectedClassification = DiagnosticKind::Error;\n       MatchStart = MatchStart.substr(strlen(\"expected-error\"));\n     } else if (MatchStart.startswith(\"expected-remark\")) {\n-      ExpectedClassification = llvm::SourceMgr::DK_Remark;\n+      ExpectedClassification = DiagnosticKind::Remark;\n       MatchStart = MatchStart.substr(strlen(\"expected-remark\"));\n     } else\n       continue;\n@@ -479,13 +529,14 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Make sure all the expected diagnostics appeared.\n   std::reverse(ExpectedDiagnostics.begin(), ExpectedDiagnostics.end());\n-  \n+\n   for (unsigned i = ExpectedDiagnostics.size(); i != 0; ) {\n     --i;\n     auto &expected = ExpectedDiagnostics[i];\n-    \n+\n     // Check to see if we had this expected diagnostic.\n-    auto FoundDiagnosticIter = findDiagnostic(expected, BufferName);\n+    auto FoundDiagnosticIter =\n+        findDiagnostic(CapturedDiagnostics, expected, BufferName);\n     if (FoundDiagnosticIter == CapturedDiagnostics.end()) {\n       // Diagnostic didn't exist.  If this is a 'mayAppear' diagnostic, then\n       // we're ok.  Otherwise, leave it in the list.\n@@ -505,20 +556,20 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n     }\n \n     bool matchedAllFixIts =\n-      expected.Fixits.size() == FoundDiagnostic.getFixIts().size();\n-    \n+        expected.Fixits.size() == FoundDiagnostic.FixIts.size();\n+\n     // If we have any expected fixits that didn't get matched, then they are\n     // wrong.  Replace the failed fixit with what actually happened.\n     if (IncorrectFixit) {\n-      if (FoundDiagnostic.getFixIts().empty()) {\n+      if (FoundDiagnostic.FixIts.empty()) {\n         addError(IncorrectFixit, \"expected fix-it not seen\");\n       } else {\n         // If we had an incorrect expected fixit, render it and produce a fixit\n         // of our own.\n-        auto actual = renderFixits(FoundDiagnostic.getFixIts(), InputFile);\n+        auto actual = renderFixits(FoundDiagnostic.FixIts, InputFile);\n         auto replStartLoc = SMLoc::getFromPointer(expected.Fixits[0].StartLoc);\n         auto replEndLoc = SMLoc::getFromPointer(expected.Fixits.back().EndLoc);\n-        \n+\n         llvm::SMFixIt fix(llvm::SMRange(replStartLoc, replEndLoc), actual);\n         addError(IncorrectFixit,\n                  \"expected fix-it not seen; actual fix-its: \" + actual, fix);\n@@ -528,7 +579,7 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n                !expected.mayAppear) {\n       // If there was no fixit specification, but some were produced, add a\n       // fixit to add them in.\n-      auto actual = renderFixits(FoundDiagnostic.getFixIts(), InputFile);\n+      auto actual = renderFixits(FoundDiagnostic.FixIts, InputFile);\n       auto replStartLoc = SMLoc::getFromPointer(expected.ExpectedEnd - 8); // {{none}} length\n       auto replEndLoc = SMLoc::getFromPointer(expected.ExpectedEnd);\n \n@@ -551,46 +602,46 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Check to see if we have any incorrect diagnostics.  If so, diagnose them as\n   // such.\n-  for (unsigned i = ExpectedDiagnostics.size(); i != 0; ) {\n-    --i;\n-    auto &expected = ExpectedDiagnostics[i];\n-\n+  auto expectedDiagIter = ExpectedDiagnostics.begin();\n+  while (expectedDiagIter != ExpectedDiagnostics.end()) {\n     // Check to see if any found diagnostics have the right line and\n     // classification, but the wrong text.\n     auto I = CapturedDiagnostics.begin();\n     for (auto E = CapturedDiagnostics.end(); I != E; ++I) {\n       // Verify the file and line of the diagnostic.\n-      if (I->getLineNo() != (int)expected.LineNo ||\n-          I->getFilename() != BufferName ||\n-          I->getKind() != expected.Classification)\n+      if (I->Line != expectedDiagIter->LineNo || I->FileName != BufferName ||\n+          I->Classification != expectedDiagIter->Classification)\n         continue;\n       \n       // Otherwise, we found it, break out.\n       break;\n     }\n \n-    if (I == CapturedDiagnostics.end()) continue;\n+    if (I == CapturedDiagnostics.end()) {\n+      expectedDiagIter++;\n+      continue;\n+    }\n \n-    if (I->getMessage().find(expected.MessageStr) == StringRef::npos) {\n-      auto StartLoc = SMLoc::getFromPointer(expected.MessageRange.begin());\n-      auto EndLoc = SMLoc::getFromPointer(expected.MessageRange.end());\n+    if (I->Message.find(expectedDiagIter->MessageStr) == StringRef::npos) {\n+      auto StartLoc =\n+          SMLoc::getFromPointer(expectedDiagIter->MessageRange.begin());\n+      auto EndLoc = SMLoc::getFromPointer(expectedDiagIter->MessageRange.end());\n \n-      llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->getMessage());\n-      addError(expected.MessageRange.begin(), \"incorrect message found\", fixIt);\n-    } else if (I->getColumnNo() + 1 != (int)*expected.ColumnNo) {\n+      llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->Message);\n+      addError(expectedDiagIter->MessageRange.begin(),\n+               \"incorrect message found\", fixIt);\n+    } else if (I->Column != *expectedDiagIter->ColumnNo) {\n       // The difference must be only in the column\n-      addError(expected.MessageRange.begin(),\n+      addError(expectedDiagIter->MessageRange.begin(),\n                llvm::formatv(\"message found at column {0} but was expected to \"\n                              \"appear at column {1}\",\n-                             I->getColumnNo() + 1, *expected.ColumnNo));\n+                             I->Column, *expectedDiagIter->ColumnNo));\n     } else {\n       llvm_unreachable(\"unhandled difference from expected diagnostic\");\n     }\n     CapturedDiagnostics.erase(I);\n-    ExpectedDiagnostics.erase(ExpectedDiagnostics.begin()+i);\n+    expectedDiagIter = ExpectedDiagnostics.erase(expectedDiagIter);\n   }\n-  \n-  \n \n   // Diagnose expected diagnostics that didn't appear.\n   std::reverse(ExpectedDiagnostics.begin(), ExpectedDiagnostics.end());\n@@ -645,19 +696,20 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   \n   // Verify that there are no diagnostics (in MemoryBuffer) left in the list.\n   bool HadUnexpectedDiag = false;\n-  for (unsigned i = CapturedDiagnostics.size(); i != 0; ) {\n-    --i;\n-    if (CapturedDiagnostics[i].getFilename() != BufferName) {\n+  auto CapturedDiagIter = CapturedDiagnostics.begin();\n+  while (CapturedDiagIter != CapturedDiagnostics.end()) {\n+    if (CapturedDiagIter->FileName != BufferName) {\n+      CapturedDiagIter++;\n       continue;\n     }\n \n     HadUnexpectedDiag = true;\n     std::string Message =\n-      \"unexpected \"+getDiagKindString(CapturedDiagnostics[i].getKind())+\n-      \" produced: \"+CapturedDiagnostics[i].getMessage().str();\n-    addError(CapturedDiagnostics[i].getLoc().getPointer(),\n-             Message);\n-    CapturedDiagnostics.erase(CapturedDiagnostics.begin() + i);\n+        (\"unexpected \" + getDiagKindString(CapturedDiagIter->Classification) +\n+         \" produced: \" + CapturedDiagIter->Message)\n+            .str();\n+    addError(getRawLoc(CapturedDiagIter->Loc).getPointer(), Message);\n+    CapturedDiagIter = CapturedDiagnostics.erase(CapturedDiagIter);\n   }\n \n   // Sort the diagnostics by their address in the memory buffer as the primary\n@@ -672,111 +724,40 @@ DiagnosticVerifier::verifyFile(unsigned BufferID, bool shouldAutoApplyFixes) {\n   // Emit all of the queue'd up errors.\n   for (auto Err : Errors)\n     SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), Err);\n-  \n+\n   // If auto-apply fixits is on, rewrite the original source file.\n-  if (shouldAutoApplyFixes)\n-    autoApplyFixes(BufferID, Errors);\n+  if (AutoApplyFixes)\n+    autoApplyFixes(SM, BufferID, Errors);\n \n   return Result{!Errors.empty(), HadUnexpectedDiag};\n }\n \n-bool DiagnosticVerifier::verifyUnknown() {\n-  bool HadError = false;\n-  for (unsigned i = 0, e = CapturedDiagnostics.size(); i != e; ++i) {\n-    if (CapturedDiagnostics[i].getFilename() != \"<unknown>\")\n-      continue;\n-\n-    HadError = true;\n-    std::string Message =\n-      \"unexpected \"+getDiagKindString(CapturedDiagnostics[i].getKind())+\n-      \" produced: \"+CapturedDiagnostics[i].getMessage().str();\n-\n-    auto diag = SM.GetMessage({}, llvm::SourceMgr::DK_Error, Message,\n-                              {}, {});\n-    SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), diag);\n-  }\n-  return HadError;\n-}\n-\n void DiagnosticVerifier::printRemainingDiagnostics() const {\n   for (const auto &diag : CapturedDiagnostics) {\n-    SM.getLLVMSourceMgr().PrintMessage(\n-        llvm::errs(), diag.getLoc(), diag.getKind(),\n-        \"diagnostic produced by Clang: \" + diag.getMessage(),\n-        /*Ranges=*/ {}, diag.getFixIts());\n-  }\n-}\n-\n-/// If there are any -verify errors (e.g. differences between expectations\n-/// and actual diagnostics produced), apply fixits to the original source\n-/// file and drop it back in place.\n-void DiagnosticVerifier::autoApplyFixes(unsigned BufferID,\n-                                        ArrayRef<llvm::SMDiagnostic> diags) {\n-  // Walk the list of diagnostics, pulling out any fixits into an array of just\n-  // them.\n-  SmallVector<llvm::SMFixIt, 4> FixIts;\n-  for (auto &diag : diags)\n-    FixIts.append(diag.getFixIts().begin(), diag.getFixIts().end());\n+    // Determine what kind of diagnostic we're emitting.\n+    llvm::SourceMgr::DiagKind SMKind;\n+    switch (diag.Classification) {\n+    case DiagnosticKind::Error:\n+      SMKind = llvm::SourceMgr::DK_Error;\n+      break;\n+    case DiagnosticKind::Warning:\n+      SMKind = llvm::SourceMgr::DK_Warning;\n+      break;\n \n-  // If we have no fixits to apply, avoid touching the file.\n-  if (FixIts.empty())\n-    return;\n-  \n-  // Sort the fixits by their start location.\n-  std::sort(FixIts.begin(), FixIts.end(),\n-            [&](const llvm::SMFixIt &lhs, const llvm::SMFixIt &rhs) -> bool {\n-              return lhs.getRange().Start.getPointer()\n-                   < rhs.getRange().Start.getPointer();\n-            });\n-  // Coalesce identical fix-its. This happens most often with \"expected-error 2\"\n-  // syntax.\n-  FixIts.erase(std::unique(FixIts.begin(), FixIts.end(),\n-                           [](const llvm::SMFixIt &lhs,\n-                              const llvm::SMFixIt &rhs) -> bool {\n-                 return lhs.getRange().Start == rhs.getRange().Start &&\n-                        lhs.getRange().End == rhs.getRange().End &&\n-                        lhs.getText() == rhs.getText();\n-               }), FixIts.end());\n-  // Filter out overlapping fix-its. This allows the compiler to apply changes\n-  // to the easy parts of the file, and leave in the tricky cases for the\n-  // developer to handle manually.\n-  FixIts.erase(swift::removeAdjacentIf(FixIts.begin(), FixIts.end(),\n-                                       [](const llvm::SMFixIt &lhs,\n-                                          const llvm::SMFixIt &rhs) {\n-    return lhs.getRange().End.getPointer() > rhs.getRange().Start.getPointer();\n-  }), FixIts.end());\n+    case DiagnosticKind::Note:\n+      SMKind = llvm::SourceMgr::DK_Note;\n+      break;\n \n-  // Get the contents of the original source file.\n-  auto memBuffer = SM.getLLVMSourceMgr().getMemoryBuffer(BufferID);\n-  auto bufferRange = memBuffer->getBuffer();\n+    case DiagnosticKind::Remark:\n+      SMKind = llvm::SourceMgr::DK_Remark;\n+      break;\n+    }\n \n-  // Apply the fixes, building up a new buffer as an std::string.\n-  const char *LastPos = bufferRange.begin();\n-  std::string Result;\n-  \n-  for (auto &fix : FixIts) {\n-    // We cannot handle overlapping fixits, so assert that they don't happen.\n-    assert(LastPos <= fix.getRange().Start.getPointer() &&\n-           \"Cannot handle overlapping fixits\");\n-    \n-    // Keep anything from the last spot we've checked to the start of the fixit.\n-    Result.append(LastPos, fix.getRange().Start.getPointer());\n-    \n-    // Replace the content covered by the fixit with the replacement text.\n-    Result.append(fix.getText().begin(), fix.getText().end());\n-    \n-    // Next character to consider is at the end of the fixit.\n-    LastPos = fix.getRange().End.getPointer();\n+    SM.getLLVMSourceMgr().PrintMessage(\n+        llvm::errs(), getRawLoc(diag.Loc), SMKind,\n+        \"diagnostic produced by Clang: \" + diag.Message.str(),\n+        /*Ranges=*/{}, {});\n   }\n-  \n-  // Retain the end of the file.\n-  Result.append(LastPos, bufferRange.end());\n-\n-  std::error_code error;\n-  llvm::raw_fd_ostream outs(memBuffer->getBufferIdentifier(), error,\n-                            llvm::sys::fs::OpenFlags::F_None);\n-  if (!error)\n-    outs << Result;\n }\n \n //===----------------------------------------------------------------------===//\n@@ -786,42 +767,48 @@ void DiagnosticVerifier::autoApplyFixes(unsigned BufferID,\n /// Every time a diagnostic is generated in -verify mode, this function is\n /// called with the diagnostic.  We just buffer them up until the end of the\n /// file.\n-static void VerifyModeDiagnosticHook(const llvm::SMDiagnostic &Diag,\n-                                     void *Context) {\n-  ((DiagnosticVerifier*)Context)->addDiagnostic(Diag);\n-}\n-\n+void DiagnosticVerifier::handleDiagnostic(SourceManager &SM,\n+                                          const DiagnosticInfo &Info) {\n+  SmallVector<DiagnosticInfo::FixIt, 2> fixIts;\n+  std::copy(Info.FixIts.begin(), Info.FixIts.end(), std::back_inserter(fixIts));\n+\n+  llvm::SmallString<128> message;\n+  {\n+    llvm::raw_svector_ostream Out(message);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n+  }\n \n-void swift::enableDiagnosticVerifier(SourceManager &SM) {\n-  SM.getLLVMSourceMgr().setDiagHandler(VerifyModeDiagnosticHook,\n-                                       new DiagnosticVerifier(SM));\n+  if (Info.Loc.isValid()) {\n+    const auto lineAndColumn = SM.getLineAndColumn(Info.Loc);\n+    const auto fileName = SM.getDisplayNameForLoc(Info.Loc);\n+    CapturedDiagnostics.emplace_back(message, fileName, Info.Kind, Info.Loc,\n+                                     lineAndColumn.first, lineAndColumn.second,\n+                                     fixIts);\n+  } else {\n+    CapturedDiagnostics.emplace_back(message, StringRef(), Info.Kind, Info.Loc,\n+                                     0, 0, fixIts);\n+  }\n }\n \n-bool swift::verifyDiagnostics(SourceManager &SM, ArrayRef<unsigned> BufferIDs,\n-                              bool autoApplyFixes, bool ignoreUnknown) {\n-  auto *Verifier = (DiagnosticVerifier*)SM.getLLVMSourceMgr().getDiagContext();\n-  SM.getLLVMSourceMgr().setDiagHandler(nullptr, nullptr);\n-  \n+/// Once all diagnostics have been captured, perform verification.\n+bool DiagnosticVerifier::finishProcessing() {\n   DiagnosticVerifier::Result Result = {false, false};\n \n   for (auto &BufferID : BufferIDs) {\n-    DiagnosticVerifier::Result FileResult =\n-        Verifier->verifyFile(BufferID, autoApplyFixes);\n+    DiagnosticVerifier::Result FileResult = verifyFile(BufferID);\n     Result.HadError |= FileResult.HadError;\n     Result.HadUnexpectedDiag |= FileResult.HadUnexpectedDiag;\n   }\n-  if (!ignoreUnknown) {\n-    bool HadError = Verifier->verifyUnknown();\n+  if (!IgnoreUnknown) {\n+    bool HadError = verifyUnknown(SM, CapturedDiagnostics);\n     Result.HadError |= HadError;\n     // For <unknown>, all errors are unexpected.\n     Result.HadUnexpectedDiag |= HadError;\n   }\n \n   if (Result.HadUnexpectedDiag)\n-    Verifier->printRemainingDiagnostics();\n-\n-  delete Verifier;\n+    printRemainingDiagnostics();\n \n   return Result.HadError;\n }\n-"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -293,6 +293,17 @@ void CompilerInstance::setupStatsReporter() {\n   Stats = std::move(Reporter);\n }\n \n+void CompilerInstance::setupDiagnosticVerifierIfNeeded() {\n+  auto &diagOpts = Invocation.getDiagnosticOptions();\n+  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n+    DiagVerifier = std::make_unique<DiagnosticVerifier>(\n+        SourceMgr, InputSourceCodeBufferIDs,\n+        diagOpts.VerifyMode == DiagnosticOptions::VerifyAndApplyFixes,\n+        diagOpts.VerifyIgnoreUnknown);\n+    addDiagnosticConsumer(DiagVerifier.get());\n+  }\n+}\n+\n bool CompilerInstance::setup(const CompilerInvocation &Invok) {\n   Invocation = Invok;\n \n@@ -337,6 +348,7 @@ bool CompilerInstance::setup(const CompilerInvocation &Invok) {\n     return true;\n \n   setupStatsReporter();\n+  setupDiagnosticVerifierIfNeeded();\n \n   return false;\n }"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -883,6 +883,9 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n     DidErrorOccur = true;\n   }\n \n+  if (SuppressOutput)\n+    return;\n+\n   if (Info.IsChildNote)\n     return;\n "
                    },
                    {
                        "filename": "lib/FrontendTool/FrontendTool.cpp",
                        "code": "@@ -2046,15 +2046,22 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     }\n   } FinishDiagProcessingCheckRAII;\n \n-  auto finishDiagProcessing = [&](int retValue) -> int {\n+  auto finishDiagProcessing = [&](int retValue, bool verifierEnabled) -> int {\n     FinishDiagProcessingCheckRAII.CalledFinishDiagProcessing = true;\n-    bool err = Instance->getDiags().finishProcessing();\n-    return retValue ? retValue : err;\n+    PDC.setSuppressOutput(false);\n+    bool diagnosticsError = Instance->getDiags().finishProcessing();\n+    // If the verifier is enabled and did not encounter any verification errors,\n+    // return 0 even if the compile failed. This behavior isn't ideal, but large\n+    // parts of the test suite are reliant on it.\n+    if (verifierEnabled && !diagnosticsError) {\n+      return 0;\n+    }\n+    return retValue ? retValue : diagnosticsError;\n   };\n \n   if (Args.empty()) {\n     Instance->getDiags().diagnose(SourceLoc(), diag::error_no_frontend_args);\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   CompilerInvocation Invocation;\n@@ -2069,7 +2076,7 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   SmallVector<std::unique_ptr<llvm::MemoryBuffer>, 4> configurationFileBuffers;\n   if (Invocation.parseArgs(Args, Instance->getDiags(),\n                            &configurationFileBuffers, workingDirectory)) {\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // Make an array of PrettyStackTrace objects to dump the configuration files\n@@ -2111,19 +2118,19 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     Options->PrintHelp(llvm::outs(), displayName(MainExecutablePath).c_str(),\n                        \"Swift frontend\", IncludedFlagsBitmask,\n                        ExcludedFlagsBitmask, /*ShowAllAliases*/false);\n-    return finishDiagProcessing(0);\n+    return finishDiagProcessing(0, /*verifierEnabled*/ false);\n   }\n \n   if (Invocation.getFrontendOptions().PrintTargetInfo) {\n     printTargetInfo(Invocation, llvm::outs());\n-    return finishDiagProcessing(0);\n+    return finishDiagProcessing(0, /*verifierEnabled*/ false);\n   }\n \n   if (Invocation.getFrontendOptions().RequestedAction ==\n       FrontendOptions::ActionType::NoneAction) {\n     Instance->getDiags().diagnose(SourceLoc(),\n                                   diag::error_missing_frontend_action);\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // Because the serialized diagnostics consumer is initialized here,\n@@ -2159,9 +2166,7 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   }\n \n   const DiagnosticOptions &diagOpts = Invocation.getDiagnosticOptions();\n-  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n-    enableDiagnosticVerifier(Instance->getSourceMgr());\n-  }\n+  bool verifierEnabled = diagOpts.VerifyMode != DiagnosticOptions::NoVerify;\n \n   if (Invocation.getFrontendOptions()\n           .InputsAndOutputs.hasDependencyTrackerPath() ||\n@@ -2176,14 +2181,20 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   }\n \n   if (Instance->setup(Invocation)) {\n-    return finishDiagProcessing(1);\n+    return finishDiagProcessing(1, /*verifierEnabled*/ false);\n   }\n \n   // The compiler instance has been configured; notify our observer.\n   if (observer) {\n     observer->configuredCompiler(*Instance);\n   }\n \n+  if (verifierEnabled) {\n+    // Suppress printed diagnostic output during the compile if the verifier is\n+    // enabled.\n+    PDC.setSuppressOutput(true);\n+  }\n+\n   int ReturnValue = 0;\n   bool HadError =\n     performCompile(*Instance, Invocation, Args, ReturnValue, observer);\n@@ -2211,23 +2222,18 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n     }\n   }\n \n-  if (diagOpts.VerifyMode != DiagnosticOptions::NoVerify) {\n-    HadError = verifyDiagnostics(\n-        Instance->getSourceMgr(),\n-        Instance->getInputBufferIDs(),\n-        diagOpts.VerifyMode == DiagnosticOptions::VerifyAndApplyFixes,\n-        diagOpts.VerifyIgnoreUnknown);\n-\n+  if (verifierEnabled) {\n     DiagnosticEngine &diags = Instance->getDiags();\n     if (diags.hasFatalErrorOccurred() &&\n         !Invocation.getDiagnosticOptions().ShowDiagnosticsAfterFatalError) {\n       diags.resetHadAnyError();\n+      PDC.setSuppressOutput(false);\n       diags.diagnose(SourceLoc(), diag::verify_encountered_fatal);\n       HadError = true;\n     }\n   }\n \n-  auto r = finishDiagProcessing(HadError ? 1 : ReturnValue);\n+  auto r = finishDiagProcessing(HadError ? 1 : ReturnValue, verifierEnabled);\n   if (auto *StatsReporter = Instance->getStatsReporter())\n     StatsReporter->noteCurrentProcessExitStatus(r);\n   return r;"
                    },
                    {
                        "filename": "test/diagnostics/sil-opt-verifier.sil",
                        "code": "@@ -0,0 +1,14 @@\n+// RUN: not %target-sil-opt -enable-sil-verify-all %s -definite-init -verify 2>&1 | %FileCheck %s\n+\n+import Builtin\n+import Swift\n+\n+// main\n+sil [ossa] @main : $@convention(c) (Int32, UnsafeMutablePointer<Optional<UnsafeMutablePointer<Int8>>>) -> Int32 {\n+bb0(%0 : $Int32, %1 : $UnsafeMutablePointer<Optional<UnsafeMutablePointer<Int8>>>):\n+  %2 = integer_literal $Builtin.Int32, 0\n+  %3 = struct $Int32 (%2 : $Builtin.Int32)\n+  return %4 : $Int32 // expected-error {{use of undefined value '%5'}}\n+  // CHECK-NOT: error: use of undefined value '%4'\n+  // CHECK: incorrect message found\n+}"
                    },
                    {
                        "filename": "test/diagnostics/verifier.swift",
                        "code": "@@ -0,0 +1,44 @@\n+// RUN: %empty-directory(%t)\n+// RUN: not %target-swift-frontend -typecheck -verify -serialize-diagnostics-path %t/serialized.dia -emit-fixits-path %t/fixits %s 2>&1 | %FileCheck %s\n+// RUN: not %target-swift-frontend -typecheck -verify -warnings-as-errors %s 2>&1 | %FileCheck %s -check-prefix CHECK-WARNINGS-AS-ERRORS\n+// RUN: %FileCheck %s -check-prefix CHECK-SERIALIZED <%t/serialized.dia\n+// RUN: %FileCheck %s -check-prefix CHECK-FIXITS <%t/fixits\n+\n+// Wrong message\n+let x: Int = \"hello, world!\" // expected-error {{foo bar baz}}\n+// CHECK-NOT: error: cannot convert value of type 'String' to specified type 'Int'\n+// CHECK: error: incorrect message found\n+\n+// Wrong column\n+let y: Int = \"hello, world!\" // expected-error@:49 {{cannot convert value of type}}\n+// CHECK: message found at column 14 but was expected to appear at column 49\n+\n+// Wrong fix-it\n+let z: Int = \"hello, world!\" as Any\n+// expected-error@-1 {{cannot convert value of type}} {{3-3=foobarbaz}}\n+// CHECK: expected fix-it not seen; actual fix-its: {{[{][{]}}36-36= as! Int{{[}][}]}}\n+\n+// Expected no fix-it\n+let a: Bool = \"hello, world!\" as Any\n+// expected-error@-1 {{cannot convert value of type}} {{none}}\n+// CHECK: expected no fix-its; actual fix-it seen: {{[{][{]}}37-37= as! Bool{{[}][}]}}\n+\n+// Unexpected error\n+_ = foo()\n+// CHECK: unexpected error produced: use of unresolved identifier 'foo'\n+\n+func b() {\n+  let c = 2\n+}\n+// CHECK: unexpected warning produced: initialization of immutable value 'c' was never used\n+// CHECK-WARNINGS-AS-ERRORS: unexpected error produced: initialization of immutable value 'c' was never used\n+\n+// Verify the serialized diags have the right magic at the top.\n+// CHECK-SERIALIZED: DIA\n+\n+// Ensure the verifier doesn't interfere with -emit-fixits-path.\n+// CHECK-FIXITS: {\n+// CHECK-FIXITS: \"file\":\n+// CHECK-FIXITS: \"offset\":\n+// CHECK-FIXITS: \"text\": \" as! Int\",\n+// CHECK-FIXITS: },"
                    },
                    {
                        "filename": "tools/sil-opt/SILOpt.cpp",
                        "code": "@@ -349,6 +349,9 @@ int main(int argc, char **argv) {\n   Invocation.getLangOptions().EnableExperimentalDifferentiableProgramming =\n       EnableExperimentalDifferentiableProgramming;\n \n+  Invocation.getDiagnosticOptions().VerifyMode =\n+      VerifyMode ? DiagnosticOptions::Verify : DiagnosticOptions::NoVerify;\n+\n   // Setup the SIL Options.\n   SILOptions &SILOpts = Invocation.getSILOptions();\n   SILOpts.InlineThreshold = SILInlineThreshold;\n@@ -404,15 +407,40 @@ int main(int argc, char **argv) {\n   PrintingDiagnosticConsumer PrintDiags;\n   CI.addDiagnosticConsumer(&PrintDiags);\n \n+  if (VerifyMode)\n+    PrintDiags.setSuppressOutput(true);\n+\n+  struct FinishDiagProcessingCheckRAII {\n+    bool CalledFinishDiagProcessing = false;\n+    ~FinishDiagProcessingCheckRAII() {\n+      assert(CalledFinishDiagProcessing &&\n+             \"returned from the function \"\n+             \"without calling finishDiagProcessing\");\n+    }\n+  } FinishDiagProcessingCheckRAII;\n+\n+  auto finishDiagProcessing = [&](int retValue) -> int {\n+    FinishDiagProcessingCheckRAII.CalledFinishDiagProcessing = true;\n+    PrintDiags.setSuppressOutput(false);\n+    bool diagnosticsError = CI.getDiags().finishProcessing();\n+    // If the verifier is enabled and did not encounter any verification errors,\n+    // return 0 even if the compile failed. This behavior isn't ideal, but large\n+    // parts of the test suite are reliant on it.\n+    if (VerifyMode && !diagnosticsError) {\n+      return 0;\n+    }\n+    return retValue ? retValue : diagnosticsError;\n+  };\n+\n   if (CI.setup(Invocation))\n-    return 1;\n+    return finishDiagProcessing(1);\n \n   CI.performSema();\n \n   // If parsing produced an error, don't run any passes.\n   bool HadError = CI.getASTContext().hadError();\n   if (HadError)\n-    return 1;\n+    return finishDiagProcessing(1);\n \n   // Load the SIL if we have a module. We have to do this after SILParse\n   // creating the unfortunate double if statement.\n@@ -429,11 +457,6 @@ int main(int argc, char **argv) {\n       SL->getAll();\n   }\n \n-  // If we're in verify mode, install a custom diagnostic handling for\n-  // SourceMgr.\n-  if (VerifyMode)\n-    enableDiagnosticVerifier(CI.getSourceMgr());\n-\n   if (CI.getSILModule())\n     CI.getSILModule()->setSerializeSILAction([]{});\n \n@@ -511,7 +534,7 @@ int main(int argc, char **argv) {\n       if (EC) {\n         llvm::errs() << \"while opening '\" << OutputFile << \"': \"\n                      << EC.message() << '\\n';\n-        return 1;\n+        return finishDiagProcessing(1);\n       }\n       CI.getSILModule()->print(OS, CI.getMainModule(), SILOpts,\n                                !DisableASTDump);\n@@ -520,12 +543,7 @@ int main(int argc, char **argv) {\n \n   HadError |= CI.getASTContext().hadError();\n \n-  // If we're in -verify mode, we've buffered up all of the generated\n-  // diagnostics.  Check now to ensure that they meet our expectations.\n   if (VerifyMode) {\n-    HadError = verifyDiagnostics(CI.getSourceMgr(), CI.getInputBufferIDs(),\n-                                 /*autoApplyFixes*/false,\n-                                 /*ignoreUnknown*/false);\n     DiagnosticEngine &diags = CI.getDiags();\n     if (diags.hasFatalErrorOccurred() &&\n         !Invocation.getDiagnosticOptions().ShowDiagnosticsAfterFatalError) {\n@@ -535,5 +553,5 @@ int main(int argc, char **argv) {\n     }\n   }\n \n-  return HadError;\n+  return finishDiagProcessing(HadError);\n }"
                    }
                ]
            },
            {
                "date": "2020-03-27T22:29:48Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/791312fb7481f07b675482490eaa97fc318f0901",
                "changes": [
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -92,23 +92,34 @@ Most diagnostics have no reason to change behavior under editor mode. An example\n \n ### Educational Notes ###\n \n-**Note**: This feature is currently experimental. It can be enabled by passing the `-Xfrontend -enable-descriptive-diagnostics` flag.\n+Educational notes are short-form documentation attached to a diagnostic which explain relevant language concepts. They are intended to further Swift's goal of progressive disclosure by providing a learning resource at the point of use when encountering an error message for the first time. In very limited circumstances, they also allow the main diagnostic message to use precise terminology (e.g. nominal types) which would otherwise be too unfriendly for beginners.\n \n-Educational notes are small snippets of documentation attached to a diagnostic which explain relevant language concepts. They are intended to further Swift's goal of progressive disclosure by providing a learning resource at the point of use for users encountering a new error message for the first time. In very limited circumstances, they also allow the main diagnostic message to use more precise and correct terminology (e.g. nominal types) which would otherwise be too unfriendly for beginners.\n+When outputting diagnostics on the command line, educational notes will be printed after the main diagnostic body if enabled using the `-print-educational-notes` driver option. When presented in an IDE, it's expected they will be collapsed under a disclosure arrow, info button, or similar to avoid cluttering output.\n \n-When outputting diagnostics on the command line, educational notes will be printed after the main diagnostic body if descriptive diagnostics are enabled. When presented in an IDE, it's expected they will be collapsed under a disclosure arrow, info button, or similar to avoid cluttering output.\n-\n-Generally speaking, a diagnostic should try to provide educational notes for any concepts/terminology which is difficult to understand from context or is especially subtle. Educational notes should:\n-- Explain a single language concept. This makes them easy to reuse across diagnostics and helps keep them clear, concise, and easy to understand.\n-- Be written in unabbreviated English. These are longer form messages compared to the main diagnostic, so there is no need to omit needless words and punctuation.\n-- Not generally exceed 3-4 paragraphs. Educational notes should be clear and easily digestible. Messages which are too long also have the potential to create diagnostics UX issues in some contexts.\n+Educational notes should:\n+- Explain a single language concept. This makes them easy to reuse across related diagnostics and helps keep them clear, concise, and easy to understand.\n+- Be written in unabbreviated English. These are longer-form messages compared to the main diagnostic, so there's no need to omit needless words and punctuation.\n+- Not generally exceed 3-4 paragraphs. Educational notes should be clear and easily digestible. Messages which are too long also have the potential to create UX issues on the command line.\n - Be accessible. Educational notes should be beginner friendly and avoid assuming unnecesary prior knowledge. The goal is not only to help users understand what a diagnostic is telling them, but also to turn errors and warnings into \"teachable moments\".\n-- Include references to relevant chapters of _The Swift Programming Language_ if applicable.\n-- Be written in Markdown, but avoid excessive markup to avoid impacting the terminal UX. \n+- Include references to relevant chapters of _The Swift Programming Language_.\n+- Be written in Markdown, but avoid excessive markup which negatively impacts the terminal UX.\n+\n+### Quick-Start Guide for Contributing New Educational Notes ###\n+\n+Adding new educational notes is a great way to get familiar with the process of contributing to Swift, while also making a big impact!\n \n To add a new educational note:\n-1. Add a new Markdown file in the `userdocs/diagnostics/` directory containing the contents of the note. \n-2. Associate the note with one or more diagnostics in EducationalNotes.def.\n+1. Follow the [directions in the README](https://github.com/apple/swift#getting-sources-for-swift-and-related-projects) to checkout the Swift sources locally. Being able to build the Swift compiler is recommended, but not required, when contributing a new note.\n+2. Identify a diagnostic to write an educational note for. To associate an educational note with a diagnostic name, you'll need to know its internal identifier. The easiest way to do this is to write a small program which triggers the diagnostic, and run it using the `-debug-diagnostic-names` compiler flag. This flag will cause the internal diagnostic identifier to be printed after the diagnostic message in square brackets.\n+3. Find any closely related diagnostics. Sometimes, what appears to be one diagnostic from a user's perspective may have multiple variations internally. After determining a diagnostic's internal identifier, run a search for it in the compiler source. You should find:\n+    - An entry in a `Diagnostics*.def` file describing the diagnostic. If there are any closely related diagnostics the note should also be attached to, they can usually be found nearby.\n+    - Each point in the compiler source where the diagnostic is emitted. This can be helpful in determining the exact circumstances which cause it to be emitted.\n+4. Add a new Markdown file in the `userdocs/diagnostics/` directory in the swift repository containing the contents of the note. When writing a note, keep the writing guidelines from the section above in mind. The existing notes in the directory are another useful guide.\n+5. Associate the note with the appropriate diagnostics in `EducationalNotes.def`. An entry like `EDUCATIONAL_NOTES(property_wrapper_failable_init, \"property-wrapper-requirements.md\")` will associate the note with filename `property-wrapper-requirements.md` with the diagnostic having an internal identifier of `property_wrapper_failable_init`.\n+6. If possible, rebuild the compiler and try recompiling your test program with `-print-educational-notes`. Your new note should appear after the diagnostic in the terminal.\n+7. That's it! The new note is now ready to be submitted as a pull request on GitHub.\n+\n+If you run into any issues or have questions while following the steps above, feel free to post a question on the Swift forums or open a work-in-progress pull request on GitHub.\n \n ### Format Specifiers ###\n "
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -676,9 +676,6 @@ namespace swift {\n     /// Print diagnostic names after their messages\n     bool printDiagnosticNames = false;\n \n-    /// Use educational notes when available.\n-    bool useEducationalNotes = false;\n-\n     /// Path to diagnostic documentation directory.\n     std::string diagnosticDocumentationPath = \"\";\n \n@@ -730,9 +727,6 @@ namespace swift {\n       return printDiagnosticNames;\n     }\n \n-    void setUseEducationalNotes(bool val) { useEducationalNotes = val; }\n-    bool getUseEducationalNotes() const { return useEducationalNotes; }\n-\n     void setDiagnosticDocumentationPath(std::string path) {\n       diagnosticDocumentationPath = path;\n     }"
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -55,9 +55,9 @@ class DiagnosticOptions {\n   // When printing diagnostics, include the diagnostic name at the end\n   bool PrintDiagnosticNames = false;\n \n-  /// If set to true, display educational note content to the user if available.\n+  /// If set to true, include educational notes in printed output if available.\n   /// Educational notes are documentation which supplement diagnostics.\n-  bool EnableEducationalNotes = false;\n+  bool PrintEducationalNotes = false;\n \n   // If set to true, use the more descriptive experimental formatting style for\n   // diagnostics."
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -31,6 +31,7 @@ class AnnotatedSourceSnippet;\n class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   llvm::raw_ostream &Stream;\n   bool ForceColors = false;\n+  bool PrintEducationalNotes = false;\n   bool DidErrorOccur = false;\n   bool ExperimentalFormattingEnabled = false;\n   // The current snippet used to display an error/warning/remark and the notes\n@@ -59,6 +60,10 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n     llvm::sys::Process::UseANSIEscapeCodes(true);\n   }\n \n+  void setPrintEducationalNotes(bool ShouldPrint) {\n+    PrintEducationalNotes = ShouldPrint;\n+  }\n+\n   void enableExperimentalFormatting() { ExperimentalFormattingEnabled = true; }\n \n   bool didErrorOccur() {"
                    },
                    {
                        "filename": "include/swift/Option/FrontendOptions.td",
                        "code": "@@ -130,9 +130,6 @@ def enable_cross_import_overlays : Flag<[\"-\"], \"enable-cross-import-overlays\">,\n   HelpText<\"Automatically import declared cross-import overlays.\">;\n def disable_cross_import_overlays : Flag<[\"-\"], \"disable-cross-import-overlays\">,\n   HelpText<\"Do not automatically import declared cross-import overlays.\">;\n-\n-def enable_educational_notes : Flag<[\"-\"], \"enable-educational-notes\">,\n-  HelpText<\"Show educational notes, if available.\">;\n   \n def enable_experimental_diagnostic_formatting :\n   Flag<[\"-\"], \"enable-experimental-diagnostic-formatting\">,"
                    },
                    {
                        "filename": "include/swift/Option/Options.td",
                        "code": "@@ -372,6 +372,9 @@ def no_color_diagnostics : Flag<[\"-\"], \"no-color-diagnostics\">,\n def debug_diagnostic_names : Flag<[\"-\"], \"debug-diagnostic-names\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild, HelpHidden]>,\n   HelpText<\"Include diagnostic names when printing\">;\n+def print_educational_notes : Flag<[\"-\"], \"print-educational-notes\">,\n+  Flags<[FrontendOption, DoesNotAffectIncrementalBuild]>,\n+  HelpText<\"Include educational notes in printed diagnostic output, if available\">;\n \n def module_cache_path : Separate<[\"-\"], \"module-cache-path\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild, ArgumentIsPath]>,"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -984,16 +984,15 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n     info->ChildDiagnosticInfo = childInfoPtrs;\n     \n     SmallVector<std::string, 1> educationalNotePaths;\n-    if (useEducationalNotes) {\n-      auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n-      while (associatedNotes && *associatedNotes) {\n-        SmallString<128> notePath(getDiagnosticDocumentationPath());\n-        llvm::sys::path::append(notePath, *associatedNotes);\n-        educationalNotePaths.push_back(notePath.str().str());\n-        associatedNotes++;\n-      }\n-      info->EducationalNotePaths = educationalNotePaths;\n+\n+    auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n+    while (associatedNotes && *associatedNotes) {\n+      SmallString<128> notePath(getDiagnosticDocumentationPath());\n+      llvm::sys::path::append(notePath, *associatedNotes);\n+      educationalNotePaths.push_back(notePath.str().str());\n+      associatedNotes++;\n     }\n+    info->EducationalNotePaths = educationalNotePaths;\n \n     for (auto &consumer : Consumers) {\n       consumer->handleDiagnostic(SourceMgr, *info);"
                    },
                    {
                        "filename": "lib/Driver/ToolChains.cpp",
                        "code": "@@ -249,6 +249,7 @@ static void addCommonFrontendArgs(const ToolChain &TC, const OutputInfo &OI,\n   inputArgs.AddLastArg(arguments, options::OPT_package_description_version);\n   inputArgs.AddLastArg(arguments, options::OPT_serialize_diagnostics_path);\n   inputArgs.AddLastArg(arguments, options::OPT_debug_diagnostic_names);\n+  inputArgs.AddLastArg(arguments, options::OPT_print_educational_notes);\n   inputArgs.AddLastArg(arguments, options::OPT_enable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_parser_lookup);"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -821,7 +821,7 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.SuppressWarnings |= Args.hasArg(OPT_suppress_warnings);\n   Opts.WarningsAsErrors |= Args.hasArg(OPT_warnings_as_errors);\n   Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n-  Opts.EnableEducationalNotes |= Args.hasArg(OPT_enable_educational_notes);\n+  Opts.PrintEducationalNotes |= Args.hasArg(OPT_print_educational_notes);\n   Opts.EnableExperimentalFormatting |=\n       Args.hasArg(OPT_enable_experimental_diagnostic_formatting);\n   if (Arg *A = Args.getLastArg(OPT_diagnostic_documentation_path)) {"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -410,9 +410,6 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().PrintDiagnosticNames) {\n     Diagnostics.setPrintDiagnosticNames(true);\n   }\n-  if (Invocation.getDiagnosticOptions().EnableEducationalNotes) {\n-    Diagnostics.setUseEducationalNotes(true);\n-  }\n   Diagnostics.setDiagnosticDocumentationPath(\n       Invocation.getDiagnosticOptions().DiagnosticDocumentationPath);\n }"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -898,17 +898,21 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n       currentSnippet = std::make_unique<AnnotatedSourceSnippet>(SM);\n       annotateSnippetWithInfo(SM, Info, *currentSnippet);\n     }\n-    for (auto path : Info.EducationalNotePaths) {\n-      if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n-        BufferedEducationalNotes.push_back(buffer->get()->getBuffer().str());\n+    if (PrintEducationalNotes) {\n+      for (auto path : Info.EducationalNotePaths) {\n+        if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n+          BufferedEducationalNotes.push_back(buffer->get()->getBuffer().str());\n+      }\n     }\n   } else {\n     printDiagnostic(SM, Info);\n \n-    for (auto path : Info.EducationalNotePaths) {\n-      if (auto buffer = SM.getFileSystem()->getBufferForFile(path)) {\n-        printMarkdown(buffer->get()->getBuffer(), Stream, ForceColors);\n-        Stream << \"\\n\";\n+    if (PrintEducationalNotes) {\n+      for (auto path : Info.EducationalNotePaths) {\n+        if (auto buffer = SM.getFileSystem()->getBufferForFile(path)) {\n+          printMarkdown(buffer->get()->getBuffer(), Stream, ForceColors);\n+          Stream << \"\\n\";\n+        }\n       }\n     }\n "
                    },
                    {
                        "filename": "lib/FrontendTool/FrontendTool.cpp",
                        "code": "@@ -2150,6 +2150,9 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   if (Invocation.getDiagnosticOptions().UseColor)\n     PDC.forceColors();\n \n+  PDC.setPrintEducationalNotes(\n+      Invocation.getDiagnosticOptions().PrintEducationalNotes);\n+\n   // Temporarily stage the new diagnostic formatting style behind\n   // -enable-descriptive-diagnostics\n   if (Invocation.getDiagnosticOptions().EnableExperimentalFormatting)"
                    },
                    {
                        "filename": "test/SourceKit/Sema/educational_note_diags.swift",
                        "code": "@@ -1,13 +1,8 @@\n extension (Int, Int) {}\n \n-// RUN: %sourcekitd-test -req=sema %s -- -Xfrontend -enable-educational-notes -Xfrontend -diagnostic-documentation-path -Xfrontend /educational/notes/path/prefix %s | %FileCheck %s -check-prefix=DESCRIPTIVE\n+// RUN: %sourcekitd-test -req=sema %s -- -Xfrontend -print-educational-notes -Xfrontend -diagnostic-documentation-path -Xfrontend /educational/notes/path/prefix %s | %FileCheck %s -check-prefix=DESCRIPTIVE\n \n // DESCRIPTIVE:      key.description: \"non-nominal type\n // DESCRIPTIVE:      key.educational_note_paths: [\n // DESCRIPTIVE-NEXT:   \"{{[/\\\\]+}}educational{{[/\\\\]+}}notes{{[/\\\\]+}}path{{[/\\\\]+}}prefix{{[/\\\\]+}}nominal-types.md\"\n // DESCRIPTIVE-NEXT: ]\n-\n-// RUN: %sourcekitd-test -req=sema %s -- %s | %FileCheck %s -check-prefix=DESCRIPTIVE-DISABLED\n-\n-// DESCRIPTIVE-DISABLED:     key.description: \"non-nominal type\n-// DESCRIPTIVE-DISABLED-NOT: key.educational_note_paths"
                    },
                    {
                        "filename": "test/diagnostics/educational-notes.swift",
                        "code": "@@ -1,6 +1,6 @@\n-// RUN: not %target-swift-frontend -color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace\n-// RUN: not %target-swift-frontend -no-color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace --check-prefix=NO-COLOR\n-// RUN: not %target-swift-frontend -enable-experimental-diagnostic-formatting -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --check-prefix=CHECK-DESCRIPTIVE\n+// RUN: not %target-swift-frontend -color-diagnostics -print-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace\n+// RUN: not %target-swift-frontend -no-color-diagnostics -print-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace --check-prefix=NO-COLOR\n+// RUN: not %target-swift-frontend -enable-experimental-diagnostic-formatting -print-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --check-prefix=CHECK-DESCRIPTIVE\n \n // A diagnostic with no educational notes\n let x = 1 +"
                    }
                ]
            },
            {
                "date": "2020-03-21T22:11:46Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/768c4385cfb4e8b2d2edccc0c793002b2f05c450",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -702,7 +702,7 @@ void DiagnosticVerifier::printRemainingDiagnostics() const {\n   for (const auto &diag : CapturedDiagnostics) {\n     SM.getLLVMSourceMgr().PrintMessage(\n         llvm::errs(), diag.getLoc(), diag.getKind(),\n-        \"diagnostic produced by Clang: \" + diag.getMessage(),\n+        \"diagnostic produced elsewhere: \" + diag.getMessage(),\n         /*Ranges=*/ {}, diag.getFixIts());\n   }\n }"
                    },
                    {
                        "filename": "test/Frontend/verify-broken-c-module.swift",
                        "code": "@@ -6,6 +6,6 @@\n // RUN: not %target-typecheck-verify-swift -I %S/Inputs/broken-c-module 2>&1 | %FileCheck %s\n \n // CHECK: [[@LINE+3]]:8: error: unexpected error produced: could not build\n-// CHECK: note: diagnostic produced by Clang: in file included from <module-includes>\n-// CHECK: broken_c.h:2:11: error: diagnostic produced by Clang: expected function body after function declarator\n+// CHECK: note: diagnostic produced elsewhere: in file included from <module-includes>\n+// CHECK: broken_c.h:2:11: error: diagnostic produced elsewhere: expected function body after function declarator\n import BrokenCModule"
                    },
                    {
                        "filename": "test/Frontend/verify.swift",
                        "code": "@@ -10,3 +10,7 @@ undefinedFunc()\n \n // CHECK: [[@LINE+1]]:20: error: expected {{{{}} in {{expected}}-{{warning}}\n // expected-warning\n+\n+// CHECK: [[@LINE+2]]:8: error: unexpected error produced: generic type 'Array' specialized with too many type parameters\n+// CHECK: note: diagnostic produced elsewhere: generic type 'Array' declared here\n+let x: Array<Int, Int>"
                    }
                ]
            },
            {
                "date": "2020-03-14T18:08:47Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/cfbfadfb43668769c1ec56fa34ae532a66216b48",
                "changes": [
                    {
                        "filename": "userdocs/diagnostics/associated-type-requirements.md",
                        "code": "@@ -1,5 +1,4 @@\n-Using Protocols with `Self` or Associated Type Requirements\n----\n+# Using Protocols with `Self` or Associated Type Requirements\n Protocols in Swift may be used as types, as part of a generic constraint, or as part of an opaque result type.\n ```\n // CustomStringConvertible can be used as a type."
                    },
                    {
                        "filename": "userdocs/diagnostics/complex-closure-inference.md",
                        "code": "@@ -1,5 +1,4 @@\n-Inferring Closure Types\n----\n+# Inferring Closure Types\n If a closure contains a single expression, Swift will consider its body in addition to its signature and the surrounding context when performing type inference. For example, in the following code the type of `doubler` is inferred to be `(Int) -> Int` using only its body:\n ```\n let doubler = {"
                    },
                    {
                        "filename": "userdocs/diagnostics/dynamic-callable-requirements.md",
                        "code": "@@ -1,5 +1,4 @@\n-@dynamicCallable Implementation Requirements\n----\n+# @dynamicCallable Implementation Requirements\n If a type is marked with the `@dynamicCallable` attribute, it must provide a valid implementation of `dynamicallyCall(withArguments:)`, `dynamicallyCall(withKeywordArguments:)`, or both. If it fails to do so, an error will be reported at compile-time. Note that an implementation of `dynamicallyCall(withKeywordArguments:)` is required to support calls with keyword arguments.\n \n To be considered valid, an implementation of `dynamicallyCall(withArguments:)` must:"
                    },
                    {
                        "filename": "userdocs/diagnostics/nominal-types.md",
                        "code": "@@ -1,5 +1,4 @@\n-## Nominal types\n-***\n+# Nominal types\n In Swift, a type is considered a nominal type if it is named.  In other words, it has been defined by declaring the type somewhere in code. Examples of nominal types include classes, structs and enums, all of which must be declared before using them. Nominal types are an important concept in Swift because they can be extended, explicitly initialized using the `MyType()` syntax, and may conform to protocols.\n \n In contrast, non-nominal types have none of these capabilities. A non-nominal type is any type which is not nominal. They are sometimes called \"structural types\" because they are usually obtained by composing other types. Examples include function types like `(Int) -> (String)`, tuple types like `(Int, String)`, metatypes like `Int.Type`, and special types like `Any` and `AnyObject`."
                    },
                    {
                        "filename": "userdocs/diagnostics/property-wrapper-requirements.md",
                        "code": "@@ -1,5 +1,4 @@\n-Property Wrapper Implementation Requirements\n----\n+# Property Wrapper Implementation Requirements\n If a type is marked with the `@propertyWrapper` attribute, it must meet certain requirements to be a valid property wrapper.\n \n First, all property wrapper types must have a property named `wrappedValue`. This property cannot be static and must have the same access level as the property wrapper type. If the property wrapper provides a `projectedValue` property, it is subject to the same requirements."
                    }
                ]
            },
            {
                "date": "2020-03-05T03:01:43Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/592ce68c5573f23de3ab3b83303899f176c9c748",
                "changes": [
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -37,6 +37,9 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   // implicitly associated with it. Uses `std::unique_ptr` so that\n   // `AnnotatedSourceSnippet` can be forward declared.\n   std::unique_ptr<AnnotatedSourceSnippet> currentSnippet;\n+  // Educational notes which are buffered until the consumer is finished\n+  // constructing a snippet.\n+  SmallVector<std::string, 1> BufferedEducationalNotes;\n \n public:\n   PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs());"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -898,6 +898,10 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n       currentSnippet = std::make_unique<AnnotatedSourceSnippet>(SM);\n       annotateSnippetWithInfo(SM, Info, *currentSnippet);\n     }\n+    for (auto path : Info.EducationalNotePaths) {\n+      if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n+        BufferedEducationalNotes.push_back(buffer->get()->getBuffer().str());\n+    }\n   } else {\n     printDiagnostic(SM, Info);\n \n@@ -929,6 +933,13 @@ void PrintingDiagnosticConsumer::flush(bool includeTrailingBreak) {\n     }\n     currentSnippet.reset();\n   }\n+\n+  for (auto note : BufferedEducationalNotes) {\n+    printMarkdown(note, Stream, ForceColors);\n+    Stream << \"\\n\";\n+  }\n+\n+  BufferedEducationalNotes.clear();\n }\n \n bool PrintingDiagnosticConsumer::finishProcessing() {"
                    },
                    {
                        "filename": "test/diagnostics/educational-notes.swift",
                        "code": "@@ -1,5 +1,6 @@\n // RUN: not %target-swift-frontend -color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace\n // RUN: not %target-swift-frontend -no-color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace --check-prefix=NO-COLOR\n+// RUN: not %target-swift-frontend -enable-experimental-diagnostic-formatting -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --check-prefix=CHECK-DESCRIPTIVE\n \n // A diagnostic with no educational notes\n let x = 1 +\n@@ -66,3 +67,18 @@ extension (Int, Int) {}\n // NO-COLOR-NEXT:--------------\n // NO-COLOR-NEXT:Header 1\n // NO-COLOR-NEXT:Header 3\n+\n+// CHECK-DESCRIPTIVE: educational-notes.swift\n+// CHECK-DESCRIPTIVE-NEXT:  | // A diagnostic with an educational note\n+// CHECK-DESCRIPTIVE-NEXT:  | extension (Int, Int) {}\n+// CHECK-DESCRIPTIVE-NEXT:  | ^ error: expected expression after operator\n+// CHECK-DESCRIPTIVE-NEXT:  |\n+\n+// CHECK-DESCRIPTIVE: educational-notes.swift\n+// CHECK-DESCRIPTIVE-NEXT:  | // A diagnostic with an educational note\n+// CHECK-DESCRIPTIVE-NEXT:  | extension (Int, Int) {}\n+// CHECK-DESCRIPTIVE-NEXT:  |           ~~~~~~~~~~\n+// CHECK-DESCRIPTIVE-NEXT:  | ^ error: non-nominal type '(Int, Int)' cannot be extended\n+// CHECK-DESCRIPTIVE-NEXT:  |\n+// CHECK-DESCRIPTIVE-NEXT: Nominal Types\n+// CHECK-DESCRIPTIVE-NEXT: -------------"
                    }
                ]
            },
            {
                "date": "2020-03-10T21:48:39Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/72fba7db8ad52361d448110ff1a314bb55e99c69",
                "changes": [
                    {
                        "filename": "include/swift/AST/EducationalNotes.def",
                        "code": "@@ -21,6 +21,9 @@\n \n // EDUCATIONAL_NOTES(DIAG_ID, EDUCATIONAL_NOTE_FILENAMES...)\n \n+EDUCATIONAL_NOTES(unsupported_existential_type,\n+                  \"associated-type-requirements.md\")\n+\n EDUCATIONAL_NOTES(non_nominal_no_initializers, \"nominal-types.md\")\n EDUCATIONAL_NOTES(non_nominal_extension, \"nominal-types.md\")\n EDUCATIONAL_NOTES(associated_type_witness_conform_impossible,"
                    },
                    {
                        "filename": "userdocs/diagnostics/associated-type-requirements.md",
                        "code": "@@ -0,0 +1,23 @@\n+Using Protocols with `Self` or Associated Type Requirements\n+---\n+Protocols in Swift may be used as types, as part of a generic constraint, or as part of an opaque result type.\n+```\n+// CustomStringConvertible can be used as a type.\n+func foo(bar: CustomStringConvertible) { /* ... */ }\n+\n+// ...or as a generic constraint on 'T'.\n+func bar<T: CustomStringConvertible>(baz: T) { /* ... */ }\n+\n+// ...or as part of an opaque result type.\n+func baz() -> some CustomStringConvertible { /* ... */ }\n+```\n+\n+While all Swift protocols can be used as generic constraints and as part of opaque result types, not all protocols can be used as types in general. Specifically, if a protocol has a requirement which references `Self` or an associated type, it cannot be used as a type. One such protocol is `Identifiable`, which has the requirement `var id: ID { get }`, where `ID` is an associated type. As a result, the following code is not allowed:\n+```\n+func foo(bar: Identifiable) { /* ... */ }\n+// error: protocol 'Identifiable' can only be used as a generic constraint because it has Self or associated type requirements\n+```\n+\n+Protocols like `Identifiable` which have `Self` or associated type requirements cannot be used as types because such types would rarely be useful in practice. They would be unable to allow use of `Self` or associated type requirements like `var id: ID { get }` because the associated type is not specified.\n+\n+When working with protocols having `Self` or associated type requirements constrained generics, opaque result types, or manual type erasure is sufficient to support most use cases. To learn more, see the [Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html), [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html), and [Opaque Types](https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html) sections of _The Swift Programming Language_.\n\\ No newline at end of file"
                    }
                ]
            },
            {
                "date": "2020-03-02T03:21:08Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/16e84e3c1cd668de249b4b726f46fafba0bb343f",
                "changes": [
                    {
                        "filename": "include/swift/AST/EducationalNotes.def",
                        "code": "@@ -21,6 +21,9 @@\n \n // EDUCATIONAL_NOTES(DIAG_ID, EDUCATIONAL_NOTE_FILENAMES...)\n \n+EDUCATIONAL_NOTES(unsupported_existential_type,\n+                  \"associated-type-requirements.md\")\n+\n EDUCATIONAL_NOTES(non_nominal_no_initializers, \"nominal-types.md\")\n EDUCATIONAL_NOTES(non_nominal_extension, \"nominal-types.md\")\n EDUCATIONAL_NOTES(associated_type_witness_conform_impossible,"
                    },
                    {
                        "filename": "userdocs/diagnostics/associated-type-requirements.md",
                        "code": "@@ -0,0 +1,23 @@\n+Using Protocols with `Self` or Associated Type Requirements\n+---\n+Protocols in Swift may be used as types, as part of a generic constraint, or as part of an opaque result type.\n+```\n+// CustomStringConvertible can be used as a type.\n+func foo(bar: CustomStringConvertible) { /* ... */ }\n+\n+// ...or as a generic constraint on 'T'.\n+func bar<T: CustomStringConvertible>(baz: T) { /* ... */ }\n+\n+// ...or as part of an opaque result type.\n+func baz() -> some CustomStringConvertible { /* ... */ }\n+```\n+\n+While all Swift protocols can be used as generic constraints and as part of opaque result types, not all protocols can be used as types in general. Specifically, if a protocol has a requirement which references `Self` or an associated type, it cannot be used as a type. One such protocol is `Identifiable`, which has the requirement `var id: ID { get }`, where `ID` is an associated type. As a result, the following code is not allowed:\n+```\n+func foo(bar: Identifiable) { /* ... */ }\n+// error: protocol 'Identifiable' can only be used as a generic constraint because it has Self or associated type requirements\n+```\n+\n+Protocols like `Identifiable` which have `Self` or associated type requirements cannot be used as types because such types would rarely be useful in practice. They would be unable to allow use of `Self` or associated type requirements like `var id: ID { get }` because the associated type is not specified.\n+\n+When working with protocols having `Self` or associated type requirements constrained generics, opaque result types, or manual type erasure is sufficient to support most use cases. To learn more, see the [Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html), [Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html), and [Opaque Types](https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html) sections of _The Swift Programming Language_.\n\\ No newline at end of file"
                    }
                ]
            },
            {
                "date": "2019-12-06T04:00:01Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/d68089dcf982aeb2c7251ca0f3bf5bb5361d253e",
                "changes": [
                    {
                        "filename": "include/swift/Markup/Markup.h",
                        "code": "@@ -60,6 +60,7 @@ class MarkupContext final {\n   LineList getLineList(swift::RawComment RC);\n };\n \n+Document *parseDocument(MarkupContext &MC, StringRef String);\n Document *parseDocument(MarkupContext &MC, LineList &LL);\n \n } // namespace markup"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -18,6 +18,7 @@\n #include \"swift/AST/DiagnosticEngine.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/SourceManager.h\"\n+#include \"swift/Markup/Markup.h\"\n #include \"llvm/ADT/SmallString.h\"\n #include \"llvm/ADT/StringRef.h\"\n #include \"llvm/ADT/Twine.h\"\n@@ -28,6 +29,7 @@\n #include <algorithm>\n \n using namespace swift;\n+using namespace swift::markup;\n \n namespace {\n   class ColoredStream : public raw_ostream {\n@@ -85,6 +87,190 @@ namespace {\n     size_t preferred_buffer_size() const override { return 0; }\n   };\n \n+// MARK: Markdown Printing\n+    class TerminalMarkupPrinter : public MarkupASTVisitor<TerminalMarkupPrinter> {\n+      llvm::raw_ostream &OS;\n+      unsigned Indent;\n+      unsigned ShouldBold;\n+\n+      void indent(unsigned Amount = 2) { Indent += Amount; }\n+\n+      void dedent(unsigned Amount = 2) {\n+        assert(Indent >= Amount && \"dedent without matching indent\");\n+        Indent -= Amount;\n+      }\n+\n+      void bold() {\n+        ++ShouldBold;\n+        updateFormatting();\n+      }\n+\n+      void unbold() {\n+        assert(ShouldBold > 0 && \"unbolded without matching bold\");\n+        --ShouldBold;\n+        updateFormatting();\n+      }\n+\n+      void updateFormatting() {\n+        OS.resetColor();\n+        if (ShouldBold > 0)\n+          OS.changeColor(raw_ostream::Colors::SAVEDCOLOR, true);\n+      }\n+\n+      void print(StringRef Str) {\n+        for (auto c : Str) {\n+          OS << c;\n+          if (c == '\\n')\n+            for (unsigned i = 0; i < Indent; ++i)\n+              OS << ' ';\n+        }\n+      }\n+\n+    public:\n+      TerminalMarkupPrinter(llvm::raw_ostream &OS)\n+          : OS(OS), Indent(0), ShouldBold(0) {}\n+\n+      void printNewline() { print(\"\\n\"); }\n+\n+      void visitDocument(const Document *D) {\n+        for (const auto *Child : D->getChildren()) {\n+          if (Child->getKind() == ASTNodeKind::Paragraph) {\n+            // Add a newline before top-level paragraphs\n+            printNewline();\n+          }\n+          visit(Child);\n+        }\n+      }\n+\n+      void visitBlockQuote(const BlockQuote *BQ) {\n+        indent();\n+        printNewline();\n+        for (const auto *Child : BQ->getChildren())\n+          visit(Child);\n+        dedent();\n+      }\n+\n+      void visitList(const List *BL) {\n+        indent();\n+        printNewline();\n+        for (const auto *Child : BL->getChildren())\n+          visit(Child);\n+        dedent();\n+      }\n+\n+      void visitItem(const Item *I) {\n+        print(\"- \");\n+        for (const auto *N : I->getChildren())\n+          visit(N);\n+      }\n+\n+      void visitCodeBlock(const CodeBlock *CB) {\n+        indent();\n+        printNewline();\n+        print(CB->getLiteralContent());\n+        dedent();\n+      }\n+\n+      void visitCode(const Code *C) {\n+        print(\"'\");\n+        print(C->getLiteralContent());\n+        print(\"'\");\n+      }\n+\n+      void visitHTML(const HTML *H) { print(H->getLiteralContent()); }\n+\n+      void visitInlineHTML(const InlineHTML *IH) {\n+        print(IH->getLiteralContent());\n+      }\n+\n+      void visitSoftBreak(const SoftBreak *SB) { printNewline(); }\n+\n+      void visitLineBreak(const LineBreak *LB) {\n+        printNewline();\n+        printNewline();\n+      }\n+\n+      void visitLink(const Link *L) {\n+        print(\"[\");\n+        for (const auto *Child : L->getChildren())\n+          visit(Child);\n+        print(\"](\");\n+        print(L->getDestination());\n+        print(\")\");\n+      }\n+\n+      void visitImage(const Image *I) { llvm_unreachable(\"unsupported\"); }\n+\n+      void visitParagraph(const Paragraph *P) {\n+        for (const auto *Child : P->getChildren())\n+          visit(Child);\n+        printNewline();\n+      }\n+\n+      // TODO: add raw_ostream support for italics ANSI codes in LLVM.\n+      void visitEmphasis(const Emphasis *E) {\n+        for (const auto *Child : E->getChildren())\n+          visit(Child);\n+      }\n+\n+      void visitStrong(const Strong *E) {\n+        bold();\n+        for (const auto *Child : E->getChildren())\n+          visit(Child);\n+        unbold();\n+      }\n+\n+      void visitHRule(const HRule *HR) {\n+        print(\"--------------\");\n+        printNewline();\n+      }\n+\n+      void visitHeader(const Header *H) {\n+        bold();\n+        for (const auto *Child : H->getChildren())\n+          visit(Child);\n+        unbold();\n+        printNewline();\n+      }\n+\n+      void visitText(const Text *T) { print(T->getLiteralContent()); }\n+\n+      void visitPrivateExtension(const PrivateExtension *PE) {\n+        llvm_unreachable(\"unsupported\");\n+      }\n+\n+      void visitParamField(const ParamField *PF) {\n+        llvm_unreachable(\"unsupported\");\n+      }\n+\n+      void visitReturnField(const ReturnsField *RF) {\n+        llvm_unreachable(\"unsupported\");\n+      }\n+\n+      void visitThrowField(const ThrowsField *TF) {\n+        llvm_unreachable(\"unsupported\");\n+      }\n+\n+  #define MARKUP_SIMPLE_FIELD(Id, Keyword, XMLKind)                              \\\n+    void visit##Id(const Id *Field) { llvm_unreachable(\"unsupported\"); }\n+  #include \"swift/Markup/SimpleFields.def\"\n+    };\n+\n+    static void printMarkdown(StringRef Content, raw_ostream &Out,\n+                              bool UseColor) {\n+      markup::MarkupContext ctx;\n+      auto document = markup::parseDocument(ctx, Content);\n+      if (UseColor) {\n+        ColoredStream stream{Out};\n+        TerminalMarkupPrinter printer(stream);\n+        printer.visit(document);\n+      } else {\n+        NoColorStream stream{Out};\n+        TerminalMarkupPrinter printer(stream);\n+        printer.visit(document);\n+      }\n+    }\n+\n   // MARK: Experimental diagnostic printing.\n \n   static void printDiagnosticKind(DiagnosticKind kind, raw_ostream &out) {\n@@ -716,8 +902,10 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n     printDiagnostic(SM, Info);\n \n     for (auto path : Info.EducationalNotePaths) {\n-      if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n-        Stream << buffer->get()->getBuffer() << \"\\n\";\n+      if (auto buffer = SM.getFileSystem()->getBufferForFile(path)) {\n+        printMarkdown(buffer->get()->getBuffer(), Stream, ForceColors);\n+        Stream << \"\\n\";\n+      }\n     }\n \n     for (auto ChildInfo : Info.ChildDiagnosticInfo) {"
                    },
                    {
                        "filename": "lib/Markup/Markup.cpp",
                        "code": "@@ -54,7 +54,7 @@ struct ParseResult {\n   }\n };\n \n-StringRef getLiteralContent(MarkupContext &MC, LineList &LL, cmark_node *Node) {\n+StringRef getLiteralContent(MarkupContext &MC, cmark_node *Node) {\n   // Literal content nodes never have start/end column line information.\n   // It is a floating piece of text that inherits location information from\n   // its parent.\n@@ -63,50 +63,45 @@ StringRef getLiteralContent(MarkupContext &MC, LineList &LL, cmark_node *Node) {\n   return MC.allocateCopy(StringRef(Literal));\n }\n \n-ParseResult<MarkupASTNode>\n-parseElement(MarkupContext &MC, LineList &LL, ParseState State);\n+ParseResult<MarkupASTNode> parseElement(MarkupContext &MC, ParseState State);\n \n-ParseState parseChildren(MarkupContext &MC, LineList &LL, ParseState State,\n+ParseState parseChildren(MarkupContext &MC, ParseState State,\n                          SmallVectorImpl<MarkupASTNode *> &Children) {\n   auto Root = State.Node;\n   State = State.next();\n   do {\n     if (Root == State.Node && State.Event == CMARK_EVENT_EXIT)\n       break;\n-    auto Result = parseElement(MC, LL, State);\n+    auto Result = parseElement(MC, State);\n     Children.push_back(Result.Node);\n     State = Result.State;\n   } while (!(Root == State.Node && State.Event == CMARK_EVENT_EXIT));\n   return State;\n }\n \n-ParseResult<Text> parseText(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<Text> parseText(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_TEXT\n       && State.Event == CMARK_EVENT_ENTER);\n-  return { Text::create(MC, getLiteralContent(MC, LL, State.Node)),\n-           State.next() };\n+  return {Text::create(MC, getLiteralContent(MC, State.Node)), State.next()};\n }\n \n-ParseResult<BlockQuote> parseBlockQuote(MarkupContext &MC, LineList &LL,\n-                                        ParseState State) {\n+ParseResult<BlockQuote> parseBlockQuote(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_BLOCK_QUOTE\n       && State.Event == CMARK_EVENT_ENTER);\n   SmallVector<MarkupASTNode *, 4> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { BlockQuote::create(MC, Children), ResultState.next() };\n }\n \n-ParseResult<Code> parseCode(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<Code> parseCode(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_CODE\n       && State.Event == CMARK_EVENT_ENTER);\n-  return { Code::create(MC, getLiteralContent(MC, LL, State.Node)),\n-           State.next() };\n+  return {Code::create(MC, getLiteralContent(MC, State.Node)), State.next()};\n }\n \n-ParseResult<CodeBlock> parseCodeBlock(MarkupContext &MC, LineList &LL,\n-                                      ParseState State) {\n+ParseResult<CodeBlock> parseCodeBlock(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_CODE_BLOCK\n       && State.Event == CMARK_EVENT_ENTER);\n \n@@ -117,69 +112,62 @@ ParseResult<CodeBlock> parseCodeBlock(MarkupContext &MC, LineList &LL,\n     if (!FenceInfoStr.empty())\n       Language = MC.allocateCopy(FenceInfoStr);\n   }\n-  return { CodeBlock::create(MC, getLiteralContent(MC, LL, State.Node),\n-                             Language),\n-           State.next() };\n+  return {CodeBlock::create(MC, getLiteralContent(MC, State.Node), Language),\n+          State.next()};\n }\n \n-ParseResult<Emphasis> parseEmphasis(MarkupContext &MC, LineList &LL,\n-                                    ParseState State) {\n+ParseResult<Emphasis> parseEmphasis(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_EMPH\n       && State.Event == CMARK_EVENT_ENTER);\n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Emphasis::create(MC, Children), ResultState.next() };\n }\n \n-ParseResult<Strong> parseStrong(MarkupContext &MC, LineList &LL,\n-                                ParseState State) {\n+ParseResult<Strong> parseStrong(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_STRONG\n       && State.Event == CMARK_EVENT_ENTER);\n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Strong::create(MC, Children), ResultState.next() };\n }\n \n-ParseResult<Header> parseHeader(MarkupContext &MC, LineList &LL,\n-                                ParseState State) {\n+ParseResult<Header> parseHeader(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_HEADER\n       && State.Event == CMARK_EVENT_ENTER);\n   auto Level = cmark_node_get_header_level(State.Node);\n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   (void) ResultState;\n   return { Header::create(MC, Level, Children), State.next() };\n }\n \n-ParseResult<HRule> parseHRule(MarkupContext &MC, LineList &LL,\n-                              ParseState State) {\n+ParseResult<HRule> parseHRule(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_HRULE\n       && State.Event == CMARK_EVENT_ENTER);\n   return { HRule::create(MC), State.next() };\n }\n \n-ParseResult<HTML> parseHTML(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<HTML> parseHTML(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_HTML\n       && State.Event == CMARK_EVENT_ENTER);\n-  return { HTML::create(MC, getLiteralContent(MC, LL, State.Node)),\n-           State.next() };\n+  return {HTML::create(MC, getLiteralContent(MC, State.Node)), State.next()};\n }\n \n-ParseResult<InlineHTML> parseInlineHTML(MarkupContext &MC, LineList &LL,\n-                                        ParseState State) {\n+ParseResult<InlineHTML> parseInlineHTML(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_INLINE_HTML\n       && State.Event == CMARK_EVENT_ENTER);\n-  return { InlineHTML::create(MC, getLiteralContent(MC, LL, State.Node)),\n-           State.next() };\n+  return {InlineHTML::create(MC, getLiteralContent(MC, State.Node)),\n+          State.next()};\n }\n \n-ParseResult<Image> parseImage(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<Image> parseImage(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_IMAGE\n       && State.Event == CMARK_EVENT_ENTER);\n   std::string Destination(cmark_node_get_url(State.Node));\n@@ -189,139 +177,134 @@ ParseResult<Image> parseImage(MarkupContext &MC, LineList &LL, ParseState State)\n   auto Title = TitleString.empty() ? None : Optional<StringRef>(TitleString);\n \n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Image::create(MC, Destination, Title, Children), ResultState.next() };\n }\n \n-ParseResult<Item> parseItem(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<Item> parseItem(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_ITEM\n       && State.Event == CMARK_EVENT_ENTER);\n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Item::create(MC, Children), ResultState.next() };\n }\n \n-ParseResult<LineBreak> parseLineBreak(MarkupContext &MC, LineList &LL,\n-    ParseState State) {\n+ParseResult<LineBreak> parseLineBreak(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_LINEBREAK\n       && State.Event == CMARK_EVENT_ENTER);\n   return { LineBreak::create(MC), State.next() };\n }\n \n-ParseResult<SoftBreak> parseSoftBreak(MarkupContext &MC, LineList &LL,\n-    ParseState State) {\n+ParseResult<SoftBreak> parseSoftBreak(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_SOFTBREAK\n       && State.Event == CMARK_EVENT_ENTER);\n   return { SoftBreak::create(MC), State.next() };\n }\n \n-ParseResult<Link> parseLink(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<Link> parseLink(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_LINK\n       && State.Event == CMARK_EVENT_ENTER);\n   std::string Destination(cmark_node_get_url(State.Node));\n   SmallVector<MarkupASTNode *, 2> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Link::create(MC, Destination, Children), ResultState.next() };\n }\n \n-ParseResult<List> parseList(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<List> parseList(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_LIST\n       && State.Event == CMARK_EVENT_ENTER);\n   auto ListRoot = State.Node;\n   auto IsOrdered = cmark_node_get_list_type(ListRoot) == CMARK_ORDERED_LIST;\n   SmallVector<MarkupASTNode *, 3> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { List::create(MC, Children, IsOrdered), ResultState.next() };\n }\n \n-ParseResult<Paragraph> parseParagraph(MarkupContext &MC, LineList &LL,\n-                                      ParseState State) {\n+ParseResult<Paragraph> parseParagraph(MarkupContext &MC, ParseState State) {\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_PARAGRAPH\n       && State.Event == CMARK_EVENT_ENTER);\n   SmallVector<MarkupASTNode *, 3> Children;\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   return { Paragraph::create(MC, Children), ResultState.next() };\n }\n \n-ParseResult<MarkupASTNode>\n-parseElement(MarkupContext &MC, LineList &LL, ParseState State) {\n+ParseResult<MarkupASTNode> parseElement(MarkupContext &MC, ParseState State) {\n   assert(State.Event == CMARK_EVENT_ENTER);\n   auto NodeType = cmark_node_get_type(State.Node);\n   switch (NodeType) {\n   case CMARK_NODE_DOCUMENT: {\n     llvm_unreachable(\"Markup documents cannot be nested\");\n   }\n   case CMARK_NODE_BLOCK_QUOTE: {\n-    return parseBlockQuote(MC, LL, State);\n+    return parseBlockQuote(MC, State);\n   }\n   case CMARK_NODE_CODE: {\n-    return parseCode(MC, LL, State);\n+    return parseCode(MC, State);\n   }\n   case CMARK_NODE_CODE_BLOCK: {\n-    return parseCodeBlock(MC, LL, State);\n+    return parseCodeBlock(MC, State);\n   }\n   case CMARK_NODE_EMPH: {\n-    return parseEmphasis(MC, LL, State);\n+    return parseEmphasis(MC, State);\n   }\n   case CMARK_NODE_HEADER: {\n-    return parseHeader(MC, LL, State);\n+    return parseHeader(MC, State);\n   }\n   case CMARK_NODE_HRULE: {\n-    return parseHRule(MC, LL, State);\n+    return parseHRule(MC, State);\n   }\n   case CMARK_NODE_HTML: {\n-    return parseHTML(MC, LL, State);\n+    return parseHTML(MC, State);\n   }\n   case CMARK_NODE_IMAGE: {\n-    return parseImage(MC, LL, State);\n+    return parseImage(MC, State);\n   }\n   case CMARK_NODE_INLINE_HTML: {\n-    return parseInlineHTML(MC, LL, State);\n+    return parseInlineHTML(MC, State);\n   }\n   case CMARK_NODE_ITEM: {\n-    return parseItem(MC, LL, State);\n+    return parseItem(MC, State);\n   }\n   case CMARK_NODE_LINEBREAK: {\n-    return parseLineBreak(MC, LL, State);\n+    return parseLineBreak(MC, State);\n   }\n   case CMARK_NODE_LINK: {\n-    return parseLink(MC, LL, State);\n+    return parseLink(MC, State);\n   }\n   case CMARK_NODE_LIST: {\n-    return parseList(MC, LL, State);\n+    return parseList(MC, State);\n   }\n   case CMARK_NODE_PARAGRAPH: {\n-    return parseParagraph(MC, LL, State);\n+    return parseParagraph(MC, State);\n   }\n   case CMARK_NODE_SOFTBREAK: {\n-    return parseSoftBreak(MC, LL, State);\n+    return parseSoftBreak(MC, State);\n   }\n   case CMARK_NODE_STRONG: {\n-    return parseStrong(MC, LL, State);\n+    return parseStrong(MC, State);\n   }\n   case CMARK_NODE_TEXT: {\n-    return parseText(MC, LL, State);\n+    return parseText(MC, State);\n   }\n   default: {\n     llvm_unreachable(\"Can't parse a Markup node of type 'None'\");\n   }\n   }\n }\n \n-Document *swift::markup::parseDocument(MarkupContext &MC, LineList &LL) {\n-  auto Comment = LL.str();\n-  auto CMarkDoc = cmark_parse_document(Comment.c_str(), Comment.size(),\n-                                       CMARK_OPT_SMART);\n+static Document *parseDocumentImpl(MarkupContext &MC, StringRef String) {\n+  auto CMarkDoc =\n+      cmark_parse_document(String.data(), String.size(), CMARK_OPT_SMART);\n \n   if (CMarkDoc == nullptr)\n     return nullptr;\n@@ -332,7 +315,7 @@ Document *swift::markup::parseDocument(MarkupContext &MC, LineList &LL) {\n   SmallVector<MarkupASTNode *, 8> Children;\n   assert(cmark_node_get_type(State.Node) == CMARK_NODE_DOCUMENT\n       && State.Event == CMARK_EVENT_ENTER);\n-  auto ResultState = parseChildren(MC, LL, State, Children);\n+  auto ResultState = parseChildren(MC, State, Children);\n   assert(State.Node == ResultState.Node\n       && ResultState.Event == CMARK_EVENT_EXIT);\n   State = ResultState.next();\n@@ -341,3 +324,11 @@ Document *swift::markup::parseDocument(MarkupContext &MC, LineList &LL) {\n   cmark_iter_free(State.Iter);\n   return Document::create(MC, Children);\n }\n+\n+Document *swift::markup::parseDocument(MarkupContext &MC, LineList &LL) {\n+  return parseDocumentImpl(MC, LL.str());\n+}\n+\n+Document *swift::markup::parseDocument(MarkupContext &MC, StringRef String) {\n+  return parseDocumentImpl(MC, MC.allocateCopy(String));\n+}"
                    },
                    {
                        "filename": "test/diagnostics/educational-notes.swift",
                        "code": "@@ -1,15 +1,68 @@\n-// RUN: not %target-swift-frontend -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s\n+// RUN: not %target-swift-frontend -color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace\n+// RUN: not %target-swift-frontend -no-color-diagnostics -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s --match-full-lines --strict-whitespace --check-prefix=NO-COLOR\n \n // A diagnostic with no educational notes\n let x = 1 +\n-// CHECK: error: expected expression after operator\n+// CHECK:{{.*}}[0m\u001b[0;1;31merror: \u001b[0m\u001b[1mexpected expression after operator\n // CHECK-NOT: {{-+$}}\n \n-// A diagnostic with an educational note\n+// NO-COLOR:{{.*}}error: expected expression after operator\n+// NO-COLOR-NOT: {{-+$}}\n+\n+// A diagnostic with an educational note using supported markdown features\n extension (Int, Int) {}\n-// CHECK: error: non-nominal type '(Int, Int)' cannot be extended\n-// CHECK-NEXT: extension (Int, Int) {}\n-// CHECK-NEXT: ^         ~~~~~~~~~~\n-// CHECK-NEXT: Nominal Types\n-// CHECK-NEXT: -------------\n-// CHECK-NEXT: Nominal types documentation content\n+// CHECK:{{.*}}[0m\u001b[0;1;31merror: \u001b[0m\u001b[1mnon-nominal type '(Int, Int)' cannot be extended\n+// CHECK-NEXT:\u001b[0mextension (Int, Int) {}\n+// CHECK-NEXT:\u001b[0;1;32m^         ~~~~~~~~~~\n+// CHECK-NEXT:\u001b[0m\u001b[0m\u001b[1mNominal Types\u001b[0m\n+// CHECK-NEXT:--------------\n+// CHECK-EMPTY:\n+// CHECK-NEXT:Nominal types documentation content. This is a paragraph\n+// CHECK-EMPTY:\n+// CHECK-NEXT:  blockquote\n+// CHECK-NEXT:  {{$}}\n+// CHECK-NEXT:  - item 1\n+// CHECK-NEXT:  - item 2\n+// CHECK-NEXT:  - item 3\n+// CHECK-NEXT:  {{$}}\n+// CHECK-NEXT:  let x = 42\n+// CHECK-NEXT:  if x > 0 {\n+// CHECK-NEXT:    print(\"positive\")\n+// CHECK-NEXT:  }\n+// CHECK-NEXT:  {{$}}\n+// CHECK-NEXT:Type 'MyClass'\n+// CHECK-EMPTY:\n+// CHECK-NEXT:[Swift](swift.org)\n+// CHECK-EMPTY:\n+// CHECK-NEXT:\u001b[0m\u001b[1mbold\u001b[0m italics\n+// CHECK-NEXT:--------------\n+// CHECK-NEXT:\u001b[0m\u001b[1mHeader 1\u001b[0m\n+// CHECK-NEXT:\u001b[0m\u001b[1mHeader 3\u001b[0m\n+\n+// NO-COLOR:{{.*}}error: non-nominal type '(Int, Int)' cannot be extended\n+// NO-COLOR-NEXT:extension (Int, Int) {}\n+// NO-COLOR-NEXT:^         ~~~~~~~~~~\n+// NO-COLOR-NEXT:Nominal Types\n+// NO-COLOR-NEXT:--------------\n+// NO-COLOR-EMPTY:\n+// NO-COLOR-NEXT:Nominal types documentation content. This is a paragraph\n+// NO-COLOR-EMPTY:\n+// NO-COLOR-NEXT:  blockquote\n+// NO-COLOR-NEXT:  {{$}}\n+// NO-COLOR-NEXT:  - item 1\n+// NO-COLOR-NEXT:  - item 2\n+// NO-COLOR-NEXT:  - item 3\n+// NO-COLOR-NEXT:  {{$}}\n+// NO-COLOR-NEXT:  let x = 42\n+// NO-COLOR-NEXT:  if x > 0 {\n+// NO-COLOR-NEXT:    print(\"positive\")\n+// NO-COLOR-NEXT:  }\n+// NO-COLOR-NEXT:  {{$}}\n+// NO-COLOR-NEXT:Type 'MyClass'\n+// NO-COLOR-EMPTY:\n+// NO-COLOR-NEXT:[Swift](swift.org)\n+// NO-COLOR-EMPTY:\n+// NO-COLOR-NEXT:bold italics\n+// NO-COLOR-NEXT:--------------\n+// NO-COLOR-NEXT:Header 1\n+// NO-COLOR-NEXT:Header 3"
                    },
                    {
                        "filename": "test/diagnostics/test-docs/nominal-types.md",
                        "code": "@@ -1,3 +1,27 @@\n-Nominal Types\n--------------\n-Nominal types documentation content\n+# Nominal Types\n+***\n+Nominal types documentation content. This is a paragraph\n+\n+> blockquote\n+\n+- item 1\n+- item 2\n+- item 3\n+\n+```\n+let x = 42\n+if x > 0 {\n+  print(\"positive\")\n+}\n+```\n+\n+Type `MyClass`\n+\n+[Swift](swift.org)\n+\n+**bold** *italics*\n+\n+***\n+\n+# Header 1\n+### Header 3\n\\ No newline at end of file"
                    },
                    {
                        "filename": "userdocs/diagnostics/nominal-types.md",
                        "code": "@@ -1,7 +1,7 @@\n-Nominal types\n--------------\n-In Swift, a type is considered a nominal type if it is named.  In other words, it has been defined by declaring the type somewhere in code. Examples of nominal types include classes, structs and enums, all of which must be declared before using them. Nominal types are an important concept in Swift because they can be extended, explicitly initialized using the 'MyType()' syntax, and may conform to protocols.\n+## Nominal types\n+***\n+In Swift, a type is considered a nominal type if it is named.  In other words, it has been defined by declaring the type somewhere in code. Examples of nominal types include classes, structs and enums, all of which must be declared before using them. Nominal types are an important concept in Swift because they can be extended, explicitly initialized using the `MyType()` syntax, and may conform to protocols.\n \n-In contrast, non-nominal types have none of these capabilities. A non-nominal type is any type which is not nominal. They are sometimes called \u201dstructural types\u201d because they are usually obtained by composing other types. Examples include function types like '(Int) -> (String)', tuple types like '(Int, String)', metatypes like 'Int.Type', and special types like 'Any' and 'AnyObject'.\n+In contrast, non-nominal types have none of these capabilities. A non-nominal type is any type which is not nominal. They are sometimes called \"structural types\" because they are usually obtained by composing other types. Examples include function types like `(Int) -> (String)`, tuple types like `(Int, String)`, metatypes like `Int.Type`, and special types like `Any` and `AnyObject`.\n \n-Whether the name of a protocol refers to a nominal or non-nominal type depends on where it appears in code. When used in a declaration or extension like 'extension MyProtocol { \u2026 }', 'MyProtocol' refers to a protocol type, which is nominal. This means that it may be extended and conform to protocols. However, when written as the type of a constant or variable, MyProtocol instead refers to a non-nominal, existential type. As a result, code like 'let value: MyProtocol = MyProtocol()' is not allowed because 'MyProtocol' refers to a non-nominal type in this context and cannot be explicitly initialized.\n+Whether the name of a protocol refers to a nominal or non-nominal type depends on where it appears in code. When used in a declaration or extension like `extension MyProtocol { \u2026 }`, `MyProtocol` refers to a protocol type, which is nominal. This means that it may be extended and conform to protocols. However, when written as the type of a constant or variable, `MyProtocol` instead refers to a non-nominal, existential type. As a result, code like `let value: MyProtocol = MyProtocol()` is not allowed because `MyProtocol` refers to a non-nominal type in this context and cannot be explicitly initialized."
                    }
                ]
            },
            {
                "date": "2020-03-05T20:41:04Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/0ffb727dfe3ffbd598f79c277814c22a1b218616",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsFrontend.def",
                        "code": "@@ -381,6 +381,32 @@ REMARK(interface_file_lock_failure,none,\n REMARK(interface_file_lock_timed_out,none,\n       \"timed out waiting to acquire lock file for module interface '%0'\", (StringRef))\n \n+// Dependency Verifier Diagnostics\n+ERROR(dependency_cascading_mismatch,none,\n+      \"expected %select{cascading|non-cascading}0 dependency; found \"\n+      \"%select{cascading|non-cascading}1 dependency instead\",\n+      (bool, bool))\n+ERROR(potential_dependency_cascading_mismatch,none,\n+      \"expected %select{cascading|non-cascading}0 potential member dependency; \"\n+      \"found %select{cascading|non-cascading}1 potential member dependency \"\n+      \"instead\", (bool, bool))\n+ERROR(missing_member_dependency,none,\n+      \"expected \"\n+      \"%select{%error|provided|member|potential member|dynamic member}0 \"\n+      \"dependency does not exist: %1\",\n+      (/*Expectation::Kind*/uint8_t, StringRef))\n+ERROR(unexpected_dependency,none,\n+      \"unexpected %0 %select{%error|%error||potential member|dynamic member}1 \"\n+      \"dependency: %2\", (StringRef, /*Expectation::Kind*/uint8_t, StringRef))\n+ERROR(unexpected_provided_entity,none,\n+      \"unexpected provided entity: %0\", (StringRef))\n+ERROR(negative_expectation_violated,none,\n+      \"unexpected dependency exists: %0\", (StringRef))\n+ERROR(expectation_missing_opening_braces,none,\n+      \"expected {{ in expectation\", ())\n+ERROR(expectation_missing_closing_braces,none,\n+      \"didn't find '}}' to match '{{' in expectation\", ())\n+\n #ifndef DIAG_NO_UNDEF\n # if defined(DIAG)\n #  undef DIAG"
                    },
                    {
                        "filename": "lib/Frontend/DependencyVerifier.cpp",
                        "code": "@@ -18,9 +18,10 @@\n #include \"swift/AST/ASTContext.h\"\n #include \"swift/AST/ASTMangler.h\"\n #include \"swift/AST/ASTPrinter.h\"\n+#include \"swift/AST/DiagnosticsFrontend.h\"\n #include \"swift/AST/SourceFile.h\"\n-#include \"swift/Demangling/Demangler.h\"\n #include \"swift/Basic/OptionSet.h\"\n+#include \"swift/Demangling/Demangler.h\"\n #include \"swift/Frontend/DiagnosticVerifier.h\"\n #include \"swift/Parse/Lexer.h\"\n \n@@ -261,7 +262,6 @@ struct Obligation {\n class DependencyVerifier {\n   SourceManager &SM;\n   const DependencyTracker &DT;\n-  std::vector<llvm::SMDiagnostic> Errors = {};\n \n public:\n   explicit DependencyVerifier(SourceManager &SM, const DependencyTracker &DT)\n@@ -286,7 +286,7 @@ class DependencyVerifier {\n                          ObligationMap &Obs,\n                          NegativeExpectationMap &NegativeExpectations);\n \n-  bool verifyNegativeExpectations(ObligationMap &Obs,\n+  bool verifyNegativeExpectations(const SourceFile *SF, ObligationMap &Obs,\n                                   NegativeExpectationMap &Negs);\n \n   bool diagnoseUnfulfilledObligations(const SourceFile *SF, ObligationMap &OM);\n@@ -328,29 +328,13 @@ class DependencyVerifier {\n   }\n \n private:\n-  template <typename... Ts>\n-  inline auto addFormattedDiagnostic(const Expectation &dep, const char *Fmt,\n-                                     Ts &&... Vals) {\n-    return addFormattedDiagnostic(dep.MessageRange.begin(), Fmt,\n-                                  std::forward<Ts>(Vals)...);\n-  }\n-\n-  template <typename... Ts>\n-  inline auto addFormattedDiagnostic(const char *Loc, const char *Fmt,\n-                                     Ts &&... Vals) {\n-    auto loc = SourceLoc(llvm::SMLoc::getFromPointer(Loc));\n-    auto diag =\n-        SM.GetMessage(loc, llvm::SourceMgr::DK_Error,\n-                      llvm::formatv(Fmt, std::forward<Ts>(Vals)...), {}, {});\n-    Errors.push_back(diag);\n+  template <typename... ArgTypes>\n+  InFlightDiagnostic\n+  diagnose(DiagnosticEngine &Diags, const char *LocPtr, Diag<ArgTypes...> ID,\n+           typename detail::PassArgument<ArgTypes>::type... Args) const {\n+    auto Loc = SourceLoc(llvm::SMLoc::getFromPointer(LocPtr));\n+    return Diags.diagnose(Loc, ID, std::move(Args)...);\n   }\n-\n-  void addError(const char *Loc, const Twine &Msg,\n-                ArrayRef<llvm::SMFixIt> FixIts = {}) {\n-    auto loc = SourceLoc(llvm::SMLoc::getFromPointer(Loc));\n-    auto diag = SM.GetMessage(loc, llvm::SourceMgr::DK_Error, Msg, {}, FixIts);\n-    Errors.push_back(diag);\n-  };\n };\n } // end anonymous namespace\n \n@@ -391,17 +375,19 @@ bool DependencyVerifier::parseExpectations(\n \n     // Skip any whitespace before the {{.\n     MatchStart = MatchStart.substr(MatchStart.find_first_not_of(\" \\t\"));\n+    auto &diags = SF->getASTContext().Diags;\n \n     const size_t TextStartIdx = MatchStart.find(\"{{\");\n     if (TextStartIdx == StringRef::npos) {\n-      addError(MatchStart.data(), \"expected {{ in expectation\");\n+      diagnose(diags, MatchStart.data(),\n+               diag::expectation_missing_opening_braces);\n       continue;\n     }\n \n     const size_t End = MatchStart.find(\"}}\");\n     if (End == StringRef::npos) {\n-      addError(MatchStart.data(),\n-               \"didn't find '}}' to match '{{' in expectation\");\n+      diagnose(diags, MatchStart.data(),\n+               diag::expectation_missing_closing_braces);\n       continue;\n     }\n \n@@ -483,7 +469,7 @@ bool DependencyVerifier::verifyObligations(\n     ObligationMap &OM, llvm::StringMap<Expectation> &NegativeExpectations) {\n   auto *tracker = SF->getReferencedNameTracker();\n   assert(tracker && \"Constructed source file without referenced name tracker!\");\n-\n+  auto &diags = SF->getASTContext().Diags;\n   for (auto &expectation : ExpectedDependencies) {\n     const bool wantsCascade = expectation.isCascading();\n     switch (expectation.Info.Kind) {\n@@ -497,20 +483,18 @@ bool DependencyVerifier::verifyObligations(\n           [&](Obligation &p) {\n             const auto haveCascade = p.getCascades();\n             if (haveCascade != wantsCascade) {\n-              addFormattedDiagnostic(\n-                  expectation,\n-                  \"expected {0} dependency; found {1} dependency instead\",\n-                  wantsCascade ? \"cascading\" : \"non-cascading\",\n-                  haveCascade ? \"cascading\" : \"non-cascading\");\n+              diagnose(diags, expectation.MessageRange.begin(),\n+                       diag::dependency_cascading_mismatch, wantsCascade,\n+                       haveCascade);\n               return p.fail();\n             }\n \n             return p.fullfill();\n           },\n-          [this](const Expectation &e) {\n-            addFormattedDiagnostic(\n-                e, \"expected member dependency does not exist: {0}\",\n-                e.MessageRange);\n+          [&](const Expectation &e) {\n+            diagnose(\n+                diags, e.MessageRange.begin(), diag::missing_member_dependency,\n+                static_cast<uint8_t>(expectation.Info.Kind), e.MessageRange);\n           });\n       break;\n     case Expectation::Kind::PotentialMember:\n@@ -520,39 +504,36 @@ bool DependencyVerifier::verifyObligations(\n             assert(p.getName().empty());\n             const auto haveCascade = p.getCascades();\n             if (haveCascade != wantsCascade) {\n-              addFormattedDiagnostic(\n-                  expectation,\n-                  \"expected {0} potential member dependency; found {1} \"\n-                  \"potential member dependency instead\",\n-                  wantsCascade ? \"cascading\" : \"non-cascading\",\n-                  haveCascade ? \"cascading\" : \"non-cascading\");\n+              diagnose(diags, expectation.MessageRange.begin(),\n+                       diag::potential_dependency_cascading_mismatch,\n+                       wantsCascade, haveCascade);\n               return p.fail();\n             }\n \n             return p.fullfill();\n           },\n-          [this](const Expectation &e) {\n-            addFormattedDiagnostic(\n-                e, \"expected potential member dependency does not exist: {0}\",\n-                e.MessageRange);\n+          [&](const Expectation &e) {\n+            diagnose(\n+                diags, e.MessageRange.begin(), diag::missing_member_dependency,\n+                static_cast<uint8_t>(expectation.Info.Kind), e.MessageRange);\n           });\n       break;\n     case Expectation::Kind::Provides:\n       matchExpectationOrFail(\n           OM, expectation, [](Obligation &O) { return O.fullfill(); },\n-          [this](const Expectation &e) {\n-            addFormattedDiagnostic(\n-                e, \"expected provided dependency does not exist: {0}\",\n-                e.MessageRange);\n+          [&](const Expectation &e) {\n+            diagnose(\n+                diags, e.MessageRange.begin(), diag::missing_member_dependency,\n+                static_cast<uint8_t>(expectation.Info.Kind), e.MessageRange);\n           });\n       break;\n     case Expectation::Kind::DynamicMember:\n       matchExpectationOrFail(\n           OM, expectation, [](Obligation &O) { return O.fullfill(); },\n-          [this](const Expectation &e) {\n-            addFormattedDiagnostic(\n-                e, \"expected dynamic member dependency does not exist: {0}\",\n-                e.MessageRange);\n+          [&](const Expectation &e) {\n+            diagnose(\n+                diags, e.MessageRange.begin(), diag::missing_member_dependency,\n+                static_cast<uint8_t>(expectation.Info.Kind), e.MessageRange);\n           });\n       break;\n     }\n@@ -562,16 +543,17 @@ bool DependencyVerifier::verifyObligations(\n }\n \n bool DependencyVerifier::verifyNegativeExpectations(\n-    ObligationMap &Obligations, NegativeExpectationMap &NegativeExpectations) {\n+    const SourceFile *SF, ObligationMap &Obligations,\n+    NegativeExpectationMap &NegativeExpectations) {\n   forEachOwedObligation(Obligations, [&](StringRef key, Obligation &p) {\n     auto entry = NegativeExpectations.find(key);\n     if (entry == NegativeExpectations.end()) {\n       return;\n     }\n \n     auto &expectation = entry->second;\n-    addFormattedDiagnostic(expectation, \"unexpected dependency exists: {0}\",\n-                           expectation.MessageRange);\n+    diagnose(SF->getASTContext().Diags, expectation.MessageRange.begin(),\n+             diag::negative_expectation_violated, expectation.MessageRange);\n     p.fail();\n   });\n   return false;\n@@ -581,31 +563,23 @@ bool DependencyVerifier::diagnoseUnfulfilledObligations(\n     const SourceFile *SF, ObligationMap &Obligations) {\n   CharSourceRange EntireRange = SM.getRangeForBuffer(*SF->getBufferID());\n   StringRef InputFile = SM.extractText(EntireRange);\n+  auto &diags = SF->getASTContext().Diags;\n   forEachOwedObligation(Obligations, [&](StringRef key, Obligation &p) {\n     // HACK: Diagnosing the end of the buffer will print a carat pointing\n     // at the file path, but not print any of the buffer's contents, which\n     // might be misleading.\n-    const char *Loc = InputFile.end();\n+    auto Loc = SourceLoc(llvm::SMLoc::getFromPointer(InputFile.end()));\n     switch (p.getKind()) {\n     case Expectation::Kind::Negative:\n       llvm_unreachable(\"Obligations may not be negative; only Expectations!\");\n     case Expectation::Kind::Member:\n-      addFormattedDiagnostic(Loc, \"unexpected {0} dependency: {1}\",\n-                             p.describeCascade(), key);\n-      break;\n     case Expectation::Kind::DynamicMember:\n-      addFormattedDiagnostic(Loc,\n-                             \"unexpected {0} dynamic member dependency: {1}\",\n-                             p.describeCascade(), p.getName());\n-      break;\n     case Expectation::Kind::PotentialMember:\n-      addFormattedDiagnostic(Loc,\n-                             \"unexpected {0} potential member dependency: {1}\",\n-                             p.describeCascade(), key);\n+      diags.diagnose(Loc, diag::unexpected_dependency, p.describeCascade(),\n+                     static_cast<uint8_t>(p.getKind()), key);\n       break;\n     case Expectation::Kind::Provides:\n-      addFormattedDiagnostic(Loc, \"unexpected provided entity: {0}\",\n-                             p.getName());\n+      diags.diagnose(Loc, diag::unexpected_provided_entity, p.getName());\n       break;\n     }\n   });\n@@ -629,25 +603,15 @@ bool DependencyVerifier::verifyFile(const SourceFile *SF) {\n     return true;\n   }\n \n-  if (verifyNegativeExpectations(Obligations, Negatives)) {\n+  if (verifyNegativeExpectations(SF, Obligations, Negatives)) {\n     return true;\n   }\n \n   if (diagnoseUnfulfilledObligations(SF, Obligations)) {\n     return true;\n   }\n \n-  // Sort the diagnostics by location so we get a stable ordering.\n-  std::sort(Errors.begin(), Errors.end(),\n-            [&](const llvm::SMDiagnostic &lhs,\n-                const llvm::SMDiagnostic &rhs) -> bool {\n-              return lhs.getLoc().getPointer() < rhs.getLoc().getPointer();\n-            });\n-\n-  for (auto Err : Errors)\n-    SM.getLLVMSourceMgr().PrintMessage(llvm::errs(), Err);\n-\n-  return !Errors.empty();\n+  return SF->getASTContext().Diags.hadAnyError();\n }\n \n //===----------------------------------------------------------------------===//"
                    }
                ]
            },
            {
                "date": "2020-03-04T23:34:16Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/b8a87f651ecb8a5b6904b9aa29875fccd2c39912",
                "changes": [
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -124,16 +124,31 @@ namespace {\n     Out.resetColor();\n   }\n \n+  static void printStringAsSingleQuotedLine(StringRef str, raw_ostream &Out) {\n+    Out << \"'\";\n+    for (auto character : str) {\n+      if (character == '\\n')\n+        Out << \"\\\\n\";\n+      else\n+        Out << character;\n+    }\n+    Out << \"'\";\n+  }\n+\n   // Describe a fix-it out-of-line.\n   static void describeFixIt(SourceManager &SM, DiagnosticInfo::FixIt fixIt,\n                             raw_ostream &Out) {\n     if (fixIt.getRange().getByteLength() == 0) {\n-      Out << \"insert '\" << fixIt.getText() << \"'\";\n+      Out << \"insert \";\n+      printStringAsSingleQuotedLine(fixIt.getText(), Out);\n     } else if (fixIt.getText().empty()) {\n-      Out << \"remove '\" << SM.extractText(fixIt.getRange()) << \"'\";\n+      Out << \"remove \";\n+      printStringAsSingleQuotedLine(SM.extractText(fixIt.getRange()), Out);\n     } else {\n-      Out << \"replace '\" << SM.extractText(fixIt.getRange()) << \"' with '\"\n-          << fixIt.getText() << \"'\";\n+      Out << \"replace \";\n+      printStringAsSingleQuotedLine(SM.extractText(fixIt.getRange()), Out);\n+      Out << \" with \";\n+      printStringAsSingleQuotedLine(fixIt.getText(), Out);\n     }\n   }\n \n@@ -280,6 +295,11 @@ namespace {\n       // line.\n       unsigned *byteToColumnMap = new unsigned[LineText.size() + 1];\n       unsigned extraColumns = 0;\n+      // Track the location of the first character in the line that is not a\n+      // whitespace character. This can be used to avoid underlining leading\n+      // whitespace, which looks weird even though it is technically accurate.\n+      unsigned firstNonWhitespaceColumn = 0;\n+      bool seenNonWhitespaceCharacter = false;\n       // We count one past the end of LineText here to handle trailing fix-it\n       // insertions.\n       for (unsigned i = 0; i < LineText.size() + 1; ++i) {\n@@ -294,9 +314,17 @@ namespace {\n             }\n           }\n         }\n-        // Tabs are mapped to 2 spaces so they have a known column width.\n-        if (i < LineText.size() && LineText[i] == '\\t')\n-          extraColumns += 1;\n+\n+        if (i < LineText.size()) {\n+          // Tabs are mapped to 2 spaces so they have a known column width.\n+          if (LineText[i] == '\\t')\n+            extraColumns += 1;\n+\n+          if (!seenNonWhitespaceCharacter && !isspace(LineText[i])) {\n+            firstNonWhitespaceColumn = i + extraColumns;\n+            seenNonWhitespaceCharacter = true;\n+          }\n+        }\n \n         byteToColumnMap[i] = i + extraColumns;\n       }\n@@ -325,18 +353,28 @@ namespace {\n       if (isASCII) {\n         auto highlightLine = std::string(byteToColumnMap[LineText.size()], ' ');\n         for (auto highlight : Highlights) {\n-          for (unsigned i = highlight.StartByte; i < highlight.EndByte; ++i)\n+          for (unsigned i =\n+                   std::max(highlight.StartByte, firstNonWhitespaceColumn);\n+               i < highlight.EndByte; ++i)\n             highlightLine[byteToColumnMap[i]] = '~';\n         }\n \n         for (auto fixIt : FixIts) {\n           // Mark deletions.\n-          for (unsigned i = fixIt.StartByte; i < fixIt.EndByte; ++i)\n+          for (unsigned i = std::max(fixIt.StartByte, firstNonWhitespaceColumn);\n+               i < fixIt.EndByte; ++i)\n             highlightLine[byteToColumnMap[i]] = '-';\n-\n-          // Mark insertions.\n-          for (unsigned i = byteToColumnMap[fixIt.StartByte - 1] + 1;\n-               i < byteToColumnMap[fixIt.StartByte]; ++i)\n+          // Mark insertions. If the fix-it starts at the beginning of the line,\n+          // highlight from column zero to the end column. Otherwise, find the\n+          // column which immediately precedes the insertion. Then, highlight\n+          // from the column after that to the end column. The end column in\n+          // this case is obtained from the fix-it's starting byte, because\n+          // insertions are printed before the deleted range.\n+          unsigned startColumn = fixIt.StartByte == 0\n+                                     ? 0\n+                                     : byteToColumnMap[fixIt.StartByte - 1] + 1;\n+          for (unsigned i = startColumn; i < byteToColumnMap[fixIt.StartByte];\n+               ++i)\n             highlightLine[i] = '+';\n         }\n \n@@ -640,7 +678,10 @@ static void annotateSnippetWithInfo(SourceManager &SM,\n   // Don't print inline fix-its for notes.\n   if (Info.Kind != DiagnosticKind::Note) {\n     for (auto fixIt : Info.FixIts) {\n-      Snippet.addFixIt(fixIt.getRange(), fixIt.getText());\n+      // Don't print multi-line fix-its inline, only include them at the end of\n+      // the message.\n+      if (fixIt.getText().find(\"\\n\") == std::string::npos)\n+        Snippet.addFixIt(fixIt.getRange(), fixIt.getText());\n     }\n   }\n   // Add any explicitly grouped notes to the snippet."
                    },
                    {
                        "filename": "test/diagnostics/pretty-printed-diagnostics.swift",
                        "code": "@@ -51,6 +51,20 @@ let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n   return y\n }\n \n+// Multi-line fix-its\n+foo(b: 1,\n+    a: 2)\n+\n+foo(b:\n+    1,\n+    a:\n+    2)\n+\n+foo(b:\n+    1,\n+    a: 2)\n+\n+\n // Test fallback for non-ASCII characters.\n // CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:11\n // CHECK: [[#LINE-1]] |\n@@ -143,6 +157,41 @@ let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n // CHECK:    | --> error: unable to infer complex closure return type; add explicit type to disambiguate [insert ' () -> <#Result#> in ']\n // CHECK: [[#LINE+1]] |   let y = 1\n \n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-2]] | // Multi-line fix-its\n+// CHECK: [[#LINE-1]] | foo(a: 2, b: 1,\n+// CHECK:             |     ++++++~~~~-\n+// CHECK: [[#LINE]]   |     a: 2)\n+// CHECK:             |     ----\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]] |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-3]] |\n+// CHECK: [[#LINE-2]] | foo(b:\n+// CHECK:             |     ~~\n+// CHECK: [[#LINE-1]] |     1,\n+// CHECK:             |     ~-\n+// CHECK: [[#LINE]]   |     a:\n+// CHECK:             |     --\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a:\\n    2' and insert 'a:\\n    2, ']\n+// CHECK: [[#LINE+1]] |     2)\n+// CHECK:             |     -\n+// CHECK: [[#LINE+2]] |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-3]] |\n+// CHECK: [[#LINE-2]] | foo(a: 2, b:\n+// CHECK:             |     ++++++~~\n+// CHECK: [[#LINE-1]] |     1,\n+// CHECK:             |     ~-\n+// CHECK: [[#LINE]]   |     a: 2)\n+// CHECK:             |     ----\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]] |\n+\n // CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n // CHECK: [[#LINE-1]] | func foo(a: Int, b: Int) {\n // CHECK: [[#LINE]]   |   a + b"
                    }
                ]
            },
            {
                "date": "2020-03-04T02:26:57Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/d220ac80f3f75ee149cd2fbccf01f224d825baa0",
                "changes": [
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -124,16 +124,31 @@ namespace {\n     Out.resetColor();\n   }\n \n+  static void printStringAsSingleQuotedLine(StringRef str, raw_ostream &Out) {\n+    Out << \"'\";\n+    for (auto character : str) {\n+      if (character == '\\n')\n+        Out << \"\\\\n\";\n+      else\n+        Out << character;\n+    }\n+    Out << \"'\";\n+  }\n+\n   // Describe a fix-it out-of-line.\n   static void describeFixIt(SourceManager &SM, DiagnosticInfo::FixIt fixIt,\n                             raw_ostream &Out) {\n     if (fixIt.getRange().getByteLength() == 0) {\n-      Out << \"insert '\" << fixIt.getText() << \"'\";\n+      Out << \"insert \";\n+      printStringAsSingleQuotedLine(fixIt.getText(), Out);\n     } else if (fixIt.getText().empty()) {\n-      Out << \"remove '\" << SM.extractText(fixIt.getRange()) << \"'\";\n+      Out << \"remove \";\n+      printStringAsSingleQuotedLine(SM.extractText(fixIt.getRange()), Out);\n     } else {\n-      Out << \"replace '\" << SM.extractText(fixIt.getRange()) << \"' with '\"\n-          << fixIt.getText() << \"'\";\n+      Out << \"replace \";\n+      printStringAsSingleQuotedLine(SM.extractText(fixIt.getRange()), Out);\n+      Out << \" with \";\n+      printStringAsSingleQuotedLine(fixIt.getText(), Out);\n     }\n   }\n \n@@ -280,6 +295,11 @@ namespace {\n       // line.\n       unsigned *byteToColumnMap = new unsigned[LineText.size() + 1];\n       unsigned extraColumns = 0;\n+      // Track the location of the first character in the line that is not a\n+      // whitespace character. This can be used to avoid underlining leading\n+      // whitespace, which looks weird even though it is technically accurate.\n+      unsigned firstNonWhitespaceColumn = 0;\n+      bool seenNonWhitespaceCharacter = false;\n       // We count one past the end of LineText here to handle trailing fix-it\n       // insertions.\n       for (unsigned i = 0; i < LineText.size() + 1; ++i) {\n@@ -294,9 +314,17 @@ namespace {\n             }\n           }\n         }\n-        // Tabs are mapped to 2 spaces so they have a known column width.\n-        if (i < LineText.size() && LineText[i] == '\\t')\n-          extraColumns += 1;\n+\n+        if (i < LineText.size()) {\n+          // Tabs are mapped to 2 spaces so they have a known column width.\n+          if (LineText[i] == '\\t')\n+            extraColumns += 1;\n+\n+          if (!seenNonWhitespaceCharacter && !isspace(LineText[i])) {\n+            firstNonWhitespaceColumn = i + extraColumns;\n+            seenNonWhitespaceCharacter = true;\n+          }\n+        }\n \n         byteToColumnMap[i] = i + extraColumns;\n       }\n@@ -325,18 +353,28 @@ namespace {\n       if (isASCII) {\n         auto highlightLine = std::string(byteToColumnMap[LineText.size()], ' ');\n         for (auto highlight : Highlights) {\n-          for (unsigned i = highlight.StartByte; i < highlight.EndByte; ++i)\n+          for (unsigned i =\n+                   std::max(highlight.StartByte, firstNonWhitespaceColumn);\n+               i < highlight.EndByte; ++i)\n             highlightLine[byteToColumnMap[i]] = '~';\n         }\n \n         for (auto fixIt : FixIts) {\n           // Mark deletions.\n-          for (unsigned i = fixIt.StartByte; i < fixIt.EndByte; ++i)\n+          for (unsigned i = std::max(fixIt.StartByte, firstNonWhitespaceColumn);\n+               i < fixIt.EndByte; ++i)\n             highlightLine[byteToColumnMap[i]] = '-';\n-\n-          // Mark insertions.\n-          for (unsigned i = byteToColumnMap[fixIt.StartByte - 1] + 1;\n-               i < byteToColumnMap[fixIt.StartByte]; ++i)\n+          // Mark insertions. If the fix-it starts at the beginning of the line,\n+          // highlight from column zero to the end column. Otherwise, find the\n+          // column which immediately precedes the insertion. Then, highlight\n+          // from the column after that to the end column. The end column in\n+          // this case is obtained from the fix-it's starting byte, because\n+          // insertions are printed before the deleted range.\n+          unsigned startColumn = fixIt.StartByte == 0\n+                                     ? 0\n+                                     : byteToColumnMap[fixIt.StartByte - 1] + 1;\n+          for (unsigned i = startColumn; i < byteToColumnMap[fixIt.StartByte];\n+               ++i)\n             highlightLine[i] = '+';\n         }\n \n@@ -640,7 +678,10 @@ static void annotateSnippetWithInfo(SourceManager &SM,\n   // Don't print inline fix-its for notes.\n   if (Info.Kind != DiagnosticKind::Note) {\n     for (auto fixIt : Info.FixIts) {\n-      Snippet.addFixIt(fixIt.getRange(), fixIt.getText());\n+      // Don't print multi-line fix-its inline, only include them at the end of\n+      // the message.\n+      if (fixIt.getText().find(\"\\n\") == std::string::npos)\n+        Snippet.addFixIt(fixIt.getRange(), fixIt.getText());\n     }\n   }\n   // Add any explicitly grouped notes to the snippet."
                    },
                    {
                        "filename": "test/diagnostics/pretty-printed-diagnostics.swift",
                        "code": "@@ -51,6 +51,20 @@ let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n   return y\n }\n \n+// Multi-line fix-its\n+foo(b: 1,\n+    a: 2)\n+\n+foo(b:\n+    1,\n+    a:\n+    2)\n+\n+foo(b:\n+    1,\n+    a: 2)\n+\n+\n // Test fallback for non-ASCII characters.\n // CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:11\n // CHECK: [[#LINE-1]] |\n@@ -143,6 +157,41 @@ let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n // CHECK:    | --> error: unable to infer complex closure return type; add explicit type to disambiguate [insert ' () -> <#Result#> in ']\n // CHECK: [[#LINE+1]] |   let y = 1\n \n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-2]] | // Multi-line fix-its\n+// CHECK: [[#LINE-1]] | foo(a: 2, b: 1,\n+// CHECK:             |     ++++++~~~~-\n+// CHECK: [[#LINE]]   |     a: 2)\n+// CHECK:             |     ----\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]] |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-3]] |\n+// CHECK: [[#LINE-2]] | foo(b:\n+// CHECK:             |     ~~\n+// CHECK: [[#LINE-1]] |     1,\n+// CHECK:             |     ~-\n+// CHECK: [[#LINE]]   |     a:\n+// CHECK:             |     --\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a:\\n    2' and insert 'a:\\n    2, ']\n+// CHECK: [[#LINE+1]] |     2)\n+// CHECK:             |     -\n+// CHECK: [[#LINE+2]] |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-3]] |\n+// CHECK: [[#LINE-2]] | foo(a: 2, b:\n+// CHECK:             |     ++++++~~\n+// CHECK: [[#LINE-1]] |     1,\n+// CHECK:             |     ~-\n+// CHECK: [[#LINE]]   |     a: 2)\n+// CHECK:             |     ----\n+// CHECK:             |     ^ error: argument 'a' must precede argument 'b' [remove ',\\n    a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]] |\n+\n // CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n // CHECK: [[#LINE-1]] | func foo(a: Int, b: Int) {\n // CHECK: [[#LINE]]   |   a + b"
                    }
                ]
            },
            {
                "date": "2020-03-03T16:48:32Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/69b513afaf073de6246a25156df87bc0e29d4dcb",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticConsumer.h",
                        "code": "@@ -126,6 +126,9 @@ class DiagnosticConsumer {\n   /// \\returns true if an error occurred while finishing-up.\n   virtual bool finishProcessing() { return false; }\n \n+  /// Flush any in-flight diagnostics.\n+  virtual void flush() {}\n+\n   /// In batch mode, any error causes failure for all primary files, but\n   /// anyone consulting .dia files will only see an error for a particular\n   /// primary in that primary's serialized diagnostics file. For other"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -676,8 +676,8 @@ namespace swift {\n     /// Print diagnostic names after their messages\n     bool printDiagnosticNames = false;\n \n-    /// Use descriptive diagnostic style when available.\n-    bool useDescriptiveDiagnostics = false;\n+    /// Use educational notes when available.\n+    bool useEducationalNotes = false;\n \n     /// Path to diagnostic documentation directory.\n     std::string diagnosticDocumentationPath = \"\";\n@@ -705,6 +705,11 @@ namespace swift {\n       return state.getShowDiagnosticsAfterFatalError();\n     }\n \n+    void flushConsumers() {\n+      for (auto consumer : Consumers)\n+        consumer->flush();\n+    }\n+\n     /// Whether to skip emitting warnings\n     void setSuppressWarnings(bool val) { state.setSuppressWarnings(val); }\n     bool getSuppressWarnings() const {\n@@ -725,12 +730,8 @@ namespace swift {\n       return printDiagnosticNames;\n     }\n \n-    void setUseDescriptiveDiagnostics(bool val) {\n-       useDescriptiveDiagnostics = val;\n-    }\n-    bool getUseDescriptiveDiagnostics() const {\n-      return useDescriptiveDiagnostics;\n-    }\n+    void setUseEducationalNotes(bool val) { useEducationalNotes = val; }\n+    bool getUseEducationalNotes() const { return useEducationalNotes; }\n \n     void setDiagnosticDocumentationPath(std::string path) {\n       diagnosticDocumentationPath = path;"
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -55,9 +55,13 @@ class DiagnosticOptions {\n   // When printing diagnostics, include the diagnostic name at the end\n   bool PrintDiagnosticNames = false;\n \n-  /// If set to true, produce more descriptive diagnostic output if available.\n-  /// Descriptive diagnostic output is not intended to be machine-readable.\n-  bool EnableDescriptiveDiagnostics = false;\n+  /// If set to true, display educational note content to the user if available.\n+  /// Educational notes are documentation which supplement diagnostics.\n+  bool EnableEducationalNotes = false;\n+\n+  // If set to true, use the more descriptive experimental formatting style for\n+  // diagnostics.\n+  bool EnableExperimentalFormatting = false;\n \n   std::string DiagnosticDocumentationPath = \"\";\n "
                    },
                    {
                        "filename": "include/swift/Basic/SourceManager.h",
                        "code": "@@ -256,6 +256,8 @@ class SourceManager {\n                                SourceLoc();\n   }\n \n+  std::string getLineString(unsigned BufferID, unsigned LineNumber);\n+\n   SourceLoc getLocFromExternalSource(StringRef Path, unsigned Line, unsigned Col);\n private:\n   const VirtualFile *getVirtualFile(SourceLoc Loc) const;"
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -25,24 +25,39 @@\n #include \"llvm/Support/Process.h\"\n \n namespace swift {\n+class AnnotatedSourceSnippet;\n \n /// Diagnostic consumer that displays diagnostics to standard error.\n class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   llvm::raw_ostream &Stream;\n   bool ForceColors = false;\n   bool DidErrorOccur = false;\n+  bool ExperimentalFormattingEnabled = false;\n+  // The current snippet used to display an error/warning/remark and the notes\n+  // implicitly associated with it. Uses `std::unique_ptr` so that\n+  // `AnnotatedSourceSnippet` can be forward declared.\n+  std::unique_ptr<AnnotatedSourceSnippet> currentSnippet;\n+\n public:\n-  PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs()) :\n-    Stream(stream) { }\n+  PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs());\n+  ~PrintingDiagnosticConsumer();\n \n   virtual void handleDiagnostic(SourceManager &SM,\n                                 const DiagnosticInfo &Info) override;\n \n+  virtual bool finishProcessing() override;\n+\n+  void flush(bool includeTrailingBreak);\n+\n+  virtual void flush() override { flush(false); }\n+\n   void forceColors() {\n     ForceColors = true;\n     llvm::sys::Process::UseANSIEscapeCodes(true);\n   }\n \n+  void enableExperimentalFormatting() { ExperimentalFormattingEnabled = true; }\n+\n   bool didErrorOccur() {\n     return DidErrorOccur;\n   }"
                    },
                    {
                        "filename": "include/swift/Option/FrontendOptions.td",
                        "code": "@@ -131,8 +131,12 @@ def enable_cross_import_overlays : Flag<[\"-\"], \"enable-cross-import-overlays\">,\n def disable_cross_import_overlays : Flag<[\"-\"], \"disable-cross-import-overlays\">,\n   HelpText<\"Do not automatically import declared cross-import overlays.\">;\n \n-def enable_descriptive_diagnostics : Flag<[\"-\"], \"enable-descriptive-diagnostics\">,\n-  HelpText<\"Show descriptive diagnostic information, if available.\">;\n+def enable_educational_notes : Flag<[\"-\"], \"enable-educational-notes\">,\n+  HelpText<\"Show educational notes, if available.\">;\n+  \n+def enable_experimental_diagnostic_formatting :\n+  Flag<[\"-\"], \"enable-experimental-diagnostic-formatting\">,\n+  HelpText<\"Enable experimental diagnostic formatting features.\">;\n   \n def diagnostic_documentation_path\n   : Separate<[\"-\"], \"diagnostic-documentation-path\">, MetaVarName<\"<path>\">,"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -984,7 +984,7 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n     info->ChildDiagnosticInfo = childInfoPtrs;\n     \n     SmallVector<std::string, 1> educationalNotePaths;\n-    if (useDescriptiveDiagnostics) {\n+    if (useEducationalNotes) {\n       auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n       while (associatedNotes && *associatedNotes) {\n         SmallString<128> notePath(getDiagnosticDocumentationPath());"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -819,8 +819,9 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.SuppressWarnings |= Args.hasArg(OPT_suppress_warnings);\n   Opts.WarningsAsErrors |= Args.hasArg(OPT_warnings_as_errors);\n   Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n-  Opts.EnableDescriptiveDiagnostics |=\n-      Args.hasArg(OPT_enable_descriptive_diagnostics);\n+  Opts.EnableEducationalNotes |= Args.hasArg(OPT_enable_educational_notes);\n+  Opts.EnableExperimentalFormatting |=\n+      Args.hasArg(OPT_enable_experimental_diagnostic_formatting);\n   if (Arg *A = Args.getLastArg(OPT_diagnostic_documentation_path)) {\n     Opts.DiagnosticDocumentationPath = A->getValue();\n   }"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -406,8 +406,8 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().PrintDiagnosticNames) {\n     Diagnostics.setPrintDiagnosticNames(true);\n   }\n-  if (Invocation.getDiagnosticOptions().EnableDescriptiveDiagnostics) {\n-    Diagnostics.setUseDescriptiveDiagnostics(true);\n+  if (Invocation.getDiagnosticOptions().EnableEducationalNotes) {\n+    Diagnostics.setUseEducationalNotes(true);\n   }\n   Diagnostics.setDiagnosticDocumentationPath(\n       Invocation.getDiagnosticOptions().DiagnosticDocumentationPath);"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -2,7 +2,7 @@\n //\n // This source file is part of the Swift.org open source project\n //\n-// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors\n+// Copyright (c) 2014 - 2020 Apple Inc. and the Swift project authors\n // Licensed under Apache License v2.0 with Runtime Library Exception\n //\n // See https://swift.org/LICENSE.txt for license information\n@@ -15,14 +15,17 @@\n //===----------------------------------------------------------------------===//\n \n #include \"swift/Frontend/PrintingDiagnosticConsumer.h\"\n+#include \"swift/AST/DiagnosticEngine.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/SourceManager.h\"\n-#include \"swift/AST/DiagnosticEngine.h\"\n #include \"llvm/ADT/SmallString.h\"\n #include \"llvm/ADT/StringRef.h\"\n #include \"llvm/ADT/Twine.h\"\n+#include \"llvm/Support/FormatAdapters.h\"\n+#include \"llvm/Support/FormatVariadic.h\"\n #include \"llvm/Support/MemoryBuffer.h\"\n #include \"llvm/Support/raw_ostream.h\"\n+#include <algorithm>\n \n using namespace swift;\n \n@@ -61,24 +64,651 @@ namespace {\n       return 0;\n     }\n   };\n+\n+  /// A stream which drops all color settings.\n+  class NoColorStream : public raw_ostream {\n+    raw_ostream &Underlying;\n+\n+  public:\n+    explicit NoColorStream(raw_ostream &underlying) : Underlying(underlying) {}\n+    ~NoColorStream() override { flush(); }\n+\n+    bool has_colors() const override { return false; }\n+\n+    void write_impl(const char *ptr, size_t size) override {\n+      Underlying.write(ptr, size);\n+    }\n+    uint64_t current_pos() const override {\n+      return Underlying.tell() - GetNumBytesInBuffer();\n+    }\n+\n+    size_t preferred_buffer_size() const override { return 0; }\n+  };\n+\n+  // MARK: Experimental diagnostic printing.\n+\n+  static void printDiagnosticKind(DiagnosticKind kind, raw_ostream &out) {\n+    switch (kind) {\n+    case DiagnosticKind::Error:\n+      out.changeColor(ColoredStream::Colors::RED, true);\n+      out << \"error:\";\n+      break;\n+    case DiagnosticKind::Warning:\n+      out.changeColor(ColoredStream::Colors::YELLOW, true);\n+      out << \"warning:\";\n+      break;\n+    case DiagnosticKind::Note:\n+      out.changeColor(ColoredStream::Colors::CYAN, true);\n+      out << \"note:\";\n+      break;\n+    case DiagnosticKind::Remark:\n+      out.changeColor(ColoredStream::Colors::CYAN, true);\n+      out << \"remark:\";\n+      break;\n+    }\n+    out.resetColor();\n+  }\n+\n+  static void printNumberedGutter(unsigned LineNumber,\n+                                  unsigned LineNumberIndent, raw_ostream &Out) {\n+    Out.changeColor(ColoredStream::Colors::BLUE, true);\n+    Out << llvm::formatv(\n+        \"{0} | \",\n+        llvm::fmt_align(LineNumber, llvm::AlignStyle::Right, LineNumberIndent));\n+    Out.resetColor();\n+  }\n+\n+  static void printEmptyGutter(unsigned LineNumberIndent, raw_ostream &Out) {\n+    Out.changeColor(ColoredStream::Colors::BLUE, true);\n+    Out << std::string(LineNumberIndent + 1, ' ') << \"| \";\n+    Out.resetColor();\n+  }\n+\n+  // Describe a fix-it out-of-line.\n+  static void describeFixIt(SourceManager &SM, DiagnosticInfo::FixIt fixIt,\n+                            raw_ostream &Out) {\n+    if (fixIt.getRange().getByteLength() == 0) {\n+      Out << \"insert '\" << fixIt.getText() << \"'\";\n+    } else if (fixIt.getText().empty()) {\n+      Out << \"remove '\" << SM.extractText(fixIt.getRange()) << \"'\";\n+    } else {\n+      Out << \"replace '\" << SM.extractText(fixIt.getRange()) << \"' with '\"\n+          << fixIt.getText() << \"'\";\n+    }\n+  }\n+\n+  static void describeFixIts(SourceManager &SM,\n+                             ArrayRef<DiagnosticInfo::FixIt> fixIts,\n+                             raw_ostream &Out) {\n+    Out << \"[\";\n+    for (unsigned i = 0; i < fixIts.size(); ++i) {\n+      if (fixIts.size() > 2 && i + 1 == fixIts.size()) {\n+        Out << \", and \";\n+      } else if (fixIts.size() > 2 && i > 0) {\n+        Out << \", \";\n+      } else if (fixIts.size() == 2 && i == 1) {\n+        Out << \" and \";\n+      }\n+      describeFixIt(SM, fixIts[i], Out);\n+    }\n+    Out << \"]\";\n+  }\n+\n+  /// Represents a single line of source code annotated with optional messages,\n+  /// highlights, and fix-its.\n+  class AnnotatedLine {\n+    friend class AnnotatedFileExcerpt;\n+\n+    // A diagnostic message located at a specific byte in the line.\n+    struct Message {\n+      unsigned Byte;\n+      DiagnosticKind Kind;\n+      std::string Text;\n+    };\n+\n+    // A half-open byte range which should be highlighted.\n+    struct Highlight {\n+      unsigned StartByte;\n+      unsigned EndByte;\n+    };\n+\n+    // A half-open byte range which should be replaced with the given text.\n+    struct FixIt {\n+      unsigned StartByte;\n+      unsigned EndByte;\n+      std::string Text;\n+    };\n+\n+    unsigned LineNumber;\n+    std::string LineText;\n+    SmallVector<Message, 1> Messages;\n+    SmallVector<Highlight, 1> Highlights;\n+    SmallVector<FixIt, 1> FixIts;\n+\n+    // Adjust output color as needed if this byte is part of a fix-it deletion.\n+    void applyStyleForLineByte(unsigned Byte, raw_ostream &Out, bool &Deleted) {\n+      bool shouldDelete = false;\n+\n+      for (auto fixIt : FixIts) {\n+        if (Byte >= fixIt.StartByte && Byte < fixIt.EndByte)\n+          shouldDelete = true;\n+      }\n+\n+      // Only modify deletions when we reach the start or end of\n+      // a fix-it. This ensures that so long as the original\n+      // SourceLocs pointed to the first byte of a grapheme cluster, we won't\n+      // output an ANSI escape sequence in the middle of one.\n+      if (shouldDelete != Deleted) {\n+        Out.resetColor();\n+        if (shouldDelete) {\n+          Out.changeColor(ColoredStream::Colors::RED);\n+        }\n+      }\n+      Deleted = shouldDelete;\n+    }\n+\n+    // Insert fix-it replacement text at the appropriate point in the line.\n+    bool maybePrintInsertionAfter(int Byte, bool isLineASCII,\n+                                  raw_ostream &Out) {\n+      // Don't print insertions inline for non-ASCII lines, because we can't\n+      // print an underline beneath them.\n+      if (!isLineASCII)\n+        return false;\n+\n+      for (auto fixIt : FixIts) {\n+        if ((int)fixIt.EndByte - 1 == Byte) {\n+          Out.changeColor(ColoredStream::Colors::GREEN, /*bold*/ true);\n+          for (unsigned i = 0; i < fixIt.Text.size(); ++i) {\n+            // Invert text colors for editor placeholders.\n+            if (i + 1 < fixIt.Text.size() && fixIt.Text.substr(i, 2) == \"<#\") {\n+              Out.changeColor(ColoredStream::Colors::GREEN, /*bold*/ true,\n+                              /*background*/ true);\n+              ++i;\n+            } else if (i + 1 < fixIt.Text.size() &&\n+                       fixIt.Text.substr(i, 2) == \"#>\") {\n+              Out.changeColor(ColoredStream::Colors::GREEN, /*bold*/ true,\n+                              /*background*/ false);\n+              ++i;\n+            } else {\n+              Out << fixIt.Text[i];\n+            }\n+          }\n+          Out.resetColor();\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    unsigned lineByteOffsetForLoc(SourceManager &SM, SourceLoc Loc) {\n+      SourceLoc lineStart = SM.getLocForLineCol(SM.findBufferContainingLoc(Loc),\n+                                                getLineNumber(), 1);\n+      return SM.getByteDistance(lineStart, Loc);\n+    }\n+\n+  public:\n+    AnnotatedLine(unsigned LineNumber, StringRef LineText)\n+        : LineNumber(LineNumber), LineText(LineText) {}\n+\n+    unsigned getLineNumber() { return LineNumber; }\n+\n+    void addMessage(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n+                    StringRef Message) {\n+      Messages.push_back({lineByteOffsetForLoc(SM, Loc), Kind, Message});\n+    }\n+\n+    void addHighlight(SourceManager &SM, CharSourceRange Range) {\n+      Highlights.push_back({lineByteOffsetForLoc(SM, Range.getStart()),\n+                            lineByteOffsetForLoc(SM, Range.getEnd())});\n+    }\n+\n+    void addFixIt(SourceManager &SM, CharSourceRange Range, StringRef Text) {\n+      FixIts.push_back({lineByteOffsetForLoc(SM, Range.getStart()),\n+                        lineByteOffsetForLoc(SM, Range.getEnd()), Text});\n+    }\n+\n+    void render(unsigned LineNumberIndent, raw_ostream &Out) {\n+      printNumberedGutter(LineNumber, LineNumberIndent, Out);\n+\n+      // Determine if the line is all-ASCII. This will determine a number of\n+      // later formatting decisions.\n+      bool isASCII = true;\n+      for (unsigned i = 0; i < LineText.size(); ++i)\n+        isASCII = isASCII && static_cast<unsigned char>(LineText[i]) <= 127;\n+\n+      // Map a byte in the original source line to a column in the annotated\n+      // line.\n+      unsigned *byteToColumnMap = new unsigned[LineText.size() + 1];\n+      unsigned extraColumns = 0;\n+      // We count one past the end of LineText here to handle trailing fix-it\n+      // insertions.\n+      for (unsigned i = 0; i < LineText.size() + 1; ++i) {\n+        if (isASCII) {\n+          for (auto fixIt : FixIts) {\n+            if (fixIt.EndByte == i) {\n+              // We don't print editor placeholder indicators, so make sure we\n+              // don't count them here.\n+              extraColumns += fixIt.Text.size() -\n+                              StringRef(fixIt.Text).count(\"<#\") * 2 -\n+                              StringRef(fixIt.Text).count(\"#>\") * 2;\n+            }\n+          }\n+        }\n+        // Tabs are mapped to 2 spaces so they have a known column width.\n+        if (i < LineText.size() && LineText[i] == '\\t')\n+          extraColumns += 1;\n+\n+        byteToColumnMap[i] = i + extraColumns;\n+      }\n+\n+      // Print the source line byte-by-byte, emitting ANSI escape sequences as\n+      // needed to style fix-its, and checking for non-ASCII characters.\n+      bool deleted = false;\n+      maybePrintInsertionAfter(-1, isASCII, Out);\n+      for (unsigned i = 0; i < LineText.size(); ++i) {\n+        applyStyleForLineByte(i, Out, deleted);\n+        if (LineText[i] == '\\t')\n+          Out << \"  \";\n+        else\n+          Out << LineText[i];\n+        if (maybePrintInsertionAfter(i, isASCII, Out)) {\n+          deleted = false;\n+        }\n+      }\n+      maybePrintInsertionAfter(LineText.size(), isASCII, Out);\n+      Out.resetColor();\n+      Out << \"\\n\";\n+\n+      // If the entire line is composed of ASCII characters, we can position '~'\n+      // characters in the appropriate columns on the following line to\n+      // represent highlights.\n+      if (isASCII) {\n+        auto highlightLine = std::string(byteToColumnMap[LineText.size()], ' ');\n+        for (auto highlight : Highlights) {\n+          for (unsigned i = highlight.StartByte; i < highlight.EndByte; ++i)\n+            highlightLine[byteToColumnMap[i]] = '~';\n+        }\n+\n+        for (auto fixIt : FixIts) {\n+          // Mark deletions.\n+          for (unsigned i = fixIt.StartByte; i < fixIt.EndByte; ++i)\n+            highlightLine[byteToColumnMap[i]] = '-';\n+\n+          // Mark insertions.\n+          for (unsigned i = byteToColumnMap[fixIt.StartByte - 1] + 1;\n+               i < byteToColumnMap[fixIt.StartByte]; ++i)\n+            highlightLine[i] = '+';\n+        }\n+\n+        // Print the highlight line with the appropriate colors.\n+        if (!(Highlights.empty() && FixIts.empty())) {\n+          printEmptyGutter(LineNumberIndent, Out);\n+          auto currentColor = ColoredStream::Colors::WHITE;\n+          for (unsigned i = 0; i < highlightLine.size(); ++i) {\n+            llvm::raw_ostream::Colors charColor;\n+            switch (highlightLine[i]) {\n+            case '+':\n+              charColor = ColoredStream::Colors::GREEN;\n+              break;\n+            case '-':\n+              charColor = ColoredStream::Colors::RED;\n+              break;\n+            case '~':\n+              charColor = ColoredStream::Colors::BLUE;\n+              break;\n+            default:\n+              charColor = ColoredStream::Colors::WHITE;\n+              break;\n+            }\n+            if (currentColor != charColor) {\n+              currentColor = charColor;\n+              Out.changeColor(charColor, /*bold*/ true);\n+            }\n+            Out << highlightLine[i];\n+          }\n+          Out.resetColor();\n+          Out << \"\\n\";\n+        }\n+      }\n+\n+      // Print each message on its own line below the source line. If the source\n+      // line is ASCII, we can insert a caret pointing directly to the message\n+      // location. If not, use a more generic \"-->\" indicator.\n+      // FIXME: Improve Unicode support so every message can include a direct\n+      // location indicator.\n+      for (auto msg : Messages) {\n+        printEmptyGutter(LineNumberIndent, Out);\n+        if (isASCII) {\n+          Out << std::string(byteToColumnMap[msg.Byte], ' ') << \"^ \";\n+          printDiagnosticKind(msg.Kind, Out);\n+          Out << \" \" << msg.Text << \"\\n\";\n+        } else {\n+          Out.changeColor(ColoredStream::Colors::BLUE, /*bold*/true);\n+          Out << \"--> \";\n+          Out.resetColor();\n+          printDiagnosticKind(msg.Kind, Out);\n+          Out << \" \" << msg.Text << \"\\n\";\n+        }\n+      }\n+      delete[] byteToColumnMap;\n+    }\n+  };\n+\n+  /// Represents an excerpt of a source file which contains one or more\n+  /// annotated source lines.\n+  class AnnotatedFileExcerpt {\n+    SourceManager &SM;\n+    unsigned BufferID;\n+    /// The primary location of the parent error/warning/remark for this\n+    /// diagnostic message. This is printed alongside the file path so it can be\n+    /// parsed by editors and other tooling.\n+    SourceLoc PrimaryLoc;\n+    std::vector<AnnotatedLine> AnnotatedLines;\n+\n+    /// Return the AnnotatedLine for a given SourceLoc, creating it if it\n+    /// doesn't already exist.\n+    AnnotatedLine &lineForLoc(SourceLoc Loc) {\n+      // FIXME: This call to `getLineAndColumn` is expensive.\n+      unsigned lineNo = SM.getLineAndColumn(Loc).first;\n+      AnnotatedLine newLine(lineNo, \"\");\n+      auto iter =\n+          std::lower_bound(AnnotatedLines.begin(), AnnotatedLines.end(),\n+                           newLine, [](AnnotatedLine l1, AnnotatedLine l2) {\n+                             return l1.getLineNumber() < l2.getLineNumber();\n+                           });\n+      if (iter == AnnotatedLines.end() || iter->getLineNumber() != lineNo) {\n+        newLine.LineText = SM.getLineString(BufferID, lineNo);\n+        return *AnnotatedLines.insert(iter, newLine);\n+      } else {\n+        return *iter;\n+      }\n+    }\n+\n+    unsigned getLineNumberIndent() {\n+      // The lines are already in sorted ascending order, and we render one line\n+      // after the last one for context. Use the last line number plus one to\n+      // determine the indent.\n+      return floor(1 + log10(AnnotatedLines.back().getLineNumber() + 1));\n+    }\n+\n+    void printNumberedLine(SourceManager &SM, unsigned BufferID,\n+                           unsigned LineNumber, unsigned LineNumberIndent,\n+                           raw_ostream &Out) {\n+      printNumberedGutter(LineNumber, LineNumberIndent, Out);\n+      Out << SM.getLineString(BufferID, LineNumber) << \"\\n\";\n+    }\n+\n+    void lineRangesForRange(CharSourceRange Range,\n+                            SmallVectorImpl<CharSourceRange> &LineRanges) {\n+      // FIXME: The calls to `getLineAndColumn` and `getLocForLineCol` are\n+      // expensive.\n+      unsigned startLineNo = SM.getLineAndColumn(Range.getStart()).first;\n+      unsigned endLineNo = SM.getLineAndColumn(Range.getEnd()).first;\n+\n+      if (startLineNo == endLineNo) {\n+        LineRanges.push_back(Range);\n+        return;\n+      }\n+\n+      // Split the range by line.\n+      SourceLoc lineEnd = SM.getLocForOffset(\n+          BufferID, *SM.resolveOffsetForEndOfLine(BufferID, startLineNo));\n+      LineRanges.push_back(CharSourceRange(SM, Range.getStart(), lineEnd));\n+\n+      for (unsigned intermediateLine = startLineNo + 1;\n+           intermediateLine < endLineNo; ++intermediateLine) {\n+        SourceLoc lineStart =\n+            SM.getLocForLineCol(BufferID, intermediateLine, 1);\n+        SourceLoc lineEnd = SM.getLocForOffset(\n+            BufferID,\n+            *SM.resolveOffsetForEndOfLine(BufferID, intermediateLine));\n+        LineRanges.push_back(CharSourceRange(SM, lineStart, lineEnd));\n+      }\n+\n+      SourceLoc lastLineStart = SM.getLocForLineCol(BufferID, endLineNo, 1);\n+      LineRanges.push_back(CharSourceRange(SM, lastLineStart, Range.getEnd()));\n+    }\n+\n+  public:\n+    AnnotatedFileExcerpt(SourceManager &SM, unsigned BufferID,\n+                         SourceLoc PrimaryLoc)\n+        : SM(SM), BufferID(BufferID), PrimaryLoc(PrimaryLoc) {}\n+\n+    void addMessage(SourceLoc Loc, DiagnosticKind Kind, StringRef Message) {\n+      lineForLoc(Loc).addMessage(SM, Loc, Kind, Message);\n+    }\n+\n+    void addHighlight(CharSourceRange Range) {\n+      SmallVector<CharSourceRange, 1> ranges;\n+      lineRangesForRange(Range, ranges);\n+      for (auto lineRange : ranges)\n+        lineForLoc(lineRange.getStart()).addHighlight(SM, lineRange);\n+    }\n+\n+    void addFixIt(CharSourceRange Range, StringRef Text) {\n+      SmallVector<CharSourceRange, 1> ranges;\n+      lineRangesForRange(Range, ranges);\n+      // The removals are broken down line-by-line, so only add any insertions\n+      // to the last replacement.\n+      auto last = ranges.pop_back_val();\n+      lineForLoc(last.getStart()).addFixIt(SM, last, Text);\n+      for (auto lineRange : ranges)\n+        lineForLoc(lineRange.getStart()).addFixIt(SM, lineRange, \"\");\n+    }\n+\n+    void render(raw_ostream &Out) {\n+      // Tha maximum number of intermediate lines without annotations to render\n+      // between annotated lines before using an ellipsis.\n+      static const unsigned maxIntermediateLines = 3;\n+\n+      assert(!AnnotatedLines.empty() && \"File excerpt has no lines\");\n+      unsigned lineNumberIndent = getLineNumberIndent();\n+\n+      // Print the file name at the top of each excerpt.\n+      auto primaryLineAndColumn = SM.getLineAndColumn(PrimaryLoc);\n+      Out.changeColor(ColoredStream::Colors::MAGENTA, /*bold*/ true);\n+      Out << SM.getIdentifierForBuffer(BufferID) << \":\"\n+          << primaryLineAndColumn.first << \":\" << primaryLineAndColumn.second\n+          << \"\\n\";\n+      Out.resetColor();\n+\n+      // Print one extra line at the top for context.\n+      if (AnnotatedLines.front().getLineNumber() > 1)\n+        printNumberedLine(SM, BufferID,\n+                          AnnotatedLines.front().getLineNumber() - 1,\n+                          lineNumberIndent, Out);\n+\n+      // Render the first annotated line.\n+      AnnotatedLines.front().render(lineNumberIndent, Out);\n+      unsigned lastLineNumber = AnnotatedLines.front().getLineNumber();\n+\n+      // Render intermediate lines/ellipsis, followed by the next annotated\n+      // line until they have all been output.\n+      for (auto line = AnnotatedLines.begin() + 1; line != AnnotatedLines.end();\n+           ++line) {\n+        unsigned lineNumber = line->getLineNumber();\n+        if (lineNumber - lastLineNumber > maxIntermediateLines) {\n+          // Use an ellipsis to denote an ommitted part of the file.\n+          printNumberedLine(SM, BufferID, lastLineNumber + 1, lineNumberIndent,\n+                            Out);\n+          Out.changeColor(ColoredStream::Colors::BLUE, true);\n+          Out << llvm::formatv(\"{0}...\\n\",\n+                               llvm::fmt_repeat(\" \", lineNumberIndent));\n+          Out.resetColor();\n+          printNumberedLine(SM, BufferID, lineNumber - 1, lineNumberIndent,\n+                            Out);\n+        } else {\n+          // Print all the intermediate lines.\n+          for (unsigned l = lastLineNumber + 1; l < lineNumber; ++l) {\n+            printNumberedLine(SM, BufferID, l, lineNumberIndent, Out);\n+          }\n+        }\n+        // Print the annotated line.\n+        line->render(lineNumberIndent, Out);\n+        lastLineNumber = lineNumber;\n+      }\n+      // Print one extra line at the bottom for context.\n+      printNumberedLine(\n+          SM, BufferID,\n+          AnnotatedLines[AnnotatedLines.size() - 1].getLineNumber() + 1,\n+          lineNumberIndent, Out);\n+    }\n+  };\n } // end anonymous namespace\n \n+namespace swift {\n+/// Represents one or more annotated file snippets which together form a\n+/// complete diagnostic message.\n+class AnnotatedSourceSnippet {\n+  SourceManager &SM;\n+  std::map<unsigned, AnnotatedFileExcerpt> FileExcerpts;\n+  SmallVector<std::pair<DiagnosticKind, std::string>, 1>\n+      UnknownLocationMessages;\n+\n+  AnnotatedFileExcerpt &excerptForLoc(SourceLoc Loc) {\n+    unsigned bufID = SM.findBufferContainingLoc(Loc);\n+    FileExcerpts.emplace(bufID, AnnotatedFileExcerpt(SM, bufID, Loc));\n+    return FileExcerpts.find(bufID)->second;\n+  }\n+\n+public:\n+  AnnotatedSourceSnippet(SourceManager &SM) : SM(SM){};\n+\n+  void addMessage(SourceLoc Loc, DiagnosticKind Kind, StringRef Message) {\n+    if (Loc.isInvalid()) {\n+      UnknownLocationMessages.push_back({Kind, Message.str()});\n+      return;\n+    }\n+    excerptForLoc(Loc).addMessage(Loc, Kind, Message);\n+  }\n+\n+  void addHighlight(CharSourceRange Range) {\n+    if (Range.isInvalid())\n+      return;\n+    excerptForLoc(Range.getStart()).addHighlight(Range);\n+  }\n+\n+  void addFixIt(CharSourceRange Range, StringRef Text) {\n+    if (Range.isInvalid())\n+      return;\n+    excerptForLoc(Range.getStart()).addFixIt(Range, Text);\n+  }\n+\n+  void render(raw_ostream &Out) {\n+    // Print the excerpt for each file.\n+    for (auto excerpt : FileExcerpts)\n+      excerpt.second.render(Out);\n+\n+    // Handle messages with invalid locations.\n+    if (!UnknownLocationMessages.empty()) {\n+      Out.changeColor(ColoredStream::Colors::MAGENTA, /*bold*/ true);\n+      Out << \"Unknown Location\\n\";\n+      Out.resetColor();\n+    }\n+    for (auto unknownMessage : UnknownLocationMessages) {\n+      printEmptyGutter(2, Out);\n+      printDiagnosticKind(unknownMessage.first, Out);\n+      Out << \" \" << unknownMessage.second << \"\\n\";\n+    }\n+  }\n+};\n+} // namespace swift\n+\n+static void annotateSnippetWithInfo(SourceManager &SM,\n+                                    const DiagnosticInfo &Info,\n+                                    AnnotatedSourceSnippet &Snippet) {\n+  llvm::SmallString<256> Text;\n+  {\n+    llvm::raw_svector_ostream Out(Text);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n+    // Show associated fix-its as part of the message. This is a\n+    // better experience when notes offer a choice of fix-its. It's redundant\n+    // for fix-its which are also displayed inline, but helps improve\n+    // readability in some situations.\n+    if (!Info.FixIts.empty()) {\n+      Out << \" \";\n+      describeFixIts(SM, Info.FixIts, Out);\n+    }\n+  }\n+\n+  Snippet.addMessage(Info.Loc, Info.Kind, Text);\n+  for (auto range : Info.Ranges) {\n+    Snippet.addHighlight(range);\n+  }\n+\n+  // Don't print inline fix-its for notes.\n+  if (Info.Kind != DiagnosticKind::Note) {\n+    for (auto fixIt : Info.FixIts) {\n+      Snippet.addFixIt(fixIt.getRange(), fixIt.getText());\n+    }\n+  }\n+  // Add any explicitly grouped notes to the snippet.\n+  for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n+    annotateSnippetWithInfo(SM, *ChildInfo, Snippet);\n+  }\n+}\n+\n+// MARK: Main DiagnosticConsumer entrypoint.\n void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n                                                   const DiagnosticInfo &Info) {\n+  if (Info.Kind == DiagnosticKind::Error) {\n+    DidErrorOccur = true;\n+  }\n+\n   if (Info.IsChildNote)\n     return;\n \n-  printDiagnostic(SM, Info);\n-  for (auto path : Info.EducationalNotePaths) {\n-    if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n-      Stream << buffer->get()->getBuffer() << \"\\n\";\n+  if (ExperimentalFormattingEnabled) {\n+    if (Info.Kind == DiagnosticKind::Note && currentSnippet) {\n+      // If this is a note and we have an in-flight message, add it to that\n+      // instead of emitting it separately.\n+      annotateSnippetWithInfo(SM, Info, *currentSnippet);\n+    } else {\n+      // If we encounter a new error/warning/remark, flush any in-flight\n+      // snippets.\n+      flush(/*includeTrailingBreak*/ true);\n+      currentSnippet = std::make_unique<AnnotatedSourceSnippet>(SM);\n+      annotateSnippetWithInfo(SM, Info, *currentSnippet);\n+    }\n+  } else {\n+    printDiagnostic(SM, Info);\n+\n+    for (auto path : Info.EducationalNotePaths) {\n+      if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n+        Stream << buffer->get()->getBuffer() << \"\\n\";\n+    }\n+\n+    for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n+      printDiagnostic(SM, *ChildInfo);\n+    }\n   }\n+}\n \n-  for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n-    printDiagnostic(SM, *ChildInfo);\n+void PrintingDiagnosticConsumer::flush(bool includeTrailingBreak) {\n+  if (currentSnippet) {\n+    if (ForceColors) {\n+      ColoredStream colorStream{Stream};\n+      currentSnippet->render(colorStream);\n+      if (includeTrailingBreak)\n+        colorStream << \"\\n\\n\";\n+    } else {\n+      NoColorStream noColorStream{Stream};\n+      currentSnippet->render(noColorStream);\n+      if (includeTrailingBreak)\n+        noColorStream << \"\\n\\n\";\n+    }\n+    currentSnippet.reset();\n   }\n }\n \n+bool PrintingDiagnosticConsumer::finishProcessing() {\n+  // If there's an in-flight snippet, flush it.\n+  flush(false);\n+  return false;\n+}\n+\n+// MARK: LLVM style diagnostic printing\n void PrintingDiagnosticConsumer::printDiagnostic(SourceManager &SM,\n                                                  const DiagnosticInfo &Info) {\n \n@@ -101,10 +731,6 @@ void PrintingDiagnosticConsumer::printDiagnostic(SourceManager &SM,\n     break;\n   }\n \n-  if (Info.Kind == DiagnosticKind::Error) {\n-    DidErrorOccur = true;\n-  }\n-\n   // Translate ranges.\n   SmallVector<llvm::SMRange, 2> Ranges;\n   for (auto R : Info.Ranges)\n@@ -194,3 +820,31 @@ SourceManager::GetMessage(SourceLoc Loc, llvm::SourceMgr::DiagKind Kind,\n                             LineStr, ColRanges, FixIts);\n }\n \n+// These must come after the declaration of AnnotatedSourceSnippet due to the\n+// `currentSnippet` member.\n+PrintingDiagnosticConsumer::PrintingDiagnosticConsumer(\n+    llvm::raw_ostream &stream)\n+    : Stream(stream) {}\n+PrintingDiagnosticConsumer::~PrintingDiagnosticConsumer() = default;\n+\n+// FIXME: This implementation is inefficient.\n+std::string SourceManager::getLineString(unsigned BufferID,\n+                                         unsigned LineNumber) {\n+  SourceLoc Loc = getLocForLineCol(BufferID, LineNumber, 1);\n+  if (Loc.isInvalid())\n+    return \"\";\n+\n+  auto CurMB = LLVMSourceMgr.getMemoryBuffer(findBufferContainingLoc(Loc));\n+  const char *LineStart = Loc.Value.getPointer();\n+  const char *BufStart = CurMB->getBufferStart();\n+  while (LineStart != BufStart && LineStart[-1] != '\\n' &&\n+         LineStart[-1] != '\\r')\n+    --LineStart;\n+\n+  // Get the end of the line.\n+  const char *LineEnd = Loc.Value.getPointer();\n+  const char *BufEnd = CurMB->getBufferEnd();\n+  while (LineEnd != BufEnd && LineEnd[0] != '\\n' && LineEnd[0] != '\\r')\n+    ++LineEnd;\n+  return std::string(LineStart, LineEnd);\n+}"
                    },
                    {
                        "filename": "lib/FrontendTool/FrontendTool.cpp",
                        "code": "@@ -2145,6 +2145,11 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n   if (Invocation.getDiagnosticOptions().UseColor)\n     PDC.forceColors();\n \n+  // Temporarily stage the new diagnostic formatting style behind\n+  // -enable-descriptive-diagnostics\n+  if (Invocation.getDiagnosticOptions().EnableExperimentalFormatting)\n+    PDC.enableExperimentalFormatting();\n+\n   if (Invocation.getFrontendOptions().DebugTimeCompilation)\n     SharedTimer::enableCompilationTimers();\n "
                    },
                    {
                        "filename": "lib/Immediate/REPL.cpp",
                        "code": "@@ -850,6 +850,11 @@ class REPLEnvironment {\n   }\n \n   bool executeSwiftSource(llvm::StringRef Line, const ProcessCmdLine &CmdLine) {\n+    SWIFT_DEFER {\n+      // Always flush diagnostic consumers after executing a line.\n+      CI.getDiags().flushConsumers();\n+    };\n+\n     // Parse the current line(s).\n     auto InputBuf = llvm::MemoryBuffer::getMemBufferCopy(Line, \"<REPL Input>\");\n     SmallString<8> Name{\"REPL_\"};"
                    },
                    {
                        "filename": "test/SourceKit/Sema/educational_note_diags.swift",
                        "code": "@@ -1,6 +1,6 @@\n extension (Int, Int) {}\n \n-// RUN: %sourcekitd-test -req=sema %s -- -Xfrontend -enable-descriptive-diagnostics -Xfrontend -diagnostic-documentation-path -Xfrontend /educational/notes/path/prefix %s | %FileCheck %s -check-prefix=DESCRIPTIVE\n+// RUN: %sourcekitd-test -req=sema %s -- -Xfrontend -enable-educational-notes -Xfrontend -diagnostic-documentation-path -Xfrontend /educational/notes/path/prefix %s | %FileCheck %s -check-prefix=DESCRIPTIVE\n \n // DESCRIPTIVE:      key.description: \"non-nominal type\n // DESCRIPTIVE:      key.educational_note_paths: ["
                    },
                    {
                        "filename": "test/diagnostics/educational-notes.swift",
                        "code": "@@ -1,4 +1,4 @@\n-// RUN: not %target-swift-frontend -enable-descriptive-diagnostics -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s\n+// RUN: not %target-swift-frontend -enable-educational-notes -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s\n \n // A diagnostic with no educational notes\n let x = 1 +"
                    },
                    {
                        "filename": "test/diagnostics/pretty-printed-diagnostics.swift",
                        "code": "@@ -0,0 +1,165 @@\n+// RUN: not %target-swift-frontend -enable-experimental-diagnostic-formatting -typecheck %s 2>&1 | %FileCheck %s\n+\n+1 + 2\n+\n+func foo(a: Int, b: Int) {\n+  a + b\n+}\n+\n+foo(b: 1, a: 2)\n+\n+\n+func baz() {\n+  bar(a: \"hello, world!\")\n+}\n+\n+struct Foo {\n+  var x: Int\n+  var x: Int\n+}\n+\n+func bar(a: Int) {}\n+func bar(a: Float) {}\n+\n+\n+func bazz() throws {\n+\n+}\n+bazz()\n+\n+struct A {}\n+extension A {\n+  let x: Int = { 42 }\n+}\n+\n+let abc = \"\ud83d\udc4d\n+\n+let x = {\n+  let y = 1\n+  return y\n+}\n+\n+struct B: Decodable {\n+  let a: Foo\n+}\n+\n+// The line below is indented with tabs, not spaces.\n+\t\t\tfoo(b: 1, a: 2)\n+\n+let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n+  let y = 1\n+  return y\n+}\n+\n+// Test fallback for non-ASCII characters.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:11\n+// CHECK: [[#LINE-1]] |\n+// CHECK: [[#LINE]]   | let abc = \"\ud83d\udc4d\n+// CHECK:             | --> error: unterminated string literal\n+// CHECK: [[#LINE+1]] |\n+\n+// Test underlining.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:3\n+// CHECK: [[#LINE-1]] |\n+// CHECK: [[#LINE]]   | 1 + 2\n+// CHECK:             | ~   ~\n+// CHECK:             |   ^ warning: result of operator '+' is unused\n+// CHECK: [[#LINE+1]] |\n+\n+// Test inline fix-it rendering.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:11\n+// CHECK:  [[#LINE-1]] |\n+// CHECK:  [[#LINE]]   | foo(a: 2, b: 1, a: 2)\n+// CHECK:              |     ++++++~~~~------\n+// CHECK:              |                 ^ error: argument 'a' must precede argument 'b' [remove ', a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]]  |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:7\n+// CHECK: [[#LINE-2]] | struct Foo {\n+// CHECK: [[#LINE-1]] |   var x: Int\n+// CHECK:             |       ^ note: 'x' previously declared here\n+// CHECK: [[#LINE]]   |   var x: Int\n+// CHECK:             |       ^ error: invalid redeclaration of 'x'\n+// CHECK: [[#LINE+1]] | }\n+\n+// Test out-of-line fix-its on notes.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:1\n+// CHECK: [[#LINE-1]] | }\n+// CHECK: [[#LINE]]   | bazz()\n+// CHECK:             | ~~~~~~\n+// CHECK:             | ^ error: call can throw but is not marked with 'try'\n+// CHECK:             | ^ note: did you mean to use 'try'? [insert 'try ']\n+// CHECK:             | ^ note: did you mean to handle error as optional value? [insert 'try? ']\n+// CHECK:             | ^ note: did you mean to disable error propagation? [insert 'try! ']\n+// CHECK: [[#LINE+1]] |\n+\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:7\n+// CHECK: [[#LINE-1]] | extension A {\n+// CHECK: [[#LINE]]   |   let x: Int = { 42 }\n+// CHECK:             |       ^ error: extensions must not contain stored properties\n+// CHECK: [[#LINE+1]] | }\n+\n+// Test complex out-of-line fix-its.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:16\n+// CHECK: [[#LINE-1]] | extension A {\n+// CHECK: [[#LINE]]   |   let x: Int = { 42 }()\n+// CHECK:             |                ~~~~~~++\n+// CHECK:             |                ^ error: function produces expected type 'Int'; did you mean to call it with '()'?\n+// CHECK:             |                ^ note: Remove '=' to make 'x' a computed property [remove '= ' and replace 'let' with 'var']\n+// CHECK: [[#LINE+1]] | }\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:9\n+// CHECK: [[#LINE-1]] |\n+// CHECK: [[#LINE]]   | let x = { () -> Result in\n+// CHECK:             |          +++++++++++++++++\n+// CHECK:             |         ^ error: unable to infer complex closure return type; add explicit type to disambiguate\n+// CHECK: [[#LINE+1]] |   let y = 1\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:8\n+// CHECK: [[#LINE-1]] |\n+// CHECK: [[#LINE]]   | struct B: Decodable {\n+// CHECK:             |        ^ error: type 'B' does not conform to protocol 'Decodable'\n+// CHECK: [[#LINE+1]] |   let a: Foo\n+// CHECK:             |       ^ note: cannot automatically synthesize 'Decodable' because 'Foo' does not conform to 'Decodable'\n+// CHECK: [[#LINE+2]] | }\n+// CHECK: Swift.Decodable:2:5\n+// CHECK: 1 | public protocol Decodable {\n+// CHECK: 2 |     init(from decoder: Decoder) throws\n+// CHECK:   |     ^ note: protocol requires initializer 'init(from:)' with type 'Decodable'\n+// CHECK: 3 | }\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:14\n+// CHECK: [[#LINE-1]] | // The line below is indented with tabs, not spaces.\n+// CHECK: [[#LINE]]   |       foo(a: 2, b: 1, a: 2)\n+// CHECK:             |           ++++++~~~~------\n+// CHECK:             |                       ^ error: argument 'a' must precede argument 'b' [remove ', a: 2' and insert 'a: 2, ']\n+// CHECK: [[#LINE+1]] |\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:20\n+// CHECK: [[#LINE-1]] |\n+// CHECK: [[#LINE]]   | let \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d = {\n+// CHECK:    | --> error: unable to infer complex closure return type; add explicit type to disambiguate [insert ' () -> <#Result#> in ']\n+// CHECK: [[#LINE+1]] |   let y = 1\n+\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:5\n+// CHECK: [[#LINE-1]] | func foo(a: Int, b: Int) {\n+// CHECK: [[#LINE]]   |   a + b\n+// CHECK:             |   ~   ~\n+// CHECK:             |     ^ warning: result of operator '+' is unused\n+// CHECK: [[#LINE+1]] | }\n+\n+// Test snippet truncation.\n+// CHECK: SOURCE_DIR{{[/\\]+}}test{{[/\\]+}}diagnostics{{[/\\]+}}pretty-printed-diagnostics.swift:[[#LINE:]]:3\n+// CHECK: [[#LINE-1]] | func baz() {\n+// CHECK: [[#LINE]]   |   bar(a: \"hello, world!\")\n+// CHECK:             |   ^ error: no exact matches in call to global function 'bar'\n+// CHECK: [[#LINE+1]] | }\n+// CHECK:   ...\n+// CHECK: [[#LINE:]]  |\n+// CHECK: [[#LINE+1]] | func bar(a: Int) {}\n+// CHECK:             |      ^ note: candidate expects value of type 'Int' for parameter #1\n+// CHECK: [[#LINE+2]] | func bar(a: Float) {}\n+// CHECK:             |      ^ note: candidate expects value of type 'Float' for parameter #1\n+// CHECK: [[#LINE+3]] |"
                    }
                ]
            },
            {
                "date": "2020-02-29T17:39:18Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/f0eb312594797b84b9429fac513459cd113851c7",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -4797,7 +4797,7 @@ ERROR(property_wrapper_wrong_initial_value_init, none,\n       \"'wrappedValue' property type (%2) or an @autoclosure thereof\",\n       (DeclName, Type, Type))\n ERROR(property_wrapper_failable_init, none,\n-      \"%0 cannot be failable\", (DeclName))\n+      \"property wrapper initializer %0 cannot be failable\", (DeclName))\n ERROR(property_wrapper_type_requirement_not_accessible,none,\n       \"%select{private|fileprivate|internal|public|open}0 %1 %2 cannot have \"\n       \"more restrictive access than its enclosing property wrapper type %3 \""
                    },
                    {
                        "filename": "include/swift/AST/EducationalNotes.def",
                        "code": "@@ -34,4 +34,13 @@ EDUCATIONAL_NOTES(invalid_dynamic_callable_type,\n EDUCATIONAL_NOTES(missing_dynamic_callable_kwargs_method,\n                   \"dynamic-callable-requirements.md\")\n \n+EDUCATIONAL_NOTES(property_wrapper_no_value_property,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_wrong_initial_value_init,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_failable_init,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_type_requirement_not_accessible,\n+                  \"property-wrapper-requirements.md\")\n+\n #undef EDUCATIONAL_NOTES"
                    },
                    {
                        "filename": "test/decl/var/property_wrappers.swift",
                        "code": "@@ -112,7 +112,7 @@ struct MultipleInitialValues<Value> {\n struct InitialValueFailable<Value> {\n   var wrappedValue: Value\n \n-  init?(wrappedValue initialValue: Value) { // expected-error{{'init(wrappedValue:)' cannot be failable}}\n+  init?(wrappedValue initialValue: Value) { // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}}\n     return nil\n   }\n }\n@@ -121,7 +121,7 @@ struct InitialValueFailable<Value> {\n struct InitialValueFailableIUO<Value> {\n   var wrappedValue: Value\n \n-  init!(wrappedValue initialValue: Value) {  // expected-error{{'init(wrappedValue:)' cannot be failable}}\n+  init!(wrappedValue initialValue: Value) {  // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}}\n     return nil\n   }\n }"
                    },
                    {
                        "filename": "userdocs/diagnostics/property-wrapper-requirements.md",
                        "code": "@@ -0,0 +1,7 @@\n+Property Wrapper Implementation Requirements\n+---\n+If a type is marked with the `@propertyWrapper` attribute, it must meet certain requirements to be a valid property wrapper.\n+\n+First, all property wrapper types must have a property named `wrappedValue`. This property cannot be static and must have the same access level as the property wrapper type. If the property wrapper provides a `projectedValue` property, it is subject to the same requirements.\n+\n+Second, none of a property wrapper's initializers may be failable. Additionally, if a property wrapper initializer has a `wrappedValue` parameter, the type of that parameter must either be the same as the type of the `wrappedValue` property or an `@autoclosure` of that type.\n\\ No newline at end of file"
                    }
                ]
            },
            {
                "date": "2020-02-29T00:41:47Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/05e6364d39ddcc0d4fa9a60b53a3f092cf6aab3e",
                "changes": [
                    {
                        "filename": "test/SourceKit/Sema/educational_note_diags.swift",
                        "code": "@@ -4,7 +4,7 @@ extension (Int, Int) {}\n \n // DESCRIPTIVE:      key.description: \"non-nominal type\n // DESCRIPTIVE:      key.educational_note_paths: [\n-// DESCRIPTIVE-NEXT:   \"/educational/notes/path/prefix/nominal-types.md\"\n+// DESCRIPTIVE-NEXT:   \"{{[/\\\\]+}}educational{{[/\\\\]+}}notes{{[/\\\\]+}}path{{[/\\\\]+}}prefix{{[/\\\\]+}}nominal-types.md\"\n // DESCRIPTIVE-NEXT: ]\n \n // RUN: %sourcekitd-test -req=sema %s -- %s | %FileCheck %s -check-prefix=DESCRIPTIVE-DISABLED"
                    }
                ]
            },
            {
                "date": "2020-02-28T04:00:06Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/c75a363e1cbc93db6d5ddb643ada9198e1b40d8f",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -4795,7 +4795,7 @@ ERROR(property_wrapper_wrong_initial_value_init, none,\n       \"'wrappedValue' property type (%2) or an @autoclosure thereof\",\n       (DeclName, Type, Type))\n ERROR(property_wrapper_failable_init, none,\n-      \"%0 cannot be failable\", (DeclName))\n+      \"property wrapper initializer %0 cannot be failable\", (DeclName))\n ERROR(property_wrapper_type_requirement_not_accessible,none,\n       \"%select{private|fileprivate|internal|public|open}0 %1 %2 cannot have \"\n       \"more restrictive access than its enclosing property wrapper type %3 \""
                    },
                    {
                        "filename": "include/swift/AST/EducationalNotes.def",
                        "code": "@@ -34,4 +34,13 @@ EDUCATIONAL_NOTES(invalid_dynamic_callable_type,\n EDUCATIONAL_NOTES(missing_dynamic_callable_kwargs_method,\n                   \"dynamic-callable-requirements.md\")\n \n+EDUCATIONAL_NOTES(property_wrapper_no_value_property,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_wrong_initial_value_init,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_failable_init,\n+                  \"property-wrapper-requirements.md\")\n+EDUCATIONAL_NOTES(property_wrapper_type_requirement_not_accessible,\n+                  \"property-wrapper-requirements.md\")\n+\n #undef EDUCATIONAL_NOTES"
                    },
                    {
                        "filename": "test/decl/var/property_wrappers.swift",
                        "code": "@@ -112,7 +112,7 @@ struct MultipleInitialValues<Value> {\n struct InitialValueFailable<Value> {\n   var wrappedValue: Value\n \n-  init?(wrappedValue initialValue: Value) { // expected-error{{'init(wrappedValue:)' cannot be failable}}\n+  init?(wrappedValue initialValue: Value) { // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}}\n     return nil\n   }\n }\n@@ -121,7 +121,7 @@ struct InitialValueFailable<Value> {\n struct InitialValueFailableIUO<Value> {\n   var wrappedValue: Value\n \n-  init!(wrappedValue initialValue: Value) {  // expected-error{{'init(wrappedValue:)' cannot be failable}}\n+  init!(wrappedValue initialValue: Value) {  // expected-error{{property wrapper initializer 'init(wrappedValue:)' cannot be failable}}\n     return nil\n   }\n }"
                    },
                    {
                        "filename": "userdocs/diagnostics/property-wrapper-requirements.md",
                        "code": "@@ -0,0 +1,7 @@\n+Property Wrapper Implementation Requirements\n+---\n+If a type is marked with the `@propertyWrapper` attribute, it must meet certain requirements to be a valid property wrapper.\n+\n+First, all property wrapper types must have a property named `wrappedValue`. This property cannot be static and must have the same access level as the property wrapper type. If the property wrapper provides a `projectedValue` property, it is subject to the same requirements.\n+\n+Second, none of a property wrapper's initializers may be failable. Additionally, if a property wrapper initializer has a `wrappedValue` parameter, the type of that parameter must either be the same as the type of the `wrappedValue` property or an `@autoclosure` of that type.\n\\ No newline at end of file"
                    }
                ]
            },
            {
                "date": "2020-02-27T16:12:35Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/78b6759ba49b06239917f3e7d6af4d8eab401b42",
                "changes": [
                    {
                        "filename": "test/SourceKit/Sema/educational_note_diags.swift",
                        "code": "@@ -0,0 +1,13 @@\n+extension (Int, Int) {}\n+\n+// RUN: %sourcekitd-test -req=sema %s -- -Xfrontend -enable-descriptive-diagnostics -Xfrontend -diagnostic-documentation-path -Xfrontend /educational/notes/path/prefix %s | %FileCheck %s -check-prefix=DESCRIPTIVE\n+\n+// DESCRIPTIVE:      key.description: \"non-nominal type\n+// DESCRIPTIVE:      key.educational_note_paths: [\n+// DESCRIPTIVE-NEXT:   \"/educational/notes/path/prefix/nominal-types.md\"\n+// DESCRIPTIVE-NEXT: ]\n+\n+// RUN: %sourcekitd-test -req=sema %s -- %s | %FileCheck %s -check-prefix=DESCRIPTIVE-DISABLED\n+\n+// DESCRIPTIVE-DISABLED:     key.description: \"non-nominal type\n+// DESCRIPTIVE-DISABLED-NOT: key.educational_note_paths"
                    },
                    {
                        "filename": "tools/SourceKit/docs/Protocol.md",
                        "code": "@@ -418,6 +418,7 @@ of diagnostic entries. A diagnostic entry has this format:\n     [opts] <key.fixits>:    (array) [fixit+] // one or more entries for fixits\n     [opts] <key.ranges>:    (array) [range+] // one or more entries for ranges\n     [opts] <key.diagnostics>: (array) [diagnostic+] // one or more sub-diagnostic entries\n+    [opts] <key.educational_note_paths>: (array) [string+] // one or more absolute paths of educational notes, formatted as Markdown\n }\n ```\n "
                    },
                    {
                        "filename": "tools/SourceKit/include/SourceKit/Core/LangSupport.h",
                        "code": "@@ -203,6 +203,7 @@ struct DiagnosticEntryInfoBase {\n   std::string Filename;\n   SmallVector<std::pair<unsigned, unsigned>, 2> Ranges;\n   SmallVector<Fixit, 2> Fixits;\n+  SmallVector<std::string, 1> EducationalNotePaths;\n };\n \n struct DiagnosticEntryInfo : DiagnosticEntryInfoBase {"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftEditor.cpp",
                        "code": "@@ -110,6 +110,9 @@ void EditorDiagConsumer::handleDiagnostic(SourceManager &SM,\n   }\n   SKInfo.Description = Text.str();\n \n+  for (auto notePath : Info.EducationalNotePaths)\n+    SKInfo.EducationalNotePaths.push_back(notePath);\n+\n   Optional<unsigned> BufferIDOpt;\n   if (Info.Loc.isValid()) {\n     BufferIDOpt = SM.findBufferContainingLoc(Info.Loc);"
                    },
                    {
                        "filename": "tools/SourceKit/tools/sourcekitd/lib/API/Requests.cpp",
                        "code": "@@ -2686,6 +2686,9 @@ static void fillDictionaryForDiagnosticInfoBase(\n   if (!Info.Filename.empty())\n     Elem.set(KeyFilePath, Info.Filename);\n \n+  if (!Info.EducationalNotePaths.empty())\n+    Elem.set(KeyEducationalNotePaths, Info.EducationalNotePaths);\n+\n   if (!Info.Ranges.empty()) {\n     auto RangesArr = Elem.setArray(KeyRanges);\n     for (auto R : Info.Ranges) {"
                    },
                    {
                        "filename": "utils/gyb_sourcekit_support/UIDs.py",
                        "code": "@@ -96,6 +96,7 @@ def __init__(self, internal_name, external_name):\n     KEY('Ranges', 'key.ranges'),\n     KEY('Fixits', 'key.fixits'),\n     KEY('Diagnostics', 'key.diagnostics'),\n+    KEY('EducationalNotePaths', 'key.educational_note_paths'),\n     KEY('FormatOptions', 'key.editor.format.options'),\n     KEY('CodeCompleteOptions', 'key.codecomplete.options'),\n     KEY('FilterRules', 'key.codecomplete.filterrules'),"
                    }
                ]
            }
        ],
        [
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ],
        [
            {
                "date": "2019-11-07T21:18:07Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/da7e1ca8ad4731f52cbdb6eb8a0239aa35e03c8f",
                "changes": [
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -90,6 +90,25 @@ The Swift compiler has a setting (under LangOptions) called `DiagnosticsEditorMo\n \n Most diagnostics have no reason to change behavior under editor mode. An example of an exception is the \"protocol requirements not satisfied diagnostic\"; on the command line, it may be better to show all unsatisfied requirements, while in an IDE a single multi-line fix-it would be preferred.\n \n+### Educational Notes ###\n+\n+**Note**: This feature is currently experimental. It can be enabled by passing the `-Xfrontend -enable-descriptive-diagnostics` flag.\n+\n+Educational notes are small snippets of documentation attached to a diagnostic which explain relevant language concepts. They are intended to further Swift's goal of progressive disclosure by providing a learning resource at the point of use for users encountering a new error message for the first time. In very limited circumstances, they also allow the main diagnostic message to use more precise and correct terminology (e.g. nominal types) which would otherwise be too unfriendly for beginners.\n+\n+When outputting diagnostics on the command line, educational notes will be printed after the main diagnostic body if descriptive diagnostics are enabled. When presented in an IDE, it's expected they will be collapsed under a disclosure arrow, info button, or similar to avoid cluttering output.\n+\n+Generally speaking, a diagnostic should try to provide educational notes for any concepts/terminology which is difficult to understand from context or is especially subtle. Educational notes should:\n+- Explain a single language concept. This makes them easy to reuse across diagnostics and helps keep them clear, concise, and easy to understand.\n+- Be written in unabbreviated English. These are longer form messages compared to the main diagnostic, so there is no need to omit needless words and punctuation.\n+- Not generally exceed 3-4 paragraphs. Educational notes should be clear and easily digestible. Messages which are too long also have the potential to create diagnostics UX issues in some contexts.\n+- Be accessible. Educational notes should be beginner friendly and avoid assuming unnecesary prior knowledge. The goal is not only to help users understand what a diagnostic is telling them, but also to turn errors and warnings into \"teachable moments\".\n+- Include references to relevant chapters of _The Swift Programming Language_ if applicable.\n+- Be written in Markdown, but avoid excessive markup to avoid impacting the terminal UX. \n+\n+To add a new educational note:\n+1. Add a new Markdown file in the `userdocs/diagnostics/` directory containing the contents of the note. \n+2. Associate the note with one or more diagnostics in EducationalNotes.def.\n \n ### Format Specifiers ###\n "
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -70,10 +70,8 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n \n   printDiagnostic(SM, Info);\n   for (auto path : Info.EducationalNotePaths) {\n-    auto buffer = llvm::MemoryBuffer::getFile(path);\n-    if (buffer) {\n+    if (auto buffer = SM.getFileSystem()->getBufferForFile(path))\n       Stream << buffer->get()->getBuffer() << \"\\n\";\n-    }\n   }\n \n   for (auto ChildInfo : Info.ChildDiagnosticInfo) {"
                    }
                ]
            },
            {
                "date": "2019-11-02T20:48:38Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/ac05a6693803c6844a833a60fc26475960214a10",
                "changes": [
                    {
                        "filename": "CMakeLists.txt",
                        "code": "@@ -1129,6 +1129,8 @@ endif()\n \n add_subdirectory(utils)\n \n+add_subdirectory(userdocs)\n+\n if (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Darwin\")\n   if(SWIFT_BUILD_PERF_TESTSUITE)\n     add_subdirectory(benchmark)"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticConsumer.h",
                        "code": "@@ -57,6 +57,9 @@ struct DiagnosticInfo {\n   /// DiagnosticInfo of notes which are children of this diagnostic, if any\n   ArrayRef<DiagnosticInfo *> ChildDiagnosticInfo;\n \n+  /// Paths to \"educational note\" diagnostic documentation in the toolchain.\n+  ArrayRef<std::string> EducationalNotePaths;\n+\n   /// Represents a fix-it, a replacement of one range of text with another.\n   class FixIt {\n     CharSourceRange Range;"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -673,6 +673,9 @@ namespace swift {\n     /// Use descriptive diagnostic style when available.\n     bool useDescriptiveDiagnostics = false;\n \n+    /// Path to diagnostic documentation directory.\n+    std::string diagnosticDocumentationPath = \"\";\n+\n     friend class InFlightDiagnostic;\n     friend class DiagnosticTransaction;\n     friend class CompoundDiagnosticTransaction;\n@@ -723,6 +726,13 @@ namespace swift {\n       return useDescriptiveDiagnostics;\n     }\n \n+    void setDiagnosticDocumentationPath(std::string path) {\n+      diagnosticDocumentationPath = path;\n+    }\n+    StringRef getDiagnosticDocumentationPath() {\n+      return diagnosticDocumentationPath;\n+    }\n+\n     void ignoreDiagnostic(DiagID id) {\n       state.setDiagnosticBehavior(id, DiagnosticState::Behavior::Ignore);\n     }"
                    },
                    {
                        "filename": "include/swift/AST/EducationalNotes.def",
                        "code": "@@ -0,0 +1,29 @@\n+//===-- EducationalNotes.def - Diagnostic Documentation Content -*- C++ -*-===//\n+//\n+// This source file is part of the Swift.org open source project\n+//\n+// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors\n+// Licensed under Apache License v2.0 with Runtime Library Exception\n+//\n+// See https://swift.org/LICENSE.txt for license information\n+// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file associates diagnostics with relevant educational notes which\n+// explain important concepts.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef EDUCATIONAL_NOTES\n+#  error Must define EDUCATIONAL_NOTES\n+#endif\n+\n+// EDUCATIONAL_NOTES(DIAG_ID, EDUCATIONAL_NOTE_FILENAMES...)\n+\n+EDUCATIONAL_NOTES(non_nominal_no_initializers, \"nominal-types.md\")\n+EDUCATIONAL_NOTES(non_nominal_extension, \"nominal-types.md\")\n+EDUCATIONAL_NOTES(associated_type_witness_conform_impossible,\n+                  \"nominal-types.md\")\n+\n+#undef EDUCATIONAL_NOTES"
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -59,6 +59,8 @@ class DiagnosticOptions {\n   /// Descriptive diagnostic output is not intended to be machine-readable.\n   bool EnableDescriptiveDiagnostics = false;\n \n+  std::string DiagnosticDocumentationPath = \"\";\n+\n   /// Return a hash code of any components from these options that should\n   /// contribute to a Swift Bridging PCH hash.\n   llvm::hash_code getPCHHashComponents() const {"
                    },
                    {
                        "filename": "include/swift/Option/FrontendOptions.td",
                        "code": "@@ -115,6 +115,10 @@ def show_diagnostics_after_fatal : Flag<[\"-\"], \"show-diagnostics-after-fatal\">,\n   \n def enable_descriptive_diagnostics : Flag<[\"-\"], \"enable-descriptive-diagnostics\">,\n   HelpText<\"Show descriptive diagnostic information, if available.\">;\n+  \n+def diagnostic_documentation_path\n+  : Separate<[\"-\"], \"diagnostic-documentation-path\">, MetaVarName<\"<path>\">,\n+  HelpText<\"Path to diagnostic documentation resources\">;\n \n def enable_swiftcall : Flag<[\"-\"], \"enable-swiftcall\">,\n   HelpText<\"Enable the use of LLVM swiftcall support\">;"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -116,6 +116,18 @@ static constexpr const char *const fixItStrings[] = {\n     \"<not a fix-it>\",\n };\n \n+#define EDUCATIONAL_NOTES(DIAG, ...)                                           \\\n+  static constexpr const char *const DIAG##_educationalNotes[] = {__VA_ARGS__, \\\n+                                                                  nullptr};\n+#include \"swift/AST/EducationalNotes.def\"\n+\n+static constexpr const char *const *educationalNotes[LocalDiagID::NumDiags]{\n+    [LocalDiagID::invalid_diagnostic] = {},\n+#define EDUCATIONAL_NOTES(DIAG, ...)                                           \\\n+  [LocalDiagID::DIAG] = DIAG##_educationalNotes,\n+#include \"swift/AST/EducationalNotes.def\"\n+};\n+\n DiagnosticState::DiagnosticState() {\n   // Initialize our per-diagnostic state to default\n   perDiagnosticBehavior.resize(LocalDiagID::NumDiags, Behavior::Unspecified);\n@@ -951,6 +963,19 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n       }\n     }\n     info->ChildDiagnosticInfo = childInfoPtrs;\n+    \n+    SmallVector<std::string, 1> educationalNotePaths;\n+    if (useDescriptiveDiagnostics) {\n+      auto associatedNotes = educationalNotes[(uint32_t)diagnostic.getID()];\n+      while (associatedNotes && *associatedNotes) {\n+        SmallString<128> notePath(getDiagnosticDocumentationPath());\n+        llvm::sys::path::append(notePath, *associatedNotes);\n+        educationalNotePaths.push_back(notePath.str());\n+        associatedNotes++;\n+      }\n+      info->EducationalNotePaths = educationalNotePaths;\n+    }\n+\n     for (auto &consumer : Consumers) {\n       consumer->handleDiagnostic(SourceMgr, *info);\n     }"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -44,6 +44,13 @@ void CompilerInvocation::setMainExecutablePath(StringRef Path) {\n   llvm::sys::path::remove_filename(LibPath); // Remove /bin\n   llvm::sys::path::append(LibPath, \"lib\", \"swift\");\n   setRuntimeResourcePath(LibPath.str());\n+\n+  llvm::SmallString<128> DiagnosticDocsPath(Path);\n+  llvm::sys::path::remove_filename(DiagnosticDocsPath); // Remove /swift\n+  llvm::sys::path::remove_filename(DiagnosticDocsPath); // Remove /bin\n+  llvm::sys::path::append(DiagnosticDocsPath, \"share\", \"doc\", \"swift\",\n+                          \"diagnostics\");\n+  DiagnosticOpts.DiagnosticDocumentationPath = DiagnosticDocsPath.str();\n }\n \n /// If we haven't explicitly passed -prebuilt-module-cache-path, set it to\n@@ -682,7 +689,9 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n   Opts.EnableDescriptiveDiagnostics |=\n       Args.hasArg(OPT_enable_descriptive_diagnostics);\n-\n+  if (Arg *A = Args.getLastArg(OPT_diagnostic_documentation_path)) {\n+    Opts.DiagnosticDocumentationPath = A->getValue();\n+  }\n   assert(!(Opts.WarningsAsErrors && Opts.SuppressWarnings) &&\n          \"conflicting arguments; should have been caught by driver\");\n "
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -319,6 +319,8 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().EnableDescriptiveDiagnostics) {\n     Diagnostics.setUseDescriptiveDiagnostics(true);\n   }\n+  Diagnostics.setDiagnosticDocumentationPath(\n+      Invocation.getDiagnosticOptions().DiagnosticDocumentationPath);\n }\n \n // The ordering of ModuleLoaders is important!"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -69,6 +69,12 @@ void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n     return;\n \n   printDiagnostic(SM, Info);\n+  for (auto path : Info.EducationalNotePaths) {\n+    auto buffer = llvm::MemoryBuffer::getFile(path);\n+    if (buffer) {\n+      Stream << buffer->get()->getBuffer() << \"\\n\";\n+    }\n+  }\n \n   for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n     printDiagnostic(SM, *ChildInfo);"
                    },
                    {
                        "filename": "test/diagnostics/educational-notes.swift",
                        "code": "@@ -0,0 +1,15 @@\n+// RUN: not %target-swift-frontend -enable-descriptive-diagnostics -diagnostic-documentation-path %S/test-docs/ -typecheck %s 2>&1 | %FileCheck %s\n+\n+// A diagnostic with no educational notes\n+let x = 1 +\n+// CHECK: error: expected expression after operator\n+// CHECK-NOT: {{-+$}}\n+\n+// A diagnostic with an educational note\n+extension (Int, Int) {}\n+// CHECK: error: non-nominal type '(Int, Int)' cannot be extended\n+// CHECK-NEXT: extension (Int, Int) {}\n+// CHECK-NEXT: ^         ~~~~~~~~~~\n+// CHECK-NEXT: Nominal Types\n+// CHECK-NEXT: -------------\n+// CHECK-NEXT: Nominal types documentation content"
                    },
                    {
                        "filename": "test/diagnostics/test-docs/nominal-types.md",
                        "code": "@@ -0,0 +1,3 @@\n+Nominal Types\n+-------------\n+Nominal types documentation content"
                    },
                    {
                        "filename": "userdocs/CMakeLists.txt",
                        "code": "@@ -0,0 +1,3 @@\n+swift_install_in_component(DIRECTORY diagnostics\n+                           DESTINATION \"share/doc/swift\"\n+                           COMPONENT compiler)"
                    },
                    {
                        "filename": "userdocs/diagnostics/nominal-types.md",
                        "code": "@@ -0,0 +1,7 @@\n+Nominal types\n+-------------\n+In Swift, a type is considered a nominal type if it is named.  In other words, it has been defined by declaring the type somewhere in code. Examples of nominal types include classes, structs and enums, all of which must be declared before using them. Nominal types are an important concept in Swift because they can be extended, explicitly initialized using the 'MyType()' syntax, and may conform to protocols.\n+\n+In contrast, non-nominal types have none of these capabilities. A non-nominal type is any type which is not nominal. They are sometimes called \u201dstructural types\u201d because they are usually obtained by composing other types. Examples include function types like '(Int) -> (String)', tuple types like '(Int, String)', metatypes like 'Int.Type', and special types like 'Any' and 'AnyObject'.\n+\n+Whether the name of a protocol refers to a nominal or non-nominal type depends on where it appears in code. When used in a declaration or extension like 'extension MyProtocol { \u2026 }', 'MyProtocol' refers to a protocol type, which is nominal. This means that it may be extended and conform to protocols. However, when written as the type of a constant or variable, MyProtocol instead refers to a non-nominal, existential type. As a result, code like 'let value: MyProtocol = MyProtocol()' is not allowed because 'MyProtocol' refers to a non-nominal type in this context and cannot be explicitly initialized."
                    }
                ]
            },
            {
                "date": "2019-10-24T21:47:33Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/8a6711769ee1d05d4d4fbdfbc9115d9bae200b87",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticConsumer.h",
                        "code": "@@ -45,6 +45,13 @@ struct DiagnosticInfo {\n   DiagnosticKind Kind;\n   StringRef FormatString;\n   ArrayRef<DiagnosticArgument> FormatArgs;\n+\n+  /// Only used when directing diagnostics to different outputs.\n+  /// In batch mode a diagnostic may be\n+  /// located in a non-primary file, but there will be no .dia file for a\n+  /// non-primary. If valid, this argument contains a location within a buffer\n+  /// that corresponds to a primary input. The .dia file for that primary can be\n+  /// used for the diagnostic, as if it had occurred at this location.\n   SourceLoc BufferIndirectlyCausingDiagnostic;\n \n   /// DiagnosticInfo of notes which are children of this diagnostic, if any\n@@ -109,29 +116,9 @@ class DiagnosticConsumer {\n   /// \\param SM The source manager associated with the source locations in\n   /// this diagnostic.\n   ///\n-  /// \\param Loc The source location associated with this diagnostic. This\n-  /// location may be invalid, if the diagnostic is not directly related to\n-  /// the source (e.g., if it comes from command-line parsing).\n-  ///\n-  /// \\param Kind The severity of the diagnostic (error, warning, note).\n-  ///\n-  /// \\param FormatArgs The diagnostic format string arguments.\n-  ///\n-  /// \\param Info Extra information associated with the diagnostic.\n-  ///\n-  /// \\param bufferIndirectlyCausingDiagnostic Only used when directing\n-  /// diagnostics to different outputs.\n-  /// In batch mode a diagnostic may be\n-  /// located in a non-primary file, but there will be no .dia file for a\n-  /// non-primary. If valid, this argument contains a location within a buffer\n-  /// that corresponds to a primary input. The .dia file for that primary can be\n-  /// used for the diagnostic, as if it had occurred at this location.\n-  virtual void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   SourceLoc bufferIndirectlyCausingDiagnostic) = 0;\n+  /// \\param Info Information describing the diagnostic.\n+  virtual void handleDiagnostic(SourceManager &SM,\n+                                const DiagnosticInfo &Info) = 0;\n \n   /// \\returns true if an error occurred while finishing-up.\n   virtual bool finishProcessing() { return false; }\n@@ -149,11 +136,7 @@ class DiagnosticConsumer {\n /// DiagnosticConsumer that discards all diagnostics.\n class NullDiagnosticConsumer : public DiagnosticConsumer {\n public:\n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n };\n \n /// DiagnosticConsumer that forwards diagnostics to the consumers of\n@@ -162,11 +145,7 @@ class ForwardingDiagnosticConsumer : public DiagnosticConsumer {\n   DiagnosticEngine &TargetEngine;\n public:\n   ForwardingDiagnosticConsumer(DiagnosticEngine &Target);\n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n };\n \n /// DiagnosticConsumer that funnels diagnostics in certain files to\n@@ -228,18 +207,13 @@ class FileSpecificDiagnosticConsumer : public DiagnosticConsumer {\n                 std::unique_ptr<DiagnosticConsumer> consumer)\n         : inputFileName(inputFileName), consumer(std::move(consumer)) {}\n \n-    void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                          StringRef FormatString,\n-                          ArrayRef<DiagnosticArgument> FormatArgs,\n-                          const DiagnosticInfo &Info,\n-                          const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+    void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) {\n       if (!getConsumer())\n         return;\n-      hasAnErrorBeenConsumed |= Kind == DiagnosticKind::Error;\n-      getConsumer()->handleDiagnostic(SM, Loc, Kind, FormatString, FormatArgs,\n-                                      Info, bufferIndirectlyCausingDiagnostic);\n+      hasAnErrorBeenConsumed |= Info.Kind == DiagnosticKind::Error;\n+      getConsumer()->handleDiagnostic(SM, Info);\n     }\n-    \n+\n     void informDriverOfIncompleteBatchModeCompilation() {\n       if (!hasAnErrorBeenConsumed && getConsumer())\n         getConsumer()->informDriverOfIncompleteBatchModeCompilation();\n@@ -324,11 +298,7 @@ class FileSpecificDiagnosticConsumer : public DiagnosticConsumer {\n       SmallVectorImpl<Subconsumer> &consumers);\n \n public:\n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n \n   bool finishProcessing() override;\n \n@@ -348,12 +318,10 @@ class FileSpecificDiagnosticConsumer : public DiagnosticConsumer {\n   subconsumerForLocation(SourceManager &SM, SourceLoc loc);\n \n   Optional<FileSpecificDiagnosticConsumer::Subconsumer *>\n-  findSubconsumer(SourceManager &SM, SourceLoc loc, DiagnosticKind Kind,\n-                  SourceLoc bufferIndirectlyCausingDiagnostic);\n+  findSubconsumer(SourceManager &SM, const DiagnosticInfo &Info);\n \n   Optional<FileSpecificDiagnosticConsumer::Subconsumer *>\n-  findSubconsumerForNonNote(SourceManager &SM, SourceLoc loc,\n-                            SourceLoc bufferIndirectlyCausingDiagnostic);\n+  findSubconsumerForNonNote(SourceManager &SM, const DiagnosticInfo &Info);\n };\n   \n } // end namespace swift"
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -35,12 +35,8 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   PrintingDiagnosticConsumer(llvm::raw_ostream &stream = llvm::errs()) :\n     Stream(stream) { }\n \n-  virtual void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  virtual void handleDiagnostic(SourceManager &SM,\n+                                const DiagnosticInfo &Info) override;\n \n   void forceColors() {\n     ForceColors = true;\n@@ -52,11 +48,7 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   }\n \n private:\n-  void printDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                       StringRef FormatString,\n-                       ArrayRef<DiagnosticArgument> FormatArgs,\n-                       const DiagnosticInfo &Info,\n-                       SourceLoc bufferIndirectlyCausingDiagnostic);\n+  void printDiagnostic(SourceManager &SM, const DiagnosticInfo &Info);\n };\n   \n }"
                    },
                    {
                        "filename": "include/swift/Migrator/FixitApplyDiagnosticConsumer.h",
                        "code": "@@ -62,11 +62,7 @@ class FixitApplyDiagnosticConsumer final\n   /// output stream.\n   void printResult(llvm::raw_ostream &OS) const;\n \n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n \n   unsigned getNumFixitsApplied() const {\n     return NumFixitsApplied;"
                    },
                    {
                        "filename": "include/swift/Migrator/FixitFilter.h",
                        "code": "@@ -25,8 +25,7 @@ namespace migrator {\n \n struct FixitFilter {\n   /// Returns true if the fix-it should be applied.\n-  bool shouldTakeFixit(const DiagnosticKind Kind,\n-                       const DiagnosticInfo &Info) const {\n+  bool shouldTakeFixit(const DiagnosticInfo &Info) const {\n     // Do not add a semi or comma as it is wrong in most cases during migration\n     if (Info.ID == diag::statement_same_line_without_semi.ID ||\n         Info.ID == diag::declaration_same_line_without_semi.ID ||\n@@ -114,7 +113,7 @@ struct FixitFilter {\n       return false;\n     }\n \n-    if (Kind == DiagnosticKind::Error)\n+    if (Info.Kind == DiagnosticKind::Error)\n       return true;\n \n     // Fixits from warnings/notes that should be applied."
                    },
                    {
                        "filename": "lib/AST/DiagnosticConsumer.cpp",
                        "code": "@@ -179,38 +179,29 @@ FileSpecificDiagnosticConsumer::subconsumerForLocation(SourceManager &SM,\n }\n \n void FileSpecificDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n \n-  HasAnErrorBeenConsumed |= Kind == DiagnosticKind::Error;\n+  HasAnErrorBeenConsumed |= Info.Kind == DiagnosticKind::Error;\n \n-  auto subconsumer =\n-      findSubconsumer(SM, Loc, Kind, bufferIndirectlyCausingDiagnostic);\n+  auto subconsumer = findSubconsumer(SM, Info);\n   if (subconsumer) {\n-    subconsumer.getValue()->handleDiagnostic(SM, Loc, Kind, FormatString,\n-                                             FormatArgs, Info,\n-                                             bufferIndirectlyCausingDiagnostic);\n+    subconsumer.getValue()->handleDiagnostic(SM, Info);\n     return;\n   }\n   // Last resort: spray it everywhere\n   for (auto &subconsumer : Subconsumers)\n-    subconsumer.handleDiagnostic(SM, Loc, Kind, FormatString, FormatArgs, Info,\n-                                 bufferIndirectlyCausingDiagnostic);\n+    subconsumer.handleDiagnostic(SM, Info);\n }\n \n Optional<FileSpecificDiagnosticConsumer::Subconsumer *>\n-FileSpecificDiagnosticConsumer::findSubconsumer(\n-    SourceManager &SM, SourceLoc loc, DiagnosticKind Kind,\n-    SourceLoc bufferIndirectlyCausingDiagnostic) {\n+FileSpecificDiagnosticConsumer::findSubconsumer(SourceManager &SM,\n+                                                const DiagnosticInfo &Info) {\n   // Ensure that a note goes to the same place as the preceeding non-note.\n-  switch (Kind) {\n+  switch (Info.Kind) {\n   case DiagnosticKind::Error:\n   case DiagnosticKind::Warning:\n   case DiagnosticKind::Remark: {\n-    auto subconsumer =\n-        findSubconsumerForNonNote(SM, loc, bufferIndirectlyCausingDiagnostic);\n+    auto subconsumer = findSubconsumerForNonNote(SM, Info);\n     SubconsumerForSubsequentNotes = subconsumer;\n     return subconsumer;\n   }\n@@ -222,18 +213,17 @@ FileSpecificDiagnosticConsumer::findSubconsumer(\n \n Optional<FileSpecificDiagnosticConsumer::Subconsumer *>\n FileSpecificDiagnosticConsumer::findSubconsumerForNonNote(\n-    SourceManager &SM, const SourceLoc loc,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n-  const auto subconsumer = subconsumerForLocation(SM, loc);\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n+  const auto subconsumer = subconsumerForLocation(SM, Info.Loc);\n   if (!subconsumer)\n     return None; // No place to put it; might be in an imported module\n   if ((*subconsumer)->getConsumer())\n     return subconsumer; // A primary file with a .dia file\n   // Try to put it in the responsible primary input\n-  if (bufferIndirectlyCausingDiagnostic.isInvalid())\n+  if (Info.BufferIndirectlyCausingDiagnostic.isInvalid())\n     return None;\n   const auto currentPrimarySubconsumer =\n-      subconsumerForLocation(SM, bufferIndirectlyCausingDiagnostic);\n+      subconsumerForLocation(SM, Info.BufferIndirectlyCausingDiagnostic);\n   assert(!currentPrimarySubconsumer ||\n          (*currentPrimarySubconsumer)->getConsumer() &&\n              \"current primary must have a .dia file\");\n@@ -261,14 +251,12 @@ void FileSpecificDiagnosticConsumer::\n     (*this)[info].informDriverOfIncompleteBatchModeCompilation();\n }\n \n-void NullDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info, const SourceLoc) {\n+void NullDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n+                                              const DiagnosticInfo &Info) {\n   LLVM_DEBUG({\n     llvm::dbgs() << \"NullDiagnosticConsumer received diagnostic: \";\n-    DiagnosticEngine::formatDiagnosticText(llvm::dbgs(), FormatString,\n-                                           FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(llvm::dbgs(), Info.FormatString,\n+                                           Info.FormatArgs);\n     llvm::dbgs() << \"\\n\";\n   });\n }\n@@ -277,18 +265,14 @@ ForwardingDiagnosticConsumer::ForwardingDiagnosticConsumer(DiagnosticEngine &Tar\n   : TargetEngine(Target) {}\n \n void ForwardingDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n   LLVM_DEBUG({\n     llvm::dbgs() << \"ForwardingDiagnosticConsumer received diagnostic: \";\n-    DiagnosticEngine::formatDiagnosticText(llvm::dbgs(), FormatString,\n-                                           FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(llvm::dbgs(), Info.FormatString,\n+                                           Info.FormatArgs);\n     llvm::dbgs() << \"\\n\";\n   });\n   for (auto *C : TargetEngine.getConsumers()) {\n-    C->handleDiagnostic(SM, Loc, Kind, FormatString, FormatArgs, Info,\n-                        bufferIndirectlyCausingDiagnostic);\n+    C->handleDiagnostic(SM, Info);\n   }\n }"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -952,9 +952,7 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n     }\n     info->ChildDiagnosticInfo = childInfoPtrs;\n     for (auto &consumer : Consumers) {\n-      consumer->handleDiagnostic(SourceMgr, info->Loc, info->Kind,\n-                                 info->FormatString, info->FormatArgs, *info,\n-                                 info->BufferIndirectlyCausingDiagnostic);\n+      consumer->handleDiagnostic(SourceMgr, *info);\n     }\n   }\n "
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -63,53 +63,44 @@ namespace {\n   };\n } // end anonymous namespace\n \n-void PrintingDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+void PrintingDiagnosticConsumer::handleDiagnostic(SourceManager &SM,\n+                                                  const DiagnosticInfo &Info) {\n   if (Info.IsChildNote)\n     return;\n \n-  printDiagnostic(SM, Loc, Kind, FormatString, FormatArgs, Info,\n-                  bufferIndirectlyCausingDiagnostic);\n+  printDiagnostic(SM, Info);\n \n   for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n-    printDiagnostic(SM, ChildInfo->Loc, ChildInfo->Kind,\n-                    ChildInfo->FormatString, ChildInfo->FormatArgs, *ChildInfo,\n-                    ChildInfo->BufferIndirectlyCausingDiagnostic);\n+    printDiagnostic(SM, *ChildInfo);\n   }\n }\n \n-void PrintingDiagnosticConsumer::printDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+void PrintingDiagnosticConsumer::printDiagnostic(SourceManager &SM,\n+                                                 const DiagnosticInfo &Info) {\n \n   // Determine what kind of diagnostic we're emitting.\n   llvm::SourceMgr::DiagKind SMKind;\n-  switch (Kind) {\n-    case DiagnosticKind::Error:\n-      SMKind = llvm::SourceMgr::DK_Error;\n-      break;\n-    case DiagnosticKind::Warning: \n-      SMKind = llvm::SourceMgr::DK_Warning; \n-      break;\n-\n-    case DiagnosticKind::Note:\n-      SMKind = llvm::SourceMgr::DK_Note;\n-      break;\n-\n-    case DiagnosticKind::Remark:\n-      SMKind = llvm::SourceMgr::DK_Remark;\n-      break;\n+  switch (Info.Kind) {\n+  case DiagnosticKind::Error:\n+    SMKind = llvm::SourceMgr::DK_Error;\n+    break;\n+  case DiagnosticKind::Warning:\n+    SMKind = llvm::SourceMgr::DK_Warning;\n+    break;\n+\n+  case DiagnosticKind::Note:\n+    SMKind = llvm::SourceMgr::DK_Note;\n+    break;\n+\n+  case DiagnosticKind::Remark:\n+    SMKind = llvm::SourceMgr::DK_Remark;\n+    break;\n   }\n \n-  if (Kind == DiagnosticKind::Error) {\n+  if (Info.Kind == DiagnosticKind::Error) {\n     DidErrorOccur = true;\n   }\n-  \n+\n   // Translate ranges.\n   SmallVector<llvm::SMRange, 2> Ranges;\n   for (auto R : Info.Ranges)\n@@ -129,10 +120,11 @@ void PrintingDiagnosticConsumer::printDiagnostic(\n   llvm::SmallString<256> Text;\n   {\n     llvm::raw_svector_ostream Out(Text);\n-    DiagnosticEngine::formatDiagnosticText(Out, FormatString, FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n   }\n \n-  auto Msg = SM.GetMessage(Loc, SMKind, Text, Ranges, FixIts);\n+  auto Msg = SM.GetMessage(Info.Loc, SMKind, Text, Ranges, FixIts);\n   rawSM.PrintMessage(out, Msg, ForceColors);\n }\n "
                    },
                    {
                        "filename": "lib/Frontend/SerializedDiagnosticConsumer.cpp",
                        "code": "@@ -191,11 +191,7 @@ class SerializedDiagnosticConsumer : public DiagnosticConsumer {\n     CompilationWasComplete = false;\n   }\n \n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n \n   /// The version of the diagnostics file.\n   enum { Version = 1 };\n@@ -543,15 +539,12 @@ emitDiagnosticMessage(SourceManager &SM,\n }\n \n void SerializedDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n \n   // Enter the block for a non-note diagnostic immediately, rather\n   // than waiting for beginDiagnostic, in case associated notes\n   // are emitted before we get there.\n-  if (Kind != DiagnosticKind::Note) {\n+  if (Info.Kind != DiagnosticKind::Note) {\n     if (State->EmittedAnyDiagBlocks)\n       exitDiagBlock();\n \n@@ -561,7 +554,7 @@ void SerializedDiagnosticConsumer::handleDiagnostic(\n \n   // Special-case diagnostics with no location.\n   // Make sure we bracket all notes as \"sub-diagnostics\".\n-  bool bracketDiagnostic = (Kind == DiagnosticKind::Note);\n+  bool bracketDiagnostic = (Info.Kind == DiagnosticKind::Note);\n \n   if (bracketDiagnostic)\n     enterDiagBlock();\n@@ -570,10 +563,11 @@ void SerializedDiagnosticConsumer::handleDiagnostic(\n   llvm::SmallString<256> Text;\n   {\n     llvm::raw_svector_ostream Out(Text);\n-    DiagnosticEngine::formatDiagnosticText(Out, FormatString, FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n   }\n-  \n-  emitDiagnosticMessage(SM, Loc, Kind, Text, Info);\n+\n+  emitDiagnosticMessage(SM, Info.Loc, Info.Kind, Text, Info);\n \n   if (bracketDiagnostic)\n     exitDiagBlock();"
                    },
                    {
                        "filename": "lib/FrontendTool/FrontendTool.cpp",
                        "code": "@@ -605,13 +605,9 @@ class JSONFixitWriter\n       FixitAll(DiagOpts.FixitCodeForAllDiagnostics) {}\n \n private:\n-  void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n-    if (!(FixitAll || shouldTakeFixit(Kind, Info)))\n+  void handleDiagnostic(SourceManager &SM,\n+                        const DiagnosticInfo &Info) override {\n+    if (!(FixitAll || shouldTakeFixit(Info)))\n       return;\n     for (const auto &Fix : Info.FixIts) {\n       AllEdits.push_back({SM, Fix.getRange(), Fix.getText()});\n@@ -1822,13 +1818,15 @@ int swift::performFrontend(ArrayRef<const char *> Args,\n \n     SourceManager dummyMgr;\n \n-    PDC.handleDiagnostic(dummyMgr, SourceLoc(), DiagnosticKind::Error,\n-                         \"fatal error encountered during compilation; please \"\n-                         \"file a bug report with your project and the crash \"\n-                         \"log\",\n-                         {}, DiagnosticInfo(), SourceLoc());\n-    PDC.handleDiagnostic(dummyMgr, SourceLoc(), DiagnosticKind::Note, reason,\n-                         {}, DiagnosticInfo(), SourceLoc());\n+    DiagnosticInfo errorInfo(\n+        DiagID(0), SourceLoc(), DiagnosticKind::Error,\n+        \"fatal error encountered during compilation; please file a bug report \"\n+        \"with your project and the crash log\",\n+        {}, SourceLoc(), {}, {}, {}, false);\n+    DiagnosticInfo noteInfo(DiagID(0), SourceLoc(), DiagnosticKind::Note,\n+                            reason, {}, SourceLoc(), {}, {}, {}, false);\n+    PDC.handleDiagnostic(dummyMgr, errorInfo);\n+    PDC.handleDiagnostic(dummyMgr, noteInfo);\n     if (shouldCrash)\n       abort();\n   };"
                    },
                    {
                        "filename": "lib/Migrator/FixitApplyDiagnosticConsumer.cpp",
                        "code": "@@ -32,20 +32,17 @@ void FixitApplyDiagnosticConsumer::printResult(llvm::raw_ostream &OS) const {\n }\n \n void FixitApplyDiagnosticConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n-  if (Loc.isInvalid()) {\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n+  if (Info.Loc.isInvalid()) {\n     return;\n   }\n-  auto ThisBufferID = SM.findBufferContainingLoc(Loc);\n+  auto ThisBufferID = SM.findBufferContainingLoc(Info.Loc);\n   auto ThisBufferName = SM.getIdentifierForBuffer(ThisBufferID);\n   if (ThisBufferName != BufferName) {\n     return;\n   }\n \n-  if (!shouldTakeFixit(Kind, Info)) {\n+  if (!shouldTakeFixit(Info)) {\n     return;\n   }\n "
                    },
                    {
                        "filename": "lib/Sema/InstrumenterSupport.cpp",
                        "code": "@@ -36,17 +36,13 @@ class ErrorGatherer : public DiagnosticConsumer {\n     diags.addConsumer(*this);\n   }\n   ~ErrorGatherer() override { diags.takeConsumers(); }\n-  void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n-    if (Kind == swift::DiagnosticKind::Error) {\n+  void handleDiagnostic(SourceManager &SM,\n+                        const DiagnosticInfo &Info) override {\n+    if (Info.Kind == swift::DiagnosticKind::Error) {\n       error = true;\n     }\n-    DiagnosticEngine::formatDiagnosticText(llvm::errs(), FormatString,\n-                                           FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(llvm::errs(), Info.FormatString,\n+                                           Info.FormatArgs);\n     llvm::errs() << \"\\n\";\n   }\n   bool hadError() { return error; }"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftASTManager.cpp",
                        "code": "@@ -46,20 +46,25 @@ class StreamDiagConsumer : public DiagnosticConsumer {\n public:\n   StreamDiagConsumer(llvm::raw_ostream &OS) : OS(OS) {}\n \n-  void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n+  void handleDiagnostic(SourceManager &SM,\n+                        const DiagnosticInfo &Info) override {\n     // FIXME: Print location info if available.\n-    switch (Kind) {\n-      case DiagnosticKind::Error: OS << \"error: \"; break;\n-      case DiagnosticKind::Warning: OS << \"warning: \"; break;\n-      case DiagnosticKind::Note: OS << \"note: \"; break;\n-      case DiagnosticKind::Remark: OS << \"remark: \"; break;\n+    switch (Info.Kind) {\n+    case DiagnosticKind::Error:\n+      OS << \"error: \";\n+      break;\n+    case DiagnosticKind::Warning:\n+      OS << \"warning: \";\n+      break;\n+    case DiagnosticKind::Note:\n+      OS << \"note: \";\n+      break;\n+    case DiagnosticKind::Remark:\n+      OS << \"remark: \";\n+      break;\n     }\n-    DiagnosticEngine::formatDiagnosticText(OS, FormatString, FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(OS, Info.FormatString,\n+                                           Info.FormatArgs);\n   }\n };\n } // end anonymous namespace"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftDocSupport.cpp",
                        "code": "@@ -1185,12 +1185,8 @@ accept(SourceManager &SM, RegionType RegionType,\n }\n \n void RequestRefactoringEditConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n-  Impl.DiagConsumer.handleDiagnostic(SM, Loc, Kind, FormatString, FormatArgs,\n-                                     Info, bufferIndirectlyCausingDiagnostic);\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n+  Impl.DiagConsumer.handleDiagnostic(SM, Info);\n }\n \n class RequestRenameRangeConsumer::Implementation {\n@@ -1244,13 +1240,9 @@ void RequestRenameRangeConsumer::accept(\n   Impl.accept(SM, RegionType, Ranges);\n }\n \n-void RequestRenameRangeConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n-  Impl.DiagConsumer.handleDiagnostic(SM, Loc, Kind, FormatString, FormatArgs,\n-                                     Info, bufferIndirectlyCausingDiagnostic);\n+void RequestRenameRangeConsumer::handleDiagnostic(SourceManager &SM,\n+                                                  const DiagnosticInfo &Info) {\n+  Impl.DiagConsumer.handleDiagnostic(SM, Info);\n }\n \n static NameUsage getNameUsage(RenameType Type) {"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftEditor.cpp",
                        "code": "@@ -75,13 +75,10 @@ void EditorDiagConsumer::getAllDiagnostics(\n   }\n }\n \n-void EditorDiagConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+void EditorDiagConsumer::handleDiagnostic(SourceManager &SM,\n+                                          const DiagnosticInfo &Info) {\n \n-  if (Kind == DiagnosticKind::Error) {\n+  if (Info.Kind == DiagnosticKind::Error) {\n     HadAnyError = true;\n   }\n \n@@ -90,13 +87,13 @@ void EditorDiagConsumer::handleDiagnostic(\n       Info.ID == diag::error_doing_code_completion.ID)\n     return;\n \n-  bool IsNote = (Kind == DiagnosticKind::Note);\n+  bool IsNote = (Info.Kind == DiagnosticKind::Note);\n \n   if (IsNote && !haveLastDiag())\n     // Is this possible?\n     return;\n \n-  if (Kind == DiagnosticKind::Remark) {\n+  if (Info.Kind == DiagnosticKind::Remark) {\n     // FIXME: we may want to handle optimization remarks in sourcekitd.\n     LOG_WARN_FUNC(\"unhandled optimization remark\");\n     return;\n@@ -108,13 +105,14 @@ void EditorDiagConsumer::handleDiagnostic(\n   llvm::SmallString<256> Text;\n   {\n     llvm::raw_svector_ostream Out(Text);\n-    DiagnosticEngine::formatDiagnosticText(Out, FormatString, FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n   }\n   SKInfo.Description = Text.str();\n \n   Optional<unsigned> BufferIDOpt;\n-  if (Loc.isValid()) {\n-    BufferIDOpt =  SM.findBufferContainingLoc(Loc);\n+  if (Info.Loc.isValid()) {\n+    BufferIDOpt = SM.findBufferContainingLoc(Info.Loc);\n   }\n \n   if (BufferIDOpt && !isInputBufferID(*BufferIDOpt)) {\n@@ -147,9 +145,10 @@ void EditorDiagConsumer::handleDiagnostic(\n   if (BufferIDOpt.hasValue()) {\n     unsigned BufferID = *BufferIDOpt;\n \n-    SKInfo.Offset = SM.getLocOffsetInBuffer(Loc, BufferID);\n-    std::tie(SKInfo.Line, SKInfo.Column) = SM.getLineAndColumn(Loc, BufferID);\n-    SKInfo.Filename = SM.getDisplayNameForLoc(Loc);\n+    SKInfo.Offset = SM.getLocOffsetInBuffer(Info.Loc, BufferID);\n+    std::tie(SKInfo.Line, SKInfo.Column) =\n+        SM.getLineAndColumn(Info.Loc, BufferID);\n+    SKInfo.Filename = SM.getDisplayNameForLoc(Info.Loc);\n \n     for (auto R : Info.Ranges) {\n       if (R.isInvalid() || SM.findBufferContainingLoc(R.getStart()) != BufferID)\n@@ -177,16 +176,16 @@ void EditorDiagConsumer::handleDiagnostic(\n     return;\n   }\n \n-  switch (Kind) {\n-    case DiagnosticKind::Error:\n-      SKInfo.Severity = DiagnosticSeverityKind::Error;\n-      break;\n-    case DiagnosticKind::Warning:\n-      SKInfo.Severity = DiagnosticSeverityKind::Warning;\n-      break;\n-    case DiagnosticKind::Note:\n-    case DiagnosticKind::Remark:\n-      llvm_unreachable(\"already covered\");\n+  switch (Info.Kind) {\n+  case DiagnosticKind::Error:\n+    SKInfo.Severity = DiagnosticSeverityKind::Error;\n+    break;\n+  case DiagnosticKind::Warning:\n+    SKInfo.Severity = DiagnosticSeverityKind::Warning;\n+    break;\n+  case DiagnosticKind::Note:\n+  case DiagnosticKind::Remark:\n+    llvm_unreachable(\"already covered\");\n   }\n \n   if (!BufferIDOpt) {"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftEditorDiagConsumer.h",
                        "code": "@@ -66,11 +66,8 @@ class EditorDiagConsumer : public swift::DiagnosticConsumer {\n \n   bool hadAnyError() const { return HadAnyError; }\n \n-  void handleDiagnostic(swift::SourceManager &SM, swift::SourceLoc Loc,\n-                        swift::DiagnosticKind Kind, StringRef FormatString,\n-                        ArrayRef<swift::DiagnosticArgument> FormatArgs,\n-                        const swift::DiagnosticInfo &Info,\n-                        swift::SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(swift::SourceManager &SM,\n+                        const swift::DiagnosticInfo &Info) override;\n };\n \n } // namespace SourceKit"
                    },
                    {
                        "filename": "tools/SourceKit/lib/SwiftLang/SwiftLangSupport.h",
                        "code": "@@ -258,12 +258,8 @@ class RequestRefactoringEditConsumer: public swift::ide::SourceEditConsumer,\n   ~RequestRefactoringEditConsumer();\n   void accept(swift::SourceManager &SM, swift::ide::RegionType RegionType,\n               ArrayRef<swift::ide::Replacement> Replacements) override;\n-  void\n-  handleDiagnostic(swift::SourceManager &SM, swift::SourceLoc Loc,\n-                   swift::DiagnosticKind Kind, StringRef FormatString,\n-                   ArrayRef<swift::DiagnosticArgument> FormatArgs,\n-                   const swift::DiagnosticInfo &Info,\n-                   swift::SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(swift::SourceManager &SM,\n+                        const swift::DiagnosticInfo &Info) override;\n };\n \n class RequestRenameRangeConsumer : public swift::ide::FindRenameRangesConsumer,\n@@ -276,12 +272,8 @@ class RequestRenameRangeConsumer : public swift::ide::FindRenameRangesConsumer,\n   ~RequestRenameRangeConsumer();\n   void accept(swift::SourceManager &SM, swift::ide::RegionType RegionType,\n               ArrayRef<swift::ide::RenameRangeDetail> Ranges) override;\n-  void\n-  handleDiagnostic(swift::SourceManager &SM, swift::SourceLoc Loc,\n-                   swift::DiagnosticKind Kind, StringRef FormatString,\n-                   ArrayRef<swift::DiagnosticArgument> FormatArgs,\n-                   const swift::DiagnosticInfo &Info,\n-                   swift::SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(swift::SourceManager &SM,\n+                        const swift::DiagnosticInfo &Info) override;\n };\n \n struct SwiftStatistics {"
                    },
                    {
                        "filename": "tools/driver/swift_indent_main.cpp",
                        "code": "@@ -41,14 +41,11 @@ class FormatterDocument {\n   CompilerInvocation CompInv;\n   std::unique_ptr<ParserUnit> Parser;\n   class FormatterDiagConsumer : public swift::DiagnosticConsumer {\n-    void handleDiagnostic(\n-        SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-        StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-        const swift::DiagnosticInfo &Info,\n-        const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n+    void handleDiagnostic(SourceManager &SM,\n+                          const swift::DiagnosticInfo &Info) override {\n       llvm::errs() << \"Parse error: \";\n-      DiagnosticEngine::formatDiagnosticText(llvm::errs(), FormatString,\n-                                             FormatArgs);\n+      DiagnosticEngine::formatDiagnosticText(llvm::errs(), Info.FormatString,\n+                                             Info.FormatArgs);\n       llvm::errs() << \"\\n\";\n     }\n   } DiagConsumer;"
                    },
                    {
                        "filename": "tools/libSwiftSyntaxParser/libSwiftSyntaxParser.cpp",
                        "code": "@@ -233,29 +233,27 @@ struct SynParserDiagConsumer: public DiagnosticConsumer {\n   const unsigned BufferID;\n   SynParserDiagConsumer(SynParser &Parser, unsigned BufferID):\n     Parser(Parser), BufferID(BufferID) {}\n-  void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const DiagnosticInfo &Info,\n-                   const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n-    assert(Kind != DiagnosticKind::Remark && \"Shouldn't see this in parser.\");\n+  void handleDiagnostic(SourceManager &SM,\n+                        const DiagnosticInfo &Info) override {\n+    assert(Info.Kind != DiagnosticKind::Remark &&\n+           \"Shouldn't see this in parser.\");\n     // The buffer where all char* will point into.\n     llvm::SmallString<256> Buffer;\n     auto getCurrentText = [&]() -> const char* {\n       return Buffer.data() + Buffer.size();\n     };\n     DiagnosticDetail Result;\n-    Result.Severity = getSeverity(Kind);\n-    Result.Offset = getByteOffset(Loc, SM, BufferID);\n+    Result.Severity = getSeverity(Info.Kind);\n+    Result.Offset = getByteOffset(Info.Loc, SM, BufferID);\n \n     // Terminate each printed text with 0 so the client-side can use char* directly.\n     char NullTerm = '\\0';\n     {\n       // Print the error message to buffer and record it.\n       llvm::raw_svector_ostream OS(Buffer);\n       Result.Message = getCurrentText();\n-      DiagnosticEngine::formatDiagnosticText(OS, FormatString, FormatArgs);\n+      DiagnosticEngine::formatDiagnosticText(OS, Info.FormatString,\n+                                             Info.FormatArgs);\n       OS << NullTerm;\n     }\n     for (auto R: Info.Ranges) {"
                    },
                    {
                        "filename": "tools/swift-api-digester/ModuleDiagsConsumer.cpp",
                        "code": "@@ -94,23 +94,19 @@ ModuleDifferDiagsConsumer::ModuleDifferDiagsConsumer(bool DiagnoseModuleDiff,\n }\n \n void swift::ide::api::ModuleDifferDiagsConsumer::handleDiagnostic(\n-    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n-    const DiagnosticInfo &Info,\n-    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+    SourceManager &SM, const DiagnosticInfo &Info) {\n   auto Category = getCategoryName((uint32_t)Info.ID);\n   if (Category.empty()) {\n-    PrintingDiagnosticConsumer::handleDiagnostic(\n-        SM, Loc, Kind, FormatString, FormatArgs, Info,\n-        bufferIndirectlyCausingDiagnostic);\n+    PrintingDiagnosticConsumer::handleDiagnostic(SM, Info);\n     return;\n   }\n   if (!DiagnoseModuleDiff)\n     return;\n   llvm::SmallString<256> Text;\n   {\n     llvm::raw_svector_ostream Out(Text);\n-    DiagnosticEngine::formatDiagnosticText(Out, FormatString, FormatArgs);\n+    DiagnosticEngine::formatDiagnosticText(Out, Info.FormatString,\n+                                           Info.FormatArgs);\n   }\n   AllDiags[Category].insert(Text.str().str());\n }"
                    },
                    {
                        "filename": "tools/swift-api-digester/ModuleDiagsConsumer.h",
                        "code": "@@ -39,11 +39,7 @@ class ModuleDifferDiagsConsumer: public PrintingDiagnosticConsumer {\n   ModuleDifferDiagsConsumer(bool DiagnoseModuleDiff,\n                             llvm::raw_ostream &OS = llvm::errs());\n   ~ModuleDifferDiagsConsumer();\n-  void handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                        StringRef FormatString,\n-                        ArrayRef<DiagnosticArgument> FormatArgs,\n-                        const DiagnosticInfo &Info,\n-                        SourceLoc bufferIndirectlyCausingDiagnostic) override;\n+  void handleDiagnostic(SourceManager &SM, const DiagnosticInfo &Info) override;\n };\n }\n }"
                    },
                    {
                        "filename": "unittests/AST/DiagnosticConsumerTests.cpp",
                        "code": "@@ -34,13 +34,10 @@ namespace {\n       EXPECT_TRUE(expected.empty());\n     }\n \n-    void handleDiagnostic(\n-        SourceManager &SM, SourceLoc loc, DiagnosticKind kind,\n-        StringRef formatString, ArrayRef<DiagnosticArgument> formatArgs,\n-        const DiagnosticInfo &info,\n-        const SourceLoc bufferIndirectlyCausingDiagnostic) override {\n+    void handleDiagnostic(SourceManager &SM,\n+                          const DiagnosticInfo &Info) override {\n       ASSERT_FALSE(expected.empty());\n-      EXPECT_EQ(std::make_pair(loc, formatString), expected.front());\n+      EXPECT_EQ(std::make_pair(Info.Loc, Info.FormatString), expected.front());\n       expected.erase(expected.begin());\n     }\n \n@@ -52,6 +49,14 @@ namespace {\n       return false;\n     }\n   };\n+\n+  DiagnosticInfo testDiagnosticInfo(SourceLoc Loc, std::string Message,\n+                                    DiagnosticKind Kind) {\n+    return DiagnosticInfo(DiagID(0), Loc, Kind, Message, /*args*/ {},\n+                          /*indirectBuffer*/ SourceLoc(), /*childInfo*/ {},\n+                          /*ranges*/ {}, /*fixIts*/ {}, /*isChild*/ false);\n+  }\n+\n } // end anonymous namespace\n \n TEST(FileSpecificDiagnosticConsumer, SubconsumersFinishInOrder) {\n@@ -90,8 +95,9 @@ TEST(FileSpecificDiagnosticConsumer, InvalidLocDiagsGoToEveryConsumer) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, SourceLoc(), DiagnosticKind::Error,\n-                                \"dummy\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(SourceLoc(), \"dummy\", DiagnosticKind::Error));\n   topConsumer->finishProcessing();\n }\n \n@@ -131,18 +137,20 @@ TEST(FileSpecificDiagnosticConsumer, ErrorsWithLocationsGoToExpectedConsumers) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"front\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"front\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Error,\n-                                \"middle\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Error,\n-                                \"middle\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Error,\n-                                \"back\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Error,\n-                                \"back\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"front\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"front\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(middleOfA, \"middle\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(middleOfB, \"middle\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"back\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"back\", DiagnosticKind::Error));\n   topConsumer->finishProcessing();\n }\n \n@@ -186,18 +194,20 @@ TEST(FileSpecificDiagnosticConsumer,\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"front\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"front\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Error,\n-                                \"middle\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Error,\n-                                \"middle\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Error,\n-                                \"back\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Error,\n-                                \"back\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"front\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"front\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(middleOfA, \"middle\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(middleOfB, \"middle\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"back\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"back\", DiagnosticKind::Error));\n   topConsumer->finishProcessing();\n }\n \n@@ -232,14 +242,18 @@ TEST(FileSpecificDiagnosticConsumer, WarningsAndRemarksAreTreatedLikeErrors) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Warning,\n-                                \"warning\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Warning,\n-                                \"warning\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Remark,\n-                                \"remark\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Remark,\n-                                \"remark\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfA, \"warning\", DiagnosticKind::Warning));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfB, \"warning\", DiagnosticKind::Warning));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfA, \"remark\", DiagnosticKind::Remark));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfB, \"remark\", DiagnosticKind::Remark));\n   topConsumer->finishProcessing();\n }\n \n@@ -285,24 +299,24 @@ TEST(FileSpecificDiagnosticConsumer, NotesAreAttachedToErrors) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n   topConsumer->finishProcessing();\n }\n \n@@ -348,24 +362,27 @@ TEST(FileSpecificDiagnosticConsumer, NotesAreAttachedToWarningsAndRemarks) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Warning,\n-                                \"warning\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Warning,\n-                                \"warning\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Remark,\n-                                \"remark\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfA, \"warning\", DiagnosticKind::Warning));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfB, \"warning\", DiagnosticKind::Warning));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr,\n+      testDiagnosticInfo(frontOfA, \"remark\", DiagnosticKind::Remark));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n   topConsumer->finishProcessing();\n }\n \n@@ -408,24 +425,24 @@ TEST(FileSpecificDiagnosticConsumer, NotesAreAttachedToErrorsEvenAcrossFiles) {\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n   topConsumer->finishProcessing();\n }\n \n@@ -472,24 +489,24 @@ TEST(FileSpecificDiagnosticConsumer,\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, middleOfB, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, backOfA, DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfA, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(middleOfB, \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(backOfA, \"note\", DiagnosticKind::Note));\n   topConsumer->finishProcessing();\n }\n \n@@ -528,17 +545,17 @@ TEST(FileSpecificDiagnosticConsumer,\n \n   auto topConsumer =\n       FileSpecificDiagnosticConsumer::consolidateSubconsumers(consumers);\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, SourceLoc(), DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfB, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, SourceLoc(), DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, frontOfA, DiagnosticKind::Error,\n-                                \"error\", {}, DiagnosticInfo(), SourceLoc());\n-  topConsumer->handleDiagnostic(sourceMgr, SourceLoc(), DiagnosticKind::Note,\n-                                \"note\", {}, DiagnosticInfo(), SourceLoc());\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(SourceLoc(), \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfB, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(SourceLoc(), \"note\", DiagnosticKind::Note));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(frontOfA, \"error\", DiagnosticKind::Error));\n+  topConsumer->handleDiagnostic(\n+      sourceMgr, testDiagnosticInfo(SourceLoc(), \"note\", DiagnosticKind::Note));\n   topConsumer->finishProcessing();\n }"
                    },
                    {
                        "filename": "unittests/Parse/LexerTests.cpp",
                        "code": "@@ -747,16 +747,13 @@ TEST_F(LexerTest, NestedPlaceholder) {\n \n class StringCaptureDiagnosticConsumer : public DiagnosticConsumer {\n public:\n-  virtual void\n-  handleDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n-                   StringRef FormatString,\n-                   ArrayRef<DiagnosticArgument> FormatArgs,\n-                   const swift::DiagnosticInfo &Info,\n-                   SourceLoc bufferIndirectlyCausingDiagnostic) override {\n+  virtual void handleDiagnostic(SourceManager &SM,\n+                                const swift::DiagnosticInfo &Info) override {\n     std::string DiagMsg;\n     llvm::raw_string_ostream DiagOS(DiagMsg);\n-    DiagnosticEngine::formatDiagnosticText(DiagOS, FormatString, FormatArgs);\n-    auto LC = SM.getLineAndColumn(Loc);\n+    DiagnosticEngine::formatDiagnosticText(DiagOS, Info.FormatString,\n+                                           Info.FormatArgs);\n+    auto LC = SM.getLineAndColumn(Info.Loc);\n     std::ostringstream StrOS;\n     StrOS << LC.first << \", \" << LC.second << \": \" << DiagOS.str();\n     messages.push_back(StrOS.str());"
                    }
                ]
            },
            {
                "date": "2019-10-18T21:14:16Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/0a84879c749c28458d5b4edda5e9372c85d4e4dc",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -670,6 +670,9 @@ namespace swift {\n     /// Print diagnostic names after their messages\n     bool printDiagnosticNames = false;\n \n+    /// Use descriptive diagnostic style when available.\n+    bool useDescriptiveDiagnostics = false;\n+\n     friend class InFlightDiagnostic;\n     friend class DiagnosticTransaction;\n     friend class CompoundDiagnosticTransaction;\n@@ -713,6 +716,13 @@ namespace swift {\n       return printDiagnosticNames;\n     }\n \n+    void setUseDescriptiveDiagnostics(bool val) {\n+       useDescriptiveDiagnostics = val;\n+    }\n+    bool getUseDescriptiveDiagnostics() const {\n+      return useDescriptiveDiagnostics;\n+    }\n+\n     void ignoreDiagnostic(DiagID id) {\n       state.setDiagnosticBehavior(id, DiagnosticState::Behavior::Ignore);\n     }"
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -55,6 +55,10 @@ class DiagnosticOptions {\n   // When printing diagnostics, include the diagnostic name at the end\n   bool PrintDiagnosticNames = false;\n \n+  /// If set to true, produce more descriptive diagnostic output if available.\n+  /// Descriptive diagnostic output is not intended to be machine-readable.\n+  bool EnableDescriptiveDiagnostics = false;\n+\n   /// Return a hash code of any components from these options that should\n   /// contribute to a Swift Bridging PCH hash.\n   llvm::hash_code getPCHHashComponents() const {"
                    },
                    {
                        "filename": "include/swift/Option/FrontendOptions.td",
                        "code": "@@ -109,6 +109,9 @@ def verify_syntax_tree : Flag<[\"-\"], \"verify-syntax-tree\">,\n \n def show_diagnostics_after_fatal : Flag<[\"-\"], \"show-diagnostics-after-fatal\">,\n   HelpText<\"Keep emitting subsequent diagnostics after a fatal error\">;\n+  \n+def enable_descriptive_diagnostics : Flag<[\"-\"], \"enable-descriptive-diagnostics\">,\n+  HelpText<\"Show descriptive diagnostic information, if available.\">;\n \n def enable_swiftcall : Flag<[\"-\"], \"enable-swiftcall\">,\n   HelpText<\"Enable the use of LLVM swiftcall support\">;"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -678,6 +678,8 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.SuppressWarnings |= Args.hasArg(OPT_suppress_warnings);\n   Opts.WarningsAsErrors |= Args.hasArg(OPT_warnings_as_errors);\n   Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n+  Opts.EnableDescriptiveDiagnostics |=\n+      Args.hasArg(OPT_enable_descriptive_diagnostics);\n \n   assert(!(Opts.WarningsAsErrors && Opts.SuppressWarnings) &&\n          \"conflicting arguments; should have been caught by driver\");"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -315,6 +315,9 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().PrintDiagnosticNames) {\n     Diagnostics.setPrintDiagnosticNames(true);\n   }\n+  if (Invocation.getDiagnosticOptions().EnableDescriptiveDiagnostics) {\n+    Diagnostics.setUseDescriptiveDiagnostics(true);\n+  }\n }\n \n bool CompilerInstance::setUpModuleLoaders() {"
                    }
                ]
            },
            {
                "date": "2019-09-30T23:15:22Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/f749e8551f1d294b931339c8e3adaaba1663d461",
                "changes": [
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -104,3 +104,19 @@ Most diagnostics have no reason to change behavior under editor mode. An example\n - `%error` - Represents a branch in a `%select` that should never be taken. In debug builds of the compiler this produces an assertion failure.\n \n - `%%` - Emits a literal percent sign.\n+\n+### Diagnostic Verifier ###\n+\n+(This section is specific to the Swift compiler's diagnostic engine.)\n+\n+If the `-verify` frontend flag is used, the Swift compiler will check emitted diagnostics against specially formatted comments in the source. This feature is used extensively throughout the test suite to ensure diagnostics are emitted with the correct message and source location.\n+\n+An expected diagnostic is denoted by a comment which begins with `expected-error`, `expected-warning`, `expected-note`, or `expected-remark`. It is followed by:\n+\n+- (Optional) Location information. By default, the comment will match any diagnostic emitted on the same line. However, it's possible to override this behavior and/or specify column information as well. `// expected-error@-1 ...` looks for an error on the previous line, `// expected-warning@+1:3 ...` looks for a warning on the next line at the third column, and `// expected-note@:7 ...` looks for a note on the same line at the seventh column.\n+\n+- (Optional) A match count which specifies how many times the diagnostic is expected to appear. This may be a positive integer or `*`, which allows for zero or more matches. The match count must be surrounded by whitespace if present. For example, `// expected-error 2 ...` looks for two matching errors, and `// expected-warning * ...` looks for any number of matching warnings.\n+\n+- (Required) The expected error message. The message should be enclosed in double curly braces and should not include the `error:`/`warning:`/`note:`/`remark:` prefix. For example, `// expected-error {{invalid redeclaration of 'y'}}` would match an error with that message on the same line. The expected message does not need to match the emitted message verbatim. As long as the expected message is a substring of the original message, they will match.\n+\n+- (Optional) Expected fix-its. These are each enclosed in double curly braces and appear after the expected message. An expected fix-it consists of a column range followed by the text it's expected to be replaced with. For example, `let r : Int i = j // expected-error{{consecutive statements}} {{12-12=;}}` will match a fix-it attached to the consecutive statements error which inserts a semicolon at column 12, just after the 't' in 'Int'. The special {{none}} specifier is also supported, which will cause the diagnostic match to fail if unexpected fix-its are produced."
                    },
                    {
                        "filename": "docs/Testing.md",
                        "code": "@@ -232,7 +232,7 @@ code for the target that is not the build machine:\n \n * ``%target-typecheck-verify-swift``: parse and type check the current Swift file\n   for the target platform and verify diagnostics, like ``swift -frontend -typecheck -verify\n-  %s``.\n+  %s``. For further explanation of `-verify` mode, see [Diagnostics.md](Diagnostics.md).\n \n   Use this substitution for testing semantic analysis in the compiler.\n "
                    }
                ]
            },
            {
                "date": "2019-07-18T01:04:20Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/6c5185f2e3a63637b56cd9321da3b3c19dc5fc06",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -384,6 +384,15 @@ NOTE(candidate_has_invalid_argument_at_position,none,\n      \"candidate expects value of type %0 at position #%1\",\n      (Type, unsigned))\n \n+ERROR(cannot_convert_array_to_variadic,none,\n+      \"cannot pass array of type %0 as variadic arguments of type %1\",\n+      (Type,Type))\n+NOTE(candidate_would_match_array_to_variadic,none,\n+     \"candidate would match if array elements were passed as\"\n+     \" variadic arguments of type %0\", (Type))\n+NOTE(suggest_pass_elements_directly,none,\n+     \"remove brackets to pass array elements directly\", ())\n+\n ERROR(cannot_convert_argument_value_generic,none,\n       \"cannot convert value of type %0 (%1) to expected argument type %2 (%3)\",\n       (Type, StringRef, Type, StringRef))"
                    },
                    {
                        "filename": "lib/Sema/CSApply.cpp",
                        "code": "@@ -5384,10 +5384,11 @@ Expr *ExprRewriter::coerceCallArguments(\n   auto params = funcType->getParams();\n \n   // Local function to produce a locator to refer to the given parameter.\n-  auto getArgLocator = [&](unsigned argIdx, unsigned paramIdx)\n-                         -> ConstraintLocatorBuilder {\n+  auto getArgLocator =\n+      [&](unsigned argIdx, unsigned paramIdx,\n+          ParameterTypeFlags flags) -> ConstraintLocatorBuilder {\n     return locator.withPathElement(\n-             LocatorPathElt::ApplyArgToParam(argIdx, paramIdx));\n+        LocatorPathElt::ApplyArgToParam(argIdx, paramIdx, flags));\n   };\n \n   bool matchCanFail =\n@@ -5499,8 +5500,9 @@ Expr *ExprRewriter::coerceCallArguments(\n         }\n \n         // Convert the argument.\n-        auto convertedArg = coerceToType(arg, param.getPlainType(),\n-                                         getArgLocator(argIdx, paramIdx));\n+        auto convertedArg = coerceToType(\n+            arg, param.getPlainType(),\n+            getArgLocator(argIdx, paramIdx, param.getParameterFlags()));\n         if (!convertedArg)\n           return nullptr;\n \n@@ -5620,8 +5622,9 @@ Expr *ExprRewriter::coerceCallArguments(\n       convertedArg = cs.TC.buildAutoClosureExpr(dc, arg, closureType);\n       cs.cacheExprTypes(convertedArg);\n     } else {\n-      convertedArg =\n-          coerceToType(arg, paramType, getArgLocator(argIdx, paramIdx));\n+      convertedArg = coerceToType(\n+          arg, paramType,\n+          getArgLocator(argIdx, paramIdx, param.getParameterFlags()));\n     }\n \n     if (!convertedArg)"
                    },
                    {
                        "filename": "lib/Sema/CSDiag.cpp",
                        "code": "@@ -3461,11 +3461,16 @@ bool FailureDiagnosis::visitApplyExpr(ApplyExpr *callExpr) {\n     //   case (let (_, _, _)) + 1: break\n     // }\n     if (callExpr->isImplicit() && overloadName == \"~=\") {\n-      auto *locator =\n-          CS.getConstraintLocator(callExpr,\n-                                  {ConstraintLocator::ApplyArgument,\n-                                   LocatorPathElt::ApplyArgToParam(0, 0)},\n-                                  /*summaryFlags=*/0);\n+      auto flags = ParameterTypeFlags();\n+      if (calleeInfo.candidates.size() == 1)\n+        if (auto fnType = calleeInfo.candidates[0].getFunctionType())\n+          flags = fnType->getParams()[0].getParameterFlags();\n+\n+      auto *locator = CS.getConstraintLocator(\n+          callExpr,\n+          {ConstraintLocator::ApplyArgument,\n+           LocatorPathElt::ApplyArgToParam(0, 0, flags)},\n+          /*summaryFlags=*/0);\n \n       ArgumentMismatchFailure failure(expr, CS, lhsType, rhsType, locator);\n       return failure.diagnosePatternMatchingMismatch();"
                    },
                    {
                        "filename": "lib/Sema/CSDiagnostics.cpp",
                        "code": "@@ -4611,9 +4611,11 @@ bool ArgumentMismatchFailure::diagnoseUseOfReferenceEqualityOperator() const {\n   // one would cover both arguments.\n   if (getAnchor() == rhs && rhsType->is<FunctionType>()) {\n     auto &cs = getConstraintSystem();\n-    if (cs.hasFixFor(cs.getConstraintLocator(\n-            binaryOp, {ConstraintLocator::ApplyArgument,\n-                       LocatorPathElt::ApplyArgToParam(0, 0)})))\n+    auto info = getFunctionArgApplyInfo(locator);\n+    if (info && cs.hasFixFor(cs.getConstraintLocator(\n+                    binaryOp, {ConstraintLocator::ApplyArgument,\n+                               LocatorPathElt::ApplyArgToParam(\n+                                   0, 0, info->getParameterFlagsAtIndex(0))})))\n       return true;\n   }\n \n@@ -4763,3 +4765,44 @@ bool ArgumentMismatchFailure::diagnoseArchetypeMismatch() const {\n \n   return true;\n }\n+\n+void ExpandArrayIntoVarargsFailure::tryDropArrayBracketsFixIt(\n+    Expr *anchor) const {\n+  // If this is an array literal, offer to remove the brackets and pass the\n+  // elements directly as variadic arguments.\n+  if (auto *arrayExpr = dyn_cast<ArrayExpr>(anchor)) {\n+    auto diag = emitDiagnostic(arrayExpr->getLoc(),\n+                               diag::suggest_pass_elements_directly);\n+    diag.fixItRemove(arrayExpr->getLBracketLoc())\n+        .fixItRemove(arrayExpr->getRBracketLoc());\n+    // Handle the case where the array literal has a trailing comma.\n+    if (arrayExpr->getNumCommas() == arrayExpr->getNumElements())\n+      diag.fixItRemove(arrayExpr->getCommaLocs().back());\n+  }\n+}\n+\n+bool ExpandArrayIntoVarargsFailure::diagnoseAsError() {\n+  if (auto anchor = getAnchor()) {\n+    emitDiagnostic(anchor->getLoc(), diag::cannot_convert_array_to_variadic,\n+                   getFromType(), getToType());\n+    tryDropArrayBracketsFixIt(anchor);\n+    // TODO: Array splat fix-it once that's supported.\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool ExpandArrayIntoVarargsFailure::diagnoseAsNote() {\n+  auto overload = getChoiceFor(getLocator());\n+  auto anchor = getAnchor();\n+  if (!overload || !anchor)\n+    return false;\n+\n+  if (auto chosenDecl = overload->choice.getDeclOrNull()) {\n+    emitDiagnostic(chosenDecl, diag::candidate_would_match_array_to_variadic,\n+                   getToType());\n+    tryDropArrayBracketsFixIt(anchor);\n+    return true;\n+  }\n+  return false;\n+}"
                    },
                    {
                        "filename": "lib/Sema/CSDiagnostics.h",
                        "code": "@@ -1582,8 +1582,25 @@ class InvalidTupleSplatWithSingleParameterFailure final\n                                               Type paramTy,\n                                               ConstraintLocator *locator)\n       : FailureDiagnostic(root, cs, locator), ParamType(paramTy) {}\n+  bool diagnoseAsError() override;\n+};\n+\n+/// Diagnose situation when an array is passed instead of varargs.\n+///\n+/// ```swift\n+/// func foo(_ x: Int...) {}\n+/// foo([1,2,3]]) // foo expects varags like foo(1,2,3) instead.\n+/// ```\n+class ExpandArrayIntoVarargsFailure final : public ContextualFailure {\n+public:\n+  ExpandArrayIntoVarargsFailure(Expr *root, ConstraintSystem &cs, Type lhs,\n+                                Type rhs, ConstraintLocator *locator)\n+      : ContextualFailure(root, cs, lhs, rhs, locator) {}\n \n   bool diagnoseAsError() override;\n+  bool diagnoseAsNote() override;\n+\n+  void tryDropArrayBracketsFixIt(Expr *anchor) const;\n };\n \n /// Diagnose a situation there is a mismatch between argument and parameter\n@@ -1715,6 +1732,10 @@ class FunctionArgApplyInfo {\n   ParameterTypeFlags getParameterFlags() const {\n     return FnType->getParams()[ParamIdx].getParameterFlags();\n   }\n+\n+  ParameterTypeFlags getParameterFlagsAtIndex(unsigned idx) const {\n+    return FnType->getParams()[idx].getParameterFlags();\n+  }\n };\n \n } // end namespace constraints"
                    },
                    {
                        "filename": "lib/Sema/CSFix.cpp",
                        "code": "@@ -795,6 +795,36 @@ static bool isValueOfRawRepresentable(ConstraintSystem &cs,\n   return false;\n }\n \n+ExpandArrayIntoVarargs *\n+ExpandArrayIntoVarargs::attempt(ConstraintSystem &cs, Type argType,\n+                                Type paramType,\n+                                ConstraintLocatorBuilder locator) {\n+  auto constraintLocator = cs.getConstraintLocator(locator);\n+  auto elementType = cs.isArrayType(argType);\n+  if (elementType &&\n+      constraintLocator->getLastElementAs<LocatorPathElt::ApplyArgToParam>()\n+          ->getParameterFlags()\n+          .isVariadic()) {\n+    auto options = ConstraintSystem::TypeMatchOptions(\n+        ConstraintSystem::TypeMatchFlags::TMF_ApplyingFix |\n+        ConstraintSystem::TypeMatchFlags::TMF_GenerateConstraints);\n+    auto result =\n+        cs.matchTypes(*elementType, paramType,\n+                      ConstraintKind::ArgumentConversion, options, locator);\n+    if (result.isSuccess())\n+      return new (cs.getAllocator())\n+          ExpandArrayIntoVarargs(cs, argType, paramType, constraintLocator);\n+  }\n+\n+  return nullptr;\n+}\n+\n+bool ExpandArrayIntoVarargs::diagnose(Expr *root, bool asNote) const {\n+  ExpandArrayIntoVarargsFailure failure(\n+      root, getConstraintSystem(), getFromType(), getToType(), getLocator());\n+  return failure.diagnose(asNote);\n+}\n+\n ExplicitlyConstructRawRepresentable *\n ExplicitlyConstructRawRepresentable::attempt(ConstraintSystem &cs, Type argType,\n                                              Type paramType,"
                    },
                    {
                        "filename": "lib/Sema/CSFix.h",
                        "code": "@@ -204,6 +204,9 @@ enum class FixKind : uint8_t {\n   /// Use raw value type associated with raw representative accessible\n   /// using `.rawValue` member.\n   UseValueTypeOfRawRepresentative,\n+  /// If an array was passed to a variadic argument, give a specific diagnostic\n+  /// and offer to drop the brackets if it's a literal.\n+  ExpandArrayIntoVarargs,\n };\n \n class ConstraintFix {\n@@ -1342,6 +1345,25 @@ class AllowArgumentMismatch : public ContextualMismatch {\n                                        ConstraintLocator *locator);\n };\n \n+class ExpandArrayIntoVarargs final : public AllowArgumentMismatch {\n+\n+  ExpandArrayIntoVarargs(ConstraintSystem &cs, Type argType, Type paramType,\n+                         ConstraintLocator *locator)\n+      : AllowArgumentMismatch(cs, FixKind::ExpandArrayIntoVarargs, argType,\n+                              paramType, locator) {}\n+\n+public:\n+  std::string getName() const override {\n+    return \"cannot pass Array elements as variadic arguments\";\n+  }\n+\n+  bool diagnose(Expr *root, bool asNote = false) const override;\n+\n+  static ExpandArrayIntoVarargs *attempt(ConstraintSystem &cs, Type argType,\n+                                         Type paramType,\n+                                         ConstraintLocatorBuilder locator);\n+};\n+\n class ExplicitlyConstructRawRepresentable final : public AllowArgumentMismatch {\n   ExplicitlyConstructRawRepresentable(ConstraintSystem &cs, Type argType,\n                                       Type paramType,"
                    },
                    {
                        "filename": "lib/Sema/CSSimplify.cpp",
                        "code": "@@ -913,8 +913,8 @@ ConstraintSystem::TypeMatchResult constraints::matchCallArguments(\n \n     // Compare each of the bound arguments for this parameter.\n     for (auto argIdx : parameterBindings[paramIdx]) {\n-      auto loc = locator.withPathElement(\n-          LocatorPathElt::ApplyArgToParam(argIdx, paramIdx));\n+      auto loc = locator.withPathElement(LocatorPathElt::ApplyArgToParam(\n+          argIdx, paramIdx, param.getParameterFlags()));\n       auto argTy = argsWithLabels[argIdx].getOldType();\n \n       bool matchingAutoClosureResult = param.isAutoClosure();\n@@ -2598,6 +2598,11 @@ bool ConstraintSystem::repairFailures(\n         elt.castTo<LocatorPathElt::ApplyArgToParam>().getParamIdx() == 1)\n       break;\n \n+    if (auto *fix = ExpandArrayIntoVarargs::attempt(*this, lhs, rhs, locator)) {\n+      conversionsOrFixes.push_back(fix);\n+      break;\n+    }\n+\n     if (auto *fix = ExplicitlyConstructRawRepresentable::attempt(\n             *this, lhs, rhs, locator)) {\n       conversionsOrFixes.push_back(fix);\n@@ -7610,6 +7615,7 @@ ConstraintSystem::SolutionKind ConstraintSystem::simplifyFixConstraint(\n   case FixKind::SkipUnhandledConstructInFunctionBuilder:\n   case FixKind::UsePropertyWrapper:\n   case FixKind::UseWrappedValue:\n+  case FixKind::ExpandArrayIntoVarargs:\n   case FixKind::UseValueTypeOfRawRepresentative:\n   case FixKind::ExplicitlyConstructRawRepresentable: {\n     return recordFix(fix) ? SolutionKind::Error : SolutionKind::Solved;"
                    },
                    {
                        "filename": "lib/Sema/ConstraintLocator.h",
                        "code": "@@ -184,8 +184,10 @@ class ConstraintLocator : public llvm::FoldingSetNode {\n \n     case TypeParameterRequirement:\n     case ConditionalRequirement:\n-    case ApplyArgToParam:\n       return 2;\n+\n+    case ApplyArgToParam:\n+      return 3;\n     }\n \n     llvm_unreachable(\"Unhandled PathElementKind in switch.\");\n@@ -282,12 +284,12 @@ class ConstraintLocator : public llvm::FoldingSetNode {\n     uint64_t storedKind : 3;\n \n     /// Encode a path element kind and a value into the storage format.\n-    static uint64_t encodeStorage(PathElementKind kind, unsigned value) {\n-      return ((uint64_t)value << 8) | kind;\n+    static uint64_t encodeStorage(PathElementKind kind, uint64_t value) {\n+      return (value << 8) | kind;\n     }\n \n     /// Decode a storage value into path element kind and value.\n-    static std::pair<PathElementKind, unsigned>\n+    static std::pair<PathElementKind, uint64_t>\n     decodeStorage(uint64_t storage) {\n       return { (PathElementKind)((unsigned)storage & 0xFF), storage >> 8 };\n     }\n@@ -323,6 +325,17 @@ class ConstraintLocator : public llvm::FoldingSetNode {\n       assert(value1 == getValue(1) && \"value1 truncated\");\n     }\n \n+    PathElement(PathElementKind kind, uint64_t value0, uint64_t value1,\n+                uint64_t value2)\n+        : storage(encodeStorage(kind, value0 << 32 | value1 << 16 | value2)),\n+          storedKind(StoredKindAndValue) {\n+      assert(numNumericValuesInPathElement(kind) == 3 &&\n+             \"Path element kind does not require 3 values\");\n+      assert(value0 == getValue(0) && \"value0 truncated\");\n+      assert(value1 == getValue(1) && \"value1 truncated\");\n+      assert(value2 == getValue(2) && \"value2 truncated\");\n+    }\n+\n     /// Store a path element with an associated pointer, accessible using\n     /// \\c getStoredPointer.\n     template <typename T>\n@@ -695,11 +708,15 @@ dyn_cast(const LocatorPathElt &) = delete; // Use LocatorPathElt::getAs instead.\n \n class LocatorPathElt::ApplyArgToParam final : public LocatorPathElt {\n public:\n-  ApplyArgToParam(unsigned argIdx, unsigned paramIdx)\n-      : LocatorPathElt(ConstraintLocator::ApplyArgToParam, argIdx, paramIdx) {}\n+  ApplyArgToParam(unsigned argIdx, unsigned paramIdx, ParameterTypeFlags flags)\n+      : LocatorPathElt(ConstraintLocator::ApplyArgToParam, argIdx, paramIdx,\n+                       flags.toRaw()) {}\n \n   unsigned getArgIdx() const { return getValue(0); }\n   unsigned getParamIdx() const { return getValue(1); }\n+  ParameterTypeFlags getParameterFlags() const {\n+    return ParameterTypeFlags::fromRaw(getValue(2));\n+  }\n \n   static bool classof(const LocatorPathElt *elt) {\n     return elt->getKind() == ConstraintLocator::ApplyArgToParam;"
                    },
                    {
                        "filename": "test/Constraints/diagnostics.swift",
                        "code": "@@ -299,6 +299,62 @@ func rdar21784170() {\n   (Array.init as (Double...) -> Array<Double>)(initial as (Double, Double)) // expected-error {{cannot convert value of type '(Double, Double)' to expected argument type 'Double'}}\n }\n \n+// Diagnose passing an array in lieu of variadic parameters\n+func variadic(_ x: Int...) {}\n+func variadicArrays(_ x: [Int]...) {}\n+func variadicAny(_ x: Any...) {}\n+struct HasVariadicSubscript {\n+  subscript(_ x: Int...) -> Int {\n+    get { 0 }\n+  }\n+}\n+let foo = HasVariadicSubscript()\n+\n+let array = [1,2,3]\n+let arrayWithOtherEltType = [\"hello\", \"world\"]\n+\n+variadic(array) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+variadic([1,2,3]) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{10-11=}} {{16-17=}}\n+variadic([1,2,3,]) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{10-11=}} {{16-17=}} {{17-18=}}\n+variadic(0, array, 4) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+variadic(0, [1,2,3], 4) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{13-14=}} {{19-20=}}\n+variadic(0, [1,2,3,], 4) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{13-14=}} {{19-20=}} {{20-21=}}\n+variadic(arrayWithOtherEltType) // expected-error {{cannot convert value of type '[String]' to expected argument type 'Int'}}\n+variadic(1, arrayWithOtherEltType) // expected-error {{cannot convert value of type '[String]' to expected argument type 'Int'}}\n+\n+// FIXME: SR-11104\n+variadic([\"hello\", \"world\"]) // expected-error 2 {{cannot convert value of type 'String' to expected element type 'Int'}}\n+// expected-error@-1 {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-2 {{remove brackets to pass array elements directly}}\n+\n+variadic([1] + [2] as [Int]) // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+\n+foo[array] // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+foo[[1,2,3]] // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{5-6=}} {{11-12=}}\n+foo[0, [1,2,3], 4] // expected-error {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-1 {{remove brackets to pass array elements directly}} {{8-9=}} {{14-15=}}\n+\n+variadicAny(array)\n+variadicAny([1,2,3])\n+variadicArrays(array)\n+variadicArrays([1,2,3])\n+variadicArrays(arrayWithOtherEltType) // expected-error {{cannot convert value of type '[String]' to expected argument type '[Int]'}}\n+// expected-note@-1 {{arguments to generic parameter 'Element' ('String' and 'Int') are expected to be equal}}\n+variadicArrays(1,2,3) // expected-error 3 {{cannot convert value of type 'Int' to expected argument type '[Int]'}}\n+\n+protocol Proto {}\n+func f<T: Proto>(x: [T]) {}\n+func f(x: Int...) {}\n+f(x: [1,2,3])\n+// TODO(diagnostics): Diagnose both the missing conformance and the disallowed array splat to cover both overloads. \n+// expected-error@-2 {{cannot pass array of type '[Int]' as variadic arguments of type 'Int'}}\n+// expected-note@-3 {{remove brackets to pass array elements directly}}\n+\n // <rdar://problem/21829141> BOGUS: unexpected trailing closure\n func expect<T, U>(_: T) -> (U.Type) -> Int { return { a in 0 } }\n func expect<T, U>(_: T, _: Int = 1) -> (U.Type) -> String { return { a in \"String\" } }"
                    }
                ]
            },
            {
                "date": "2019-09-17T15:33:38Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/6e1e768dda33aa6c48ec5745fb5c06e49d8a528f",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -810,6 +810,15 @@ namespace swift {\n       return diagnose(decl, Diagnostic(id, std::move(args)...));\n     }\n \n+    /// Emit a parent diagnostic and attached notes.\n+    ///\n+    /// \\param parentDiag An InFlightDiagnostic representing the parent diag.\n+    ///\n+    /// \\param builder A closure which builds and emits notes to be attached to\n+    /// the parent diag.\n+    void diagnoseWithNotes(InFlightDiagnostic parentDiag,\n+                           llvm::function_ref<void(void)> builder);\n+\n     /// \\returns true if diagnostic is marked with PointsToFirstBadToken\n     /// option.\n     bool isDiagnosticPointsToFirstBadToken(DiagID id) const;\n@@ -905,7 +914,6 @@ namespace swift {\n         Depth(Engine.TransactionCount),\n         IsOpen(true)\n     {\n-      assert(!Engine.ActiveDiagnostic);\n       Engine.TransactionCount++;\n     }\n \n@@ -995,6 +1003,14 @@ namespace swift {\n     }\n   };\n \n+  inline void\n+  DiagnosticEngine::diagnoseWithNotes(InFlightDiagnostic parentDiag,\n+                                      llvm::function_ref<void(void)> builder) {\n+    CompoundDiagnosticTransaction transaction(*this);\n+    parentDiag.flush();\n+    builder();\n+  }\n+\n } // end namespace swift\n \n #endif"
                    },
                    {
                        "filename": "lib/Sema/CSApply.cpp",
                        "code": "@@ -2506,18 +2506,19 @@ namespace {\n             auto baseTyUnwrappedName = baseTyUnwrapped->getString();\n             auto loc = DSCE->getLoc();\n             auto startLoc = DSCE->getStartLoc();\n-            {\n-              CompoundDiagnosticTransaction transaction(tc.Diags);\n-              tc.diagnose(loc, swift::diag::optional_ambiguous_case_ref,\n-                          baseTyName, baseTyUnwrappedName, memberName.str());\n-\n-              tc.diagnose(loc, swift::diag::optional_fixit_ambiguous_case_ref)\n-                  .fixItInsert(startLoc, \"Optional\");\n-              tc.diagnose(loc,\n-                          swift::diag::type_fixit_optional_ambiguous_case_ref,\n-                          baseTyUnwrappedName, memberName.str())\n-                  .fixItInsert(startLoc, baseTyUnwrappedName);\n-            }\n+            tc.diagnoseWithNotes(\n+                tc.diagnose(loc, swift::diag::optional_ambiguous_case_ref,\n+                            baseTyName, baseTyUnwrappedName, memberName.str()),\n+                [&]() {\n+                  tc.diagnose(loc,\n+                              swift::diag::optional_fixit_ambiguous_case_ref)\n+                      .fixItInsert(startLoc, \"Optional\");\n+                  tc.diagnose(\n+                        loc,\n+                        swift::diag::type_fixit_optional_ambiguous_case_ref,\n+                        baseTyUnwrappedName, memberName.str())\n+                      .fixItInsert(startLoc, baseTyUnwrappedName);\n+                });\n           }\n         }\n       }"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckDecl.cpp",
                        "code": "@@ -874,9 +874,10 @@ static void checkRedeclaration(TypeChecker &tc, ValueDecl *current) {\n                         current->getFullName(),\n                         otherInit->isMemberwiseInitializer());\n         } else {\n-          CompoundDiagnosticTransaction transaction(tc.Diags);\n-          tc.diagnose(current, diag::invalid_redecl, current->getFullName());\n-          tc.diagnose(other, diag::invalid_redecl_prev, other->getFullName());\n+          tc.diagnoseWithNotes(tc.diagnose(current, diag::invalid_redecl,\n+                                           current->getFullName()), [&]() {\n+            tc.diagnose(other, diag::invalid_redecl_prev, other->getFullName());\n+          });\n         }\n         markInvalid();\n       }"
                    },
                    {
                        "filename": "lib/Sema/TypeChecker.h",
                        "code": "@@ -723,6 +723,13 @@ class TypeChecker final : public LazyResolver {\n     return Diags.diagnose(std::forward<ArgTypes>(Args)...);\n   }\n \n+  void diagnoseWithNotes(InFlightDiagnostic parentDiag,\n+                         llvm::function_ref<void(void)> builder) {\n+    CompoundDiagnosticTransaction transaction(Diags);\n+    parentDiag.flush();\n+    builder();\n+  }\n+\n   static Type getArraySliceType(SourceLoc loc, Type elementType);\n   static Type getDictionaryType(SourceLoc loc, Type keyType, Type valueType);\n   static Type getOptionalType(SourceLoc loc, Type elementType);"
                    }
                ]
            },
            {
                "date": "2019-08-25T17:44:42Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/000294f5b125def01658b74e54a67f403ae4c08d",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticConsumer.h",
                        "code": "@@ -38,10 +38,17 @@ enum class DiagnosticKind : uint8_t {\n   Note\n };\n \n-/// Extra information carried along with a diagnostic, which may or\n-/// may not be of interest to a given diagnostic consumer.\n+/// Information about a diagnostic passed to DiagnosticConsumers.\n struct DiagnosticInfo {\n   DiagID ID = DiagID(0);\n+  SourceLoc Loc;\n+  DiagnosticKind Kind;\n+  StringRef FormatString;\n+  ArrayRef<DiagnosticArgument> FormatArgs;\n+  SourceLoc BufferIndirectlyCausingDiagnostic;\n+\n+  /// DiagnosticInfo of notes which are children of this diagnostic, if any\n+  ArrayRef<DiagnosticInfo *> ChildDiagnosticInfo;\n \n   /// Represents a fix-it, a replacement of one range of text with another.\n   class FixIt {\n@@ -61,6 +68,24 @@ struct DiagnosticInfo {\n \n   /// Extra source ranges that are attached to the diagnostic.\n   ArrayRef<FixIt> FixIts;\n+\n+  /// This is a note which has a parent error or warning\n+  bool IsChildNote = false;\n+\n+  DiagnosticInfo() {}\n+\n+  DiagnosticInfo(DiagID ID, SourceLoc Loc, DiagnosticKind Kind,\n+                 StringRef FormatString,\n+                 ArrayRef<DiagnosticArgument> FormatArgs,\n+                 SourceLoc BufferIndirectlyCausingDiagnostic,\n+                 ArrayRef<DiagnosticInfo *> ChildDiagnosticInfo,\n+                 ArrayRef<CharSourceRange> Ranges, ArrayRef<FixIt> FixIts,\n+                 bool IsChildNote)\n+      : ID(ID), Loc(Loc), Kind(Kind), FormatString(FormatString),\n+        FormatArgs(FormatArgs),\n+        BufferIndirectlyCausingDiagnostic(BufferIndirectlyCausingDiagnostic),\n+        ChildDiagnosticInfo(ChildDiagnosticInfo), Ranges(Ranges),\n+        FixIts(FixIts), IsChildNote(IsChildNote) {}\n };\n   \n /// Abstract interface for classes that present diagnostics to the user."
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -322,7 +322,9 @@ namespace swift {\n     SmallVector<DiagnosticArgument, 3> Args;\n     SmallVector<CharSourceRange, 2> Ranges;\n     SmallVector<FixIt, 2> FixIts;\n+    std::vector<Diagnostic> ChildNotes;\n     SourceLoc Loc;\n+    bool IsChildNote = false;\n     const Decl *Decl = nullptr;\n \n     friend DiagnosticEngine;\n@@ -347,10 +349,13 @@ namespace swift {\n     ArrayRef<DiagnosticArgument> getArgs() const { return Args; }\n     ArrayRef<CharSourceRange> getRanges() const { return Ranges; }\n     ArrayRef<FixIt> getFixIts() const { return FixIts; }\n+    ArrayRef<Diagnostic> getChildNotes() const { return ChildNotes; }\n+    bool isChildNote() const { return IsChildNote; }\n     SourceLoc getLoc() const { return Loc; }\n     const class Decl *getDecl() const { return Decl; }\n \n     void setLoc(SourceLoc loc) { Loc = loc; }\n+    void setIsChildNote(bool isChildNote) { IsChildNote = isChildNote; }\n     void setDecl(const class Decl *decl) { Decl = decl; }\n \n     /// Returns true if this object represents a particular diagnostic.\n@@ -371,6 +376,8 @@ namespace swift {\n     void addFixIt(FixIt &&F) {\n       FixIts.push_back(std::move(F));\n     }\n+\n+    void addChildNote(Diagnostic &&D);\n   };\n   \n   /// Describes an in-flight diagnostic, which is currently active\n@@ -589,7 +596,8 @@ namespace swift {\n \n     friend class InFlightDiagnostic;\n     friend class DiagnosticTransaction;\n-    \n+    friend class CompoundDiagnosticTransaction;\n+\n   public:\n     explicit DiagnosticEngine(SourceManager &SourceMgr)\n         : SourceMgr(SourceMgr), ActiveDiagnostic(),\n@@ -829,6 +837,10 @@ namespace swift {\n     /// Retrieve the active diagnostic.\n     Diagnostic &getActiveDiagnostic() { return *ActiveDiagnostic; }\n \n+    /// Generate DiagnosticInfo for a Diagnostic to be passed to consumers.\n+    Optional<DiagnosticInfo>\n+    diagnosticInfoForDiagnostic(const Diagnostic &diagnostic);\n+\n     /// Send \\c diag to all diagnostic consumers.\n     void emitDiagnostic(const Diagnostic &diag);\n \n@@ -869,6 +881,7 @@ namespace swift {\n   /// in LIFO order. An open transaction is implicitly committed upon\n   /// destruction.\n   class DiagnosticTransaction {\n+  protected:\n     DiagnosticEngine &Engine;\n \n     /// How many tentative diagnostics there were when the transaction\n@@ -935,6 +948,53 @@ namespace swift {\n              \"transactions must be closed LIFO\");\n     }\n   };\n+\n+  /// Represents a diagnostic transaction which constructs a compound diagnostic\n+  /// from any diagnostics emitted inside. A compound diagnostic consists of a\n+  /// parent error, warning, or remark followed by a variable number of child\n+  /// notes. The semantics are otherwise the same as a regular\n+  /// DiagnosticTransaction.\n+  class CompoundDiagnosticTransaction : public DiagnosticTransaction {\n+  public:\n+    explicit CompoundDiagnosticTransaction(DiagnosticEngine &engine)\n+        : DiagnosticTransaction(engine) {}\n+\n+    ~CompoundDiagnosticTransaction() {\n+      if (IsOpen) {\n+        commit();\n+      }\n+\n+      if (Depth == 0) {\n+        Engine.TransactionStrings.clear();\n+        Engine.TransactionAllocator.Reset();\n+      }\n+    }\n+\n+    void commit() {\n+      assert(PrevDiagnostics < Engine.TentativeDiagnostics.size() &&\n+             \"CompoundDiagnosticTransaction must contain at least one diag\");\n+\n+      // The first diagnostic is assumed to be the parent. If this is not an\n+      // error or warning, we'll assert later when trying to add children.\n+      Diagnostic &parent = Engine.TentativeDiagnostics[PrevDiagnostics];\n+\n+      // Associate the children with the parent.\n+      for (auto diag =\n+               Engine.TentativeDiagnostics.begin() + PrevDiagnostics + 1;\n+           diag != Engine.TentativeDiagnostics.end(); ++diag) {\n+        diag->setIsChildNote(true);\n+        parent.addChildNote(std::move(*diag));\n+      }\n+\n+      // Erase the children, they'll be emitted alongside their parent.\n+      Engine.TentativeDiagnostics.erase(Engine.TentativeDiagnostics.begin() +\n+                                            PrevDiagnostics + 1,\n+                                        Engine.TentativeDiagnostics.end());\n+\n+      DiagnosticTransaction::commit();\n+    }\n+  };\n+\n } // end namespace swift\n \n #endif"
                    },
                    {
                        "filename": "include/swift/Frontend/PrintingDiagnosticConsumer.h",
                        "code": "@@ -50,6 +50,13 @@ class PrintingDiagnosticConsumer : public DiagnosticConsumer {\n   bool didErrorOccur() {\n     return DidErrorOccur;\n   }\n+\n+private:\n+  void printDiagnostic(SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n+                       StringRef FormatString,\n+                       ArrayRef<DiagnosticArgument> FormatArgs,\n+                       const DiagnosticInfo &Info,\n+                       SourceLoc bufferIndirectlyCausingDiagnostic);\n };\n   \n }"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -258,6 +258,14 @@ void InFlightDiagnostic::flush() {\n     Engine->flushActiveDiagnostic();\n }\n \n+void Diagnostic::addChildNote(Diagnostic &&D) {\n+  assert(storedDiagnosticInfos[(unsigned)D.ID].kind == DiagnosticKind::Note &&\n+         \"Only notes can have a parent.\");\n+  assert(storedDiagnosticInfos[(unsigned)ID].kind != DiagnosticKind::Note &&\n+         \"Notes can't have children.\");\n+  ChildNotes.push_back(std::move(D));\n+}\n+\n bool DiagnosticEngine::isDiagnosticPointsToFirstBadToken(DiagID ID) const {\n   return storedDiagnosticInfos[(unsigned) ID].pointsToFirstBadToken;\n }\n@@ -776,10 +784,11 @@ void DiagnosticEngine::emitTentativeDiagnostics() {\n   TentativeDiagnostics.clear();\n }\n \n-void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n+Optional<DiagnosticInfo>\n+DiagnosticEngine::diagnosticInfoForDiagnostic(const Diagnostic &diagnostic) {\n   auto behavior = state.determineBehavior(diagnostic.getID());\n   if (behavior == DiagnosticState::Behavior::Ignore)\n-    return;\n+    return None;\n \n   // Figure out the source location.\n   SourceLoc loc = diagnostic.getLoc();\n@@ -819,7 +828,7 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n           // FIXME: Horrible, horrible hackaround. We're not getting a\n           // DeclContext everywhere we should.\n           if (!dc) {\n-            return;\n+            return None;\n           }\n \n           while (!dc->isModuleContext()) {\n@@ -896,17 +905,37 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n     }\n   }\n \n-  // Pass the diagnostic off to the consumer.\n-  DiagnosticInfo Info;\n-  Info.ID = diagnostic.getID();\n-  Info.Ranges = diagnostic.getRanges();\n-  Info.FixIts = diagnostic.getFixIts();\n-  for (auto &Consumer : Consumers) {\n-    Consumer->handleDiagnostic(\n-        SourceMgr, loc, toDiagnosticKind(behavior),\n-        diagnosticStringFor(Info.ID, getPrintDiagnosticNames()),\n-        diagnostic.getArgs(), Info, getDefaultDiagnosticLoc());\n+  return DiagnosticInfo(\n+      diagnostic.getID(), loc, toDiagnosticKind(behavior),\n+      diagnosticStringFor(diagnostic.getID(), getPrintDiagnosticNames()),\n+      diagnostic.getArgs(), getDefaultDiagnosticLoc(), /*child note info*/ {},\n+      diagnostic.getRanges(), diagnostic.getFixIts(), diagnostic.isChildNote());\n+}\n+\n+void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n+  if (auto info = diagnosticInfoForDiagnostic(diagnostic)) {\n+    SmallVector<DiagnosticInfo, 1> childInfo;\n+    TinyPtrVector<DiagnosticInfo *> childInfoPtrs;\n+    auto childNotes = diagnostic.getChildNotes();\n+    for (unsigned idx = 0; idx < childNotes.size(); ++idx) {\n+      if (auto child = diagnosticInfoForDiagnostic(childNotes[idx])) {\n+        childInfo.push_back(*child);\n+        childInfoPtrs.push_back(&childInfo[idx]);\n+      }\n+    }\n+    info->ChildDiagnosticInfo = childInfoPtrs;\n+    for (auto &consumer : Consumers) {\n+      consumer->handleDiagnostic(SourceMgr, info->Loc, info->Kind,\n+                                 info->FormatString, info->FormatArgs, *info,\n+                                 info->BufferIndirectlyCausingDiagnostic);\n+    }\n   }\n+\n+  // For compatibility with DiagnosticConsumers which don't know about child\n+  // notes. These can be ignored by consumers which do take advantage of the\n+  // grouping.\n+  for (auto &childNote : diagnostic.getChildNotes())\n+    emitDiagnostic(childNote);\n }\n \n const char *DiagnosticEngine::diagnosticStringFor(const DiagID id,"
                    },
                    {
                        "filename": "lib/Frontend/PrintingDiagnosticConsumer.cpp",
                        "code": "@@ -68,6 +68,25 @@ void PrintingDiagnosticConsumer::handleDiagnostic(\n     StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n     const DiagnosticInfo &Info,\n     const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+  if (Info.IsChildNote)\n+    return;\n+\n+  printDiagnostic(SM, Loc, Kind, FormatString, FormatArgs, Info,\n+                  bufferIndirectlyCausingDiagnostic);\n+\n+  for (auto ChildInfo : Info.ChildDiagnosticInfo) {\n+    printDiagnostic(SM, ChildInfo->Loc, ChildInfo->Kind,\n+                    ChildInfo->FormatString, ChildInfo->FormatArgs, *ChildInfo,\n+                    ChildInfo->BufferIndirectlyCausingDiagnostic);\n+  }\n+}\n+\n+void PrintingDiagnosticConsumer::printDiagnostic(\n+    SourceManager &SM, SourceLoc Loc, DiagnosticKind Kind,\n+    StringRef FormatString, ArrayRef<DiagnosticArgument> FormatArgs,\n+    const DiagnosticInfo &Info,\n+    const SourceLoc bufferIndirectlyCausingDiagnostic) {\n+\n   // Determine what kind of diagnostic we're emitting.\n   llvm::SourceMgr::DiagKind SMKind;\n   switch (Kind) {"
                    },
                    {
                        "filename": "lib/Sema/CSApply.cpp",
                        "code": "@@ -2506,15 +2506,18 @@ namespace {\n             auto baseTyUnwrappedName = baseTyUnwrapped->getString();\n             auto loc = DSCE->getLoc();\n             auto startLoc = DSCE->getStartLoc();\n-            \n-            tc.diagnose(loc, swift::diag::optional_ambiguous_case_ref,\n-                        baseTyName, baseTyUnwrappedName, memberName.str());\n-            \n-            tc.diagnose(loc, swift::diag::optional_fixit_ambiguous_case_ref)\n-              .fixItInsert(startLoc, \"Optional\");\n-            tc.diagnose(loc, swift::diag::type_fixit_optional_ambiguous_case_ref,\n-                        baseTyUnwrappedName, memberName.str())\n-              .fixItInsert(startLoc, baseTyUnwrappedName);\n+            {\n+              CompoundDiagnosticTransaction transaction(tc.Diags);\n+              tc.diagnose(loc, swift::diag::optional_ambiguous_case_ref,\n+                          baseTyName, baseTyUnwrappedName, memberName.str());\n+\n+              tc.diagnose(loc, swift::diag::optional_fixit_ambiguous_case_ref)\n+                  .fixItInsert(startLoc, \"Optional\");\n+              tc.diagnose(loc,\n+                          swift::diag::type_fixit_optional_ambiguous_case_ref,\n+                          baseTyUnwrappedName, memberName.str())\n+                  .fixItInsert(startLoc, baseTyUnwrappedName);\n+            }\n           }\n         }\n       }"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckDecl.cpp",
                        "code": "@@ -874,6 +874,7 @@ static void checkRedeclaration(TypeChecker &tc, ValueDecl *current) {\n                         current->getFullName(),\n                         otherInit->isMemberwiseInitializer());\n         } else {\n+          CompoundDiagnosticTransaction transaction(tc.Diags);\n           tc.diagnose(current, diag::invalid_redecl, current->getFullName());\n           tc.diagnose(other, diag::invalid_redecl_prev, other->getFullName());\n         }"
                    }
                ]
            },
            {
                "date": "2019-08-02T15:05:01Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/68e6065c8ef5f873efa4db2da0f7aed1397360be",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticConsumer.h",
                        "code": "@@ -49,8 +49,7 @@ struct DiagnosticInfo {\n     std::string Text;\n \n   public:\n-    FixIt(CharSourceRange R, StringRef Str)\n-        : Range(R), Text(Str) {}\n+    FixIt(CharSourceRange R, StringRef Str, ArrayRef<DiagnosticArgument> Args);\n \n     CharSourceRange getRange() const { return Range; }\n     StringRef getText() const { return Text; }"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -309,8 +309,22 @@ namespace swift {\n         : OpeningQuotationMark(\"'\"), ClosingQuotationMark(\"'\"),\n           AKAFormatString(\"'%s' (aka '%s')\"),\n           OpaqueResultFormatString(\"'%s' (%s of '%s')\") {}\n+\n+    /// When formatting fix-it arguments, don't include quotes or other\n+    /// additions which would result in invalid code.\n+    static DiagnosticFormatOptions formatForFixIts() {\n+      return DiagnosticFormatOptions(\"\", \"\", \"%s\", \"%s\");\n+    }\n   };\n-  \n+\n+  enum class FixItID : uint32_t;\n+\n+  /// Represents a fix-it defined  with a format string and optional\n+  /// DiagnosticArguments. The template parameters allow the\n+  /// fixIt... methods on InFlightDiagnostic to infer their own\n+  /// template params.\n+  template <typename... ArgTypes> struct StructuredFixIt { FixItID ID; };\n+\n   /// Diagnostic - This is a specific instance of a diagnostic along with all of\n   /// the DiagnosticArguments that it requires. \n   class Diagnostic {\n@@ -333,7 +347,7 @@ namespace swift {\n     Diagnostic(Diag<ArgTypes...> ID,\n                typename detail::PassArgument<ArgTypes>::type... VArgs)\n       : ID(ID.ID) {\n-      DiagnosticArgument DiagArgs[] = { \n+      DiagnosticArgument DiagArgs[] = {\n         DiagnosticArgument(0), std::move(VArgs)... \n       };\n       Args.append(DiagArgs + 1, DiagArgs + 1 + sizeof...(VArgs));\n@@ -425,25 +439,70 @@ namespace swift {\n     /// Add a character-based range to the currently-active diagnostic.\n     InFlightDiagnostic &highlightChars(SourceLoc Start, SourceLoc End);\n \n+    static const char *fixItStringFor(const FixItID id);\n+\n+    /// Add a token-based replacement fix-it to the currently-active\n+    /// diagnostic.\n+    template <typename... ArgTypes>\n+    InFlightDiagnostic &\n+    fixItReplace(SourceRange R, StructuredFixIt<ArgTypes...> fixIt,\n+                 typename detail::PassArgument<ArgTypes>::type... VArgs) {\n+      DiagnosticArgument DiagArgs[] = { std::move(VArgs)... };\n+      return fixItReplace(R, fixItStringFor(fixIt.ID), DiagArgs);\n+    }\n+\n+    /// Add a character-based replacement fix-it to the currently-active\n+    /// diagnostic.\n+    template <typename... ArgTypes>\n+    InFlightDiagnostic &\n+    fixItReplaceChars(SourceLoc Start, SourceLoc End,\n+                      StructuredFixIt<ArgTypes...> fixIt,\n+                      typename detail::PassArgument<ArgTypes>::type... VArgs) {\n+      DiagnosticArgument DiagArgs[] = { std::move(VArgs)... };\n+      return fixItReplaceChars(Start, End, fixItStringFor(fixIt.ID), DiagArgs);\n+    }\n+\n+    /// Add an insertion fix-it to the currently-active diagnostic.\n+    template <typename... ArgTypes>\n+    InFlightDiagnostic &\n+    fixItInsert(SourceLoc L, StructuredFixIt<ArgTypes...> fixIt,\n+                typename detail::PassArgument<ArgTypes>::type... VArgs) {\n+      DiagnosticArgument DiagArgs[] = { std::move(VArgs)... };\n+      return fixItReplaceChars(L, L, fixItStringFor(fixIt.ID), DiagArgs);\n+    }\n+\n+    /// Add an insertion fix-it to the currently-active diagnostic.  The\n+    /// text is inserted immediately *after* the token specified.\n+    template <typename... ArgTypes>\n+    InFlightDiagnostic &\n+    fixItInsertAfter(SourceLoc L, StructuredFixIt<ArgTypes...> fixIt,\n+                     typename detail::PassArgument<ArgTypes>::type... VArgs) {\n+      DiagnosticArgument DiagArgs[] = { std::move(VArgs)... };\n+      return fixItInsertAfter(L, fixItStringFor(fixIt.ID), DiagArgs);\n+    }\n+\n     /// Add a token-based replacement fix-it to the currently-active\n     /// diagnostic.\n     InFlightDiagnostic &fixItReplace(SourceRange R, StringRef Str);\n \n     /// Add a character-based replacement fix-it to the currently-active\n     /// diagnostic.\n     InFlightDiagnostic &fixItReplaceChars(SourceLoc Start, SourceLoc End,\n-                                          StringRef Str);\n+                                          StringRef Str) {\n+      return fixItReplaceChars(Start, End, \"%0\", {Str});\n+    }\n \n     /// Add an insertion fix-it to the currently-active diagnostic.\n     InFlightDiagnostic &fixItInsert(SourceLoc L, StringRef Str) {\n-      return fixItReplaceChars(L, L, Str);\n+      return fixItReplaceChars(L, L, \"%0\", {Str});\n     }\n \n     /// Add an insertion fix-it to the currently-active diagnostic.  The\n     /// text is inserted immediately *after* the token specified.\n-    ///\n-    InFlightDiagnostic &fixItInsertAfter(SourceLoc L, StringRef);\n-\n+    InFlightDiagnostic &fixItInsertAfter(SourceLoc L, StringRef Str) {\n+      return fixItInsertAfter(L, \"%0\", {Str});\n+    }\n+    \n     /// Add a token-based removal fix-it to the currently-active\n     /// diagnostic.\n     InFlightDiagnostic &fixItRemove(SourceRange R);\n@@ -457,6 +516,22 @@ namespace swift {\n     /// Add two replacement fix-it exchanging source ranges to the\n     /// currently-active diagnostic.\n     InFlightDiagnostic &fixItExchange(SourceRange R1, SourceRange R2);\n+    \n+  private:\n+    InFlightDiagnostic &fixItReplace(SourceRange R, StringRef FormatString,\n+                                     ArrayRef<DiagnosticArgument> Args);\n+\n+    InFlightDiagnostic &fixItReplaceChars(SourceLoc Start, SourceLoc End,\n+                                          StringRef FormatString,\n+                                          ArrayRef<DiagnosticArgument> Args);\n+\n+    InFlightDiagnostic &fixItInsert(SourceLoc L, StringRef FormatString,\n+                                    ArrayRef<DiagnosticArgument> Args) {\n+      return fixItReplaceChars(L, L, FormatString, Args);\n+    }\n+\n+    InFlightDiagnostic &fixItInsertAfter(SourceLoc L, StringRef FormatString,\n+                                         ArrayRef<DiagnosticArgument> Args);\n   };\n \n   /// Class to track, map, and remap diagnostic severity and fatality"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsAll.def",
                        "code": "@@ -38,6 +38,10 @@\n   DIAG(REMARK,ID,Options,Text,Signature)\n #endif\n \n+#ifndef FIXIT\n+#  define FIXIT(ID, Text, Signature)\n+#endif\n+\n #define DIAG_NO_UNDEF\n \n #include \"DiagnosticsCommon.def\"\n@@ -60,3 +64,4 @@\n #undef WARNING\n #undef ERROR\n #undef REMARK\n+#undef FIXIT"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsCommon.def",
                        "code": "@@ -41,6 +41,10 @@\n   DIAG(REMARK,ID,Options,Text,Signature)\n #endif\n \n+#ifndef FIXIT\n+#  define FIXIT(ID, Text, Signature)\n+#endif\n+\n ERROR(invalid_diagnostic,none,\n       \"INTERNAL ERROR: this diagnostic should not be produced\", ())\n \n@@ -166,4 +170,5 @@ NOTE(kind_declname_declared_here,none,\n # undef NOTE\n # undef WARNING\n # undef ERROR\n+# undef FIXIT\n #endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsCommon.h",
                        "code": "@@ -28,14 +28,24 @@ namespace swift {\n   struct Diag;\n \n   namespace detail {\n+    // These templates are used to help extract the type arguments of the\n+    // DIAG/ERROR/WARNING/NOTE/REMARK/FIXIT macros.\n     template<typename T>\n     struct DiagWithArguments;\n     \n     template<typename ...ArgTypes>\n     struct DiagWithArguments<void(ArgTypes...)> {\n       typedef Diag<ArgTypes...> type;\n     };\n-  }\n+\n+    template <typename T>\n+    struct StructuredFixItWithArguments;\n+\n+    template <typename... ArgTypes>\n+    struct StructuredFixItWithArguments<void(ArgTypes...)> {\n+      typedef StructuredFixIt<ArgTypes...> type;\n+    };\n+  } // end namespace detail\n \n   enum class StaticSpellingKind : uint8_t;\n \n@@ -48,8 +58,10 @@ namespace swift {\n   // Declare common diagnostics objects with their appropriate types.\n #define DIAG(KIND,ID,Options,Text,Signature) \\\n     extern detail::DiagWithArguments<void Signature>::type ID;\n+#define FIXIT(ID, Text, Signature) \\\n+    extern detail::StructuredFixItWithArguments<void Signature>::type ID;\n #include \"DiagnosticsCommon.def\"\n-  }\n-}\n+  } // end namespace diag\n+} // end namespace swift\n \n #endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.def",
                        "code": "@@ -36,6 +36,10 @@\n   DIAG(NOTE,ID,Options,Text,Signature)\n #endif\n \n+#ifndef FIXIT\n+#  define FIXIT(ID, Text, Signature)\n+#endif\n+\n //==============================================================================\n // MARK: Lexing and Parsing diagnostics\n //==============================================================================\n@@ -1638,4 +1642,5 @@ ERROR(unknown_syntax_entity, PointsToFirstBadToken,\n # undef NOTE\n # undef WARNING\n # undef ERROR\n+# undef FIXIT\n #endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.h",
                        "code": "@@ -25,6 +25,8 @@ namespace swift {\n   // Declare common diagnostics objects with their appropriate types.\n #define DIAG(KIND,ID,Options,Text,Signature) \\\n   extern detail::DiagWithArguments<void Signature>::type ID;\n+#define FIXIT(ID,Text,Signature) \\\n+  extern detail::StructuredFixItWithArguments<void Signature>::type ID;\n #include \"DiagnosticsParse.def\"\n   }\n }"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -37,6 +37,10 @@\n   DIAG(NOTE,ID,Options,Text,Signature)\n #endif\n \n+#ifndef FIXIT\n+#  define FIXIT(ID, Text, Signature)\n+#endif\n+\n NOTE(decl_declared_here,none,\n      \"%0 declared here\", (DeclName))\n NOTE(kind_declared_here,none,\n@@ -145,6 +149,8 @@ ERROR(could_not_use_member_on_existential,none,\n       \"member %1 cannot be used on value of protocol type %0; use a generic\"\n       \" constraint instead\",\n       (Type, DeclName))\n+FIXIT(replace_with_type,\"%0\",(Type))\n+FIXIT(insert_type_qualification,\"%0.\",(Type))\n \n ERROR(candidate_inaccessible,none,\n       \"%0 is inaccessible due to \"\n@@ -297,6 +303,9 @@ ERROR(cannot_infer_closure_type,none,\n ERROR(cannot_infer_closure_result_type,none,\n       \"unable to infer complex closure return type; \"\n       \"add explicit type to disambiguate\", ())\n+FIXIT(insert_closure_return_type,\n+      \"%select{| () }1-> %0 %select{|in }1\",\n+      (Type, bool))\n \n ERROR(incorrect_explicit_closure_result,none,\n       \"declared closure result %0 is incompatible with contextual type %1\",\n@@ -344,6 +353,9 @@ ERROR(cannot_throw_error_code,none,\n       \"thrown error code type %0 does not conform to 'Error'; construct an %1 \"\n       \"instance\", (Type, Type))\n \n+FIXIT(insert_type_coercion,\n+      \" %select{as!|as}0 %1\",(bool, Type))\n+\n ERROR(bad_yield_count,none,\n       \"expected %0 yield value(s)\", (unsigned))\n \n@@ -4178,6 +4190,9 @@ NOTE(availability_guard_with_version_check, none,\n \n NOTE(availability_add_attribute, none,\n      \"add @available attribute to enclosing %0\", (DescriptiveDeclKind))\n+FIXIT(insert_available_attr,\n+      \"@available(%0 %1, *)\\n%2\",\n+      (StringRef, StringRef, StringRef))\n \n ERROR(availability_accessor_only_version_newer, none,\n       \"%select{getter|setter}0 for %1 is only available in %2 %3\"\n@@ -4595,4 +4610,5 @@ ERROR(function_builder_arguments, none,\n # undef NOTE\n # undef WARNING\n # undef ERROR\n+# undef FIXIT\n #endif"
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.h",
                        "code": "@@ -35,6 +35,8 @@ namespace swift {\n   // Declare common diagnostics objects with their appropriate types.\n #define DIAG(KIND,ID,Options,Text,Signature) \\\n     extern detail::DiagWithArguments<void Signature>::type ID;\n+#define FIXIT(ID,Text,Signature) \\\n+    extern detail::StructuredFixItWithArguments<void Signature>::type ID;\n #include \"DiagnosticsSema.def\"\n   }\n }"
                    },
                    {
                        "filename": "lib/AST/DiagnosticConsumer.cpp",
                        "code": "@@ -29,6 +29,15 @@ using namespace swift;\n \n DiagnosticConsumer::~DiagnosticConsumer() = default;\n \n+DiagnosticInfo::FixIt::FixIt(CharSourceRange R, StringRef Str,\n+                             ArrayRef<DiagnosticArgument> Args) : Range(R) {\n+  // FIXME: Defer text formatting to later in the pipeline.\n+  llvm::raw_string_ostream OS(Text);\n+  DiagnosticEngine::formatDiagnosticText(OS, Str, Args,\n+                                         DiagnosticFormatOptions::\n+                                         formatForFixIts());\n+}\n+\n llvm::SMLoc DiagnosticConsumer::getRawLoc(SourceLoc loc) {\n   return loc.Value;\n }"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -108,6 +108,13 @@ static constexpr const char *const debugDiagnosticStrings[] = {\n     \"<not a diagnostic>\",\n };\n \n+static constexpr const char *const fixItStrings[] = {\n+#define DIAG(KIND, ID, Options, Text, Signature)\n+#define FIXIT(ID, Text, Signature) Text,\n+#include \"swift/AST/DiagnosticsAll.def\"\n+    \"<not a fix-it>\",\n+};\n+\n DiagnosticState::DiagnosticState() {\n   // Initialize our per-diagnostic state to default\n   perDiagnosticBehavior.resize(LocalDiagID::NumDiags, Behavior::Unspecified);\n@@ -162,10 +169,11 @@ InFlightDiagnostic &InFlightDiagnostic::highlightChars(SourceLoc Start,\n /// Add an insertion fix-it to the currently-active diagnostic.  The\n /// text is inserted immediately *after* the token specified.\n ///\n-InFlightDiagnostic &InFlightDiagnostic::fixItInsertAfter(SourceLoc L,\n-                                                         StringRef Str) {\n+InFlightDiagnostic &\n+InFlightDiagnostic::fixItInsertAfter(SourceLoc L, StringRef FormatString,\n+                                     ArrayRef<DiagnosticArgument> Args) {\n   L = Lexer::getLocForEndOfToken(Engine->SourceMgr, L);\n-  return fixItInsert(L, Str);\n+  return fixItInsert(L, FormatString, Args);\n }\n \n /// Add a token-based removal fix-it to the currently-active\n@@ -189,10 +197,20 @@ InFlightDiagnostic &InFlightDiagnostic::fixItRemove(SourceRange R) {\n     charRange = CharSourceRange(charRange.getStart(),\n                                 charRange.getByteLength()+1);\n   }\n-  Engine->getActiveDiagnostic().addFixIt(Diagnostic::FixIt(charRange, {}));\n+  Engine->getActiveDiagnostic().addFixIt(Diagnostic::FixIt(charRange, {}, {}));\n   return *this;\n }\n \n+InFlightDiagnostic &\n+InFlightDiagnostic::fixItReplace(SourceRange R, StringRef FormatString,\n+                                 ArrayRef<DiagnosticArgument> Args) {\n+  auto &SM = Engine->SourceMgr;\n+  auto charRange = toCharSourceRange(SM, R);\n+\n+  Engine->getActiveDiagnostic().addFixIt(\n+      Diagnostic::FixIt(charRange, FormatString, Args));\n+  return *this;\n+}\n \n InFlightDiagnostic &InFlightDiagnostic::fixItReplace(SourceRange R,\n                                                      StringRef Str) {\n@@ -207,6 +225,7 @@ InFlightDiagnostic &InFlightDiagnostic::fixItReplace(SourceRange R,\n \n   // If we're replacing with something that wants spaces around it, do a bit of\n   // extra work so that we don't suggest extra spaces.\n+  // FIXME: This could probably be applied to structured fix-its as well.\n   if (Str.back() == ' ') {\n     if (isspace(extractCharAfter(SM, charRange.getEnd())))\n       Str = Str.drop_back();\n@@ -215,18 +234,19 @@ InFlightDiagnostic &InFlightDiagnostic::fixItReplace(SourceRange R,\n     if (isspace(extractCharBefore(SM, charRange.getStart())))\n       Str = Str.drop_front();\n   }\n-\n-  Engine->getActiveDiagnostic().addFixIt(Diagnostic::FixIt(charRange, Str));\n-  return *this;\n+  \n+  return fixItReplace(R, \"%0\", {Str});\n }\n \n-InFlightDiagnostic &InFlightDiagnostic::fixItReplaceChars(SourceLoc Start,\n-                                                          SourceLoc End,\n-                                                          StringRef Str) {\n+InFlightDiagnostic &\n+InFlightDiagnostic::fixItReplaceChars(SourceLoc Start, SourceLoc End,\n+                                      StringRef FormatString,\n+                                      ArrayRef<DiagnosticArgument> Args) {\n   assert(IsActive && \"Cannot modify an inactive diagnostic\");\n   if (Engine && Start.isValid())\n-    Engine->getActiveDiagnostic().addFixIt(Diagnostic::FixIt(\n-        toCharSourceRange(Engine->SourceMgr, Start, End), Str));\n+    Engine->getActiveDiagnostic().addFixIt(\n+        Diagnostic::FixIt(toCharSourceRange(Engine->SourceMgr, Start, End),\n+                          FormatString, Args));\n   return *this;\n }\n \n@@ -242,10 +262,10 @@ InFlightDiagnostic &InFlightDiagnostic::fixItExchange(SourceRange R1,\n   auto text1 = SM.extractText(charRange1);\n   auto text2 = SM.extractText(charRange2);\n \n-  Engine->getActiveDiagnostic()\n-    .addFixIt(Diagnostic::FixIt(charRange1, text2));\n-  Engine->getActiveDiagnostic()\n-    .addFixIt(Diagnostic::FixIt(charRange2, text1));\n+  Engine->getActiveDiagnostic().addFixIt(\n+      Diagnostic::FixIt(charRange1, \"%0\", {text2}));\n+  Engine->getActiveDiagnostic().addFixIt(\n+      Diagnostic::FixIt(charRange2, \"%0\", {text1}));\n   return *this;\n }\n \n@@ -923,6 +943,10 @@ const char *DiagnosticEngine::diagnosticStringFor(const DiagID id,\n   return diagnosticStrings[(unsigned)id];\n }\n \n+const char *InFlightDiagnostic::fixItStringFor(const FixItID id) {\n+  return fixItStrings[(unsigned)id];\n+}\n+\n void DiagnosticEngine::setBufferIndirectlyCausingDiagnosticToInput(\n     SourceLoc loc) {\n   // If in the future, nested BufferIndirectlyCausingDiagnosticRAII need be"
                    },
                    {
                        "filename": "lib/AST/DiagnosticList.cpp",
                        "code": "@@ -24,12 +24,20 @@ enum class swift::DiagID : uint32_t {\n static_assert(static_cast<uint32_t>(swift::DiagID::invalid_diagnostic) == 0,\n               \"0 is not the invalid diagnostic ID\");\n \n+enum class swift::FixItID : uint32_t {\n+#define DIAG(KIND, ID, Options, Text, Signature)\n+#define FIXIT(ID, Text, Signature) ID,\n+#include \"swift/AST/DiagnosticsAll.def\"\n+};\n+\n // Define all of the diagnostic objects and initialize them with their \n // diagnostic IDs.\n namespace swift {\n   namespace diag {\n #define DIAG(KIND,ID,Options,Text,Signature) \\\n     detail::DiagWithArguments<void Signature>::type ID = { DiagID::ID };\n+#define FIXIT(ID, Text, Signature) \\\n+    detail::StructuredFixItWithArguments<void Signature>::type ID = {FixItID::ID};\n #include \"swift/AST/DiagnosticsAll.def\"\n   } // end namespace diag\n } // end namespace swift"
                    },
                    {
                        "filename": "lib/Sema/CSDiag.cpp",
                        "code": "@@ -6121,14 +6121,13 @@ diagnoseAmbiguousMultiStatementClosure(ClosureExpr *closure) {\n     // If we found a type, presuppose it was the intended result and insert a\n     // fixit hint.\n     if (resultType && !isUnresolvedOrTypeVarType(resultType)) {\n-      std::string resultTypeStr = resultType->getString();\n-      \n       // If there is a location for an 'in' token, then the argument list was\n       // specified somehow but no return type was.  Insert a \"-> ReturnType \"\n       // before the in token.\n       if (closure->getInLoc().isValid()) {\n         diagnose(closure->getLoc(), diag::cannot_infer_closure_result_type)\n-          .fixItInsert(closure->getInLoc(), \"-> \" + resultTypeStr + \" \");\n+            .fixItInsert(closure->getInLoc(), diag::insert_closure_return_type,\n+                         resultType, /*argListSpecified*/ false);\n         return true;\n       }\n       \n@@ -6138,9 +6137,10 @@ diagnoseAmbiguousMultiStatementClosure(ClosureExpr *closure) {\n       //\n       // As such, we insert \" () -> ReturnType in \" right after the '{' that\n       // starts the closure body.\n-      auto insertString = \" () -> \" + resultTypeStr + \" \" + \"in \";\n       diagnose(closure->getLoc(), diag::cannot_infer_closure_result_type)\n-        .fixItInsertAfter(closure->getBody()->getLBraceLoc(), insertString);\n+          .fixItInsertAfter(closure->getBody()->getLBraceLoc(),\n+                            diag::insert_closure_return_type, resultType,\n+                            /*argListSpecified*/ true);\n       return true;\n     }\n   }"
                    },
                    {
                        "filename": "lib/Sema/CSDiagnostics.cpp",
                        "code": "@@ -2413,17 +2413,13 @@ bool ContextualFailure::tryTypeCoercionFixIt(\n   if (Kind != CheckedCastKind::Unresolved) {\n     auto *anchor = getAnchor();\n \n-    SmallString<32> buffer;\n-    llvm::raw_svector_ostream OS(buffer);\n     bool canUseAs = Kind == CheckedCastKind::Coercion ||\n                     Kind == CheckedCastKind::BridgingCoercion;\n     if (bothOptional && canUseAs)\n       toType = OptionalType::get(toType);\n-    toType->print(OS);\n-    diagnostic.fixItInsert(\n-        Lexer::getLocForEndOfToken(getASTContext().SourceMgr,\n-                                   anchor->getEndLoc()),\n-        (llvm::Twine(canUseAs ? \" as \" : \" as! \") + OS.str()).str());\n+    diagnostic.fixItInsert(Lexer::getLocForEndOfToken(getASTContext().SourceMgr,\n+                                                      anchor->getEndLoc()),\n+                           diag::insert_type_coercion, canUseAs, toType);\n     return true;\n   }\n \n@@ -3270,12 +3266,13 @@ bool AllowTypeOrInstanceMemberFailure::diagnoseAsError() {\n \n     // Fall back to a fix-it with a full type qualifier\n     if (auto *NTD = Member->getDeclContext()->getSelfNominalTypeDecl()) {\n-      auto typeName = NTD->getSelfInterfaceType()->getString();\n+      auto type = NTD->getSelfInterfaceType();\n       if (auto *SE = dyn_cast<SubscriptExpr>(getRawAnchor())) {\n         auto *baseExpr = SE->getBase();\n-        Diag->fixItReplace(baseExpr->getSourceRange(), typeName);\n+        Diag->fixItReplace(baseExpr->getSourceRange(), diag::replace_with_type,\n+                           type);\n       } else {\n-        Diag->fixItInsert(loc, typeName + \".\");\n+        Diag->fixItInsert(loc, diag::insert_type_qualification, type);\n       }\n     }\n "
                    },
                    {
                        "filename": "lib/Sema/TypeCheckAvailability.cpp",
                        "code": "@@ -1180,20 +1180,14 @@ static void fixAvailabilityForDecl(SourceRange ReferenceRange, const Decl *D,\n \n   StringRef OriginalIndent =\n       Lexer::getIndentationForLine(TC.Context.SourceMgr, InsertLoc);\n-\n-  std::string AttrText;\n-  {\n-    llvm::raw_string_ostream Out(AttrText);\n-\n-    PlatformKind Target = targetPlatform(TC.getLangOpts());\n-    Out << \"@available(\" << platformString(Target) << \" \"\n-        << RequiredRange.getLowerEndpoint().getAsString() << \", *)\\n\"\n-        << OriginalIndent;\n-  }\n+  PlatformKind Target = targetPlatform(TC.getLangOpts());\n \n   TC.diagnose(D, diag::availability_add_attribute,\n               KindForDiagnostic)\n-      .fixItInsert(InsertLoc, AttrText);\n+      .fixItInsert(InsertLoc, diag::insert_available_attr,\n+                   platformString(Target),\n+                   RequiredRange.getLowerEndpoint().getAsString(),\n+                   OriginalIndent);\n }\n \n /// In the special case of being in an existing, nontrivial type refinement"
                    }
                ]
            },
            {
                "date": "2019-08-30T03:13:40Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/0a239d568a5209c0cd2cfb3e0b1ccb525cfd89a7",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -565,12 +565,14 @@ bool DiagnosticVerifier::verifyFile(unsigned BufferID,\n \n       llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->getMessage());\n       addError(expected.MessageRange.begin(), \"incorrect message found\", fixIt);\n-    } else {\n+    } else if (I->getColumnNo() + 1 != (int)*expected.ColumnNo) {\n       // The difference must be only in the column\n       addError(expected.MessageRange.begin(),\n                llvm::formatv(\"message found at column {0} but was expected to \"\n                              \"appear at column {1}\",\n                              I->getColumnNo() + 1, *expected.ColumnNo));\n+    } else {\n+      llvm_unreachable(\"unhandled difference from expected diagnostic\");\n     }\n     CapturedDiagnostics.erase(I);\n     ExpectedDiagnostics.erase(ExpectedDiagnostics.begin()+i);"
                    },
                    {
                        "filename": "test/Sema/diag_deprecated_string_interpolation.swift",
                        "code": "@@ -1,24 +1,21 @@\n-// RUN: %target-swift-frontend -swift-version 5 -typecheck %s 2>&1 | %FileCheck %s\n+// RUN: %target-typecheck-verify-swift -swift-version 5\n \n extension DefaultStringInterpolation {\n     @available(*, deprecated) func appendInterpolation(deprecated: Int) {}\n }\n \n // Make sure diagnostics emitted via string interpolations have a reasonable source location\n \n-_ = \"\\(deprecated: 42)\"\n-// CHECK: [[@LINE-1]]:7: warning: 'appendInterpolation(deprecated:)' is deprecated\n+_ = \"\\(deprecated: 42)\" // expected-warning@:7 {{'appendInterpolation(deprecated:)' is deprecated}}\n \n-_ = \"hello, world\\(deprecated: 42)!!!\"\n-// CHECK: [[@LINE-1]]:19: warning: 'appendInterpolation(deprecated:)' is deprecated\n+_ = \"hello, world\\(deprecated: 42)!!!\" // expected-warning@:19 {{'appendInterpolation(deprecated:)' is deprecated}}\n \n _ = \"\\(42)\\(deprecated: 42)test\\(deprecated: 42)\"\n-// CHECK: [[@LINE-1]]:12: warning: 'appendInterpolation(deprecated:)' is deprecated\n-// CHECK: [[@LINE-2]]:33: warning: 'appendInterpolation(deprecated:)' is deprecated\n-\n+// expected-warning@-1:12 {{'appendInterpolation(deprecated:)' is deprecated}}\n+// expected-warning@-2:33 {{'appendInterpolation(deprecated:)' is deprecated}}\n _ = \"\"\"\n This is a multiline literal with a deprecated interpolation:\n \n \\(deprecated: 42)\n \"\"\"\n-// CHECK: [[@LINE-2]]:2: warning: 'appendInterpolation(deprecated:)' is deprecated\n+// expected-warning@-2:2 {{'appendInterpolation(deprecated:)' is deprecated}}"
                    }
                ]
            },
            {
                "date": "2019-08-26T01:18:59Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/3a2547ce0c1fab05cb6b4414901f323b3cf7e190",
                "changes": [
                    {
                        "filename": "lib/Frontend/DiagnosticVerifier.cpp",
                        "code": "@@ -18,6 +18,7 @@\n #include \"swift/Basic/SourceManager.h\"\n #include \"swift/Parse/Lexer.h\"\n #include \"llvm/Support/FileSystem.h\"\n+#include \"llvm/Support/FormatVariadic.h\"\n #include \"llvm/Support/MemoryBuffer.h\"\n #include \"llvm/Support/raw_ostream.h\"\n \n@@ -52,7 +53,8 @@ namespace {\n     // This is the message string with escapes expanded.\n     std::string MessageStr;\n     unsigned LineNo = ~0U;\n-    \n+    Optional<unsigned> ColumnNo;\n+\n     std::vector<ExpectedFixIt> Fixits;\n \n     ExpectedDiagnosticInfo(const char *ExpectedStart,\n@@ -127,6 +129,12 @@ DiagnosticVerifier::findDiagnostic(const ExpectedDiagnosticInfo &Expected,\n         I->getFilename() != BufferName)\n       continue;\n \n+    // If a specific column was expected, verify it. Add one to the captured\n+    // index so expected column numbers correspond to printed output.\n+    if (Expected.ColumnNo.hasValue() &&\n+        I->getColumnNo() + 1 != (int)*Expected.ColumnNo)\n+      continue;\n+\n     // Verify the classification and string.\n     if (I->getKind() != Expected.Classification ||\n         I->getMessage().find(Expected.MessageStr) == StringRef::npos)\n@@ -262,10 +270,14 @@ bool DiagnosticVerifier::verifyFile(unsigned BufferID,\n       continue;\n     }\n \n+    ExpectedDiagnosticInfo Expected(DiagnosticLoc, ExpectedClassification);\n     int LineOffset = 0;\n+\n     if (TextStartIdx > 0 && MatchStart[0] == '@') {\n-      if (MatchStart[1] != '+' && MatchStart[1] != '-') {\n-        addError(MatchStart.data(), \"expected '+'/'-' for line offset\");\n+      if (MatchStart[1] != '+' && MatchStart[1] != '-' &&\n+          MatchStart[1] != ':') {\n+        addError(MatchStart.data(),\n+                 \"expected '+'/'-' for line offset, or ':' for column\");\n         continue;\n       }\n       StringRef Offs;\n@@ -285,13 +297,27 @@ bool DiagnosticVerifier::verifyFile(unsigned BufferID,\n         TextStartIdx = 0;\n       }\n \n-      if (Offs.getAsInteger(10, LineOffset)) {\n-        addError(MatchStart.data(), \"expected line offset before '{{'\");\n-        continue;\n+      size_t ColonIndex = Offs.find(':');\n+      // Check whether a line offset was provided\n+      if (ColonIndex != 0) {\n+        StringRef LineOffs = Offs.slice(0, ColonIndex);\n+        if (LineOffs.getAsInteger(10, LineOffset)) {\n+          addError(MatchStart.data(), \"expected line offset before '{{'\");\n+          continue;\n+        }\n       }\n-    }\n \n-    ExpectedDiagnosticInfo Expected(DiagnosticLoc, ExpectedClassification);\n+      // Check whether a column was provided\n+      if (ColonIndex != StringRef::npos) {\n+        Offs = Offs.slice(ColonIndex + 1, Offs.size());\n+        int Column = 0;\n+        if (Offs.getAsInteger(10, Column)) {\n+          addError(MatchStart.data(), \"expected column before '{{'\");\n+          continue;\n+        }\n+        Expected.ColumnNo = Column;\n+      }\n+    }\n \n     unsigned Count = 1;\n     if (TextStartIdx > 0) {\n@@ -532,12 +558,20 @@ bool DiagnosticVerifier::verifyFile(unsigned BufferID,\n     }\n \n     if (I == CapturedDiagnostics.end()) continue;\n-    \n-    auto StartLoc = SMLoc::getFromPointer(expected.MessageRange.begin());\n-    auto EndLoc = SMLoc::getFromPointer(expected.MessageRange.end());\n-    \n-    llvm::SMFixIt fixIt(llvm::SMRange{ StartLoc, EndLoc }, I->getMessage());\n-    addError(expected.MessageRange.begin(), \"incorrect message found\", fixIt);\n+\n+    if (I->getMessage().find(expected.MessageStr) == StringRef::npos) {\n+      auto StartLoc = SMLoc::getFromPointer(expected.MessageRange.begin());\n+      auto EndLoc = SMLoc::getFromPointer(expected.MessageRange.end());\n+\n+      llvm::SMFixIt fixIt(llvm::SMRange{StartLoc, EndLoc}, I->getMessage());\n+      addError(expected.MessageRange.begin(), \"incorrect message found\", fixIt);\n+    } else {\n+      // The difference must be only in the column\n+      addError(expected.MessageRange.begin(),\n+               llvm::formatv(\"message found at column {0} but was expected to \"\n+                             \"appear at column {1}\",\n+                             I->getColumnNo() + 1, *expected.ColumnNo));\n+    }\n     CapturedDiagnostics.erase(I);\n     ExpectedDiagnostics.erase(ExpectedDiagnostics.begin()+i);\n   }"
                    }
                ]
            },
            {
                "date": "2019-08-25T22:46:34Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/486c7b883d0e37967821eb940938faea145f1374",
                "changes": [
                    {
                        "filename": "docs/Diagnostics.md",
                        "code": "@@ -97,7 +97,7 @@ Most diagnostics have no reason to change behavior under editor mode. An example\n \n - `%0`, `%1`, etc - Formats the specified diagnostic argument based on its type.\n \n-- `%select{a|b|c}0` - Chooses from a list of alternatives, separated by vertical bars, based on the value of the given argument. In this example, a value of 2 in diagnostic argument 0 would result in \"c\" being output.\n+- `%select{a|b|c}0` - Chooses from a list of alternatives, separated by vertical bars, based on the value of the given argument. In this example, a value of 2 in diagnostic argument 0 would result in \"c\" being output. The argument to the %select may be an integer, enum, or StringRef. If it's a StringRef, the specifier acts as an emptiness check.\n \n - `%s0` - Produces an \"s\" if the given argument is anything other than 1, as meant for an English plural. This isn't particularly localizable without a more general `%plural` form, but most diagnostics try to avoid cases where a plural/singular distinction would be necessary in the first place.\n "
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -2223,10 +2223,8 @@ ERROR(multiple_override,none,\n NOTE(multiple_override_prev,none,\n      \"%0 previously overridden here\", (DeclName))\n \n-ERROR(override_unavailable,none,\n-      \"cannot override %0 which has been marked unavailable\", (DeclBaseName))\n-ERROR(override_unavailable_msg, none,\n-      \"cannot override %0 which has been marked unavailable: %1\",\n+ERROR(override_unavailable, none,\n+      \"cannot override %0 which has been marked unavailable%select{|: %1}1\",\n       (DeclBaseName, StringRef))\n \n ERROR(override_less_available,none,\n@@ -4118,27 +4116,16 @@ ERROR(dynamic_replacement_replaced_constructor_is_not_convenience, none,\n \n ERROR(availability_decl_unavailable, none,\n       \"%select{getter for |setter for |}0%1 is unavailable\"\n-      \"%select{ in %3|}2\",\n-      (unsigned, DeclName, bool, StringRef))\n+      \"%select{ in %3|}2%select{|: %4}4\",\n+      (unsigned, DeclName, bool, StringRef, StringRef))\n \n #define REPLACEMENT_DECL_KIND_SELECT \"select{| instance method| property}\"\n ERROR(availability_decl_unavailable_rename, none,\n       \"%select{getter for |setter for |}0%1 has been \"\n       \"%select{renamed to|replaced by}2%\" REPLACEMENT_DECL_KIND_SELECT \"3 \"\n-      \"'%4'\",\n-      (unsigned, DeclName, bool, unsigned, StringRef))\n-\n-ERROR(availability_decl_unavailable_rename_msg, none,\n-      \"%select{getter for |setter for |}0%1 has been \"\n-      \"%select{renamed to|replaced by}2%\" REPLACEMENT_DECL_KIND_SELECT \"3 \"\n-      \"'%4': %5\",\n+      \"'%4'%select{|: %5}5\",\n       (unsigned, DeclName, bool, unsigned, StringRef, StringRef))\n \n-ERROR(availability_decl_unavailable_msg, none,\n-      \"%select{getter for |setter for |}0%1 is unavailable\"\n-      \"%select{ in %3|}2: %4\",\n-      (unsigned, DeclName, bool, StringRef, StringRef))\n-\n NOTE(availability_marked_unavailable, none,\n      \"%select{getter for |setter for |}0%1 has been explicitly marked \"\n      \"unavailable here\", (unsigned, DeclName))\n@@ -4153,12 +4140,7 @@ NOTE(availability_obsoleted, none,\n \n WARNING(availability_deprecated, none,\n         \"%select{getter for |setter for |}0%1 %select{is|%select{is|was}4}2 \"\n-        \"deprecated%select{| in %3%select{| %5}4}2\",\n-        (unsigned, DeclName, bool, StringRef, bool, llvm::VersionTuple))\n-\n-WARNING(availability_deprecated_msg, none,\n-        \"%select{getter for |setter for |}0%1 %select{is|%select{is|was}4}2 \"\n-        \"deprecated%select{| in %3%select{| %5}4}2: %6\",\n+        \"deprecated%select{| in %3%select{| %5}4}2%select{|: %6}6\",\n         (unsigned, DeclName, bool, StringRef, bool, llvm::VersionTuple,\n          StringRef))\n "
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -449,8 +449,14 @@ static void formatDiagnosticArgument(StringRef Modifier,\n     break;\n \n   case DiagnosticArgumentKind::String:\n-    assert(Modifier.empty() && \"Improper modifier for string argument\");\n-    Out << Arg.getAsString();\n+    if (Modifier == \"select\") {\n+      formatSelectionArgument(ModifierArguments, Args,\n+                              Arg.getAsString().empty() ? 0 : 1, FormatOpts,\n+                              Out);\n+    } else {\n+      assert(Modifier.empty() && \"Improper modifier for string argument\");\n+      Out << Arg.getAsString();\n+    }\n     break;\n \n   case DiagnosticArgumentKind::Identifier:"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckAvailability.cpp",
                        "code": "@@ -1955,8 +1955,9 @@ void TypeChecker::diagnoseIfDeprecated(SourceRange ReferenceRange,\n   if (Attr->Message.empty() && Attr->Rename.empty()) {\n     diagnose(ReferenceRange.Start, diag::availability_deprecated,\n              RawAccessorKind, Name, Attr->hasPlatform(), Platform,\n-             Attr->Deprecated.hasValue(), DeprecatedVersion)\n-      .highlight(Attr->getRange());\n+             Attr->Deprecated.hasValue(), DeprecatedVersion,\n+             /*message*/ StringRef())\n+        .highlight(Attr->getRange());\n     return;\n   }\n \n@@ -1967,11 +1968,11 @@ void TypeChecker::diagnoseIfDeprecated(SourceRange ReferenceRange,\n \n   if (!Attr->Message.empty()) {\n     EncodedDiagnosticMessage EncodedMessage(Attr->Message);\n-    diagnose(ReferenceRange.Start, diag::availability_deprecated_msg,\n+    diagnose(ReferenceRange.Start, diag::availability_deprecated,\n              RawAccessorKind, Name, Attr->hasPlatform(), Platform,\n              Attr->Deprecated.hasValue(), DeprecatedVersion,\n              EncodedMessage.Message)\n-      .highlight(Attr->getRange());\n+        .highlight(Attr->getRange());\n   } else {\n     unsigned rawReplaceKind = static_cast<unsigned>(\n         replacementDeclKind.getValueOr(ReplacementDeclKind::None));\n@@ -1998,12 +1999,9 @@ void swift::diagnoseUnavailableOverride(ValueDecl *override,\n   ASTContext &ctx = override->getASTContext();\n   auto &diags = ctx.Diags;\n   if (attr->Rename.empty()) {\n-    if (attr->Message.empty())\n-      diags.diagnose(override, diag::override_unavailable,\n-                     override->getBaseName());\n-    else\n-      diags.diagnose(override, diag::override_unavailable_msg,\n-                     override->getBaseName(), attr->Message);\n+    EncodedDiagnosticMessage EncodedMessage(attr->Message);\n+    diags.diagnose(override, diag::override_unavailable,\n+                   override->getBaseName(), EncodedMessage.Message);\n \n     DeclName name;\n     unsigned rawAccessorKind;\n@@ -2185,22 +2183,12 @@ bool swift::diagnoseExplicitUnavailability(\n     unsigned rawReplaceKind = static_cast<unsigned>(\n         replaceKind.getValueOr(ReplacementDeclKind::None));\n     StringRef newName = replaceKind ? newNameBuf.str() : Attr->Rename;\n-\n-    if (Attr->Message.empty()) {\n-      auto diag = diags.diagnose(Loc,\n-                                 diag::availability_decl_unavailable_rename,\n-                                 RawAccessorKind, Name,\n-                                 replaceKind.hasValue(),\n-                                 rawReplaceKind, newName);\n-      attachRenameFixIts(diag);\n-    } else {\n       EncodedDiagnosticMessage EncodedMessage(Attr->Message);\n       auto diag =\n-        diags.diagnose(Loc, diag::availability_decl_unavailable_rename_msg,\n-                       RawAccessorKind, Name, replaceKind.hasValue(),\n-                       rawReplaceKind, newName, EncodedMessage.Message);\n+          diags.diagnose(Loc, diag::availability_decl_unavailable_rename,\n+                         RawAccessorKind, Name, replaceKind.hasValue(),\n+                         rawReplaceKind, newName, EncodedMessage.Message);\n       attachRenameFixIts(diag);\n-    }\n   } else if (isSubscriptReturningString(D, ctx)) {\n     diags.diagnose(Loc, diag::availabilty_string_subscript_migration)\n       .highlight(R)\n@@ -2209,16 +2197,12 @@ bool swift::diagnoseExplicitUnavailability(\n \n     // Skip the note emitted below.\n     return true;\n-  } else if (Attr->Message.empty()) {\n-    diags.diagnose(Loc, diag::availability_decl_unavailable,\n-                   RawAccessorKind, Name, platform.empty(), platform)\n-      .highlight(R);\n   } else {\n     EncodedDiagnosticMessage EncodedMessage(Attr->Message);\n-    diags.diagnose(Loc, diag::availability_decl_unavailable_msg,\n-                   RawAccessorKind, Name, platform.empty(), platform,\n-                   EncodedMessage.Message)\n-      .highlight(R);\n+    diags\n+        .diagnose(Loc, diag::availability_decl_unavailable, RawAccessorKind,\n+                  Name, platform.empty(), platform, EncodedMessage.Message)\n+        .highlight(R);\n   }\n \n   switch (Attr->getVersionAvailability(ctx)) {\n@@ -2695,7 +2679,7 @@ AvailabilityWalker::diagnoseIncDecRemoval(const ValueDecl *D, SourceRange R,\n     std::tie(RawAccessorKind, Name) = getAccessorKindAndNameForDiagnostics(D);\n \n     // If we emit a deprecation diagnostic, produce a fixit hint as well.\n-    auto diag = TC.diagnose(R.Start, diag::availability_decl_unavailable_msg,\n+    auto diag = TC.diagnose(R.Start, diag::availability_decl_unavailable,\n                             RawAccessorKind, Name, true, \"\",\n                             \"it has been removed in Swift 3\");\n     if (isa<PrefixUnaryExpr>(call)) {\n@@ -2746,9 +2730,9 @@ AvailabilityWalker::diagnoseMemoryLayoutMigration(const ValueDecl *D,\n   std::tie(RawAccessorKind, Name) = getAccessorKindAndNameForDiagnostics(D);\n \n   EncodedDiagnosticMessage EncodedMessage(Attr->Message);\n-  auto diag = TC.diagnose(R.Start, diag::availability_decl_unavailable_msg,\n-                          RawAccessorKind, Name, true, \"\",\n-                          EncodedMessage.Message);\n+  auto diag =\n+      TC.diagnose(R.Start, diag::availability_decl_unavailable, RawAccessorKind,\n+                  Name, true, \"\", EncodedMessage.Message);\n   diag.highlight(R);\n \n   auto subject = args->getSubExpr();"
                    },
                    {
                        "filename": "lib/Sema/TypeCheckPattern.cpp",
                        "code": "@@ -1414,11 +1414,11 @@ bool TypeChecker::coercePatternToType(Pattern *&P, TypeResolution resolution,\n                 EEP->getName().str() == \"Some\") {\n               SmallString<4> Rename;\n               camel_case::toLowercaseWord(EEP->getName().str(), Rename);\n-              diagnose(EEP->getLoc(),\n-                       diag::availability_decl_unavailable_rename,\n-                       /*\"getter\" prefix*/2, EEP->getName(), /*replaced*/false,\n-                       /*special kind*/0, Rename.str())\n-                .fixItReplace(EEP->getLoc(), Rename.str());\n+              diagnose(\n+                  EEP->getLoc(), diag::availability_decl_unavailable_rename,\n+                  /*\"getter\" prefix*/ 2, EEP->getName(), /*replaced*/ false,\n+                  /*special kind*/ 0, Rename.str(), /*message*/ StringRef())\n+                  .fixItReplace(EEP->getLoc(), Rename.str());\n \n               return true;\n             }"
                    }
                ]
            },
            {
                "date": "2019-08-12T21:57:15Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/2802ad515d1ac4e484683ac17459bb7939bdb770",
                "changes": [
                    {
                        "filename": "include/swift/AST/NameLookupTypeIDZone.def",
                        "code": "@@ -21,4 +21,4 @@ SWIFT_TYPEID(ExtendedNominalRequest)\n SWIFT_TYPEID(SelfBoundsFromWhereClauseRequest)\n SWIFT_TYPEID(TypeDeclsFromWhereClauseRequest)\n SWIFT_TYPEID(CustomAttrNominalRequest)\n-SWIFT_TYPEID(GetDestructorRequest)\n\\ No newline at end of file\n+SWIFT_TYPEID(GetDestructorRequest)"
                    },
                    {
                        "filename": "include/swift/Basic/CTypeIDZone.def",
                        "code": "@@ -39,4 +39,4 @@ SWIFT_TYPEID_TEMPLATE1_NAMED(std::vector, Vector, typename T, T)\n \n // LLVM ADT types.\n SWIFT_TYPEID_TEMPLATE1_NAMED(llvm::TinyPtrVector, TinyPtrVector, typename T, T)\n-SWIFT_TYPEID_TEMPLATE1_NAMED(llvm::ArrayRef, ArrayRef, typename T, T)\n\\ No newline at end of file\n+SWIFT_TYPEID_TEMPLATE1_NAMED(llvm::ArrayRef, ArrayRef, typename T, T)"
                    }
                ]
            },
            {
                "date": "2019-08-04T02:11:26Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/e7a1a1cc3d0222f2fb8090db0c4fd20e93ca13db",
                "changes": [
                    {
                        "filename": "docs/DebuggingTheCompiler.rst",
                        "code": "@@ -86,6 +86,14 @@ diagnostic engine to assert on the first error/warning:\n These allow one to dump a stack trace of where the diagnostic is being emitted\n (if run without a debugger) or drop into the debugger if a debugger is attached.\n \n+Finding Diagnostic Names\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+Some diagnostics rely heavily on format string arguments, so it can be difficult\n+to find their implementation by searching for parts of the emitted message in\n+the codebase. To print the corresponding diagnostic name at the end of each\n+emitted message, use the ``-Xfrontend -debug-diagnostic-names`` argument.\n+\n Debugging the Type Checker\n --------------------------\n "
                    },
                    {
                        "filename": "include/swift/AST/DiagnosticEngine.h",
                        "code": "@@ -583,6 +583,9 @@ namespace swift {\n     /// input being compiled.\n     /// May be invalid.\n     SourceLoc bufferIndirectlyCausingDiagnostic;\n+    \n+    /// Print diagnostic names after their messages\n+    bool printDiagnosticNames = false;\n \n     friend class InFlightDiagnostic;\n     friend class DiagnosticTransaction;\n@@ -618,6 +621,14 @@ namespace swift {\n       return state.getWarningsAsErrors();\n     }\n \n+    /// Whether to print diagnostic names after their messages\n+    void setPrintDiagnosticNames(bool val) {\n+      printDiagnosticNames = val;\n+    }\n+    bool getPrintDiagnosticNames() const {\n+      return printDiagnosticNames;\n+    }\n+\n     void ignoreDiagnostic(DiagID id) {\n       state.setDiagnosticBehavior(id, DiagnosticState::Behavior::Ignore);\n     }\n@@ -826,7 +837,8 @@ namespace swift {\n     void emitTentativeDiagnostics();\n \n   public:\n-    static const char *diagnosticStringFor(const DiagID id);\n+    static const char *diagnosticStringFor(const DiagID id,\n+                                           bool printDiagnosticName);\n \n     /// If there is no clear .dia file for a diagnostic, put it in the one\n     /// corresponding to the SourceLoc given here."
                    },
                    {
                        "filename": "include/swift/Basic/DiagnosticOptions.h",
                        "code": "@@ -52,6 +52,9 @@ class DiagnosticOptions {\n   /// Treat all warnings as errors\n   bool WarningsAsErrors = false;\n \n+  // When printing diagnostics, include the diagnostic name at the end\n+  bool PrintDiagnosticNames = false;\n+\n   /// Return a hash code of any components from these options that should\n   /// contribute to a Swift Bridging PCH hash.\n   llvm::hash_code getPCHHashComponents() const {"
                    },
                    {
                        "filename": "include/swift/Option/Options.td",
                        "code": "@@ -306,6 +306,9 @@ def color_diagnostics : Flag<[\"-\"], \"color-diagnostics\">,\n def no_color_diagnostics : Flag<[\"-\"], \"no-color-diagnostics\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild]>,\n   HelpText<\"Do not print diagnostics in color\">;\n+def debug_diagnostic_names : Flag<[\"-\"], \"debug-diagnostic-names\">,\n+  Flags<[FrontendOption, DoesNotAffectIncrementalBuild, HelpHidden]>,\n+  HelpText<\"Include diagnostic names when printing\">;\n \n def module_cache_path : Separate<[\"-\"], \"module-cache-path\">,\n   Flags<[FrontendOption, DoesNotAffectIncrementalBuild, ArgumentIsPath]>,"
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -99,6 +99,15 @@ static constexpr const char * const diagnosticStrings[] = {\n     \"<not a diagnostic>\",\n };\n \n+static constexpr const char *const debugDiagnosticStrings[] = {\n+#define ERROR(ID, Options, Text, Signature) Text \" [\" #ID \"]\",\n+#define WARNING(ID, Options, Text, Signature) Text \" [\" #ID \"]\",\n+#define NOTE(ID, Options, Text, Signature) Text \" [\" #ID \"]\",\n+#define REMARK(ID, Options, Text, Signature) Text \" [\" #ID \"]\",\n+#include \"swift/AST/DiagnosticsAll.def\"\n+    \"<not a diagnostic>\",\n+};\n+\n DiagnosticState::DiagnosticState() {\n   // Initialize our per-diagnostic state to default\n   perDiagnosticBehavior.resize(LocalDiagID::NumDiags, Behavior::Unspecified);\n@@ -893,14 +902,18 @@ void DiagnosticEngine::emitDiagnostic(const Diagnostic &diagnostic) {\n   Info.Ranges = diagnostic.getRanges();\n   Info.FixIts = diagnostic.getFixIts();\n   for (auto &Consumer : Consumers) {\n-    Consumer->handleDiagnostic(SourceMgr, loc, toDiagnosticKind(behavior),\n-                               diagnosticStringFor(Info.ID),\n-                               diagnostic.getArgs(), Info,\n-                               getDefaultDiagnosticLoc());\n+    Consumer->handleDiagnostic(\n+        SourceMgr, loc, toDiagnosticKind(behavior),\n+        diagnosticStringFor(Info.ID, getPrintDiagnosticNames()),\n+        diagnostic.getArgs(), Info, getDefaultDiagnosticLoc());\n   }\n }\n \n-const char *DiagnosticEngine::diagnosticStringFor(const DiagID id) {\n+const char *DiagnosticEngine::diagnosticStringFor(const DiagID id,\n+                                                  bool printDiagnosticName) {\n+  if (printDiagnosticName) {\n+    return debugDiagnosticStrings[(unsigned)id];\n+  }\n   return diagnosticStrings[(unsigned)id];\n }\n "
                    },
                    {
                        "filename": "lib/Driver/ToolChains.cpp",
                        "code": "@@ -233,6 +233,7 @@ static void addCommonFrontendArgs(const ToolChain &TC, const OutputInfo &OI,\n                        options::OPT_experimental_dependency_include_intrafile);\n   inputArgs.AddLastArg(arguments, options::OPT_package_description_version);\n   inputArgs.AddLastArg(arguments, options::OPT_serialize_diagnostics_path);\n+  inputArgs.AddLastArg(arguments, options::OPT_debug_diagnostic_names);\n   inputArgs.AddLastArg(arguments, options::OPT_enable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_astscope_lookup);\n   inputArgs.AddLastArg(arguments, options::OPT_disable_parser_lookup);"
                    },
                    {
                        "filename": "lib/Frontend/CompilerInvocation.cpp",
                        "code": "@@ -669,6 +669,7 @@ static bool ParseDiagnosticArgs(DiagnosticOptions &Opts, ArgList &Args,\n   Opts.FixitCodeForAllDiagnostics |= Args.hasArg(OPT_fixit_all);\n   Opts.SuppressWarnings |= Args.hasArg(OPT_suppress_warnings);\n   Opts.WarningsAsErrors |= Args.hasArg(OPT_warnings_as_errors);\n+  Opts.PrintDiagnosticNames |= Args.hasArg(OPT_debug_diagnostic_names);\n \n   assert(!(Opts.WarningsAsErrors && Opts.SuppressWarnings) &&\n          \"conflicting arguments; should have been caught by driver\");"
                    },
                    {
                        "filename": "lib/Frontend/Frontend.cpp",
                        "code": "@@ -305,6 +305,9 @@ void CompilerInstance::setUpDiagnosticOptions() {\n   if (Invocation.getDiagnosticOptions().WarningsAsErrors) {\n     Diagnostics.setWarningsAsErrors(true);\n   }\n+  if (Invocation.getDiagnosticOptions().PrintDiagnosticNames) {\n+    Diagnostics.setPrintDiagnosticNames(true);\n+  }\n }\n \n bool CompilerInstance::setUpModuleLoaders() {"
                    },
                    {
                        "filename": "test/Frontend/debug-diagnostic-names.swift",
                        "code": "@@ -0,0 +1,23 @@\n+// RUN: not %target-swift-frontend -debug-diagnostic-names -typecheck %s 2>&1 | %FileCheck %s --check-prefix=CHECK_NAMES\n+// RUN: not %target-swift-frontend -typecheck %s 2>&1 | %FileCheck %s --check-prefix=CHECK_NONAMES\n+\n+let x =\n+// CHECK_NAMES: error: expected initial value after '=' [expected_init_value]{{$}}\n+// CHECK_NONAMES: error: expected initial value after '='{{$}}\n+\n+guard let y = 0 else {}\n+// CHECK_NAMES: error: initializer for conditional binding must have Optional type, not 'Int' [condition_optional_element_pattern_not_valid_type]{{$}}\n+// CHECK_NONAMES: error: initializer for conditional binding must have Optional type, not 'Int'{{$}}\n+\n+let z: Double = \"\"\n+// CHECK_NAMES: error: cannot convert value of type 'String' to specified type 'Double' [cannot_convert_initializer_value]{{$}}\n+// CHECK_NONAMES: error: cannot convert value of type 'String' to specified type 'Double'{{$}}\n+\n+func foo() -> Int {\n+  return\n+  42\n+}\n+// CHECK_NAMES: warning: expression following 'return' is treated as an argument of the 'return' [unindented_code_after_return]{{$}}\n+// CHECK_NAMES: note: indent the expression to silence this warning [indent_expression_to_silence]{{$}}\n+// CHECK_NONAMES: warning: expression following 'return' is treated as an argument of the 'return'{{$}}\n+// CHECK_NONAMES: note: indent the expression to silence this warning{{$}}"
                    }
                ]
            },
            {
                "date": "2019-08-05T00:57:54Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/686e4a600cd1c076b2a6b698adbdd54247ce6617",
                "changes": [
                    {
                        "filename": "lib/Parse/ParseExpr.cpp",
                        "code": "@@ -1855,11 +1855,11 @@ parseStringSegments(SmallVectorImpl<Lexer::StringSegment> &Segments,\n       TokReceiver->registerTokenKindChange(Tok.getLoc(),\n                                            tok::string_interpolation_anchor);\n \n-      auto callee = new (Context) UnresolvedDotExpr(InterpolationVarRef,\n-                                                    /*dotloc=*/BackSlashLoc,\n-                                                    appendInterpolation,\n-                                                    /*nameloc=*/DeclNameLoc(),\n-                                                    /*Implicit=*/true);\n+      auto callee = new (Context)\n+          UnresolvedDotExpr(InterpolationVarRef,\n+                            /*dotloc=*/BackSlashLoc, appendInterpolation,\n+                            /*nameloc=*/DeclNameLoc(Segment.Loc),\n+                            /*Implicit=*/true);\n       auto S = parseExprCallSuffix(makeParserResult(callee), true);\n \n       // If we stopped parsing the expression before the expression segment is"
                    },
                    {
                        "filename": "test/Sema/diag_deprecated_string_interpolation.swift",
                        "code": "@@ -0,0 +1,24 @@\n+// RUN: %target-swift-frontend -swift-version 5 -typecheck %s 2>&1 | %FileCheck %s\n+\n+extension DefaultStringInterpolation {\n+    @available(*, deprecated) func appendInterpolation(deprecated: Int) {}\n+}\n+\n+// Make sure diagnostics emitted via string interpolations have a reasonable source location\n+\n+_ = \"\\(deprecated: 42)\"\n+// CHECK: [[@LINE-1]]:7: warning: 'appendInterpolation(deprecated:)' is deprecated\n+\n+_ = \"hello, world\\(deprecated: 42)!!!\"\n+// CHECK: [[@LINE-1]]:19: warning: 'appendInterpolation(deprecated:)' is deprecated\n+\n+_ = \"\\(42)\\(deprecated: 42)test\\(deprecated: 42)\"\n+// CHECK: [[@LINE-1]]:12: warning: 'appendInterpolation(deprecated:)' is deprecated\n+// CHECK: [[@LINE-2]]:33: warning: 'appendInterpolation(deprecated:)' is deprecated\n+\n+_ = \"\"\"\n+This is a multiline literal with a deprecated interpolation:\n+\n+\\(deprecated: 42)\n+\"\"\"\n+// CHECK: [[@LINE-2]]:2: warning: 'appendInterpolation(deprecated:)' is deprecated"
                    }
                ]
            },
            {
                "date": "2019-06-30T03:45:27Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/89eaa1e612894b1c23b98303b0a1c9277afdae83",
                "changes": [
                    {
                        "filename": "include/swift/AST/Types.h",
                        "code": "@@ -457,6 +457,10 @@ class alignas(1 << TypeAlignInBits) TypeBase {\n   /// types, optionals, etc.\n   TypeBase *reconstituteSugar(bool Recursive);\n \n+  // If this type is a syntax sugar type, desugar it. Also desugar any nested\n+  // syntax sugar types.\n+  TypeBase *getWithoutSyntaxSugar();\n+\n   /// getASTContext - Return the ASTContext that this type belongs to.\n   ASTContext &getASTContext() {\n     // If this type is canonical, it has the ASTContext in it."
                    },
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -468,6 +468,13 @@ static void formatDiagnosticArgument(StringRef Modifier,\n     \n     // Strip extraneous parentheses; they add no value.\n     auto type = Arg.getAsType()->getWithoutParens();\n+\n+    // If a type has an unresolved type, print it with syntax sugar removed for\n+    // clarity. For example, print `Array<_>` instead of `[_]`.\n+    if (type->hasUnresolvedType()) {\n+      type = type->getWithoutSyntaxSugar();\n+    }\n+\n     bool isAmbiguous = typeSpellingIsAmbiguous(type, Args);\n \n     if (isAmbiguous && isa<OpaqueTypeArchetypeType>(type.getPointer())) {"
                    },
                    {
                        "filename": "lib/AST/Type.cpp",
                        "code": "@@ -1252,6 +1252,15 @@ TypeBase *TypeBase::reconstituteSugar(bool Recursive) {\n     return Func(this).getPointer();\n }\n \n+TypeBase *TypeBase::getWithoutSyntaxSugar() {\n+  auto Func = [](Type Ty) -> Type {\n+    if (auto *syntaxSugarType = dyn_cast<SyntaxSugarType>(Ty.getPointer()))\n+      return syntaxSugarType->getSinglyDesugaredType()->getWithoutSyntaxSugar();\n+    return Ty;\n+  };\n+  return Type(this).transform(Func).getPointer();\n+}\n+\n #define TYPE(Id, Parent)\n #define SUGARED_TYPE(Id, Parent) \\\n   static_assert(std::is_base_of<SugarType, Id##Type>::value, \"Sugar mismatch\");"
                    },
                    {
                        "filename": "test/Constraints/diagnostics.swift",
                        "code": "@@ -424,7 +424,7 @@ enum Color {\n }\n \n // FIXME: This used to be better: \"'map' produces '[T]', not the expected contextual result type '(Int, Color)'\"\n-let _: (Int, Color) = [1,2].map({ ($0, .Unknown(\"\")) }) // expected-error {{expression type '((Int) throws -> _) throws -> [_]' is ambiguous without more context}}\n+let _: (Int, Color) = [1,2].map({ ($0, .Unknown(\"\")) }) // expected-error {{expression type '((Int) throws -> _) throws -> Array<_>' is ambiguous without more context}}\n \n let _: [(Int, Color)] = [1,2].map({ ($0, .Unknown(\"\")) })// expected-error {{missing argument label 'description:' in call}}\n \n@@ -1233,3 +1233,24 @@ let baz: (Swift.Error) = Error() //expected-error {{value of type 'diagnostics.E\n let baz2: Swift.Error = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n let baz3: (Swift.Error) = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n let baz4: ((Swift.Error)) = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n+\n+// SyntaxSugarTypes with unresolved types\n+func takesGenericArray<T>(_ x: [T]) {}\n+takesGenericArray(1) // expected-error {{cannot convert value of type 'Int' to expected argument type 'Array<_>'}}\n+func takesNestedGenericArray<T>(_ x: [[T]]) {}\n+takesNestedGenericArray(1) // expected-error {{cannot convert value of type 'Int' to expected argument type 'Array<Array<_>>'}}\n+func takesSetOfGenericArrays<T>(_ x: Set<[T]>) {}\n+takesSetOfGenericArrays(1) // expected-error {{cannot convert value of type 'Int' to expected argument type 'Set<Array<_>>'}}\n+func takesArrayOfSetOfGenericArrays<T>(_ x: [Set<[T]>]) {}\n+takesArrayOfSetOfGenericArrays(1) // expected-error {{cannot convert value of type 'Int' to expected argument type 'Array<Set<Array<_>>>'}}\n+func takesArrayOfGenericOptionals<T>(_ x: [T?]) {}\n+takesArrayOfGenericOptionals(1) // expected-error {{cannot convert value of type 'Int' to expected argument type 'Array<Optional<_>>'}}\n+func takesGenericDictionary<T, U>(_ x: [T : U]) {}\n+takesGenericDictionary(true) // expected-error {{cannot convert value of type 'Bool' to expected argument type 'Dictionary<_, _>'}}\n+typealias Z = Int\n+func takesGenericDictionaryWithTypealias<T>(_ x: [T : Z]) {}\n+takesGenericDictionaryWithTypealias(true) // expected-error {{cannot convert value of type 'Bool' to expected argument type 'Dictionary<_, Z>'}}\n+func takesGenericFunction<T>(_ x: ([T]) -> Void) {}\n+takesGenericFunction(true) // expected-error {{cannot convert value of type 'Bool' to expected argument type '(Array<_>) -> Void'}}\n+func takesTuple<T>(_ x: ([T], [T])) {}\n+takesTuple(true) // expected-error {{cannot convert value of type 'Bool' to expected argument type '(Array<_>, Array<_>)'}}"
                    },
                    {
                        "filename": "test/expr/closure/anonymous.swift",
                        "code": "@@ -35,7 +35,7 @@ func variadic() {\n   // expected-error@-1 {{cannot convert value of type '([Int]) -> ()' to specified type '(Int...) -> ()'}}\n \n   takesVariadicGeneric({takesIntArray($0)})\n-  // expected-error@-1 {{cannot convert value of type '[_]' to expected argument type '[Int]'}}\n+  // expected-error@-1 {{cannot convert value of type 'Array<_>' to expected argument type '[Int]'}}\n \n   takesVariadicGeneric({let _: [Int] = $0})\n   // expected-error@-1 {{cannot convert value of type '(_) -> ()' to expected argument type '(_...) -> ()'}}"
                    }
                ]
            },
            {
                "date": "2019-06-16T23:09:51Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/9d07d06886c386670cd89985a57ab98754af6ac3",
                "changes": [
                    {
                        "filename": "lib/AST/DiagnosticEngine.cpp",
                        "code": "@@ -385,6 +385,22 @@ static bool shouldShowAKA(Type type, StringRef typeName) {\n   return true;\n }\n \n+/// If a type is part of an argument list which includes another, distinct type\n+/// with the same string representation, it should be qualified during\n+/// formatting.\n+static bool shouldQualifyType(Type type, ArrayRef<DiagnosticArgument> Args) {\n+  for (auto arg : Args) {\n+    if (arg.getKind() == DiagnosticArgumentKind::Type) {\n+      auto argType = arg.getAsType();\n+      if (argType && !argType->isEqual(type) &&\n+          argType->getWithoutParens().getString() == type.getString()) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n /// Format a single diagnostic argument and write it to the given\n /// stream.\n static void formatDiagnosticArgument(StringRef Modifier, \n@@ -451,7 +467,10 @@ static void formatDiagnosticArgument(StringRef Modifier,\n     \n     // Strip extraneous parentheses; they add no value.\n     auto type = Arg.getAsType()->getWithoutParens();\n-    std::string typeName = type->getString();\n+\n+    auto printOptions = PrintOptions();\n+    printOptions.FullyQualifiedTypes = shouldQualifyType(type, Args);\n+    std::string typeName = type->getString(printOptions);\n \n     if (shouldShowAKA(type, typeName)) {\n       llvm::SmallString<256> AkaText;"
                    },
                    {
                        "filename": "lib/AST/Type.cpp",
                        "code": "@@ -1306,7 +1306,9 @@ Type SugarType::getSinglyDesugaredTypeSlow() {\n     implDecl = Context->getDictionaryDecl();\n     break;\n   }\n-  assert(implDecl && \"Type has not been set yet\");\n+  if (!implDecl) {\n+    return ErrorType::get(*Context);\n+  }\n \n   Bits.SugarType.HasCachedType = true;\n   if (auto Ty = dyn_cast<UnarySyntaxSugarType>(this)) {"
                    },
                    {
                        "filename": "test/Constraints/diagnostics.swift",
                        "code": "@@ -1223,3 +1223,13 @@ func unresolvedTypeExistential() -> Bool {\n \n func rdar43525641(_ a: Int, _ b: Int = 0, c: Int = 0, _ d: Int) {}\n rdar43525641(1, c: 2, 3) // Ok\n+\n+struct Array {}\n+let foo: Swift.Array = Array() // expected-error {{cannot convert value of type 'diagnostics.Array' to specified type 'Swift.Array'}}\n+\n+struct Error {}\n+let bar: Swift.Error = Error() //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n+let baz: (Swift.Error) = Error() //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n+let baz2: Swift.Error = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n+let baz3: (Swift.Error) = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}\n+let baz4: ((Swift.Error)) = (Error()) //expected-error {{value of type 'diagnostics.Error' does not conform to specified type 'Swift.Error'}}"
                    },
                    {
                        "filename": "test/TypeCoercion/integer_literals.swift",
                        "code": "@@ -63,6 +63,6 @@ func chaining() {\n func memberaccess() {\n   Int32(5._value) // expected-warning{{unused}}\n   // This diagnostic is actually better than it looks, because the inner type is Builtin.Int32, not actually Int32.\n-  let x : Int32 = 7._value // expected-error{{cannot convert value of type 'Int32' to specified type 'Int32'}}\n+  let x : Int32 = 7._value // expected-error{{cannot convert value of type 'Builtin.Int32' to specified type 'Swift.Int32'}}\n   _ = x\n }"
                    },
                    {
                        "filename": "test/type/opaque.swift",
                        "code": "@@ -394,6 +394,6 @@ protocol OpaqueProtocolRequirement {\n \n func testCoercionDiagnostics() {\n   var opaque = foo()\n-  opaque = bar() // expected-error {{cannot assign value of type 'some P' to type 'some P'}} {{none}}\n+  opaque = bar() // expected-error {{cannot assign value of type 'some opaque.P' to type 'some opaque.P'}} {{none}}\n   opaque = () // expected-error {{cannot assign value of type '()' to type 'some P'}} {{none}}\n }"
                    }
                ]
            },
            {
                "date": "2019-06-17T02:35:17Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/89d4e6378d18201c45ec35a1ff80b487c36400de",
                "changes": [
                    {
                        "filename": "include/swift/Parse/Parser.h",
                        "code": "@@ -1012,6 +1012,7 @@ class Parser {\n   ParserResult<VarDecl> parseDeclVarGetSet(Pattern *pattern,\n                                            ParseDeclOptions Flags,\n                                            SourceLoc StaticLoc,\n+                                           StaticSpellingKind StaticSpelling,\n                                            SourceLoc VarLoc,\n                                            bool hasInitializer,\n                                            const DeclAttributes &Attributes,"
                    },
                    {
                        "filename": "lib/Parse/ParseDecl.cpp",
                        "code": "@@ -4675,8 +4675,9 @@ static void fillInAccessorTypeErrors(Parser &P,\n /// Parse the brace-enclosed getter and setter for a variable.\n ParserResult<VarDecl>\n Parser::parseDeclVarGetSet(Pattern *pattern, ParseDeclOptions Flags,\n-                           SourceLoc StaticLoc, SourceLoc VarLoc,\n-                           bool hasInitializer,\n+                           SourceLoc StaticLoc,\n+                           StaticSpellingKind StaticSpelling,\n+                           SourceLoc VarLoc, bool hasInitializer,\n                            const DeclAttributes &Attributes,\n                            SmallVectorImpl<Decl *> &Decls) {\n   bool Invalid = false;\n@@ -4740,7 +4741,7 @@ Parser::parseDeclVarGetSet(Pattern *pattern, ParseDeclOptions Flags,\n     PatternBindingEntry entry(pattern, /*EqualLoc*/ SourceLoc(),\n                               /*Init*/ nullptr, /*InitContext*/ nullptr);\n     auto binding = PatternBindingDecl::create(Context, StaticLoc,\n-                                              StaticSpellingKind::None,\n+                                              StaticSpelling,\n                                               VarLoc, entry, CurDeclContext);\n     binding->setInvalid(true);\n     storage->setParentPatternBinding(binding);\n@@ -5362,9 +5363,9 @@ Parser::parseDeclVar(ParseDeclOptions Flags,\n     // var-get-set clause, parse the var-get-set clause.\n     if (Tok.is(tok::l_brace)) {\n       HasAccessors = true;\n-      auto boundVar = parseDeclVarGetSet(pattern, Flags, StaticLoc, VarLoc,\n-                                         PatternInit != nullptr,Attributes,\n-                                         Decls);\n+      auto boundVar =\n+          parseDeclVarGetSet(pattern, Flags, StaticLoc, StaticSpelling, VarLoc,\n+                             PatternInit != nullptr, Attributes, Decls);\n       if (boundVar.hasCodeCompletion())\n         return makeResult(makeParserCodeCompletionStatus());\n       if (PatternInit && boundVar.isNonNull() &&"
                    },
                    {
                        "filename": "test/Parse/pattern_without_variables.swift",
                        "code": "@@ -37,3 +37,8 @@ func testVarLetPattern(a : SimpleEnum) {\n   // expected-warning @+1 {{'if' condition is always true}}\n   if case let _ = \"str\" {}  // expected-warning {{'let' pattern has no effect; sub-pattern didn't bind any variables}} {{11-15=}}\n }\n+\n+class SR10903 {\n+  static var _: Int { 0 } //expected-error {{getter/setter can only be defined for a single variable}}\n+  //expected-error@-1 {{property declaration does not bind any variables}}\n+}"
                    }
                ]
            },
            {
                "date": "2019-05-25T22:21:52Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/e273d0546046af357692efec0f0b30ba2d480679",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -2518,6 +2518,12 @@ NOTE(decodable_suggest_overriding_init_here,none,\n NOTE(codable_suggest_overriding_init_here,none,\n      \"did you mean to override 'init(from:)' and 'encode(to:)'?\", ())\n \n+NOTE(missing_member_type_conformance_prevents_synthesis, none,\n+     \"%select{associated value|stored property}0 type %1 does not conform to \"\n+     \"protocol %2, preventing synthesized conformance \"\n+     \"of %3 to %2\",\n+     (unsigned, Type, Type, Type))\n+\n // Dynamic Self\n ERROR(dynamic_self_non_method,none,\n       \"%select{global|local}0 function cannot return 'Self'\", (bool))"
                    },
                    {
                        "filename": "lib/Sema/DerivedConformanceEquatableHashable.cpp",
                        "code": "@@ -32,15 +32,21 @@\n \n using namespace swift;\n \n-/// Returns true if, for every element of the given enum, it either has no\n-/// associated values or all of them conform to a protocol.\n+enum NonconformingMemberKind {\n+  AssociatedValue,\n+  StoredProperty\n+};\n+\n+/// Returns the ParamDecl for each associated value of the given enum whose type\n+/// does not conform to a protocol\n /// \\p theEnum The enum whose elements and associated values should be checked.\n /// \\p protocol The protocol being requested.\n-/// \\return True if all associated values of all elements of the enum conform.\n-static bool allAssociatedValuesConformToProtocol(DeclContext *DC,\n-                                                 EnumDecl *theEnum,\n-                                                 ProtocolDecl *protocol) {\n+/// \\return The ParamDecl of each associated value whose type does not conform.\n+static SmallVector<ParamDecl *, 3>\n+associatedValuesNotConformingToProtocol(DeclContext *DC, EnumDecl *theEnum,\n+                                        ProtocolDecl *protocol) {\n   auto lazyResolver = DC->getASTContext().getLazyResolver();\n+  SmallVector<ParamDecl *, 3> nonconformingAssociatedValues;\n   for (auto elt : theEnum->getAllElements()) {\n     if (!elt->hasInterfaceType())\n       lazyResolver->resolveDeclSignature(elt);\n@@ -53,38 +59,62 @@ static bool allAssociatedValuesConformToProtocol(DeclContext *DC,\n       auto type = param->getInterfaceType();\n       if (!TypeChecker::conformsToProtocol(DC->mapTypeIntoContext(type),\n                                            protocol, DC, None)) {\n-        return false;\n+        nonconformingAssociatedValues.push_back(param);\n       }\n     }\n   }\n-  return true;\n+  return nonconformingAssociatedValues;\n }\n \n-/// Returns true if every stored property in the given struct conforms to the\n-/// protocol (or, vacuously, if it has no stored properties).\n-/// \\p theStruct The struct whose stored properties should be checked.\n+/// Returns true if, for every element of the given enum, it either has no\n+/// associated values or all of them conform to a protocol.\n+/// \\p theEnum The enum whose elements and associated values should be checked.\n /// \\p protocol The protocol being requested.\n-/// \\return True if all stored properties of the struct conform.\n-static bool allStoredPropertiesConformToProtocol(DeclContext *DC,\n-                                                 StructDecl *theStruct,\n+/// \\return True if all associated values of all elements of the enum conform.\n+static bool allAssociatedValuesConformToProtocol(DeclContext *DC,\n+                                                 EnumDecl *theEnum,\n                                                  ProtocolDecl *protocol) {\n+  return associatedValuesNotConformingToProtocol(DC, theEnum, protocol).empty();\n+}\n+\n+/// Returns the VarDecl of each stored property in the given struct whose type\n+/// does not conform to a protocol.\n+/// \\p theStruct The struct whose stored properties should be checked.\n+/// \\p protocol The protocol being requested.\n+/// \\return The VarDecl of each stored property whose type does not conform.\n+static SmallVector<VarDecl *, 3>\n+storedPropertiesNotConformingToProtocol(DeclContext *DC, StructDecl *theStruct,\n+                                        ProtocolDecl *protocol) {\n   auto lazyResolver = DC->getASTContext().getLazyResolver();\n   auto storedProperties =\n-    theStruct->getStoredProperties(/*skipInaccessible=*/true);\n+      theStruct->getStoredProperties(/*skipInaccessible=*/true);\n+  SmallVector<VarDecl *, 3> nonconformingProperties;\n   for (auto propertyDecl : storedProperties) {\n     if (!propertyDecl->hasInterfaceType())\n       lazyResolver->resolveDeclSignature(propertyDecl);\n     if (!propertyDecl->hasInterfaceType())\n-      return false;\n+      nonconformingProperties.push_back(propertyDecl);\n \n     auto type = propertyDecl->getValueInterfaceType();\n \n-    if (!TypeChecker::conformsToProtocol(DC->mapTypeIntoContext(type),\n-                                         protocol, DC, None)) {\n-      return false;\n+    if (!TypeChecker::conformsToProtocol(DC->mapTypeIntoContext(type), protocol,\n+                                         DC, None)) {\n+      nonconformingProperties.push_back(propertyDecl);\n     }\n   }\n-  return true;\n+  return nonconformingProperties;\n+}\n+\n+/// Returns true if every stored property in the given struct conforms to the\n+/// protocol (or, vacuously, if it has no stored properties).\n+/// \\p theStruct The struct whose stored properties should be checked.\n+/// \\p protocol The protocol being requested.\n+/// \\return True if all stored properties of the struct conform.\n+static bool allStoredPropertiesConformToProtocol(DeclContext *DC,\n+                                                 StructDecl *theStruct,\n+                                                 ProtocolDecl *protocol) {\n+  return storedPropertiesNotConformingToProtocol(DC, theStruct, protocol)\n+      .empty();\n }\n \n /// Common preconditions for Equatable and Hashable.\n@@ -106,6 +136,39 @@ static bool canDeriveConformance(DeclContext *DC,\n   return false;\n }\n \n+/// Diagnose failed conformance synthesis caused by a member type not conforming\n+/// to the same protocol\n+void diagnoseFailedDerivation(DeclContext *DC, NominalTypeDecl *nominal,\n+                              ProtocolDecl *protocol) {\n+  ASTContext &ctx = DC->getASTContext();\n+\n+  if (auto *enumDecl = dyn_cast<EnumDecl>(nominal)) {\n+    auto nonconformingAssociatedTypes =\n+        associatedValuesNotConformingToProtocol(DC, enumDecl, protocol);\n+    for (auto *typeToDiagnose : nonconformingAssociatedTypes) {\n+      ctx.Diags.diagnose(\n+          typeToDiagnose->getTypeLoc().getLoc(),\n+          diag::missing_member_type_conformance_prevents_synthesis,\n+          NonconformingMemberKind::AssociatedValue,\n+          typeToDiagnose->getInterfaceType(), protocol->getDeclaredType(),\n+          nominal->getDeclaredInterfaceType());\n+    }\n+  }\n+\n+  if (auto *structDecl = dyn_cast<StructDecl>(nominal)) {\n+    auto nonconformingStoredProperties =\n+        storedPropertiesNotConformingToProtocol(DC, structDecl, protocol);\n+    for (auto *propertyToDiagnose : nonconformingStoredProperties) {\n+      ctx.Diags.diagnose(\n+          propertyToDiagnose->getLoc(),\n+          diag::missing_member_type_conformance_prevents_synthesis,\n+          NonconformingMemberKind::StoredProperty,\n+          propertyToDiagnose->getInterfaceType(), protocol->getDeclaredType(),\n+          nominal->getDeclaredInterfaceType());\n+    }\n+  }\n+}\n+\n /// Creates a named variable based on a prefix character and a numeric index.\n /// \\p prefixChar The prefix character for the variable's name.\n /// \\p index The numeric index to append to the variable's name.\n@@ -722,6 +785,13 @@ ValueDecl *DerivedConformance::deriveEquatable(ValueDecl *requirement) {\n   return nullptr;\n }\n \n+void DerivedConformance::tryDiagnoseFailedEquatableDerivation(\n+    DeclContext *DC, NominalTypeDecl *nominal) {\n+  ASTContext &ctx = DC->getASTContext();\n+  auto *equatableProto = ctx.getProtocol(KnownProtocolKind::Equatable);\n+  diagnoseFailedDerivation(DC, nominal, equatableProto);\n+}\n+\n /// Returns a new \\c CallExpr representing\n ///\n ///   hasher.combine(hashable)\n@@ -1184,6 +1254,13 @@ bool DerivedConformance::canDeriveHashable(NominalTypeDecl *type) {\n   return true;\n }\n \n+void DerivedConformance::tryDiagnoseFailedHashableDerivation(\n+    DeclContext *DC, NominalTypeDecl *nominal) {\n+  ASTContext &ctx = DC->getASTContext();\n+  auto *hashableProto = ctx.getProtocol(KnownProtocolKind::Hashable);\n+  diagnoseFailedDerivation(DC, nominal, hashableProto);\n+}\n+\n ValueDecl *DerivedConformance::deriveHashable(ValueDecl *requirement) {\n   ASTContext &C = ConformanceDecl->getASTContext();\n \n@@ -1217,6 +1294,13 @@ ValueDecl *DerivedConformance::deriveHashable(ValueDecl *requirement) {\n         ConformanceDecl->diagnose(diag::type_does_not_conform,\n                                   Nominal->getDeclaredType(),\n                                   hashableProto->getDeclaredType());\n+        // Ideally, this would be diagnosed in\n+        // ConformanceChecker::resolveWitnessViaLookup. That doesn't work for\n+        // Hashable because DerivedConformance::canDeriveHashable returns true\n+        // even if the conformance can't be derived. See the note there for\n+        // details.\n+        auto *dc = ConformanceDecl->getDeclContext();\n+        tryDiagnoseFailedHashableDerivation(dc, Nominal);\n         return nullptr;\n       }\n "
                    },
                    {
                        "filename": "lib/Sema/DerivedConformances.cpp",
                        "code": "@@ -137,6 +137,22 @@ bool DerivedConformance::derivesProtocolConformance(DeclContext *DC,\n   return false;\n }\n \n+void DerivedConformance::tryDiagnoseFailedDerivation(DeclContext *DC,\n+                                                     NominalTypeDecl *nominal,\n+                                                     ProtocolDecl *protocol) {\n+  auto knownProtocol = protocol->getKnownProtocolKind();\n+  if (!knownProtocol)\n+    return;\n+\n+  if (*knownProtocol == KnownProtocolKind::Equatable) {\n+    tryDiagnoseFailedEquatableDerivation(DC, nominal);\n+  }\n+\n+  if (*knownProtocol == KnownProtocolKind::Hashable) {\n+    tryDiagnoseFailedHashableDerivation(DC, nominal);\n+  }\n+}\n+\n ValueDecl *DerivedConformance::getDerivableRequirement(TypeChecker &tc,\n                                                        NominalTypeDecl *nominal,\n                                                        ValueDecl *requirement) {"
                    },
                    {
                        "filename": "lib/Sema/DerivedConformances.h",
                        "code": "@@ -69,6 +69,18 @@ class DerivedConformance {\n                                          NominalTypeDecl *nominal,\n                                          ProtocolDecl *protocol);\n \n+  /// Diagnose problems, if any, preventing automatic derivation of protocol\n+  /// requirements\n+  ///\n+  /// \\param nominal The nominal type for which we would like to diagnose\n+  /// derivation failures\n+  ///\n+  /// \\param protocol The protocol with requirements we would like to diagnose\n+  /// derivation failures for\n+  static void tryDiagnoseFailedDerivation(DeclContext *DC,\n+                                          NominalTypeDecl *nominal,\n+                                          ProtocolDecl *protocol);\n+\n   /// Determine the derivable requirement that would satisfy the given\n   /// requirement, if there is one.\n   ///\n@@ -128,6 +140,14 @@ class DerivedConformance {\n   /// \\returns the derived member, which will also be added to the type.\n   ValueDecl *deriveEquatable(ValueDecl *requirement);\n \n+  /// Diagnose problems, if any, preventing automatic derivation of Equatable\n+  /// requirements\n+  ///\n+  /// \\param nominal The nominal type for which we would like to diagnose\n+  /// derivation failures\n+  static void tryDiagnoseFailedEquatableDerivation(DeclContext *DC,\n+                                                   NominalTypeDecl *nominal);\n+\n   /// Determine if a Hashable requirement can be derived for a type.\n   ///\n   /// This is implemented for enums without associated values or all-Hashable\n@@ -144,6 +164,14 @@ class DerivedConformance {\n   /// \\returns the derived member, which will also be added to the type.\n   ValueDecl *deriveHashable(ValueDecl *requirement);\n \n+  /// Diagnose problems, if any, preventing automatic derivation of Hashable\n+  /// requirements\n+  ///\n+  /// \\param nominal The nominal type for which we would like to diagnose\n+  /// derivation failures\n+  static void tryDiagnoseFailedHashableDerivation(DeclContext *DC,\n+                                                  NominalTypeDecl *nominal);\n+\n   /// Derive a _BridgedNSError requirement for an @objc enum type.\n   ///\n   /// \\returns the derived member, which will also be added to the type."
                    },
                    {
                        "filename": "lib/Sema/TypeCheckProtocol.cpp",
                        "code": "@@ -3305,8 +3305,11 @@ ConformanceChecker::resolveWitnessViaLookup(ValueDecl *requirement) {\n     // Save the missing requirement for later diagnosis.\n     GlobalMissingWitnesses.insert(requirement);\n     diagnoseOrDefer(requirement, true,\n-      [requirement, matches](NormalProtocolConformance *conformance) {\n+      [requirement, matches, nominal](NormalProtocolConformance *conformance) {\n         auto dc = conformance->getDeclContext();\n+        auto *protocol = conformance->getProtocol();\n+        // Possibly diagnose reason for automatic derivation failure\n+        DerivedConformance::tryDiagnoseFailedDerivation(dc, nominal, protocol);\n         // Diagnose each of the matches.\n         for (const auto &match : matches)\n           diagnoseMatch(dc->getParentModule(), conformance, requirement, match);"
                    },
                    {
                        "filename": "test/Sema/enum_conformance_synthesis.swift",
                        "code": "@@ -147,7 +147,8 @@ func enumWithHashablePayload() {\n // Enums with non-hashable payloads don't derive conformance.\n struct NotHashable {}\n enum EnumWithNonHashablePayload: Hashable { // expected-error 2 {{does not conform}}\n-  case A(NotHashable)\n+  case A(NotHashable) //expected-note {{associated value type 'NotHashable' does not conform to protocol 'Hashable', preventing synthesized conformance of 'EnumWithNonHashablePayload' to 'Hashable'}}\n+  // expected-note@-1 {{associated value type 'NotHashable' does not conform to protocol 'Equatable', preventing synthesized conformance of 'EnumWithNonHashablePayload' to 'Equatable'}}\n }\n \n // Enums should be able to derive conformances based on the conformances of\n@@ -164,7 +165,7 @@ func genericHashable() {\n // But it should be an error if the generic argument doesn't have the necessary\n // constraints to satisfy the conditions for derivation.\n enum GenericNotHashable<T: Equatable>: Hashable { // expected-error 2 {{does not conform to protocol 'Hashable'}}\n-  case A(T)\n+  case A(T) //expected-note 2 {{associated value type 'T' does not conform to protocol 'Hashable', preventing synthesized conformance of 'GenericNotHashable<T>' to 'Hashable'}}\n   case B\n }\n func genericNotHashable() {\n@@ -228,7 +229,8 @@ extension FromOtherFile: CaseIterable {} // expected-error {{cannot be automatic\n \n // No explicit conformance and it cannot be derived.\n enum NotExplicitlyHashableAndCannotDerive {\n-  case A(NotHashable)\n+  case A(NotHashable) //expected-note {{associated value type 'NotHashable' does not conform to protocol 'Hashable', preventing synthesized conformance of 'NotExplicitlyHashableAndCannotDerive' to 'Hashable'}}\n+  // expected-note@-1 {{associated value type 'NotHashable' does not conform to protocol 'Equatable', preventing synthesized conformance of 'NotExplicitlyHashableAndCannotDerive' to 'Equatable'}}\n }\n extension NotExplicitlyHashableAndCannotDerive : Hashable {} // expected-error 2 {{does not conform}}\n extension NotExplicitlyHashableAndCannotDerive : CaseIterable {} // expected-error {{does not conform}}\n@@ -282,7 +284,7 @@ case only([Int])\n struct NotEquatable { }\n \n enum ArrayOfNotEquatables : Equatable { // expected-error{{type 'ArrayOfNotEquatables' does not conform to protocol 'Equatable'}}\n-case only([NotEquatable])\n+case only([NotEquatable]) //expected-note {{associated value type '[NotEquatable]' does not conform to protocol 'Equatable', preventing synthesized conformance of 'ArrayOfNotEquatables' to 'Equatable'}}\n }\n \n // Conditional conformances should be able to be synthesized\n@@ -294,7 +296,8 @@ extension GenericDeriveExtension: Hashable where T: Hashable {}\n \n // Incorrectly/insufficiently conditional shouldn't work\n enum BadGenericDeriveExtension<T> {\n-    case A(T)\n+    case A(T) //expected-note {{associated value type 'T' does not conform to protocol 'Hashable', preventing synthesized conformance of 'BadGenericDeriveExtension<T>' to 'Hashable'}}\n+  //expected-note@-1 {{associated value type 'T' does not conform to protocol 'Equatable', preventing synthesized conformance of 'BadGenericDeriveExtension<T>' to 'Equatable'}}\n }\n extension BadGenericDeriveExtension: Equatable {}\n // expected-error@-1 {{type 'BadGenericDeriveExtension<T>' does not conform to protocol 'Equatable'}}"
                    },
                    {
                        "filename": "test/Sema/enum_equatable_conditional.swift",
                        "code": "@@ -3,11 +3,11 @@\n struct NotEquatable { }\n \n enum WithArrayOfNotEquatables : Equatable { // expected-error{{type 'WithArrayOfNotEquatables' does not conform to protocol 'Equatable'}}\n-case only([NotEquatable])\n+  case only([NotEquatable]) // expected-note{{associated value type '[NotEquatable]' does not conform to protocol 'Equatable', preventing synthesized conformance of 'WithArrayOfNotEquatables' to 'Equatable'}}\n }\n \n enum WithArrayOfNotEquatables2<T> : Equatable { // expected-error{{type 'WithArrayOfNotEquatables2<T>' does not conform to protocol 'Equatable'}}\n-case only([T])\n+  case only([T]) // expected-note{{associated value type '[T]' does not conform to protocol 'Equatable', preventing synthesized conformance of 'WithArrayOfNotEquatables2<T>' to 'Equatable'}}\n }\n \n "
                    },
                    {
                        "filename": "test/Sema/struct_equatable_hashable.swift",
                        "code": "@@ -121,7 +121,8 @@ func structWithoutExplicitConformance() {\n // Structs with non-hashable/equatable stored properties don't derive conformance.\n struct NotHashable {}\n struct StructWithNonHashablePayload: Hashable { // expected-error 2 {{does not conform}}\n-  let a: NotHashable\n+  let a: NotHashable // expected-note {{stored property type 'NotHashable' does not conform to protocol 'Hashable', preventing synthesized conformance of 'StructWithNonHashablePayload' to 'Hashable'}}\n+  // expected-note@-1 {{stored property type 'NotHashable' does not conform to protocol 'Equatable', preventing synthesized conformance of 'StructWithNonHashablePayload' to 'Equatable'}}\n }\n \n // ...but computed properties and static properties are not considered.\n@@ -151,7 +152,7 @@ func genericHashable() {\n // But it should be an error if the generic argument doesn't have the necessary\n // constraints to satisfy the conditions for derivation.\n struct GenericNotHashable<T: Equatable>: Hashable { // expected-error 2 {{does not conform to protocol 'Hashable'}}\n-  let value: T\n+  let value: T // expected-note 2 {{stored property type 'T' does not conform to protocol 'Hashable', preventing synthesized conformance of 'GenericNotHashable<T>' to 'Hashable'}}\n }\n func genericNotHashable() {\n   if GenericNotHashable<String>(value: \"a\") == GenericNotHashable<String>(value: \"b\") { }\n@@ -178,7 +179,8 @@ extension StructConformsAndImplementsInExtension : Equatable {\n \n // No explicit conformance and it cannot be derived.\n struct NotExplicitlyHashableAndCannotDerive {\n-  let v: NotHashable\n+  let v: NotHashable // expected-note {{stored property type 'NotHashable' does not conform to protocol 'Hashable', preventing synthesized conformance of 'NotExplicitlyHashableAndCannotDerive' to 'Hashable'}}\n+  // expected-note@-1 {{stored property type 'NotHashable' does not conform to protocol 'Equatable', preventing synthesized conformance of 'NotExplicitlyHashableAndCannotDerive' to 'Equatable'}}\n }\n extension NotExplicitlyHashableAndCannotDerive : Hashable {}  // expected-error 2 {{does not conform}}\n \n@@ -233,7 +235,8 @@ extension GenericDeriveExtension: Hashable where T: Hashable {}\n \n // Incorrectly/insufficiently conditional shouldn't work\n struct BadGenericDeriveExtension<T> {\n-    let value: T\n+    let value: T // expected-note {{stored property type 'T' does not conform to protocol 'Hashable', preventing synthesized conformance of 'BadGenericDeriveExtension<T>' to 'Hashable'}}\n+// expected-note@-1 {{stored property type 'T' does not conform to protocol 'Equatable', preventing synthesized conformance of 'BadGenericDeriveExtension<T>' to 'Equatable'}}\n }\n extension BadGenericDeriveExtension: Equatable {}\n // expected-error@-1 {{type 'BadGenericDeriveExtension<T>' does not conform to protocol 'Equatable'}}"
                    }
                ]
            },
            {
                "date": "2019-05-27T04:04:58Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/8e1c00cb46910edb5a1d0aa632c6bed483623383",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsSema.def",
                        "code": "@@ -447,6 +447,16 @@ ERROR(cannot_convert_assign_protocol,none,\n ERROR(cannot_convert_assign_nil,none,\n       \"'nil' cannot be assigned to type %0\", (Type))\n \n+// Subscript Assign Expr\n+ERROR(cannot_convert_subscript_assign,none,\n+      \"cannot assign value of type %0 to subscript of type %1\",\n+      (Type,Type))\n+ERROR(cannot_convert_subscript_assign_protocol,none,\n+      \"value of type %0 does not conform to %1 in subscript assignment\",\n+      (Type, Type))\n+ERROR(cannot_convert_subscript_assign_nil,none,\n+      \"'nil' cannot be assigned to subscript of type %0\", (Type))\n+\n // for ... in expression\n ERROR(cannot_convert_sequence_element_value,none,\n       \"cannot convert sequence element type %0 to expected type %1\","
                    },
                    {
                        "filename": "lib/Sema/CSDiag.cpp",
                        "code": "@@ -2201,6 +2201,10 @@ bool FailureDiagnosis::diagnoseContextualConversionError(\n     diagID = diag::cannot_convert_assign;\n     nilDiag = diag::cannot_convert_assign_nil;\n     break;\n+  case CTP_SubscriptAssignSource:\n+    diagID = diag::cannot_convert_subscript_assign;\n+    nilDiag = diag::cannot_convert_subscript_assign_nil;\n+    break;\n   }\n \n   // If we're diagnostic an issue with 'nil', produce a specific diagnostic,\n@@ -2356,6 +2360,7 @@ bool FailureDiagnosis::diagnoseContextualConversionError(\n   case CTP_DictionaryKey:\n   case CTP_DictionaryValue:\n   case CTP_AssignSource:\n+  case CTP_SubscriptAssignSource:\n   case CTP_Initialization:\n   case CTP_ReturnStmt:\n     tryRawRepresentableFixIts(diag, CS, exprType, contextualType,\n@@ -5383,7 +5388,9 @@ bool FailureDiagnosis::visitAssignExpr(AssignExpr *assignExpr) {\n \n   auto *srcExpr = assignExpr->getSrc();\n   auto contextualType = destType->getRValueType();\n-\n+  auto contextualTypePurpose = isa<SubscriptExpr>(destExpr)\n+                                   ? CTP_SubscriptAssignSource\n+                                   : CTP_AssignSource;\n   // Let's try to type-check assignment source expression without using\n   // destination as a contextual type, that allows us to diagnose\n   // contextual problems related to source much easier.\n@@ -5399,11 +5406,11 @@ bool FailureDiagnosis::visitAssignExpr(AssignExpr *assignExpr) {\n \n     if (type && !type->isEqual(contextualType))\n       return diagnoseContextualConversionError(\n-          assignExpr->getSrc(), contextualType, CTP_AssignSource);\n+          assignExpr->getSrc(), contextualType, contextualTypePurpose);\n   }\n \n   srcExpr = typeCheckChildIndependently(assignExpr->getSrc(), contextualType,\n-                                        CTP_AssignSource);\n+                                        contextualTypePurpose);\n   if (!srcExpr)\n     return true;\n "
                    },
                    {
                        "filename": "lib/Sema/CSDiagnostics.cpp",
                        "code": "@@ -2804,7 +2804,11 @@ bool MissingContextualConformanceFailure::diagnoseAsError() {\n   Optional<Diag<Type, Type>> diagnostic;\n   if (path.empty()) {\n     assert(isa<AssignExpr>(anchor));\n-    diagnostic = getDiagnosticFor(CTP_AssignSource);\n+    if (isa<SubscriptExpr>(cast<AssignExpr>(anchor)->getDest())) {\n+      diagnostic = getDiagnosticFor(CTP_SubscriptAssignSource);\n+    } else {\n+      diagnostic = getDiagnosticFor(CTP_AssignSource);\n+    }\n   } else {\n     const auto &last = path.back();\n     switch (last.getKind()) {\n@@ -2871,6 +2875,8 @@ MissingContextualConformanceFailure::getDiagnosticFor(\n     return diag::cannot_convert_coerce_protocol;\n   case CTP_AssignSource:\n     return diag::cannot_convert_assign_protocol;\n+  case CTP_SubscriptAssignSource:\n+    return diag::cannot_convert_subscript_assign_protocol;\n \n   case CTP_ThrowStmt:\n   case CTP_Unused:"
                    },
                    {
                        "filename": "lib/Sema/TypeChecker.h",
                        "code": "@@ -217,6 +217,8 @@ enum ContextualTypePurpose {\n   CTP_DictionaryValue,  ///< DictionaryExpr values should have a specific type.\n   CTP_CoerceOperand,    ///< CoerceExpr operand coerced to specific type.\n   CTP_AssignSource,     ///< AssignExpr source operand coerced to result type.\n+  CTP_SubscriptAssignSource, ///< AssignExpr source operand coerced to subscript\n+                             ///< result type.\n \n   CTP_CannotFail,       ///< Conversion can never fail. abort() if it does.\n };"
                    },
                    {
                        "filename": "test/Constraints/assignment.swift",
                        "code": "@@ -2,6 +2,7 @@\n \n struct X { }\n struct Y { }\n+protocol Z { }\n \n struct WithOverloadedSubscript {\n   subscript(i: Int) -> X {\n@@ -14,6 +15,13 @@ struct WithOverloadedSubscript {\n   }\n }\n \n+struct WithProtocolSubscript {\n+  subscript(i: Int) -> Z {\n+    get {}\n+    set {}\n+  }\n+}\n+\n func test_assign() {\n   var a = WithOverloadedSubscript()\n   a[0] = X()\n@@ -26,6 +34,7 @@ var f: Y\n func getXY() -> (X, Y) {}\n var ift : (X, Y)\n var ovl = WithOverloadedSubscript()\n+var ps = WithProtocolSubscript()\n \n var slice: [X]\n \n@@ -40,7 +49,11 @@ i = j\n _ = (i, f)\n slice[7] = i\n \n-slice[7] = f // expected-error{{cannot assign value of type 'Y' to type 'X'}}\n+slice[7] = f // expected-error{{cannot assign value of type 'Y' to subscript of type 'X'}}\n+\n+slice[7] = nil // expected-error{{'nil' cannot be assigned to subscript of type 'X'}}\n+\n+ps[7] = i // expected-error{{value of type 'X' does not conform to 'Z' in subscript assignment}}\n \n slice[7] = _ // expected-error{{'_' can only appear in a pattern or on the left side of an assignment}}\n "
                    }
                ]
            },
            {
                "date": "2019-05-23T04:39:54Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/901d947478fc5eecd66ad1445419d6e6b340fb6a",
                "changes": [
                    {
                        "filename": "include/swift/AST/DiagnosticsParse.def",
                        "code": "@@ -68,6 +68,10 @@ ERROR(extra_tokens_conditional_compilation_directive,none,\n       \"extra tokens following conditional compilation directive\", ())\n ERROR(unexpected_rbrace_in_conditional_compilation_block,none,\n       \"unexpected '}' in conditional compilation block\", ())\n+ERROR(unexpected_if_following_else_compilation_directive,none,\n+      \"unexpected 'if' keyword following '#else' conditional compilation \"\n+      \"directive; did you mean '#elseif'?\",\n+      ())\n \n ERROR(pound_diagnostic_expected_string,none,\n       \"expected string literal in %select{#warning|#error}0 directive\",(bool))"
                    },
                    {
                        "filename": "lib/Parse/ParseIfConfig.cpp",
                        "code": "@@ -594,6 +594,12 @@ ParserResult<IfConfigDecl> Parser::parseIfConfig(\n     Expr *Condition = nullptr;\n     bool isActive = false;\n \n+    if (!Tok.isAtStartOfLine() && isElse && Tok.is(tok::kw_if)) {\n+      diagnose(Tok, diag::unexpected_if_following_else_compilation_directive)\n+          .fixItReplace(SourceRange(ClauseLoc, consumeToken()), \"#elseif\");\n+      isElse = false;\n+    }\n+\n     // Parse the condition.  Evaluate it to determine the active\n     // clause unless we're doing a parse-only pass.\n     if (isElse) {"
                    },
                    {
                        "filename": "test/Parse/ConditionalCompilation/basicParseErrors.swift",
                        "code": "@@ -138,3 +138,14 @@ fn_k()\n func undefinedFunc() // ignored.\n #endif\n undefinedFunc() // expected-error {{use of unresolved identifier 'undefinedFunc'}}\n+\n+#if FOO\n+#else if BAR\n+// expected-error@-1 {{unexpected 'if' keyword following '#else' conditional compilation directive; did you mean '#elseif'?}} {{1-9=#elseif}}\n+#else\n+#endif\n+\n+#if FOO\n+#else\n+if true {}\n+#endif // OK"
                    }
                ]
            },
            {
                "date": "2018-10-06T02:11:23Z",
                "url": "https://api.github.com/repos/airspeedswift/swift/commits/a676ab6d4c2edfd0dc8f19d90ed7396262a55e08",
                "changes": [
                    {
                        "filename": "lib/FrontendTool/ReferenceDependencies.cpp",
                        "code": "@@ -22,6 +22,7 @@\n #include \"swift/AST/NameLookup.h\"\n #include \"swift/AST/ReferencedNameTracker.h\"\n #include \"swift/AST/Types.h\"\n+#include \"swift/Basic/FileSystem.h\"\n #include \"swift/Basic/LLVM.h\"\n #include \"swift/Basic/ReferenceDependencyKeys.h\"\n #include \"swift/Frontend/FrontendOptions.h\"\n@@ -65,11 +66,6 @@ class ReferenceDependenciesEmitter {\n                    llvm::raw_ostream &out);\n \n private:\n-  /// Opens file for reference dependencies. Emits diagnostic if needed.\n-  ///\n-  /// \\return nullptr on error\n-  static std::unique_ptr<llvm::raw_fd_ostream> openFile(DiagnosticEngine &diags,\n-                                                        StringRef OutputPath);\n   /// Emits all the dependency information.\n   void emit() const;\n \n@@ -189,35 +185,24 @@ static std::string escape(DeclBaseName name) {\n   return llvm::yaml::escape(name.userFacingName());\n }\n \n-std::unique_ptr<llvm::raw_fd_ostream>\n-ReferenceDependenciesEmitter::openFile(DiagnosticEngine &diags,\n-                                       StringRef outputPath) {\n+bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n+                                        SourceFile *const SF,\n+                                        const DependencyTracker &depTracker,\n+                                        StringRef outputPath) {\n   // Before writing to the dependencies file path, preserve any previous file\n   // that may have been there. No error handling -- this is just a nicety, it\n   // doesn't matter if it fails.\n   llvm::sys::fs::rename(outputPath, outputPath + \"~\");\n-\n-  std::error_code EC;\n-  auto out = llvm::make_unique<llvm::raw_fd_ostream>(outputPath, EC,\n-                                                     llvm::sys::fs::F_None);\n-\n-  if (out->has_error() || EC) {\n+  std::error_code EC =\n+      swift::atomicallyWritingToFile(outputPath,\n+                                     [&](llvm::raw_pwrite_stream &out) {\n+    ReferenceDependenciesEmitter::emit(SF, depTracker, out);\n+  });\n+  if (EC) {\n     diags.diagnose(SourceLoc(), diag::error_opening_output, outputPath,\n                    EC.message());\n-    out->clear_error();\n-    return nullptr;\n-  }\n-  return out;\n-}\n-\n-bool ReferenceDependenciesEmitter::emit(DiagnosticEngine &diags,\n-                                        SourceFile *const SF,\n-                                        const DependencyTracker &depTracker,\n-                                        StringRef outputPath) {\n-  const std::unique_ptr<llvm::raw_ostream> out = openFile(diags, outputPath);\n-  if (!out.get())\n     return true;\n-  ReferenceDependenciesEmitter::emit(SF, depTracker, *out);\n+  }\n   return false;\n }\n "
                    }
                ]
            }
        ]
    ]
}